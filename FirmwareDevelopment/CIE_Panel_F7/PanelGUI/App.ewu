$version 6.60

$rect <1240,470,1440,510>
$output false
resource Resources::Bitmap SmokeBitmap
{
  attr bitmapfile FileName = .\Images\smoke1.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <140,40,240,80>
inline Inline1
{
  #include "stm32f7xx_hal_rtc.h"

  #include "MM_Command2.h"
  #include "MM_CUtils.h"

  #include "CO_Site.h"
  #include "CO_RBU.h"
  #include "MM_Device.h" 

  #include "MM_Application.h"

  #include <stdio.h>
  #include <string.h>

}

$rect <1240,630,1440,670>
$output false
resource Resources::Bitmap Circle55Bitmap
{
  attr bitmapfile FileName = .\Images\circle55.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,270,1440,310>
$output false
resource Resources::Bitmap UpBitmap
{
  attr bitmapfile FileName = .\Images\up.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <970,40,1100,80>
$output false
class PushButton : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,50,50>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) ;

    Image.Bitmap = IconImage;

    if ( isPressed )
    {
        Background.Color = #00EE00FF;
    }                                               
    else
    {
        Background.ColorBR = #444444FF;  
        Background.ColorBL = #FFFFFFFF;  
        Background.ColorTL = #FFFFFFFF;  
        Background.ColorTR = #777777FF;  
          
    }

  }

  // To do:
  // 
  // - Adjust the visible size of your button (the thick blue border). This will \
  // be the button's default size.
  // - Resize the member 'TouchHandler' so it still fills the button's new area.
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your button.
  // - According to your desired button design add and configure new views (e.g. \
  // an image view to show the icon or a text view to show the button caption, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the button's current state.
  // - You can also add and configure animation effects to your button. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your button.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the button itself is resized.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // button to be activated with key other than the 'Enter' key.
  // - Alternatively remove the members 'KeyHandler' and 'onPressKey' if you don't \
  // want any keyboard handling.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your button. One property \
  // for every button specific setting (e.g. 'Caption', 'Icon', 'Color', 'Font', \
  // ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your button where \
  // the icon is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,370,990,750>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
     
    //Background.Color = #00EE00FF;

      postsignal OnActivate;
     
     
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,50,50>;
    preset ColorBL = #CCCCCCFF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,50,50>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #313131FF;
    preset ColorTR = #363636FF;
    preset ColorTL = #FFFFFFFF;
    preset Visible = false;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,50,50>;
    preset ColorBL = #6E6E6EFF;
    preset Bitmap = IconImage;
  }

  $rect <220,80,420,120>
  property Resources::Bitmap IconImage = null;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,50>;
    preset Point3 = <50,50>;
    preset Point2 = <50,0>;
    preset Point1 = <0,0>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }
}

$rect <630,1420,850,1460>
$output false
autoobject WidgetSet::PushButtonConfig NormalPushButton
{
  preset LabelColorActive = #FFFFFFFF;
  preset LabelColorDisabled = #565656FF;
  preset LabelFont = Flat::FontS;
  preset FaceFrameActive = 3;
  preset FaceFrameFocused = 2;
  preset FaceFrameDisabled = 0;
  preset FaceFrameDefault = 1;
  preset FaceActive = WidgetSet::PushButtonMedium;
  preset FaceFocused = WidgetSet::PushButtonMedium;
  preset FaceDisabled = WidgetSet::PushButtonMedium;
  preset FaceDefault = WidgetSet::PushButtonMedium;
}

$rect <1440,630,1640,670>
$output false
resource Resources::Bitmap FireBitmap
{
  attr bitmapfile FileName = .\Images\fire3.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

// This is the root component of the entire GUI application.
$rect <0,40,140,80>
$output false
class Application : Core::Root
{
  $rect <830,0,1030,40>
  inherited property Bounds = <0,0,800,480>;

  // To do:
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <5,740,785,940>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,50,800,480>;
    preset ColorBL = #383838FF;
    preset ColorBR = #666666FF;
    preset ColorTR = #202020FF;
    preset ColorTL = #212121FF;
    preset Color = #FFFFFFFF;
    preset AlphaBlended = true;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Seperator
  {
    preset Bounds = <0,45,800,50>;
    preset ColorBL = #78AAFFFF;
    preset ColorBR = #2B3844FF;
    preset ColorTR = #2B3844FF;
    preset ColorTL = #78AAFFFF;
    preset Color = #8BB8E8FF;
  }

  $rect <20,20,160,60>
  object Views::Text TimeDateText
  {
    preset Bounds = <624,405,792,424>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertBottom];
    preset String = "$time";
    preset Font = App::FontVerdana16;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::TabButton AlarmsTabButton
  {
    preset Bounds = <0,0,133,45>;
    preset OnActivate = AlarmsEnter;
    preset Text = "{fnt3}{clr1} Fires";
    preset Icon = App::Fire4Bitmap;
    preset pressed = true;
    preset Selected = ^SelectedTab;
    preset OnDeactivate = AlarmsExit;
    preset NumberOf = 0;
  }

  $rect <20,20,160,60>
  object App::Button EvacuateButton
  {
    preset Bounds = <128,430,248,475>;
    preset Icon = App::EvacuateBitmap;
    preset ButtonText = "{parc}Evacuate";
    preset ActionPress = Evacuate;
    preset Elevation = 2;
  }

  $rect <20,20,160,60>
  object App::Button MuteButton
  {
    preset Bounds = <3,430,123,475>;
    preset Enabled = true;
    preset Icon = App::MuteBitmap;
    preset ButtonText = "{fnt0}{parc}Mute Buzzer";
    preset ActionPress = Mute;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <618,361,802,399>;
    preset AutoSize = true;
    preset Bitmap = App::cygnusblue2;
  }

  $rect <15,496,215,536>
  slot AlarmsEnter
  {
    sender; /* the method is called from the sender object */

    Alarms.Visible = true;
    Alarms.Enabled = true;

    //Alarms.SlideTouchHandler.Enabled = true;


  }

  $rect <20,20,160,60>
  object App::TabButton FaultsTabButton
  {
    preset Bounds = <133,0,266,45>;
    preset OnActivate = FaultsEnter;
    preset Text = "{fnt3}{clr1} Faults";
    preset Icon = App::FaultBitmap;
    preset Selected = ^SelectedTab;
    preset OnDeactivate = FaultsExit;
    preset NumberOf = 0;
  }

  $rect <20,20,160,60>
  object App::TabButton OnTestTabButton
  {
    preset Bounds = <533,0,666,45>;
    preset OnActivate = OnTestEnter;
    preset Text = "{fnt3}{clr1}  On Test";
    preset Icon = App::ontest;
    preset Selected = ^SelectedTab;
    preset OnDeactivate = OnTestExit;
    preset NumberOf = 0;
  }

  $rect <20,20,160,60>
  object App::TabButton EventsTabButton
  {
    preset Bounds = <266,0,400,45>;
    preset OnActivate = EventsEnter;
    preset Text = "{fnt3}{clr1}Other Events";
    preset Icon = App::AlertBitmap;
    preset Selected = ^SelectedTab;
    preset OnDeactivate = EventsExit;
    preset NumberOf = 0;
  }

  $rect <835,40,1035,80>
  property string SelectedTab = "{fnt3}{clr1} Fires";

  $rect <20,20,160,60>
  object App::Button ResetButton
  {
    preset Bounds = <378,430,498,475>;
    preset Icon = App::ResetBitmap;
    preset ButtonText = "{parc}Reset";
    preset ActionPress = Reset;
    preset Elevation = 2;
  }

  $rect <20,20,160,60>
  object App::Button SilenceButton
  {
    preset Bounds = <503,430,623,475>;
    preset Enabled = true;
    preset Icon = App::SilenceBitmap;
    preset ButtonText = "{parc}Silence";
    preset ActionPress = Silence;
    preset Elevation = 2;
  }

  $rect <20,20,160,60>
  object App::Button LogOnButton
  {
    preset Bounds = <253,430,373,475>;
    preset Enabled = true;
    preset Icon = App::KeyBitmap;
    preset ButtonText = "{parc}Log On";
    preset ActionPress = LogOn;
  }

  $rect <425,495,625,535>
  slot DisablementsEnter
  {
    sender; /* the method is called from the sender object */



    Disablements.Visible = true;
    Disablements.Enabled = true;




  }

  $rect <415,540,615,580>
  slot DisablementsExit
  {
    sender; /* the method is called from the sender object */ 


    Disablements.Visible = false;
    Disablements.Enabled = false;
  }

  $rect <213,496,413,536>
  slot EventsEnter
  {
    sender; /* the method is called from the sender object */




    OtherEvents.Visible = true;
    OtherEvents.Enabled = true;


    //Events.SlideTouchHandler.Enabled = true;


  }

  $rect <200,540,400,580>
  slot EventsExit
  {
    sender; /* the method is called from the sender object */

    OtherEvents.Visible = false;
    OtherEvents.Enabled = false;

    //Events.SlideTouchHandler.Enabled = false;



  }

  $rect <6,543,206,583>
  slot AlarmsExit
  {
    sender; /* the method is called from the sender object */

    Alarms.Visible = false;
    Alarms.Enabled = false;

    //Alarms.SlideTouchHandler.Enabled = false;



  }

  $rect <20,20,160,60>
  object App::Events OtherEvents
  {
    preset Bounds = <5,55,800,420>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <835,120,1035,160>
  slot PageSelection
  {
    sender; /* the method is called from the sender object */


    if ( SelectedTab == "Enable/Disable" )
    {
        EnableDisable.Enabled = true;
        EnableDisable.Visible = true;
    }
    else if ( SelectedTab == "Testing" )
    {
         Test.Enabled = true;
         Test.Visible = true;
    }
    else if ( SelectedTab == "Site Settings" )
    {
         Settings.Visible = true;
         Settings.Enabled = true;
    }
    else if ( SelectedTab == "Mesh Status" )
    {
         MeshTree.Enabled = true;
         MeshTree.Visible = true;
    }
    else if ( SelectedTab == "System Settings" )
    {
       SystemPage.Enabled = true;
       SystemPage.Visible = true;
       SystemPage.Timer.Enabled = true;
    }
    else if ( SelectedTab == "Modify Devices" )
    {
       Modify.Enabled = true;
       Modify.Visible = true;
    }

  }

  $rect <835,160,1035,200>
  method void PageDeselection()
  {
    var object v = first;

    while ( v != last )
    {
        var App::TabButton tb = (App::TabButton) v;

        if ( tb != null )
        {
            if ( tb.Text1.String == SelectedTab )
            {            
                tb.pressed = false;
                postsignal tb.OnDeactivate;
                return;
            }

        }
        else
        {
            if ( DisablementsTabButton.Text1.String == SelectedTab )
            {            
                DisablementsTabButton.pressed = false;
                postsignal DisablementsTabButton.OnDeactivate;
                return;
            } 
        }

        v = ((Core::View)v).next;
    }
       
    TabButtonPull.SelectionText.String = "Menu level " + string( LevelAccess.AccessLevel );
    TabButtonPull.TabPullBackground.Color = #BBBBBBFF;
     

    if ( SelectedTab == "Enable/Disable" )
    {
        EnableDisable.Visible = false;
        EnableDisable.Enabled = false;
    }
    else if ( SelectedTab == "Site Settings" )
    {
         Settings.Visible = false;
         Settings.Enabled = false;
    }
    else if ( SelectedTab == "Testing" )
    {
         Test.Enabled = false;
         Test.Visible = false;
         Test.TreeView.j();
         signal Test.AllOff;
    }
    else if ( SelectedTab == "Mesh Status" )
    {
         MeshTree.Enabled = false;
         MeshTree.Visible = false;
    }
    else if ( SelectedTab == "System Settings" )
    {
       SystemPage.Visible = false;
       SystemPage.Enabled = false;
       SystemPage.Enabled = false;
       SystemPage.Timer.Enabled = false;
    }
    else if ( SelectedTab == "Modify Devices" )
    {
       Modify.Enabled = false;
       Modify.Visible = false;
    }

    return ;
  }

  $rect <20,20,160,60>
  object App::Test Test
  {
    preset Bounds = <5,55,800,420>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object App::Settings Settings
  {
    preset Bounds = <5,55,800,420>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object App::SystemPage SystemPage
  {
    preset Bounds = <5,55,800,420>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object App::Modify Modify
  {
    preset Bounds = <5,55,800,420>;
    preset Enabled = false;
    preset AlphaBlended = true;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object App::Faults Faults
  {
    preset Bounds = <5,55,800,420>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <623,495,823,535>
  slot FaultsEnter
  {
    sender; /* the method is called from the sender object */

    Faults.Visible = true;
    Faults.Enabled = true;


    //Events.SlideTouchHandler.Enabled = true;


  }

  $rect <610,539,810,579>
  slot FaultsExit
  {
    sender; /* the method is called from the sender object */

    Faults.Visible = false;
    Faults.Enabled = false;

    //Events.SlideTouchHandler.Enabled = false;



  }

  $rect <828,495,1028,535>
  slot OnTestEnter
  {
    sender; /* the method is called from the sender object */

    OnTest.Visible = true;
    OnTest.Enabled = true;


    //Events.SlideTouchHandler.Enabled = true;


  }

  $rect <20,20,160,60>
  object App::LevelAccess LevelAccess
  {
    preset Bounds = <621,415,648,434>;
    preset AccessLevel = 1;
  }

  $rect <815,539,1015,579>
  slot OnTestExit
  {
    sender; /* the method is called from the sender object */

    OnTest.Visible = false;
    OnTest.Enabled = false;

    //Events.SlideTouchHandler.Enabled = false;



  }

  $rect <489,589,609,629>
  slot Mute
  {
    native 
    {
       event( EVENT_MUTE_BUZZER_BUTTON );
    }




  }

  $rect <830,295,1030,335>
  var Core::Time TheTime = null;

  $rect <880,370,1080,410>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font3 = OldResources::FontVerdana20;
    preset Font2 = OldResources::FontVerdana18;
    preset Font1 = App::FontVerdana16;
    preset Font0 = App::FontVerdana14;
    preset Color1 = #FFFFFFFF;
  }

  $rect <860,400,1060,440>
  object Core::Timer Timer
  {
    preset OnTrigger = Tick;
    preset Enabled = true;
  }

  $rect <850,440,1050,480>
  slot Tick
  {
    sender; /* the method is called from the sender object */

    //if ( Time == null )
    {

      var Core::Time Time = new Core::Time;
       
                 
     
      Time = Time.CurrentTime;

       TimeDateText.String = Time.Format( "%H:%M.%S %a %#d" );

       var string pf;

       if ( Time.Day > 3 && Time.Day < 21 )
       {
       pf = "th";
       }
       else switch ( Time.Day % 10 )
       {
          case 1 : pf = "st";
          case 2 : pf = "nd";
          case 3 : pf = "rd";
          default : pf = "th";
       }
        
       TimeDateText.String = TimeDateText.String + pf + Time.Format( " %b" );


     }
  }

  $rect <9,580,138,620>
  slot Evacuate
  {
     
     
      var App::ConfirmPopup popup = new App::ConfirmPopup;

      popup.Text1.String = "Sound alarms?";

      popup.ShowThen( GetRoot(), Evacuate1 );


        
  }

  $rect <129,589,238,629>
  slot LogOn
  {
     
    if ( LogOnButton.ButtonText == "{parc}Log On" )
    {
      var App::KeypadPopup popup = new App::KeypadPopup;
      
    //  var App::Group blank = new App::KeypadPopup; 
      popup.getting = true;
      popup.Show( GetRoot( ) );
      popup.Writable.ObtainFocus( );
    }
    else
    {
    /*
      if ( OnTestTabButton.NumberOf > 0 )
      {
        var App::OnTestWarning warning = new App::OnTestWarning;
        warning.Text.String = "Please take devices/zones out of test mode before logging off.";
        warning.Show( GetRoot() );
        warning.Timer.restart( 0, 2400 );
        warning.Timer.Enabled = true;
      }
       */
       
        if ( LevelAccess.AccessLevel > 1 )
        { 
            var int32 user = LevelAccess.UserIndex;
            
            native( user )
            {
              Command3( CMD_LOGON_ACCESS, 0, user, 0 );
            }  
            postsignal  onGotoScreenEvent;

          LevelAccess.AccessLevel = 1;
        }
    }





  }

  $rect <240,589,360,629>
  slot Reset
  {
    var App::ConfirmPopup popup = new App::ConfirmPopup;

    var bool inputs_active = false;
    var bool inputs_inactive = false;

    native( inputs_active )
    {
      Command cmd;

      Command0( CMD_CHECK_ACTIVE_ON_TEST, &cmd );
      
       inputs_active = cmd.int0;
       inputs_inactive = cmd.int1;
    }

    if ( inputs_active )
    {
        popup.Text1.String = "Devices on test are still active. Reset into Alarm?";
    }
    else if (  inputs_inactive )
    {
          popup.Text1.String = "Take devices off test and Reset?";
    }
    else
    {
        popup.Text1.String = "Reset System?";
    }

    popup.ShowThen( GetRoot(), Reset1 );



  }

  $rect <369,589,489,629>
  method void LowLevel( arg int8 level )
  {
    var App::AccesssPopup ll = new App::AccesssPopup;

    if ( level == 1 )
    {
      ll.Text.String = "Site data required for user validation.";
    }
    else
    {
      ll.Text.String = "User level " + string(level) + " logon required";
    }

    ll.Show( GetRoot() );

  }

  $rect <830,215,1030,255>
  property App::Popup TestPop = null;

  $rect <830,255,1030,295>
  property App::Popup DisablePop = null;

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1150,300,1280,340>
  slot onFireEvent
  {
    var int32 fires = Alarms.SetListSize( );
     

    if ( fires > 0 )
    {
         
        Seperator.ColorBL = #FF0000FF ;
        Seperator.ColorBR = #3C0000FF ;
        Seperator.ColorTL = #FF0000FF ;
        Seperator.ColorTR = #3C0000FF ;

        Alarms.LogoImage.Visible = false;

       
     
     }
     else
     {
        native
        {
          Command2( CMD_BUZZER, 1, 0 );
        }

        Seperator.ColorBL  = #78AAFFFF ;
        Seperator.ColorBR  = #2B3844FF ;
        Seperator.ColorTL  = #78AAFFFF ;
        Seperator.ColorTR  = #2B3844FF ;

        Alarms.LogoImage.Visible = true;              
     }


    AlarmsTabButton.NumberOf = fires;
    AlarmsTabButton.pressed = AlarmsTabButton.pressed;
    AlarmsTabButton.InvalidateViewState();

    Alarms.InvalidateViewState();


    if ( (fires != 0 || HazardWallpaper.Visible) && sender != SiteChangedEventHandler )
    {
      postsignal AlarmsTabButton.OnPress;

      Alarms.ListViewer.ScrollOffset = 0;
    }





     
  }

  $rect <1160,0,1360,40>
  var int32 xpos = 0;

  $rect <1050,260,1250,300>
  object Core::SystemEventHandler FireListChangeEventHandler
  {
    preset OnEvent = onFireEvent;
    preset Event = App::Devices.FireListChangeEvent;
  }

  $rect <275,625,395,665>
  slot Reset1
  {
      var App::Action a = App::Action.Reset;

      native (a)
      {
         event( EVENT_RESET_BUTTON );
         Command1( CMD_NETWORK, a );
      }
     
     


  }

  $rect <9,620,138,660>
  slot Evacuate1
  {
     
     
      native 
      {
         event( EVENT_EVACUATE_BUTTON );
      }
     


  }

  $rect <614,586,734,626>
  slot Silence
  {
     

      var App::Action a = App::Action.Silence;

      native (a)
      {
         event( EVENT_SILENCE_BUTTON );
         Command1( CMD_NETWORK, a );
      }
     

    //postsignal onFireEvent;


  }

  $rect <1070,350,1300,390>
  object Core::SystemEventHandler StartProgressEventHandler
  {
    preset OnEvent = onEvent;
    preset Enabled = true;
    preset Event = App::Devices.StartProgressEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1070,390,1270,430>
  slot onEvent
  {
    ProgressPopup.HorizontalValueBar.CurrentValue = 0;
    ProgressPopup.Visible = true;
    ProgressPopup.Enabled = true;
    ProgressPopup.PushButton.Label = "Cancel";
    ProgressPopup.UnusedTimer.Enabled = true;


  }

  $rect <20,20,160,60>
  object App::Fire Alarms
  {
    preset Bounds = <5,55,800,420>;
  }

  $rect <20,20,160,60>
  object App::Disablements Disablements
  {
    preset Bounds = <5,55,800,420>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object App::OnTest OnTest
  {
    preset Bounds = <5,55,800,420>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object App::Disable EnableDisable
  {
    preset Bounds = <5,55,800,420>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object App::MeshTree MeshTree
  {
    preset Bounds = <5,55,800,420>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object App::ProgressPopup ProgressPopup
  {
    preset Bounds = <170,140,600,370>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object App::TabButtonPull TabButtonPull
  {
    preset Bounds = <630,0,800,340>;
    preset Text = "Access";
    preset Icon = App::AccessBitmap;
    preset OnSelectItem = PageSelection;
  }

  $rect <1070,445,1300,485>
  object Core::SystemEventHandler WriteProtectedEventHandler
  {
    preset OnEvent = onEvent1;
    preset Enabled = true;
    preset Event = App::Devices.WriteProtectedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1070,485,1270,525>
  slot onEvent1
  {
    var App::AccesssPopup ll = new App::AccesssPopup;

    ll.Text.String = "Internal Flash is write protected";

    ll.Show( GetRoot() );


  }

  $rect <20,20,160,60>
  object App::DFUPopup DFUPopup
  {
    preset Bounds = <170,140,600,350>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <1070,530,1270,570>
  object Core::SystemEventHandler DFUEventHandler
  {
    preset OnEvent = onEvent2;
    preset Event = App::Devices.DFUEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1050,570,1250,610>
  slot onEvent2
  {
    DFUPopup.Visible = true;
    DFUPopup.Enabled = true;

    InvalidateViewState( );


    DFUPopup.Text.String = DFUPopup.Text.String + " ";

    InvalidateViewState( );



    DFUPopup.InvalidateArea(  DFUPopup.Bounds );

    DFUPopup.Timer.Enabled = true;




  }

  $rect <1040,180,1240,220>
  object Core::SystemEventHandler GotoScreenEventHandler
  {
    preset OnEvent = onGotoScreenEvent;
    preset Event = App::Devices.GotoPriorityDisplay;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1060,90,1240,130>
  slot onConfirmFireSwitch
  {
    var App::ButtonState conf = (App::ButtonState) SwitchConfirmFireEvent.Context;


    if ( conf.on )
    {
      Alarms.ConfirmFireButton.Enabled = true;
    }
    else
    {
       Alarms.ConfirmFireButton.Enabled = false;
    }

     
  }

  $rect <1050,50,1250,90>
  object Core::SystemEventHandler SwitchConfirmFireEvent
  {
    preset OnEvent = onConfirmFireSwitch;
    preset Event = App::Devices.ConfirmFireAvailable;
  }

  $rect <1180,140,1360,180>
  object Core::Timer ConfirmButtonTimer
  {
    preset OnTrigger = TimerEvent;
    preset Period = 800;
    preset Enabled = true;
  }

  $rect <1070,130,1160,170>
  slot TimerEvent
  {
    sender; /* the method is called from the sender object */


    if ( Alarms.ConfirmFireButton.Enabled )
    {
       if ( Alarms.ConfirmFireButton.Appearance == App::NormalPushButton )
       {
          Alarms.ConfirmFireButton.Appearance = App::FocusedPushButton;
       }
       else 
       {
           Alarms.ConfirmFireButton.Appearance = App::NormalPushButton;
       }
    }


    if ( Alarms.AcknowledgeFireButton.Enabled )
    {
      if ( Alarms.AcknowledgeFireButton.Appearance == App::NormalPushButton )
      {    
          Alarms.AcknowledgeFireButton.Appearance = App::FocusedPushButton;
      }
      else Alarms.AcknowledgeFireButton.Appearance = App::NormalPushButton;
    }
     

  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1250,90,1430,130>
  slot onAcknowldegeSwitch
  {
    var App::ButtonState conf = (App::ButtonState) SwitchAcknowledgeEvent.Context;


    if ( conf.on )
    {
       Alarms.AcknowledgeFireButton.Enabled = true;
    }
    else
    {
     Alarms.AcknowledgeFireButton.Enabled = false; 
    }

    SilenceButton.InvalidateViewState();

  }

  $rect <1240,50,1440,90>
  object Core::SystemEventHandler SwitchAcknowledgeEvent
  {
    preset OnEvent = onAcknowldegeSwitch;
    preset Event = App::Devices.AcknowledgeFireAvailable;
  }

  $rect <20,20,160,60>
  object App::DisablementsTabButton DisablementsTabButton
  {
    preset Bounds = <400,0,533,45>;
    preset OnActivate = DisablementsEnter;
    preset Text = "Disablements";
    preset Icon = App::DisableBitmap;
    preset Selected = ^SelectedTab;
    preset OnDeactivate = DisablementsExit;
  }

  $rect <20,20,160,60>
  object Views::Wallpaper HazardWallpaper
  {
    preset Bounds = <0,45,800,50>;
    preset Bitmap = App::hazardstripe;
    preset Visible = false;
  }

  $rect <1320,205,1520,245>
  object Core::SystemEventHandler SafeStateEventHandler
  {
    preset OnEvent = onSafeState;
    preset Event = App::Devices.SafeStateEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1320,240,1520,280>
  slot onSafeState
  {
    var App::Boolean b = (App::Boolean)  SafeStateEventHandler.Context;

    if ( b.State )
    {
      HazardWallpaper.Visible = true;
      Alarms.NotOperationalBitmap.Visible = true;
      Alarms.NotOperationalText.Visible = true;
      Alarms.LogoImage.Visible = false;
      Seperator.Visible = false;
      LogOnButton.Elevation = 10;
      LogOnButton.Enabled = false;
      TabButtonPull.SelectionText.String = "Menu level -";
      LevelAccess.AccessLevel = 1;
    }
    else
    {
      HazardWallpaper.Visible = false;
      Alarms.NotOperationalBitmap.Visible = false;
      Alarms.NotOperationalText.Visible = false;
      Alarms.LogoImage.Visible = true;
      Seperator.Visible = true;
      LogOnButton.Elevation = 1; 
      LogOnButton.Enabled = true;
      TabButtonPull.InvalidateViewState();

    }


    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent3'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent3' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <1310,300,1550,345>
  object Core::SystemEventHandler SiteChangedEventHandler
  {
    preset OnEvent = onFireEvent;
    preset Event = App::Devices.SiteChangedEvent;
  }

  $rect <735,585,855,625>
  slot Function1
  {
     
     
    this.ButtonFunc( true, sender, 0 );


  }

  $rect <845,585,965,625>
  slot Function2
  {
     
    this.ButtonFunc( true, sender, 1 );



    //postsignal onFireEvent;


  }

  $rect <740,615,860,655>
  slot Function1off
  {
     
    this.ButtonFunc( false, sender, 0 );



    //postsignal onFireEvent;


  }

  $rect <850,615,970,655>
  slot Function2off
  {
     
    this.ButtonFunc( false, sender, 1 );


  }

  $rect <20,20,160,60>
  object App::UserButton UserButton
  {
    preset Bounds = <632,430,712,475>;
    preset ActionPress = Function1;
    preset ActionRelease = Function1off;
  }

  $rect <20,20,160,60>
  object App::UserButton UserButton1
  {
    preset Bounds = <717,430,797,475>;
    preset ActionPress = Function2;
    preset ActionRelease = Function2off;
    preset ButtonIndex = 1;
  }

  $rect <630,655,820,700>
  property Core::Time lastTime = null;

  $rect <820,685,1020,725>
  property int32 tapCount = 0;

  $rect <1009,655,1209,695>
  object Core::SystemEventHandler GotoSysPageEventHandler
  {
    preset OnEvent = onEvent3;
    preset Event = App::Devices.GotoSysPageEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1025,695,1225,735>
  slot onEvent3
  {
    TabButtonPull.SetChoice( "System Settings" );

     
  }

  $rect <415,689,615,729>
  method void ButtonFunc( arg bool pressed, arg object sender, arg int32 chan )
  {
     
    var App::UserButton b = (App::UserButton) sender;

    if ( b != null )
    {
      var bool state;

      native( pressed, chan, state )
      {
      
           Command cmd;
           cmd.int0 = chan;
           cmd.int1 = pressed;
          Command0( CMD_FUNCTION_BUTTON, &cmd );

          state =  cmd.int1;
      }
      if ( state )
      {
        b.FillPath.Color = #8BB8E8FF; 
      }
      else
      {
        b.FillPath.Color = #E2E2E2FF;
      }
                                     
     

     }

  }

  $rect <1340,385,1549,425>
  object Core::SystemEventHandler RestEventHandler
  {
    preset OnEvent = onEvent4;
    preset Event = App::Devices.ResetEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1365,420,1565,460>
  slot onEvent4
  {
     
    UserButton.FillPath.Color = #E2E2E2FF; 
      UserButton1.FillPath.Color = #E2E2E2FF; 

  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1105,220,1300,260>
  slot onGotoScreenEvent
  {
     

    if ( AlarmsTabButton.NumberOf > 0 )
    {
      Alarms.ListViewer.ScrollOffset = 0;

      if ( SelectedTab != "{fnt3}{clr1} Fires" ) postsignal AlarmsTabButton.OnPress;
    }
    else
    {
      if ( LevelAccess.AccessLevel < 3 )
      {
        if ( FaultsTabButton.NumberOf > 0 )
        { 
           Faults.ListViewer.ScrollOffset = 0;

          if ( SelectedTab != "{fnt3}{clr1} Faults" )
            postsignal FaultsTabButton.OnPress;
        }
        else if ( DisablementsTabButton.NumberOf > 0 )
        {
           Disablements.ListViewer.ScrollOffset = 0;

           if ( SelectedTab != "Disablements" )
              postsignal DisablementsTabButton.OnPress;
        }
        else if ( OnTestTabButton.NumberOf > 0 )
        {
           OnTest.ListViewer.ScrollOffset = 0;
           
           if ( SelectedTab != "{fnt3}{clr1}  On Test" )
              postsignal  OnTestTabButton.OnPress;
        }
        else if ( EventsTabButton.NumberOf > 0 )
        {
           OtherEvents.ListViewer.ScrollOffset = 0;

           if ( SelectedTab != "{fnt3}{clr1}Other Events" )
              postsignal EventsTabButton.OnPress;
         }
         else
         {
            if ( SelectedTab != "{fnt3}{clr1} Fires" )
                postsignal AlarmsTabButton.OnPress;
         }
      }
    }





     
  }
}

$rect <400,40,530,80>
$output false
class TabButton : Core::Group
{
  $rect <0,170,140,210>
  inherited property Layout = Core::Layout[ResizeHorz, ResizeVert];

  $rect <10,230,210,270>
  inherited property Bounds = <0,0,133,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


          Text1.String = Text;
          Image.Bitmap = Icon;

          if ( NumberOf > 0 )
          {
              Text2.String = "(" + string( NumberOf ) + ")";
          }
          else
          {
              Text2.String = "";
          }

          
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle TabBackground
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <1,1,134,44>;
    preset ColorBL = #ECECECFF;
    preset ColorBR = #ECECECFF;
    preset ColorTR = #ECECECFF;
    preset ColorTL = #ECECECFF;
    preset Color = #ECECECFF;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,133,45>;
    preset Width = 1;
    preset ColorL = #737373FF;
    preset ColorR = #303030FF;
    preset ColorB = #303030FF;
    preset ColorT = #737373FF;
  }

  // This variable stores the current state of the button.
  $rect <10,490,210,530>
  var bool selected = false;

  // This variable stores the current state of the button.
  $rect <10,450,210,490>
  var bool enabled = true;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <133,0>;
    preset Point2 = <133,45>;
    preset Point1 = <0,45>;
    preset OnLeave = null;
    preset OnRelease = null;
    preset OnPress = OnPress;
  }

  $rect <330,0,530,40>
  slot OnPress
  {
    sender; /* the method is called from the sender object */

    Image.Visible = true;
    Timer.Enabled = false;


    if ( Selected^ == Text1.String ) return;

    var App::Application app = (App::Application) Owner;

    app.PageDeselection( );

    app.SelectedTab = Text1.String;
    pressed = true;

    postsignal OnActivate;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <540,0,740,40>
  property slot OnActivate = null;

  $rect <94,70,294,110>
  property string Text = "{clr1}Text {fnt0}";

  $rect <20,120,220,160>
  property Resources::Bitmap Icon = null;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToLeft, ResizeVert];
    preset Bounds = <0,0,40,45>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <1050,280,1250,320>
  property bool pressed = false;

  $rect <1050,330,1250,370>
  onset pressed
  {
    // The value doesn't change - nothing to do.
     

    // Remember the property's new value.
    pure pressed = value;

     var color t = Bevel.ColorB;
      Bevel.ColorB = Bevel.ColorT;
      Bevel.ColorT = t;

      t = Bevel.ColorL;
      Bevel.ColorL = Bevel.ColorR;
      Bevel.ColorR = t;

    if ( pressed )
    {
        if ( Text == "{fnt3}{clr1} Fires" && NumberOf > 0 )
        {
          TabBackground.ColorBL = #FF1111FF;
          TabBackground.ColorBR = #EE0000FF;
          TabBackground.ColorTL = #FF1111FF;
          TabBackground.ColorTR = #FF1111FF;     
        }
        else
        {
          TabBackground.ColorBL = #93C2FFFF;
          TabBackground.ColorBR = #83B2F0FF;
          TabBackground.ColorTL = #93C2FFFF;
          TabBackground.ColorTR = #93C2FFFF;
        }
          
    }

    else
    {
        TabBackground.ColorBL = #ECECECFF;
        TabBackground.ColorBR = #ECECECFF;
        TabBackground.ColorTL = #ECECECFF;
        TabBackground.ColorTR = #ECECECFF;

        
    }
            

    InvalidateViewState();


    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <520,160,720,200>
  property ^string Selected = null;

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <549,40,749,80>
  property slot OnDeactivate = null;

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <40,20,85,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "(33)";
    preset Font = App::FontVerdana16;
    preset Color = #0A0637FF;
  }

  $rect <300,70,500,110>
  property uint16 NumberOf = 0;

  $rect <20,20,160,60>
  object Views::AttrText Text1
  {
    preset Bounds = <35,5,132,45>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertTop];
    preset String = "";
    preset AttrSet = AttrSet1;
  }

  $rect <500,590,700,630>
  $output true
  object Graphics::AttrSet AttrSet1
  {
    preset Font3 = App::FontVerdanaProCondSemiBold18;
    preset Font2 = OldResources::FontVerdana18;
    preset Font1 = App::FontVerdana14;
    preset Font0 = App::VerdanaProSemiBold16;
    preset Color1 = #000000FF;
    preset Color0 = #111111FF;
  }

  $rect <810,80,1010,120>
  object Core::Timer Timer
  {
    preset OnTrigger = TimerSlot;
    preset Period = 400;
    preset Enabled = false;
  }

  $rect <810,120,1010,160>
  slot TimerSlot
  {
    sender; /* the method is called from the sender object */

    Image.Visible = !Image.Visible;

     

  }
}

$rect <1240,310,1440,350>
$output false
resource Resources::Bitmap AlarmBitmap
{
  attr bitmapfile FileName = .\Images\alarm2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,590,1640,630>
$output false
resource Resources::Bitmap AlertBitmap
{
  attr bitmapfile FileName = .\Images\alert2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <230,90,380,130>
$output false
class AlarmRowItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
     
          

          OrderPos.String = App::Lib.Order(  OrderPosition );



            
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,45>;
    preset Color = #E2E2E2FF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <66,20,458,43>;
    preset WrapWidth = Bounds.w;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Textual Description";
    preset Font = Resources::FontMedium;
    preset Color = #161616FF;
  }

  $rect <20,20,160,60>
  object Views::Text OrderPos
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,65,45>;
    preset String = "Text";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #161616FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <68,0,420,20>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel dfjfkdljfls Zone 95 Unit 223 (Firstaid) First Aid";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #161616FF;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <401,0,505,18>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "12:33 31/12/18";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #161616FF;
  }

  $rect <190,190,390,230>
  object Core::Timer Timer
  {
    preset OnTrigger = Trigger;
    preset Period = 600;
    preset Enabled = true;
  }

  $rect <660,10,790,50>
  slot Trigger
  {
    sender; /* the method is called from the sender object */

     
    OrderPos.Visible = !OrderPos.Visible;
     


  }

  $rect <0,70,200,110>
  property int32 OrderPosition = 1;

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight];
    preset Bounds = <469,20,501,42>;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset Bitmap = App::SilencedBitmap;
  }

  $rect <20,20,160,60>
  object App::ChannelImage ChannelImage
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <510,4,546,40>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <510,4,546,40>;
    preset Bitmap = Resources::DefaultBitmap;
  }
}

$rect <1240,350,1440,390>
$output false
resource Resources::Bitmap FireAlarmBitmap
{
  attr bitmapfile FileName = .\Images\fire_alarm.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <680,40,830,80>
$output false
class Button : Core::Group
{
  $rect <0,260,200,300>
  inherited property Bounds = <0,0,120,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

      Path1.InitSubPath( 0, 4 + 20  );
    //  Path1.Translate( 1,1 )    ;
      Path1.Begin( 0, pure Radius, 0 );
      Path1.AddArc( 0, Bounds.w-2 - pure Radius , pure Radius, pure Radius, pure Radius, -90, 0, 5 );
      Path1.AddArc( 0, Bounds.w-2 - pure Radius , Bounds.h-3 - pure Radius, pure Radius, pure Radius, 0, 90, 5 );
      Path1.AddArc( 0, pure Radius , Bounds.h-3 - pure Radius, pure Radius, pure Radius, 90, 180, 5 );
      Path1.AddArc( 0, pure Radius , pure Radius, pure Radius, pure Radius, 180, 270, 5 );
      Path1.Close( 0 );
      return;


    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var App::Application app = (App::Application) GetRoot( ) ;

    if ( app != null )
    {
      if ( Elevation > ((App::Application)GetRoot() ).LevelAccess.AccessLevel )
      {
          Greyed.Visible = true;
      }
      else
      {
          Greyed.Visible = false;
      }
    }

     
    Image.Bitmap = Icon;


    AttrText.String = ButtonText;



    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <665,125,805,165>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    // Assume the worst case of a ring composed of two ellipsis thus
    // two sub-paths.

      Path1.InitSubPath( 0, 4 + 20  );
      Path1.Translate( 1,1 )    ;
      Path1.Begin( 0, pure Radius, 0 );
      Path1.AddArc( 0, Bounds.w-2 - pure Radius , pure Radius, pure Radius, pure Radius, -90, 0, 5 );
      Path1.AddArc( 0, Bounds.w-2 - pure Radius , Bounds.h-3 - pure Radius, pure Radius, pure Radius, 0, 90, 5 );
      Path1.AddArc( 0, pure Radius , Bounds.h-3 - pure Radius, pure Radius, pure Radius, 90, 180, 5 );
      Path1.AddArc( 0, pure Radius , pure Radius, pure Radius, pure Radius, 180, 270, 5 );
      Path1.Close( 0 );
      return;

  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,45>;
    preset Color = #E2E2E2FF;
    preset Quality = false;
    preset Path = Path1;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToLeft, ResizeVert];
    preset Bounds = <0,0,40,45>;
    preset Bitmap = null;
  }

  $rect <0,60,200,100>
  property Resources::Bitmap Icon = null;

  $rect <0,110,200,150>
  property string ButtonText = "Button";

  $rect <20,20,160,60>
  object Views::AttrText AttrText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <40,0,120,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text {img0}";
    preset AttrSet = AttrSet;
  }

  $rect <410,30,610,70>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font3 = Steel::FontArial12;
    preset Font2 = App::FontVerdana14;
    preset Font1 = App::VerdanaProSemiBold16;
    preset Font0 = App::FontVerdanaProSemiBold18;
    preset Color2 = #000000FF;
    preset Color1 = #757575FF;
    preset Color0 = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::StrokePath StrokePath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,45>;
    preset Color = #646464FF;
    preset Quality = true;
    preset JoinPoints = Graphics::PathJoin.Round;
    preset Width = 2;
    preset Path = Path1;
  }

  $rect <310,160,510,200>
  object Graphics::Path Path1;

  $rect <790,0,990,40>
  property int32 Radius = 5;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <120,0>;
    preset Point2 = <120,45>;
    preset Point1 = <0,45>;
    preset OnRelease = Release;
    preset OnPress = Touch;
  }

  $rect <205,10,370,40>
  property slot ActionPress = null;

  $rect <265,95,395,135>
  slot Touch
  {
    sender; /* the method is called from the sender object */

    FillPath.Color = #8BB8E8FF;


    if ( ((App::Application)GetRoot()).LevelAccess.AccessLevel >= Elevation )
    {
      postsignal ActionPress;
    }
    else
    {
       ((App::Application)GetRoot()).LowLevel( Elevation );
    }




  }

  $rect <410,100,540,140>
  slot Release
  {
    sender; /* the method is called from the sender object */


    FillPath.Color = #E2E2E2FF;

    postsignal ActionRelease;




  }

  $rect <20,20,160,60>
  object Views::Rectangle Greyed
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,45>;
    preset Color = #ECECEC96;
  }

  $rect <210,50,370,90>
  property slot ActionRelease = null;

  $rect <0,140,200,180>
  property int8 Elevation = 0;

  $rect <0,180,200,220>
  onset Elevation
  {
    // The value doesn't change - nothing to do.
    if ( pure Elevation == value )
      return;

    // Remember the property's new value.
    pure Elevation = value;


    InvalidateViewState();

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }
}

$rect <1240,390,1440,430>
$output false
resource Resources::Bitmap KeyBitmap
{
  attr bitmapfile FileName = .\Images\logon40c.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1100,40,1220,80>
$output false
enum IconEnum
{
  $rect <10,10,210,50>
  item TempSensor;

  $rect <220,10,420,50>
  item SmokeSensor;

  $rect <430,10,630,50>
  item AlarmActivated;
}

$rect <1240,430,1440,470>
$output false
resource Resources::Bitmap MuteBitmap
{
  attr bitmapfile FileName = .\Images\mute40c.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

// This class implements a 'scrollbar' widget. The widget is intended to show the \
// current position within a large document (e.g. a long list with thousand of items). \
// It is not intended to react to user interactions.
// When using the scrollbar you need to set its property @ContentArea to the size \
// of the entire document and the property @ViewArea to the size of the visible portion \
// of the document. The scrollbar will calculate from these both values the size \
// of the scrollbar thumb. The current scroll position within the document is determined \
// by the property @Position.
// Per default the scrollbar is invisible. It appears when the properties @ContentSize, \
// @ViewSize or @Position are changed. After a short delay the scrollbar disappears \
// again.
$rect <830,40,970,80>
$output false
class VertScrollbar : Templates::VerticalScrollbar
{
  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,70,340>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2F2F2FFF;
    preset AlphaBlended = false;
  }

  $rect <540,230,740,270>
  inherited property Bounds = <0,0,70,340>;

  $rect <320,190,520,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    Thumb.ColorBR =   #D8D8FFFF;
    Thumb.ColorBL =   #5E5E93FF;
    Thumb.ColorTR =   #D8D8FFFF;
    Thumb.ColorTL =   #5E5E93FF;

    Thumb.Bounds.y1 = Rectangle2.Bounds.y1 + ( Position * Rectangle2.Bounds.h / ContentArea );
    Thumb.Bounds.h = Rectangle2.Bounds.h * ViewArea / ContentArea;

  }

  $rect <540,190,740,230>
  inherited property Enabled = false;

  // To do:
  // 
  // - Adjust the visible size of your scrollbar (the thick blue border). This will \
  // be the scrollbar's default size.
  // - Remove the 'Thumb' member if you want other views to be shown instead this \
  // in your scrollbar.
  // - According to your desired scrollbar design add and configure new views (e.g. \
  // a bitmap frame view to show the thumb, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the scrollbar's current state.
  // - You can also add and configure animation effects to your scrollbar. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your scrollbar.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the scrollbar itself is resized.
  // - Configure the property 'Begin' of the 'ActiveTimer' member to determine when \
  // the scrollbar should disappear. The default duration is 500 millisec.
  // - If you don't want the scrollbar to disappear automatically, remove the members \
  // 'ActiveTimer' and 'onActiveTimer'.
  // - From the Gallery folder 'Chora' add properties to your scrollbar. One property \
  // for every scrollbar specific setting (e.g. 'Color', 'Image', etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'ThumbColor' should update the color property of a rectangle \
  // view representing the thumb in your scrollbar).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note3
  {
    attr Bounds = <200,360,1180,700>;
  }

  // State management
  note group Note2
  {
    attr Bounds = <310,150,530,280>;
  }

  // This variable stores the current state of the scrollbar.
  $rect <320,230,520,270>
  var bool active;

  $rect <490,80,690,120>
  onget Position
  {
    // Get the internally stored value of the property 'Position' and the maximum
    // value the position may assume.
    var int32 value = pure Position;
    var int32 range = ContentArea - ViewArea;

    // Limit the value of the property to its max. allowed value.
    if (( range >  0 ) && ( value > range )) value = range;
    if (  range <= 0 )                       value = 0;

    return value;
  }

  $rect <490,40,690,80>
  onset Position
  {
    // Limit to valid range
    if ( value < 0 )
      value = 0;

    // Check if the given value differs from the current value.
    if ( pure Position == value )
      return;

    // Remember the new value.
    pure Position = value;

    if ( pure Position + ViewArea > ContentArea ) pure Position = ContentArea -  ViewArea;


    if ( Outlet != null ) Outlet^ = Position;



    // Finally force the component to update its appearance.
    InvalidateViewState();
  }

  $rect <290,40,490,80>
  onset ViewArea
  {
    // Limit to valid range
    if ( value < 0 )
      value = 0;

    // Check if the given value differs from the current value.
    if ( pure ViewArea == value )
      return;

    // Remember the new value.
    pure ViewArea = value;

    ThumbSize = Rectangle2.Bounds.h * ViewArea / ContentArea;

    // Every time the size of the view area is modified, the scrollbar should
    // appear for a short period automatically. After the period the scrollbar 
    // disappears again. This short period is controlled by the 'ActiveTimer'.
    // Restart the timer now. Do it however only when there is content to scroll:
    // when 'ContentArea' > 'ViewArea'.
    // to hide the scrollbar.


    // Finally force the component to update its appearance.
    InvalidateViewState();
  }

  $rect <90,40,290,80>
  onset ContentArea
  {
    // Limit to valid range
    if ( value < 0 )
      value = 0;

    // Check if the given value differs from the current value.
    if ( pure ContentArea == value )
      return;

    // Remember the new value.
    pure ContentArea = value;

    if ( ContentArea < ViewArea ) ContentArea = ViewArea;
    // Every time the size of the content area is modified, the scrollbar should
    // appear for a short period automatically. After the period the scrollbar 
    // disappears again. This short period is controlled by the 'ActiveTimer'.
    // Restart the timer now. Do it however only when there is content to scroll:
    // when 'ContentArea' > 'ViewArea'.

    // Finally force the component to update its appearance.
    InvalidateViewState();
  }

  // The property 'Position' determines the current scroll position within the entire \
  // content. Generally the value lies in the range 0 .. ( @ContentArea - @ViewArea \
  // ).
  $rect <490,0,690,40>
  property int32 Position = 0;

  // The property 'ViewArea' determines the size of the visible portion of the entire \
  // content. This usually corresponds to the size of the viewport where the user \
  // can see the document (the image, text, etc.). Generally the value ViewArea <= \
  // @ContentArea.
  $rect <290,0,490,40>
  property int32 ViewArea = 160;

  // The property 'ContentArea' determines the size of the entire content to scroll. \
  // This usually corresponds to the size of the document (image, text, etc.) you \
  // want to present to the user. Generally the value ContentArea >= @ViewArea.
  $rect <90,0,290,40>
  property int32 ContentArea = 1000;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,2,68,338>;
    preset Color = #353535FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Thumb
  {
    preset Layout = Core::Layout[ResizeHorz];
    preset Bounds = <2,2,68,70>;
    preset ColorBL = #D8D8FFFF;
    preset ColorBR = #5E5E83FF;
    preset ColorTR = #5E5E83FF;
    preset ColorTL = #D8D8FFFF;
    preset Color = #047601FF;
    preset AlphaBlended = false;
  }

  $rect <830,130,1030,170>
  slot Start
  {
    sender; /* the method is called from the sender object */


    //StartPos = Touch.Offset.y;

  }

  $rect <810,210,1010,250>
  slot Stop
  {
    sender; /* the method is called from the sender object */
  }

  $rect <810,170,1010,210>
  slot Drag
  {
    sender; /* the method is called from the sender object */

    //Position = Position + Touch.Offset.y;

  }

  $rect <830,80,1030,120>
  var int32 StartPos = 0;

  $rect <100,100,300,140>
  slot Bottom
  {
    sender; /* the method is called from the sender object */

    Position = 999999;

    postsignal OnChange;

    InvalidateViewState();

  }

  $rect <100,150,300,190>
  slot Top
  {
    sender; /* the method is called from the sender object */

    Position = 0;

    postsignal OnChange;

    InvalidateViewState();


  }

  $rect <100,250,300,290>
  slot Down
  {
    sender; /* the method is called from the sender object */

    Position = Position + ViewArea;

    signal OnChange;

    InvalidateViewState();

  }

  $rect <100,210,300,250>
  slot Up
  {
    sender; /* the method is called from the sender object */

    Position = Position - ViewArea;

    postsignal OnChange;

    InvalidateViewState();

  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,10,60,60>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #6C6C6CFF;
    preset ColorTR = #6C6C6CFF;
    preset ColorTL = #FFFFFFFF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <10,10>;
    preset Point3 = <60,10>;
    preset Point2 = <60,60>;
    preset Point1 = <10,60>;
    preset OnPress = Top;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,70,60,120>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #6C6C6CFF;
    preset ColorTR = #6C6C6CFF;
    preset ColorTL = #FFFFFFFF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <10,70>;
    preset Point3 = <60,70>;
    preset Point2 = <60,120>;
    preset Point1 = <10,120>;
    preset OnPress = Up;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,280,60,330>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #6C6C6CFF;
    preset ColorTR = #6C6C6CFF;
    preset ColorTL = #FFFFFFFF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <10,280>;
    preset Point3 = <60,280>;
    preset Point2 = <60,330>;
    preset Point1 = <10,330>;
    preset OnPress = Bottom;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,220,60,270>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #6C6C6CFF;
    preset ColorTR = #6C6C6CFF;
    preset ColorTL = #FFFFFFFF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <10,220>;
    preset Point3 = <60,220>;
    preset Point2 = <60,270>;
    preset Point1 = <10,270>;
    preset OnDrag = null;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnHold = null;
    preset OnRelease = null;
    preset OnPress = Down;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,10,60,60>;
    preset Color = #F00000FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,70,60,120>;
    preset Color = #F00000FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Border Border2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,220,60,270>;
    preset Color = #F00000FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Border Border3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,280,60,330>;
    preset Color = #F00000FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,70,60,120>;
    preset Bitmap = App::UpBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,280,60,330>;
    preset Bitmap = App::EndBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,10,60,60>;
    preset Bitmap = App::StartBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image Image3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,220,60,270>;
    preset Bitmap = App::DownBitmap;
  }

  // The property 'Position' determines the current scroll position within the entire \
  // content. Generally the value lies in the range 0 .. ( @ContentArea - @ViewArea \
  // ).
  $rect <700,0,900,40>
  property int32 ThumbSize = 50;

  $rect <1000,0,1200,40>
  property ^int32 Outlet = null;

  $rect <1000,40,1200,80>
  onset Outlet
  {
    /* check if the new outlet differs from the currently used outlet */
    if ( pure Outlet == value )
      return;

    /* detach from the previous outlet */
    if ( pure Outlet != null )
      detachobserver outletSlot, pure Outlet;

    /* store the new outlet */
    pure Outlet = value;

    /* ... and attach to the new one */
    if ( value != null )
      attachobserver outletSlot, value;

    /* finally, update the current state of the widget by posting a signal to the outlet slot */
    if ( value != null )
      postsignal outletSlot;

  }

  $rect <1050,80,1250,120>
  slot outletSlot
  {
    sender; /* the method is called from the sender object */

    if ( Outlet != null )
      Position = Outlet^;


  }

  $rect <310,300,510,340>
  property slot OnChange = null;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler4
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <10,70>;
    preset Point3 = <60,70>;
    preset Point2 = <60,120>;
    preset Point1 = <10,120>;
    preset OnPress = Up;
  }

  $reorder Bevel 76
}

$rect <1660,630,1860,670>
$output false
resource Resources::Bitmap HelpBitmap
{
  attr bitmapfile FileName = .\Images\help.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,670,1440,710>
$output false
resource Resources::Bitmap CygnusBitmap
{
  attr bitmapfile FileName = .\Images\Cygnus_Smartnet_crap_blue.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,710,1860,750>
$output false
resource Resources::Bitmap FaultBitmap
{
  attr bitmapfile FileName = .\Images\fault.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,310,1860,350>
$output false
resource Resources::Bitmap DisableBitmap
{
  attr bitmapfile FileName = .\Images\disablements_new.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,310,1640,350>
$output false
resource Resources::Bitmap OnTestBitmap
{
  attr bitmapfile FileName = .\Images\test.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <530,40,680,80>
$output false
class TabButtonPull : Core::Group
{
  $rect <800,110,940,150>
  inherited property Layout = Core::Layout[ResizeHorz, ResizeVert];

  $rect <810,170,1010,210>
  inherited property Bounds = <0,0,180,295>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


          Text1.String = Text;

          var App::Application app = (App::Application) GetRoot();
          var uint8 Access = 5;
          
          if ( app != null ) Access = app.LevelAccess.AccessLevel;

          SelectionText.String = "Menu level " + string( Access );
      //    Image.Bitmap = Icon;

          
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle TabPullBackground
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <47,1,179,44>;
    preset ColorBL = #BBBBBBFF;
    preset ColorBR = #BBBBBBFF;
    preset ColorTR = #BBBBBBFF;
    preset ColorTL = #BBBBBBFF;
    preset Color = #BBBBBBFF;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <46,0,180,45>;
    preset Width = 1;
    preset ColorL = #737373FF;
    preset ColorR = #303030ff;
    preset ColorB = #303030ff;
    preset ColorT = #737373FF;
  }

  // This variable stores the current state of the button.
  $rect <10,490,210,530>
  var bool selected = false;

  // This variable stores the current state of the button.
  $rect <10,450,210,490>
  var bool enabled = true;

  $rect <250,80,450,120>
  slot OnPress
  {
    sender; /* the method is called from the sender object */

       
    if ( !pressed )
    {
      var App::Application ap = (App::Application) this.GetRoot();

      if ( ap.LevelAccess.AccessLevel > 1 )
      {
     
        pressed = true;

        Menu.Visible = true;
        Menu.Enabled = true;
        Rectangle.Visible = true;
        Rectangle1.Visible = true;
        Rectangle2.Visible = true;


        outside1 = new Core::SimpleTouchHandler;
        outside2 = new Core::SimpleTouchHandler;

        outside1.Point1 = <0,0>;
        outside1.Point2 = <630,0>;
        outside1.Point3 = <630,325>;
        outside1.Point4 = <0, 325>;

        outside2.Point1 = <0,325>;
        outside2.Point2 = <800,325>;
        outside2.Point3 = <800,480>;
        outside2.Point4 = <0, 480>;

        outside1.OnPress = OutsidePress;
        outside2.OnPress = OutsidePress;

        Owner.Add( outside1, 0 );
        Owner.Add( outside2, 0 );

        InvalidateViewState();
      }
      else
      {
       ((App::Application) GetRoot()).LowLevel(2);
       }

    }


  }

  $rect <870,0,1070,40>
  property string Text = "TabButton";

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <50,0,129,25>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Access";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <820,60,1020,100>
  property Resources::Bitmap Icon = null;

  $rect <600,270,800,310>
  property bool pressed = false;

  $rect <600,320,800,360>
  onset pressed
  {
    // The value doesn't change - nothing to do.
    if ( pure pressed == value )
      return;

    // Remember the property's new value.
    pure pressed = value;

     var color t = Bevel.ColorB;
      Bevel.ColorB = Bevel.ColorT;
      Bevel.ColorT = t;

      t = Bevel.ColorL;
      Bevel.ColorL = Bevel.ColorR;
      Bevel.ColorR = t;

    if ( pressed )
    {
        TabPullBackground.ColorBR =  #8E8E8EFF;
        
    }

    else
    {
         TabPullBackground.ColorBR = TabPullBackground.ColorTR;
        
        
    }
            

    InvalidateViewState();


  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <143,3,175,32>;
    preset Bitmap = App::DropdownBitmap;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <45,0>;
    preset Point3 = <179,0>;
    preset Point2 = <179,45>;
    preset Point1 = <45,45>;
    preset OnLeave = null;
    preset OnRelease = null;
    preset OnPress = OnPress;
  }

  $rect <20,20,160,60>
  object Core::VerticalList Menu
  {
    preset Layout = Core::Layout[AlignToTop, ResizeHorz];
    preset Bounds = <10,45,180,285>;
    preset Enabled = false;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 40;
    preset NoOfItems = 6;
    preset ItemClass = App::MenuItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <225,125,425,165>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = Menu.Item;
    var App::MenuItem item = (App::MenuItem) Menu.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    item.Elevation = 2;

    switch ( itemNo )
    {
        case 0 : item.Text1.String = "Enable/Disable";
        case 1 : item.Text1.String = "Testing";

        case 5: {item.Text1.String = "System Settings";
                 item.Elevation = 3;}
        case 3 : {item.Text1.String = "Modify Devices";
                  item.Elevation = 3;}
        case 4 : item.Text1.String = "Mesh Status";
        case 2 : item.Text1.String = "Site Settings";
    }


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.

    item.Bounds.size = point( Menu.Bounds.w, Menu.ItemHeight );
  }

  $rect <260,175,460,215>
  method void MenuChoice( arg App::MenuItem choice )
  {
    /* The template just returns the given argument... */
                 
    Owner.Remove( outside1 );
    Owner.Remove( outside2 ); 



    ((App::Application) Owner).PageDeselection( );

    SelectionText.String = choice.Text1.String;
    TabPullBackground.Color = #93C2FFFF;
     


    ((App::Application) Owner).SelectedTab = SelectionText.String;
                        

    Menu.Visible = false;
    Menu.Enabled = false;

    Rectangle.Visible = false;
    Rectangle1.Visible = false;
    Rectangle2.Visible = false;

    pressed = false;                  

    postsignal OnSelectItem; 

    return;
  }

  $rect <570,10,770,50>
  property slot OnSelectItem = null;

  $rect <20,20,160,60>
  object Views::Text SelectionText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <50,20,145,46>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = App::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $rect <480,70,680,110>
  slot OutsidePress
  {
    sender; /* the method is called from the sender object */

    Owner.Remove( outside1 );
    Owner.Remove( outside2 ); 




    Menu.Visible = false;
    Menu.Enabled = false;

    Rectangle.Visible = false;
    Rectangle1.Visible = false;
    Rectangle2.Visible = false;

    pressed = false;    
  }

  $rect <490,120,690,160>
  var Core::SimpleTouchHandler outside1 = null;

  $rect <505,180,705,220>
  var Core::SimpleTouchHandler outside2 = null;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <10,285,180,295>;
    preset ColorBL = #00000000;
    preset ColorBR = #00000000;
    preset ColorTR = #00000080;
    preset ColorTL = #00000080;
    preset Color;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,285,10,295>;
    preset ColorBL = #00000000;
    preset ColorBR = #00000000;
    preset ColorTR = #00000080;
    preset ColorTL = #00000000;
    preset Color;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,45,10,285>;
    preset ColorBL = #00000000;
    preset ColorBR = #00000080;
    preset ColorTR = #00000080;
    preset ColorTL = #00000000;
    preset Visible = false;
  }

  $rect <305,285,505,325>
  method void SetChoice( arg string choice )
  {
    /* The template just returns the given argument... */
                 
     

    ((App::Application) Owner).PageDeselection( );

    SelectionText.String = choice;
    TabPullBackground.Color = #93C2FFFF;
     

    ((App::Application) Owner).SelectedTab = choice;
                        
                     

    postsignal OnSelectItem;

    return;
  }
}

$rect <1240,230,1440,270>
$output false
resource Resources::Bitmap XBitmap
{
  attr bitmapfile FileName = .\Images\x-mark-32.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,270,1640,310>
$output false
resource Resources::Bitmap AccessBitmap
{
  attr bitmapfile FileName = .\Images\access.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,710,1440,750>
$output false
resource Resources::Bitmap DropdownBitmap
{
  attr bitmapfile FileName = .\Images\dropdown.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,670,1860,710>
$output false
resource Resources::Bitmap EvacuateBitmap
{
  attr bitmapfile FileName = .\Images\evacuate40c.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,750,1640,790>
$output false
resource Resources::Bitmap OnTestBitmap1
{
  attr bitmapfile FileName = .\Images\test.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,590,1440,630>
$output false
resource Resources::Bitmap ResetBitmap
{
  attr bitmapfile FileName = .\Images\reset40c.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,670,1640,710>
$output false
resource Resources::Bitmap EndBitmap
{
  attr bitmapfile FileName = .\Images\end.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,710,1640,750>
$output false
resource Resources::Bitmap StartBitmap
{
  attr bitmapfile FileName = .\Images\start.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,590,1860,630>
$output false
resource Resources::Bitmap DownBitmap
{
  attr bitmapfile FileName = .\Images\down.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1300,1250,1500,1290>
$output false
resource Resources::Font FontVerdana16
{
  attr fontname FontName = Verdana;
  attr fontheight Height = 16;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7E;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <1660,510,1860,550>
$output false
resource Resources::Bitmap ExpandBitmap
{
  attr bitmapfile FileName = .\Images\expand30.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,550,1860,590>
$output false
resource Resources::Bitmap CollapseBitmap
{
  attr bitmapfile FileName = .\Images\collapse30.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <790,180,990,220>
$output false
class CheckBoxRow : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,600,35>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object App::FlatCheckBox FlatCheckBox0
  {
    preset Bounds = <0,0,300,35>;
  }

  $rect <20,20,160,60>
  object App::FlatCheckBox FlatCheckBox1
  {
    preset Bounds = <300,0,600,35>;
  }
}

$rect <1230,40,1430,80>
$output false
class FlatCheckBox : Flat::CheckBox
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,150,35>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  inherited object TouchHandler
  {
    preset Point4 = <0,35>;
    preset Point3 = <150,35>;
    preset Point2 = <150,0>;
  }

  $rect <20,20,160,60>
  inherited object BoxImage
  {
    preset Bounds = <0,0,40,35>;
  }

  $rect <20,20,160,60>
  inherited object CheckImage
  {
    preset Bounds = <0,0,140,35>;
  }

  $rect <20,20,160,60>
  inherited object CaptionText
  {
    preset Bounds = <35,0,140,35>;
    preset Font = Flat::FontS;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }
}

$rect <250,147,450,187>
$output false
class DeviceItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,520,50>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    UnitNumberText.String = "Disable Unit " + string( UnitNum );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object App::FlatCheckBox FlatCheckBox0
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <-1,0,60,50>;
    preset OnChange = OnChangeSlot;
    preset Caption = "";
  }

  $rect <70,80,270,120>
  property int32 UnitNum = 0;

  $rect <20,20,160,60>
  object Views::Text UnitNumberText
  {
    preset Bounds = <49,2,189,22>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 1 Unit 23";
    preset Font = App::FontVerdanaProSemiBold18;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <48,17,463,47>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Hallway, Front building 2";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, ResizeVert];
    preset Bounds = <472,5,512,45>;
    preset ScrollOffset = <0,0>;
    preset Bitmap = App::FireAlarmBitmap;
  }

  $rect <320,80,520,120>
  slot OnChangeSlot
  {
    sender; /* the method is called from the sender object */

    /*

     var Core::VerticalList vl = (Core::VerticalList) this.Owner;

            if ( vl != null )
            {
                 var Application::DeviceItem di = (Application::DeviceItem) vl.first;

                 while ( di != null )
                 {
                    if ( di.FlatCheckBox0.Checked ) return;
                
                    di = (Application::DeviceItem) di.next;
                 }
                 var Application::DynamicAreaHead head = (Application::DynamicAreaHead) vl.prev;

                 if ( head != null ) head.CheckBox.Checked = false;
             }

             */
  }
}

$rect <0,140,110,180>
$output false
class Events : Core::Group
{
  $rect <10,470,210,510>
  inherited property Bounds = <0,0,795,365>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

     

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,430,210,470>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <500,450,1280,770>;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <850,270,1050,310>
  slot OnLoadItem
  {
    var int16 itemNo   = ListViewer.Item;

    var App::AlarmRowItem row = (App::AlarmRowItem)ListViewer.VerticalList.View;

    if ( row != null )
    {
      var App::Alert alert;

      var int32 numAlarms = 0;

      native( numAlarms )
      {
        Command cmd;
        Command0( CMD_GET_NUM_OTHER_EVENTS, &cmd );
        numAlarms = cmd.int0;
      }


      if ( numAlarms == 0 || itemNo < 0 || itemNo >= numAlarms )
      {
         row.Visible = false;
         row.InvalidateViewState();
         return;
      }

      row.Visible = true;

      if ( itemNo == 0 )
      {
          row.Timer.Enabled = true;
          row.OrderPosition = numAlarms;
          alert = App::Lib.GetAlertNum( App::ActionBits[ Evacuation, FirstAid, General, Security, RoutingAck ], numAlarms - 1 );
      }
      else
      {  
         row.Timer.Enabled = false;
         row.OrderPos.Visible = true;
         row.OrderPosition = itemNo;
         alert = App::Lib.GetAlertNum( App::ActionBits[ Evacuation, FirstAid, General, Security, RoutingAck ], itemNo - 1 ); 
      }  
      
      if ( alert.flags.contains( App::AlertFlags[ Silenced ] ) )
      {
         row.Image1.Visible = true;
      }
      else
      {
         row.Image1.Visible = false;
      }

      if ( alert.flags.contains( App::AlertFlags[ CAE ] ) )
      {
         row.ZoneText.String = "Rule " + string( alert.unitnum ) + "  Zone " + string( alert.zonenum ) + " (" + App::Lib.ProfileName( (App::Profile) alert.action ) + ")";
         row.Image.Visible = true;
         row.Image.Bitmap = App::CauseEffect2;
         row.ChannelImage.Visible = false;
         row.ChannelImage.Bitmap = App::ChannelType.None;
      }
      else if ( alert.flags.contains( App::AlertFlags[ NetCAE ] ) )
      {
         row.ZoneText.String = App::Lib.GetPanelName( alert.panelnum ) + " Rule " + string( alert.unitnum ) + "  Zone " + string( alert.zonenum ) + " (" + App::Lib.ProfileName( (App::Profile) alert.action ) + ")";
         row.Image.Visible = true;
         row.Image.Bitmap = App::CauseEffect2;
         row.ChannelImage.Visible = false;
         row.ChannelImage.Bitmap = App::ChannelType.None;
      }
      else if ( alert.flags.contains( App::AlertFlags[ Device ] ) )
      {
         row.ZoneText.String = "Zone " + string( alert.zonenum ) + " " + App::Lib.Unit( alert.unitnum ) + " ("  + App::Lib.ProfileName( (App::Profile) alert.action ) + ")";
         row.Image.Visible = false;
         row.ChannelImage.Visible = true;
         row.ChannelImage.Bitmap = alert.chanimg;
         row.Image.Bitmap = null;
      }
      else if ( alert.flags.contains( App::AlertFlags[ NetDevice ] ) )
      {
         row.ZoneText.String = App::Lib.GetPanelName( alert.panelnum ) + " Zone " + string( alert.zonenum ) + " Unit " + App::Lib.Unit( alert.unitnum ) + " (" + App::Lib.ProfileName( (App::Profile) alert.action ) + ")";
         row.ChannelImage.Bitmap = alert.chanimg;
         row.ChannelImage.Visible = true;
         row.Image.Bitmap = null;
         row.Image.Visible = false;
      }
                

      row.Text.String = alert.description;
      row.TimeText.String = alert.time; 
      row.InvalidateViewState();
    }

      

      /*













    var int16 itemNo   = VerticalList.Item;

    var App::EventItem row = (App::EventItem) VerticalList.View;


    if ( itemNo == 0 )
    {
        row.Flashing = true;
    }
    else
    {  
       row.Flashing = false;
    }

    var int16 order = itemNo + 1;
    var int16 type = 0;
    var string location = "Unknown";
    var string time = "";
    var int16  zone = 0;
    var int16  yunit = 0;
    var int16 fires = 0;

    native ( order, type, location, zone, yunit, itemNo, fires, time )
    {
      Command cmd;

      Command0(  CMD_GET_NUM_OTHER_EVENTS, &cmd );  

      fires = cmd.int0;

      if ( fires != 0 )
      {
        if ( itemNo == 0 )
        {
          cmd.int0 = fires - 1;
        }
        else
        {
          cmd.int0 = itemNo - 1;
        }

        order = cmd.int0 + 1;

        Command0( CMD_GET_OTHER_EVENTS_DETAILS, &cmd );
     
        location = EwNewStringAnsi( (char*) cmd.int0 );
        time = EwNewStringAnsi( (char*) cmd.int3);
        zone  = cmd.short2;
        yunit = cmd.short3;
        type = cmd.short4;
       }
    }

    $if ($prototyper)
    if ( itemNo == 0 )
    {
      order = VerticalList.NoOfItems;
    }
    else
    {
      order = itemNo;
    }
    $endif

    row.OrderPosition = order;

    if ( type == 1 )
    {
      row.Image.Bitmap = App::GreenCallpointBitmap;
    }
    else if ( type == 4 )
    {
      row.Image.Bitmap = App::PIRBitmap;
    }
    else if ( type == 3 )
    {
       row.Image.Bitmap = App::EvacEvent;
    }

    row.Text.String = location;
    row.ZoneText.String = "Zone " + string( zone)+"  Unit " + string( yunit );
    row.TimeText.String = time; 

    row.Bounds.w = VerticalList.Bounds.w;                     */
  }

  $rect <830,330,1050,370>
  object Core::SystemEventHandler EventListChangeHandler
  {
    preset OnEvent = onEvent;
    preset Event = App::Devices.EventListChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <820,370,1020,410>
  slot onEvent
  {
    var int32 numItems = 8;


     
    native( numItems )
    {
      Command cmd;

      Command0( CMD_GET_NUM_OTHER_EVENTS, &cmd );

      numItems = cmd.int0;
    }  


    ListViewer.NoOfItems = numItems;

    var App::Application ap = (App::Application) Owner;

    if ( ap != null )
    {
      ap.EventsTabButton.NumberOf = numItems;
      ap.EventsTabButton.InvalidateViewState();

      if (   ap.AlarmsTabButton.NumberOf == 0  && 
             ap.FaultsTabButton.NumberOf == 0 &&
             ap.OnTestTabButton.NumberOf == 0  &&
             ap.DisablementsTabButton.NumberOf == 0 &&
             ap.SelectedTab != "{fnt3}{clr1}Other Events" && numItems != 0 && 
             ap.LevelAccess.AccessLevel < 3 )
      {
         postsignal ap.EventsTabButton.OnPress;  
      }
      else if ( numItems > 0 && ap.SelectedTab != "{fnt3}{clr1}Other Events" )
      {
         ap.EventsTabButton.Timer.Enabled = true;
      
      }
      else
      {
         ap.EventsTabButton.Timer.Enabled = false;
         ap.EventsTabButton.Image.Visible = true;
      } 
    }

     

    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <0,0,615,365>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::AlarmRowItem;
    preset ItemHeight = 50;
    preset onRefreshAll = RefreshAll;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <825,210,1025,250>
  slot RefreshAll
  {
    var int16 itemNo   = ListViewer.Item;

    var App::AlarmRowItem row = (App::AlarmRowItem)ListViewer.VerticalList.first;   

    if ( row != null )
    {
      var App::Alert alert;

      var int32 numAlarms = 0;
      
      var App::SiteSetting settings = App::SiteSetting[ ];

      native( numAlarms, settings )
      {
        Command cmd;
        Command0( CMD_GET_NUM_OTHER_EVENTS, &cmd );
        numAlarms = cmd.int0;

        Command0( CMD_GET_SETTINGS, &cmd );

        settings = cmd.int0;     
      }


      while ( numAlarms == 0 || itemNo < 0 || itemNo >= numAlarms )
      {
         row.Visible = false;
         row.InvalidateViewState();

         row = (App::AlarmRowItem) row.next;
         if ( row == null ) return;

         itemNo = itemNo + 1;
      }

      while ( row != null )
      {
          if ( itemNo >= numAlarms )
          {
              row.Visible = false;
          }
          else
          {
              row.Visible = true;

              if ( itemNo == 0 )
              {
                  row.Timer.Enabled = true;
                  row.OrderPosition = numAlarms;
                  alert = App::Lib.GetAlertNum( App::ActionBits[ Evacuation, FirstAid, General, Security, RoutingAck ], numAlarms - 1 );
              }
              else
              {  
                 row.Timer.Enabled = false;
                 row.OrderPos.Visible = true;
                 row.OrderPosition = itemNo;
                 alert = App::Lib.GetAlertNum( App::ActionBits[ Evacuation, FirstAid, General, Security, RoutingAck ], itemNo - 1 ); 
              }

              if ( alert.flags.isempty ) 
              {
                  row.Visible = false;
              }
              else
              {
                  if ( alert.flags.contains( App::AlertFlags[ Silenced ] ) )
                  {
                     row.Image1.Visible = true;
                  }
                  else
                  {
                     row.Image1.Visible = false;
                  }

                  if ( alert.flags.contains( App::AlertFlags[ CAE ] ) )
                  {
                     row.ZoneText.String = "Rule " + string( alert.unitnum ) + "  Zone " + string( alert.zonenum ) + " (" + App::Lib.ProfileName( (App::Profile) alert.action ) + ")";
                     row.Image.Visible = true;
                     row.Image.Bitmap = App::CauseEffect2;
                     row.ChannelImage.Visible = false;
                     row.ChannelImage.Bitmap = App::ChannelType.None;
                  }
                  else if ( alert.flags.contains( App::AlertFlags[ NetCAE ] ) )
                  {
                     row.ZoneText.String = App::Lib.GetPanelName(alert.panelnum) + " Rule " + string( alert.unitnum ) + "  Zone " + string( alert.zonenum ) + " (" + App::Lib.ProfileName( (App::Profile) alert.action ) + ")";
                     row.Image.Visible = true;
                     row.Image.Bitmap = App::CauseEffect2;
                     row.ChannelImage.Visible = false;
                     row.ChannelImage.Bitmap = App::ChannelType.None;
                  }
                  else if ( alert.flags.contains( App::AlertFlags[ Device ] ) )
                  {
                     row.ZoneText.String = "Zone " + string( alert.zonenum ) + " " + App::Lib.Unit( alert.unitnum ) + " (" + App::Lib.ProfileName( (App::Profile) alert.action ) + ")";
                     row.Image.Visible = false;
                     row.ChannelImage.Visible = true;
                     row.ChannelImage.Bitmap = alert.chanimg;
                     row.Image.Bitmap = null;
                  }
                  else if ( alert.flags.contains( App::AlertFlags[ NetDevice ] ) )
                  {
                     row.ZoneText.String = App::Lib.GetPanelName(alert.panelnum) + " Zone " + string( alert.zonenum ) + " " + App::Lib.Unit( alert.unitnum ) + " (" + App::Lib.ProfileName( (App::Profile) alert.action ) + ")";
                     row.ChannelImage.Bitmap = alert.chanimg;
                     row.ChannelImage.Visible = true;
                     row.Image.Bitmap = null;
                     row.Image.Visible = false;
                  }
                

                  row.Text.String = alert.description;
                  row.TimeText.String = alert.time; 
              }
          }
          row.InvalidateViewState();

          row = (App::AlarmRowItem) row.next;
          itemNo = itemNo + 1;
      }
    }

      

      /*













    var int16 itemNo   = VerticalList.Item;

    var App::EventItem row = (App::EventItem) VerticalList.View;


    if ( itemNo == 0 )
    {
        row.Flashing = true;
    }
    else
    {  
       row.Flashing = false;
    }

    var int16 order = itemNo + 1;
    var int16 type = 0;
    var string location = "Unknown";
    var string time = "";
    var int16  zone = 0;
    var int16  yunit = 0;
    var int16 fires = 0;

    native ( order, type, location, zone, yunit, itemNo, fires, time )
    {
      Command cmd;

      Command0(  CMD_GET_NUM_OTHER_EVENTS, &cmd );  

      fires = cmd.int0;

      if ( fires != 0 )
      {
        if ( itemNo == 0 )
        {
          cmd.int0 = fires - 1;
        }
        else
        {
          cmd.int0 = itemNo - 1;
        }

        order = cmd.int0 + 1;

        Command0( CMD_GET_OTHER_EVENTS_DETAILS, &cmd );
     
        location = EwNewStringAnsi( (char*) cmd.int0 );
        time = EwNewStringAnsi( (char*) cmd.int3);
        zone  = cmd.short2;
        yunit = cmd.short3;
        type = cmd.short4;
       }
    }

    $if ($prototyper)
    if ( itemNo == 0 )
    {
      order = VerticalList.NoOfItems;
    }
    else
    {
      order = itemNo;
    }
    $endif

    row.OrderPosition = order;

    if ( type == 1 )
    {
      row.Image.Bitmap = App::GreenCallpointBitmap;
    }
    else if ( type == 4 )
    {
      row.Image.Bitmap = App::PIRBitmap;
    }
    else if ( type == 3 )
    {
       row.Image.Bitmap = App::EvacEvent;
    }

    row.Text.String = location;
    row.ZoneText.String = "Zone " + string( zone)+"  Unit " + string( yunit );
    row.TimeText.String = time; 

    row.Bounds.w = VerticalList.Bounds.w;                     */
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ResoundAlarmsButton1
  {
    preset Bounds = <615,150,795,205>;
    preset OnRelease = null;
    preset OnActivate = ResoundSlot1;
    preset Label = "Re-sound Alarms";
    preset Appearance = App::NormalPushButton;
  }

  $rect <805,160,980,200>
  slot ResoundSlot1
  {
     
    if ( ((App::Application) GetRoot()).LevelAccess.AccessLevel >= 2 )
    {
      var App::Action a = App::Action.Resound;

      native (a)
      {
         event( EVENT_RESOUND_BUTTON );
         Command1( CMD_NETWORK, a );
      }

        signal ListViewer.onRefreshAll;
    }
    else
    {
       ((App::Application) GetRoot()).LowLevel( 2 );
    }
     
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ConfirmEventButton
  {
    preset Bounds = <615,0,795,55>;
    preset Enabled = false;
    preset OnRelease = null;
    preset OnActivate = ConfirmSlot;
    preset Label = "Confirm Event";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton AcknowledgeEventButton
  {
    preset Bounds = <615,75,795,130>;
    preset Enabled = false;
    preset OnRelease = null;
    preset OnActivate = AckSlot;
    preset IconFrame = -1;
    preset Icon = null;
    preset Label = "Acknowledge";
    preset Appearance = App::NormalPushButton;
  }

  $rect <845,5,985,45>
  slot ConfirmSlot
  {
    sender; /* the method is called from the sender object */

     
    native  
    {
       Command1( CMD_NETWORK, ACTION_SHIFT_CONFIRM_EVENT );
       event( EVENT_CONFIRM_EVENT_BUTTON );
    }
  }

  $rect <830,70,960,110>
  slot AckSlot
  {
    sender; /* the method is called from the sender object */

                                         
     
      native
      {
       Command1( CMD_NETWORK, ACTION_SHIFT_ACKNOWLEDGE_EVENT );
         event( EVENT_ACKNOWLEDGE_EVENT_BUTTON );
      }




     
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1095,105,1275,145>
  slot onConfirmEventSwitch
  {
    var App::ButtonState conf = (App::ButtonState) SwitchConfirmEventEvent.Context;


    if ( conf.on )
    {
      ConfirmEventButton.Enabled = true;
    }
    else
    {
       ConfirmEventButton.Enabled = false;
    }

     
  }

  $rect <1085,65,1285,105>
  object Core::SystemEventHandler SwitchConfirmEventEvent
  {
    preset OnEvent = onConfirmEventSwitch;
    preset Event = App::Devices.ConfirmEventAvailable;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1075,190,1270,230>
  slot onAcknowldegeEventSwitch
  {
    var App::ButtonState conf = (App::ButtonState) SwitchAcknowledgeEventEvent.Context;


    if ( conf.on )
    {
        AcknowledgeEventButton.Enabled = true;
    }
    else
    {
      AcknowledgeEventButton.Enabled = false; 
    }

     
  }

  $rect <1080,150,1280,190>
  object Core::SystemEventHandler SwitchAcknowledgeEventEvent
  {
    preset OnEvent = onAcknowldegeEventSwitch;
    preset Event = App::Devices.AcknowledgeEventAvailable;
  }

  $rect <1040,350,1275,390>
  object Core::SystemEventHandler SiteChangeEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = App::Devices.SiteChangedEvent;
  }

  $rect <550,400,795,440>
  object Core::SystemEventHandler ResoundStateEventHandler
  {
    preset OnEvent = onResoundStateEvent;
    preset Event = App::Devices.ResoudStateEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <380,395,585,435>
  slot onResoundStateEvent
  {
    ResoundAlarmsButton1.Enabled = ( ResoundStateEventHandler.Context != null );




  }
}

$rect <1270,1290,1510,1330>
$output false
resource Resources::Font VerdanaProSemiBold16
{
  attr fontname FontName = Verdana Pro SemiBold;
  attr fontheight Height = 16;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7E;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
}

$rect <1650,750,1850,790>
$output false
resource Resources::Bitmap SilenceBitmap
{
  attr bitmapfile FileName = .\Images\silence40c.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,790,1440,830>
$output false
resource Resources::Bitmap HeatBSensorBitmap
{
  attr bitmapfile FileName = .\Images\heat.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,550,1640,590>
$output false
resource Resources::Bitmap GreenCallpointBitmap
{
  attr bitmapfile FileName = .\Images\greencall2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,750,1440,790>
$output false
resource Resources::Bitmap PIRBitmap
{
  attr bitmapfile FileName = .\Images\pir.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,510,1640,550>
$output false
resource Resources::Bitmap SwitchBitmap
{
  attr bitmapfile FileName = .\Images\switch.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1530,1250,1820,1290>
$output false
resource Resources::Font FontVerdanaProCondSemiBold18
{
  attr fontname FontName = Verdana Pro Cond SemiBold;
  attr fontheight Height = 18;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7E;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <990,80,1190,120>
$output false
class MenuItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,170,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <260,40,430,80>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,170,40>;
    preset ColorBL = #414141FF;
    preset ColorBR = #414141FF;
    preset ColorTR = #828282FF;
    preset ColorTL = #828282FF;
    preset Color = #DBDBDBFF;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,170,40>;
    preset Width = 1;
    preset ColorL = #737373FF;
    preset ColorR = #303030FF;
    preset ColorB = #303030FF;
    preset ColorT = #737373FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,170,40>;
    preset String = "";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <240,60,440,100>
  slot Leave
  {
    sender; /* the method is called from the sender object */

    if ( pressed )
    {
        pressed = false;

    var color t = Bevel.ColorB;
    Bevel.ColorB = Bevel.ColorT;
    Bevel.ColorT = t;

    t = Bevel.ColorR;
    Bevel.ColorR = Bevel.ColorL;
    Bevel.ColorL = t;

    Text1.Bounds.x1 = Text1.Bounds.x1 - 2;
    Text1.Bounds.y1 = Text1.Bounds.y1 - 2;


    InvalidateViewState();


    }
  }

  $rect <240,110,440,150>
  slot Press
  {
    sender; /* the method is called from the sender object */

    if ( !pressed )
    {
        pressed = true;

    var color t = Bevel.ColorB;
    Bevel.ColorB = Bevel.ColorT;
    Bevel.ColorT = t;

    t = Bevel.ColorR;
    Bevel.ColorR = Bevel.ColorL;
    Bevel.ColorL = t;

    Text1.Bounds.x1 = Text1.Bounds.x1 + 2;
      Text1.Bounds.y1 = Text1.Bounds.y1 + 2;

                         InvalidateViewState();
                     
    }

  }

  $rect <240,160,440,200>
  slot Release
  {
    sender; /* the method is called from the sender object */


    if ( pressed )
    {
        pressed = false;

    var color t = Bevel.ColorB;
    Bevel.ColorB = Bevel.ColorT;
    Bevel.ColorT = t;

    t = Bevel.ColorR;
    Bevel.ColorR = Bevel.ColorL;
    Bevel.ColorL = t;


    Text1.Bounds.x1 = Text1.Bounds.x1 - 2;
    Text1.Bounds.y1 = Text1.Bounds.y1 - 2;
    }


    if ( ((App::Application)GetRoot()).LevelAccess.AccessLevel >= Elevation )
    {
       ((App::TabButtonPull) Owner.Owner).MenuChoice( this );
    }
    else
    {
      ((App::Application)GetRoot()).LowLevel( Elevation ); 
    }

  }

  $rect <470,20,670,60>
  property bool pressed = false;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <170,0>;
    preset Point2 = <170,40>;
    preset Point1 = <0,40>;
    preset OnLeave = Leave;
    preset OnRelease = Release;
    preset OnPress = Press;
  }

  $rect <0,70,200,110>
  property int8 Elevation = 0;
}

$rect <1450,210,1580,250>
$output false
class CAEComponent : Core::Group
{
  $rect <590,50,730,90>
  inherited method Draw()
  {
    CAERoot.Render( this.Bounds.point1 + aOffset, aClip, aCanvas );


    //and.RenderFall( <50,50>, <100,100>, aClip, aCanvas );

     //aCanvas.DrawLine( aClip, <50,50>, <100,100>, #FF00FFFF, #FFFF00FF, true );
    //var rect clp;
    //clp = <0,0,800,480>;

    //var rect aDstRect = <100,100,118,118>;
    //var rect aSrcRect = <0,0,36,36>;

    //var rect aDstRect2 = <100,100,160,160>;
    //var rect aSrcRect2 = <0,0,100,100>;


    //var Application::Application app = (Application::Application) Owner;
                  
                     
    //aCanvas.DrawLine( aClip, <100,100>, <200,100>, #FFFFFFFF, #FFFFFFFF, false );
    //aCanvas.ScaleBitmap( aClip, Application::FireAlarmBitmap, 0, aDstRect, aSrcRect, #000000FF,#000000FF,#000000FF,#000000FF, true, true );
    //aCanvas.ScaleBitmap( aClip, Application::ZoneCircleBitmap, 0, aDstRect2, aSrcRect2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FF0000FF, true, true ); 

  }

  $rect <610,120,810,160>
  inherited property Bounds = <0,0,515,280>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );




    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    //Bounds.size = CAERoot.Size();

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <870,70,1010,110>
  inherited method Init()
  {
    // TO DO: Write your code here ... 



    var App::CAEDevice alarm_dev = new App::CAEDevice;

    alarm_dev.UnitNum = 3;
    alarm_dev.ZoneNum = 15;
    alarm_dev.type = App::FireAlarmBitmap;

    var App::CAEZoneFireAlarm alarms = new App::CAEZoneFireAlarm;
    var App::CAEZoneSmokeDetectors smokes = new App::CAEZoneSmokeDetectors;

    var App::CAECompare comp = new App::CAECompare;

    comp.Input = smokes;

     alarms.ZoneNum = 5;
     smokes.ZoneNum = 6;

     var App::CAEGateAND and = new App::CAEGateAND;

     and.InputA = alarm_dev;

     and.InputB = comp;

     var App::CAEGateOR or = new App::CAEGateOR;

     or.InputA = and;
     or.InputB = and;

    var App::CAEGateAND and2 = new App::CAEGateAND;

    var App::CAEDayNight dn = new App::CAEDayNight;
    dn.Input = and;

    and2.InputA = dn;
    and2.InputB = or;

    CAERoot = new App::CAEAction;


    ((App::CAEAction)CAERoot).Input = and2;


    Bounds.size = CAERoot.Size();


  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <530,360,1310,680>;
  }

  $rect <610,160,810,200>
  property App::CAEModule CAERoot = null;

  $rect <610,200,810,240>
  onset CAERoot
  {
    // The value doesn't change - nothing to do.
    if ( pure CAERoot == value )
      return;

    // Remember the property's new value.
    pure CAERoot = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }
}

$rect <0,260,160,300>
$output false
class CauseAndEffects : Core::Group
{
  $rect <820,55,1020,95>
  inherited property Bounds = <0,0,792,360>;

  $rect <850,140,1050,180>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );



    this.VertScrollbar.ContentArea = this.CAEComponent.Bounds.h + this.Outline.Space*2 + this.OutputVerticalList.Bounds.h + this.InputVerticalList.Bounds.h;
    this.VertScrollbar.ViewArea = this.Outline.Bounds.h;


    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <855,180,1055,220>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <1060,90,1200,130>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    CAEComponent.Bounds.size = CAEComponent.CAERoot.Size() + <0,10>; 


  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,530,360>;
    preset Color = #353535FF;
    preset Visible = true;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <910,360,1690,680>;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <2,0,530,360>;
    preset SlideHandler = SlideTouchHandler;
    preset Space = 0;
    preset Formation = Core::Formation.TopToBottom;
  }

  $rect <20,20,160,60>
  object App::CAEComponent CAEComponent
  {
    preset Bounds = <0,0,550,120>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Core::VerticalList InputVerticalList
  {
    preset Bounds = <2,320,530,480>;
    preset Embedded = true;
    preset OnLoadItem = OnLoadInputItem;
    preset ItemHeight = 35;
    preset NoOfItems = 4;
    preset ItemClass = App::InputItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <830,280,1030,320>
  slot OnLoadInputItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = InputVerticalList.Item;
    var App::InputItem item = (App::InputItem) InputVerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item== null )
      return;

    // Configure the item view ...
    item.NumText.String = "In "+string( itemNo+1 );

    if ( itemNo == 1 )
    {
          item.DescriptionText.String = "Count of all smoke detectors";
          item.InputTypeText.String = "Zone Input";
          item.PanelText.String = "Panel 1";
          item.TypeText.String = "Smoke SD01";
          item.UnitText.String = "All units";
          item.ZoneText.String = "Zone 6";
          item.Image.Bitmap = App::ZoneBitmap; 
    }   
    else if ( itemNo == 2 )
    {
          item.DescriptionText.String = "Evacuate button pressed";
          item.InputTypeText.String = "Panel Input";
          item.PanelText.String = "Panel 2";
          item.TypeText.String = "Function";
          item.UnitText.String = "";
          item.ZoneText.String = "";
          item.Image.Bitmap = App::PanelBitmap; 
    }
    else if ( itemNo == 3 )
    {
          item.DescriptionText.String = "Launch rockets switch 1";
          item.InputTypeText.String = "General Input";
          item.PanelText.String = "Panel 1";
          item.TypeText.String = "Switch 1";
          item.UnitText.String = "Unit 6";
          item.ZoneText.String = "Zone 4";
          item.Image.Bitmap = App::PullSwitchBitmap; 
    }   
       

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    item.Bounds.size = point( InputVerticalList.Bounds.w, InputVerticalList.ItemHeight );
  }

  $rect <20,20,160,60>
  object Core::VerticalList OutputVerticalList
  {
    preset Bounds = <2,320,530,470>;
    preset Embedded = true;
    preset OnLoadItem = OnLoadOutputItem;
    preset ItemHeight = 35;
    preset NoOfItems = 4;
    preset ItemClass = App::OutputItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <850,240,1050,280>
  slot OnLoadOutputItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = OutputVerticalList.Item;
    var App::OutputItem item = (App::OutputItem) OutputVerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item== null )
      return;

    // Configure the item view ...
    item.NumText.String = "Out "+string( itemNo+1 );

    if ( itemNo == 1 )
    {
          item.DescriptionText.String = "Beacon Light";
          item.OutputTypeText.String = "Device Output";
          item.PanelText.String = "Panel 1";
          item.TypeText.String = "Beacon BC112";
          item.UnitText.String = "Unit 7";
          item.ZoneText.String = "Zone 4";
          item.Image.Bitmap = App::RadioBitmap; 
    }   
    else if ( itemNo == 2 )
    {
          item.DescriptionText.String = "Msg: \"This is the message!\"";
          item.OutputTypeText.String = "Panel Output";
          item.PanelText.String = "Panel 2";
          item.TypeText.String = "Disp. Message";
          item.UnitText.String = "";
          item.ZoneText.String = "";
          item.Image.Bitmap = App::PanelBitmap; 
    }
    else if ( itemNo == 3 )
    {
          item.DescriptionText.String = "Launch rockets relay";
          item.OutputTypeText.String = "General Output";
          item.PanelText.String = "Panel 3";
          item.TypeText.String = "Switch 12";
          item.UnitText.String = "";
          item.ZoneText.String = "Zone 4";
          item.Image.Bitmap = App::PullSwitchBitmap; 
    }   
       

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    item.Bounds.size = point( OutputVerticalList.Bounds.w, OutputVerticalList.ItemHeight );
  }

  $rect <820,10,1020,50>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -Outline.ScrollOffset.y;
  }

  $rect <810,100,1010,140>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    Outline.ScrollOffset.y = -VertScrollbar.Position;


  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,530,360>;
    preset OnSlide = ScrollDragSlot;
    preset SlideHorz = false;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,530,360>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2C2C2CFF;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <580,0,790,240>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler1;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset ItemHeight = 30;
    preset NoOfItems = 99;
    preset ItemClass = App::CAEName;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <1040,240,1240,280>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var App::CAEName itemView = (App::CAEName)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.NumText.String = string( itemNo+1 );
    itemView.NameText.String = "CAE Name";

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <660,370,860,410>
  slot ClickSlot
  {
    // Ignore the case, when the user interaction has been passed over to 
    // the slide touch handler
    if ( SimpleTouchHandler.AutoDeflected )
      return;

    // Get the index of the item at the tapped position
    var int32 itemNo = VerticalList.GetItemAtPosition( SimpleTouchHandler.CurrentPos );

    // If the item is valid ...
    if ( itemNo >= 0 )
    {
      // Select the item in the Vertical List. Thereupon the item appears
      // highlighted
      VerticalList.SelectedItem = itemNo;
    }

  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler1
  {
    preset Bounds = <580,0,790,240>;
    preset SnapNext = <0,30>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <580,0>;
    preset Point3 = <790,0>;
    preset Point2 = <790,240>;
    preset Point1 = <580,240>;
    preset OnRelease = null;
    preset OnPress = ClickSlot;
    preset RetargetCondition = Core::RetargetReason[LongPress, WipeDown, WipeLeft, WipeRight, WipeUp];
  }

  $rect <450,370,650,410>
  slot TopSlot
  {
    sender; /* the method is called from the sender object */

        //   SlideTouchHandler1.Offset = 0;
          VerticalList.ScrollOffset = 0;

  }

  $rect <440,410,640,450>
  slot Up
  {
    sender; /* the method is called from the sender object */

    var int32 page = 8 * VerticalList.ItemHeight; 

    if ( -VerticalList.ScrollOffset > page )    
       VerticalList.ScrollOffset = VerticalList.ScrollOffset + page; 
    else 
       VerticalList.ScrollOffset = 0;

      
  }

  $rect <650,410,850,450>
  slot Down
  {
    sender; /* the method is called from the sender object */

    var int32 page = 8 * VerticalList.ItemHeight; 

    var int32 max = (VerticalList.NoOfItems-8) * VerticalList.ItemHeight; 

    if ( max+VerticalList.ScrollOffset > page )    
       VerticalList.ScrollOffset = VerticalList.ScrollOffset - page; 
    else 
       VerticalList.ScrollOffset = -max;

      
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <530,0,580,360>;
    preset OnScroll = ScrollPressSlot;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <577,248,677,293>;
    preset OnRelease = TopSlot;
    preset Label = "Top";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <679,247,734,292>;
    preset OnRelease = Down;
    preset IconFrame = 13;
    preset Icon = Flat::FlatDemoIcons;
    preset Label = "";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <737,247,792,292>;
    preset OnRelease = Up;
    preset IconFrame = 12;
    preset Icon = Flat::FlatDemoIcons;
    preset Label = "";
    preset Appearance = App::NormalPushButton;
  }

  $reorder Rectangle 1
}

$rect <1440,390,1640,430>
$output false
resource Resources::Bitmap ActionBitmap
{
  attr bitmapfile FileName = .\Images\action.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,350,1640,390>
$output false
resource Resources::Bitmap OrBitmap
{
  attr bitmapfile FileName = .\Images\or.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1657,270,1857,310>
$output false
resource Resources::Bitmap AndBitmap
{
  attr bitmapfile FileName = .\Images\and.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,430,1640,470>
$output false
resource Resources::Bitmap RelayBitmap
{
  attr bitmapfile FileName = .\Images\relay.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,470,1640,510>
$output false
resource Resources::Bitmap ZoneCircleBitmap
{
  attr bitmapfile FileName = .\Images\circle.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1460,90,1585,130>
$output false
class CAEModule
{
  $rect <40,90,160,130>
  method point Render( arg point position, arg rect aClip, arg Graphics::Canvas aCanvas )
  {
    /* The template just returns the given argument... */



    return point(0,0);

  }

  $rect <30,220,180,260>
  method point RenderHoz( arg point start, arg int32 length, arg rect aClip, arg Graphics::Canvas aCanvas )
  {
    /* The template just returns the given argument... */
    var point dst = start;

    dst.x = dst.x + length;

    aCanvas.DrawLine( aClip, start, dst, #FFFFFFFF, #FFFFFFFF, false );
    start = start + <0,1>;
    dst = dst + <0,1>;
    aCanvas.DrawLine( aClip, start, dst, #FFFFFFFF, #FFFFFFFF, false );

    start.x = start.x + length;

    return start;

  }

  $rect <20,260,170,300>
  method point RenderVert( arg point start, arg int32 length, arg rect aClip, arg Graphics::Canvas aCanvas )
  {
    /* The template just returns the given argument... */
    var point dst = start;

    dst.y = dst.y + length;

    aCanvas.DrawLine( aClip, start, dst, #FFFFFFFF, #FFFFFFFF, false );
    start = start + <1,0>;
    dst = dst + <1,0>;
    aCanvas.DrawLine( aClip, start, dst, #FFFFFFFF, #FFFFFFFF, false );

    start.y = start.y + length;

    return start;


  }

  $rect <40,170,200,210>
  method void RenderConnect( arg point pos1, arg point pos2, arg rect aClip, arg Graphics::Canvas aCanvas )
  {
    /* The template just returns the given argument... */

    var int32 w = (pos2.x - pos1.x);// / 2;
    var int32 h = (pos2.y - pos1.y);

    pos1 = RenderHoz( pos1, w, aClip, aCanvas );
    RenderVert( pos1, h, aClip, aCanvas );

    //RenderHoz( pos1, w, aClip, aCanvas );

    return; 


  }

  $rect <160,90,280,130>
  method point Size()
  {
    /* The template just returns the given argument... */



    return <0,0>;


  }

  $rect <300,90,420,130>
  method point Output( arg point position )
  {
    /* The template just returns the given argument... */


    return position + Size() - point( 0, (Size().y / 2)   );


  }

  $rect <220,250,420,290>
  property int32 gapSize = 10;
}

$rect <1460,50,1585,90>
$output false
class CAEZone : App::CAEModule
{
  $rect <10,10,160,50>
  inherited method Render()
  {
    return RenderZone( position, aClip, aCanvas, type );

    // TO DO: Write your code here ... 

    /*
    var rect dst = <0,0,0,0>;
    var rect src = <0,0,100,100>;
    var rect dst2 = <0,0,0,0>;
    var rect src2 = <0,0,36,36>;

    dst.point1 = position;
    dst.point2 = position + <100,100>;

    dst2.point1 = position;
    dst2.point2 = position + <18,18>;


    aCanvas.ScaleBitmap( aClip, Application::ZoneCircleBitmap, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true );
    aCanvas.ScaleBitmap( aClip, Application::FireAlarmBitmap, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 + (100 - 18);
    dst2.x2 = dst2.x2 + (100 - 18);
    aCanvas.ScaleBitmap( aClip, Application::FireAlarmBitmap, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.y1 = dst2.y1 + (100 - 18);
    dst2.y2 = dst2.y2 + (100 - 18);
    aCanvas.ScaleBitmap( aClip, Application::FireAlarmBitmap, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 - (100 - 18);
    dst2.x2 = dst2.x2 - (100 - 18);
    aCanvas.ScaleBitmap( aClip, Application::FireAlarmBitmap, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 

    aCanvas.DrawText( aClip, OldResources::FontVerdana18, "Zone", 0, 6, dst, <-30,-30>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );
    aCanvas.DrawText( aClip, OldResources::FontVerdana18, string(ZoneNum), 0, 6, dst, <-45,-50>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );


    //aCanvas.DrawText( aClip, aFont, aString, aOffset, aCount, aDstRect, aSrcPos, aMinWidth, aColorTL, aColorTR, aColorBR, aColorBL, aBlend );


    return Output( position );
    */
  }

  $rect <380,40,520,80>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    return App::Circle55Bitmap.FrameSize;

  }

  $rect <20,90,220,130>
  property int32 ZoneNum = 0;

  $rect <40,200,190,240>
  method point RenderZone( arg point position, arg rect aClip, arg Graphics::Canvas aCanvas, arg Resources::Bitmap type )
  {
    // TO DO: Write your code here ... 

    var Resources::Bitmap ctype = App::Circle55Bitmap;

    var rect dst = rect( position, position + ctype.FrameSize );
    var rect dst2 = rect( position,  position + <18,18> );

    var rect src = rect( <0,0>, ctype.FrameSize );

    var rect src2 = <0,0,36,36>;



    aCanvas.ScaleBitmap( aClip, ctype, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 + (ctype.FrameSize.x - 18);
    dst2.x2 = dst2.x2 + (ctype.FrameSize.x - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.y1 = dst2.y1 + (ctype.FrameSize.y - 18);
    dst2.y2 = dst2.y2 + (ctype.FrameSize.y - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 - (ctype.FrameSize.x - 18);
    dst2.x2 = dst2.x2 - (ctype.FrameSize.x - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 

    aCanvas.DrawText( aClip, App::FontVerdana16, "Zone", 0, 5, dst, <-14,-27>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );
    aCanvas.DrawText( aClip, App::FontVerdana16, string(ZoneNum), 0, 3, dst, <-20,-40>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );



    return Output( position );
  }

  $rect <220,110,420,150>
  property Resources::Bitmap type = Resources::DefaultBitmap;
}

$rect <1650,130,1820,170>
$output false
class CAEZoneFireAlarm : App::CAEZone
{
  $rect <10,10,160,50>
  inherited method Render()
  {
    // TO DO: Write your code here ... 


    return RenderZone( position, aClip, aCanvas, App::FireAlarmBitmap );

  }

  $rect <30,80,170,120>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    return App::Circle55Bitmap.FrameSize;


  }
}

$rect <1720,50,1845,90>
$output false
class CAEGate : App::CAEModule
{
  $rect <350,30,490,70>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    var point a = InputA.Size();
    var point b = InputB.Size();

    var int32 maxx = a.x;

    if ( b.x > maxx ) maxx = b.x;

    return point( maxx + 100 + gapSize, a.y + gapSize + b.y );    


  }

  $rect <40,30,240,70>
  method point RenderGate( arg point position, arg rect aClip, arg Graphics::Canvas aCanvas, arg Resources::Bitmap aBitmap )
  {
    if ( InputA != null && InputB != null )
    {
        var point aOut = InputA.Render( position, aClip, aCanvas );

        var point bOut = InputB.Render( position + point( 0, InputA.Size().y + gapSize ), aClip, aCanvas );

       // var point size = Size();

        var point out = Output( position );    // off by one - eek

        RenderConnect( aOut, out - <100,+14>, aClip, aCanvas );
        RenderConnect( bOut, out - <100,-10>, aClip, aCanvas );
       

        var rect aDstRect = rect( out - <100,30>, out + <0, 30> );

        aCanvas.ScaleBitmap( aClip, aBitmap, 0, aDstRect, <0,0,100,60>, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );

        return out - point( 0,1);
    }

    return <0,0>;

        /*

    var rect dst = <0,0,0,0>;
    var rect src = <0,0,100,100>;
    var rect dst2 = <0,0,0,0>;
    var rect src2 = <0,0,36,36>;

    dst.point1 = position;
    dst.point2 = position + <100,60>;

    dst2.point1 = position;
    dst2.point2 = position + <18,18>;


    aCanvas.ScaleBitmap( aClip, Application::ZoneCircleBitmap, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true );
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 + (100 - 18);
    dst2.x2 = dst2.x2 + (100 - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.y1 = dst2.y1 + (100 - 18);
    dst2.y2 = dst2.y2 + (100 - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 - (100 - 18);
    dst2.x2 = dst2.x2 - (100 - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 

    aCanvas.DrawText( aClip, OldResources::FontVerdana18, "Zone", 0, 6, dst, <-30,-30>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );
    aCanvas.DrawText( aClip, OldResources::FontVerdana18, string(ZoneNum), 0, 6, dst, <-45,-50>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );


    var Application::Dimension dim = new Application::Dimension;

    dim.output = position  + <100,50>;
    dim.size = dst;

    return dim;
    */
  }

  $rect <40,120,240,160>
  property App::CAEModule InputB = null;

  $rect <40,80,240,120>
  property App::CAEModule InputA = null;
}

$rect <1580,50,1720,90>
$output false
class CAEGateOR : App::CAEGate
{
  $rect <190,70,340,110>
  inherited method Render()
  {
    // TO DO: Write your code here ... 
    var point outpos = RenderGate( position, aClip, aCanvas, App::OrBitmap );


    var rect dst = rect( outpos - <100, 30>, outpos + <0,30> );
    aCanvas.DrawText( aClip, OldResources::FontVerdana18, "OR", 0, 5, dst, <-28,-34>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );

    return outpos;
  }
}

$rect <1580,90,1730,130>
$output false
class CAEGateAND : App::CAEGate
{
  $rect <10,10,160,50>
  inherited method Render()
  {
    // TO DO: Write your code here ... 


    var point outpos = RenderGate( position, aClip, aCanvas, App::AndBitmap );


    var rect dst = rect( outpos - <100, 30>, outpos + <0,30> );
    aCanvas.DrawText( aClip, OldResources::FontVerdana18, "AND", 0, 5, dst, <-28,-34>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );

    return outpos;
  }
}

$rect <1460,130,1655,170>
$output false
class CAEZoneSmokeDetectors : App::CAEZone
{
  $rect <20,80,170,120>
  inherited method Render()
  {
    // TO DO: Write your code here ... 


    return RenderZone( position, aClip, aCanvas, App::SmokeBitmap );

  }

  $rect <190,10,340,50>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    return App::Circle55Bitmap.FrameSize;


  }
}

$rect <1600,170,1740,210>
$output false
class CAEDevice : App::CAEModule
{
  $rect <80,100,230,140>
  inherited method Render()
  {
    // TO DO: Write your code here ... 

    var rect dst = rect( position + <54,0>, position + <90,36> );


    var rect src = <0,0,36, 36>;



    aCanvas.ScaleBitmap( aClip, type, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
     
    dst.point1 = dst.point1 - <54,0>;
    aCanvas.DrawText( aClip, App::FontVerdana16, "Unit " + string(UnitNum), 0, 6, dst, <0,-13>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );
    aCanvas.DrawText( aClip, App::FontVerdana14, "Zone " + string(ZoneNum), 0, 7, dst, <0,-27>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );

    //return position + point( 116, 18 );

    //aCanvas.DrawText( aClip, aFont, aString, aOffset, aCount, aDstRect, aSrcPos, aMinWidth, aColorTL, aColorTR, aColorBR, aColorBL, aBlend );


    return Output( position );
  }

  $rect <200,10,350,50>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    return point(90, 36 );
  }

  $rect <230,100,430,140>
  property Resources::Bitmap type = Resources::DefaultBitmap;

  $rect <220,210,420,250>
  property int32 UnitNum = 0;

  $rect <220,170,420,210>
  property int32 ZoneNum = 0;
}

$rect <1510,1290,1710,1330>
$output false
resource Resources::Font FontVerdana14
{
  attr fontname FontName = Verdana;
  attr fontheight Height = 14;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7E;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <1730,90,1850,130>
$output false
class CAEAction : App::CAEModule
{
  $rect <10,10,160,50>
  inherited method Render()
  {
    // TO DO: Write your code here ... 

    var point sz = App::ActionBitmap.FrameSize;
    var point outpos = Input.Render( position, aClip, aCanvas );

    var rect dst = rect( outpos - point(0,sz.y/2), outpos + point(sz.x,(sz.y+1)/2) );
    var rect src = rect( point(0,0), sz );

    aCanvas.ScaleBitmap( aClip, App::ActionBitmap, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
     
    return <0,0>;

  }

  $rect <210,10,350,50>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    var point sz = App::ActionBitmap.FrameSize;

    var point ssz = Input.Size();

    var int32 my = 0;

    if ( sz.y > ssz.y ) my = sz.y - ssz.y;   

    return Input.Size() + point( sz.x, my );
  }

  $rect <0,80,200,120>
  property App::CAEModule Input = null;
}

$rect <1580,210,1780,250>
$output false
class CAEInput : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,510,30>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,40,30>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "1";
    preset Font = OldResources::FontVerdana18;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <50,0,130,30>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "1";
    preset Font = App::VerdanaProSemiBold16;
  }
}

$rect <610,340,740,380>
$output false
class InputItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,35>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,35>;
    preset Width = 1;
    preset ColorL = #212121FF;
    preset ColorR = #C9C9C9FF;
    preset ColorB = #D4D4D4FF;
    preset ColorT = #232323FF;
  }

  $rect <20,20,160,60>
  object Views::Text NumText
  {
    preset Bounds = <0,5,50,30>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "1";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Text PanelText
  {
    preset Bounds = <58,0,124,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel 1";
    preset Font = App::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <57,13,518,33>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Hallway, Front building 2";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, ResizeVert];
    preset Bounds = <514,0,549,35>;
    preset Bitmap = App::RadioBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text InputTypeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <387,0,507,15>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Device Input";
    preset Font = App::FontVerdana16;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <129,0,194,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 15";
    preset Font = App::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text UnitText
  {
    preset Bounds = <209,0,279,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Unit 23";
    preset Font = App::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text TypeText
  {
    preset Bounds = <289,0,384,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Smoke SD01";
    preset Font = App::VerdanaProSemiBold16;
  }
}

$rect <1660,470,1860,510>
$output false
resource Resources::Bitmap RadioBitmap
{
  attr bitmapfile FileName = .\Images\radio.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,352,1860,392>
$output false
resource Resources::Bitmap ZoneBitmap
{
  attr bitmapfile FileName = .\Images\zone2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,430,1860,470>
$output false
resource Resources::Bitmap PanelBitmap
{
  attr bitmapfile FileName = .\Images\panel.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <740,340,880,380>
$output false
class OutputItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,35>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,35>;
    preset Width = 1;
    preset ColorL = #212121FF;
    preset ColorR = #C9C9C9FF;
    preset ColorB = #D4D4D4FF;
    preset ColorT = #232323FF;
  }

  $rect <20,20,160,60>
  object Views::Text NumText
  {
    preset Bounds = <1,5,51,30>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "1";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  object Views::Text PanelText
  {
    preset Bounds = <59,0,125,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel 1";
    preset Font = App::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <58,13,519,33>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Fire Alarm";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, ResizeVert];
    preset Bounds = <514,0,549,35>;
    preset Bitmap = App::ZoneBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text OutputTypeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <387,0,507,15>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Zone Output";
    preset Font = App::FontVerdana16;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <130,0,195,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "All Zones";
    preset Font = App::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text UnitText
  {
    preset Bounds = <210,0,280,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "All Units";
    preset Font = App::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text TypeText
  {
    preset Bounds = <290,0,414,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Sounder 1";
    preset Font = App::VerdanaProSemiBold16;
  }
}

$rect <1660,390,1860,430>
$output false
resource Resources::Bitmap PullSwitchBitmap
{
  attr bitmapfile FileName = .\Images\pullswitch.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1460,170,1600,210>
$output false
class CAECompare : App::CAEModule
{
  $rect <10,10,160,50>
  inherited method Render()
  {
    var point sz = <50,30>;
    var point outpos = Input.Render( position, aClip, aCanvas ) + <10,0>;

    var rect dst = rect( outpos - point(0,sz.y/2), outpos + point(sz.x,(sz.y+1)/2) );

    RenderHoz( dst.point1, dst.w, aClip, aCanvas );
    RenderVert( dst.point1, dst.h, aClip, aCanvas );
    RenderHoz( dst.point2, -dst.w, aClip, aCanvas );
    RenderVert( dst.point2, -dst.h, aClip, aCanvas );
    RenderHoz( outpos, -10, aClip, aCanvas );

    aCanvas.DrawText( aClip, App::FontVerdana16, ">"+string(minimum-1), 0, 5, dst, <-15,-20>, 30, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true);

    return Output( position );
  }

  $rect <290,0,440,40>
  inherited method Size()
  {
    // TO DO: Write your code here ... 


    var point sz = <60,30>;

    var point ssz = Input.Size();

    var int32 my = 0;

    if ( sz.y > ssz.y ) my = sz.y - ssz.y;   

    return Input.Size() + point( sz.x, my );

  }

  $rect <220,70,470,120>
  property App::CAEModule Input = null;

  $rect <140,180,340,220>
  property int32 minimum = 2;
}

$rect <0,300,150,340>
$output false
class Test : Core::Group
{
  $rect <0,550,200,590>
  inherited property Bounds = <0,0,795,365>;

  $rect <0,410,200,450>
  inherited method UpdateLayout()
  {
    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,500,200,540>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    $if (!$prototyper)
    if ( ((App::Application)GetRoot() ).LevelAccess.AccessLevel >= 3 )
    {
         PushButton2.Enabled = true;
         PushButton2.Visible = true;
    }
    else
    {
        PushButton2.Enabled = false;
         PushButton2.Visible = false;
    }
    $endif



    var bool everything = ToggleEverything.Checked;

    native
    {
      Command cmd;
      Command0( CMD_GET_TEST_EVERYTHING, &cmd );

      everything = cmd.char0;
    }

    ToggleEverything.Checked = everything;

    TreeView.InvalidateViewState();
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <825,5,1025,45>
  slot TestDisplay
  {
    // Obtain access to the root object.
    var Core::Root rootObject = GetRoot();

    var App::Popup pop = new App::DisplayPopup;

    pop.Show( rootObject );

  }

  $rect <825,50,1025,90>
  slot TestLED
  {
    // Obtain access to the root object.
    var Core::Root rootObject = GetRoot();

    var App::Popup pop = new App::LEDPopup;


    native
    {
      Command cmd;
      cmd.int0 = 1;
      Command0( CMD_LEDS_TEST, &cmd ); 
    }

    pop.Show( rootObject );

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <615,0,795,50>;
    preset OnRelease = TestDisplay;
    preset Label = "Test Display";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <615,54,795,104>;
    preset OnRelease = TestLED;
    preset Label = "Test LEDs/Buzzer";
    preset Appearance = App::NormalPushButton;
  }

  $rect <210,420,360,460>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

     
  }

  $rect <20,20,160,60>
  object App::TreeView TreeView
  {
    preset Bounds = <0,50,615,360>;
    preset Enabled = true;
  }

  $rect <825,150,1025,190>
  slot AllOff
  {
    App::Lib.SwitchOutput( -1, -1, App::Profile.Fire, false ) ;
    TreeView.ListViewer.VerticalList.InvalidateItems( 0, TreeView.ListViewer.VerticalList.NoOfItems - 1 );





  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton
  {
    preset Bounds = <630,164,780,209>;
    preset OutletSelector = 0;
    preset Outlet = ^Tone;
    preset Label = "System";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton1
  {
    preset Bounds = <630,209,785,253>;
    preset OutletSelector = 1;
    preset Outlet = ^Tone;
    preset Label = "Local";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton2
  {
    preset Bounds = <630,253,780,298>;
    preset OutletSelector = 2;
    preset Outlet = ^Tone;
    preset Label = "Silent";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <830,205,1030,245>
  property int32 Tone = 0;

  $rect <810,270,1010,310>
  object Core::PropertyObserver PropertyObserver
  {
    preset OnEvent = onEvent;
    preset Outlet = ^Tone;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <800,320,1000,360>
  slot onEvent
  {
    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the observer
       this method has been called from. This is very useful if multiple
       property observer are connected to one and the same 'onEvent'
       method:

       if ( sender == Observer1 )
         trace "The event comes from the Observer1";

       if ( sender == Observer2 )
         trace "... or from the Observer2";
    */

    var int32 tone = Tone;

    native( tone )
    {
      Command1( CMD_SET_TEST_PROFILE, tone );
    }

  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleEverything
  {
    preset Bounds = <10,0,60,50>;
    preset OnSwitchOn = EverythingSlot;
    preset OnSwitchOff = EverythingSlot;
    preset Label = "";
    preset Appearance = App::LargeCheckBox;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <60,10,280,40>;
    preset String = "All zones (Everything)";
    preset Font = Flat::FontM;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,50,615,365>;
    preset Color = #FFFFFF7F;
    preset Visible = false;
  }

  $rect <440,400,640,440>
  slot EverythingSlot
  {
    sender; /* the method is called from the sender object */

    Rectangle.Visible = ToggleEverything.Checked;
    TreeView.Enabled = ! ToggleEverything.Checked;

    var bool allzones = ToggleEverything.Checked;

    postsignal TreeView.ListViewer.onRefreshAll;

    native ( allzones )
    {
        Command1( CMD_TEST_EVERYTHING, allzones );
    }

                                                                                                        
    postsignal TreeView.CountOnTest;
      

     

  }

  $rect <290,500,490,540>
  object Core::SystemEventHandler SystemEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = App::Devices.SiteChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <490,490,690,530>
  slot onEvent1
  {
    InvalidateViewState( );


    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent1'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent1' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <355,5,535,44>;
    preset OnActivate = DropAllSlot;
    preset Label = "Drop Mesh to PPU";
    preset Appearance = App::SmallPushButton;
  }

  $rect <705,390,905,430>
  slot DropAllSlot
  {
    sender; /* the method is called from the sender object */

     
    var App::Application app = (App::Application) GetRoot();

    if ( app != null )
    {
      if ( app.LevelAccess.AccessLevel < 3 )
      {
        app.LowLevel( 3 );
      }
      else
      {
         var App::ConfirmPopup cp = new App::ConfirmPopup;

         cp.Text1.String = "Drop entire mesh into PPU mode?";
        
         cp.ShowThen( GetRoot(), DropAllGo );         
      }
    }
     
  }

  $rect <700,470,900,510>
  slot DropAllGo
  {
    sender; /* the method is called from the sender object */

    native
    {
      Command2( CMD_PPU_MODE, 4095, 4095 );
    } 
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <615,108,795,158>;
    preset OnRelease = null;
    preset OnActivate = ShowLog;
    preset Label = "Show Log";
    preset Appearance = App::NormalPushButton;
  }

  $rect <825,90,1025,130>
  slot ShowLog
  {
    sender; /* the method is called from the sender object */

    var App::Popup pop = new App::LogPopup;

    pop.Show( GetRoot() );


  }

  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder TestDisplay 1
  $reorder TestLED 1
  $reorder PushButton 1
  $reorder PushButton1 1
}

$rect <1850,50,1990,90>
$output false
class CAEInOut : App::CAEModule
{
  $rect <200,50,350,90>
  inherited method Render()
  {
    // TO DO: Write your code here ... 

    var point sz = XFlat::ButtonNight.FrameSize;


    var rect src = rect( <0,0>, sz );


    var point outpos = Input.Render( position, aClip, aCanvas ) + <10,0>;

    var rect dst = rect( outpos - point(0,sz.y/2), outpos + point(sz.x,(sz.y+1)/2) );

    //RenderHoz( dst.point1, dst.w, aClip, aCanvas );
    //RenderVert( dst.point1, dst.h, aClip, aCanvas );
    //RenderHoz( dst.point2, -dst.w, aClip, aCanvas );
    //RenderVert( dst.point2, -dst.h, aClip, aCanvas );
    RenderHoz( outpos, -11, aClip, aCanvas );

    //aCanvas.DrawText( aClip, Application::FontVerdana16, ">"+string(minimum-1), 0, 5, dst, <-15,-20>, 30, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true);

    if ( NightTime )
    {
        aCanvas.ScaleBitmap( aClip, XFlat::ButtonNight, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
    }
    else
    {
        aCanvas.ScaleBitmap( aClip, XFlat::ButtonDay, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
    }




    return Output( position );


  }

  $rect <200,10,350,50>
  inherited method Size()
  {
    var point sz = XFlat::ButtonNight.FrameSize + <9,4>;

    var point ssz = Input.Size();

    var int32 my = 0;

    if ( sz.y > ssz.y ) my = sz.y - ssz.y;   

    return Input.Size() + point( sz.x, my );






  }

  $rect <280,110,480,150>
  property bool NightTime = true;

  $rect <160,180,360,220>
  property App::CAEModule Input = null;
}

$rect <830,80,980,120>
$output false
class Popup : Core::Group
{
  $rect <230,580,430,620>
  inherited property Bounds = <0,0,680,460>;

  $rect <5,560,160,600>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <450,590,650,630>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <10,10,160,50>
  inherited method Init()
  {
    // TO DO: Write your code here ... 


  }

  // The property 'Bounds' defines the position and the size of the view in the coordinates \
  // of the corresponding @Owner.
  $rect <130,630,260,670>
  property rect Bounds1 = <0,0,550,310>;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler InsideTouchHandler
  {
    preset Point4 = <-200,-200>;
    preset Point3 = <1000,-200>;
    preset Point2 = <1000,680>;
    preset Point1 = <-200,680>;
    preset OnPress = CatchBackgroundTap;
    preset RetargetDelay = 10000;
    preset RetargetOffset = 1000;
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <650,10,680,430>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight];
    preset Bounds = <650,430,680,460>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, ResizeHorz];
    preset Bounds = <10,430,650,460>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <650,0,680,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle5
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <0,430,10,460>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle6
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <10,0,650,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle7
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,0,10,10>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle8
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <0,10,10,430>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,10,650,430>;
    preset Color = #7F7F7FFF;
  }

  $rect <10,470,200,510>
  method void Show( arg Core::Root rootObject )
  {
    /* The template just returns the given argument... */

    // Obtain access to the root object.
    //var Core::Root rootObject = GetRoot();

    // Create a new instance of some alert panel component.
    mask = new Views::Rectangle;
    touch = new Core::SimpleTouchHandler;


    //var Core::SimpleTouchHandler i = new SimpleTouchHandler;

    //i.Point1 = Background.Bounds.point1;
    //i.Point3 = Background.Bounds.point2;
    //i.Point2.x = Background.Bounds.point1.x;
    //i.Point2.y = Background.Bounds.point2.y;
    //i.Point3 = Background.Bounds.point2;
    //i.Point4.x = Background.Bounds.point2.x;
    //i.Point4.y = Background.Bounds.point1.y;




    root = rootObject;

    touch.Point1 = <0,0>;
    touch.Point2 = <0,480>;
    touch.Point3 = <800,480>;
    touch.Point4 = <800,0>;
    touch.OnPress = OutsideTap;

    rootObject.Add( touch, 0 );


    mask.Color = #00000020;
    mask.Bounds = <0,0,800,480>;

    rootObject.Add( mask, 0 );

    var point m = point( (800 - this.Bounds.size.x) / 2, (480 - this.Bounds.size.y) / 2);

        
    this.Bounds.point1 = m;
    this.Bounds.point2 = <800,480> - m;


    Dead = false;

    rootObject.Add( this, 0 );
     


    return;
  }

  $rect <30,270,230,310>
  var Views::Rectangle mask = null;

  $rect <30,230,230,270>
  var Core::SimpleTouchHandler touch = null;

  $rect <30,310,230,350>
  var Core::Root root = null;

  $rect <0,510,190,550>
  method void Hide()
  {
    /* The template just returns the given argument... */

    // Obtain access to the root object.
    //var Core::Root rootObject = GetRoot();

    // Create a new instance of some alert panel component.

    if ( !Dead )
    {
      if ( root != null )
      {
        signal onHide;

        root.Remove( mask );
        root.Remove( touch );
        root.Remove( this );
        Dead = true;

        if ( Parent != null )
        {
          if ( Parent.Visible == false )
          {
              Parent.Visible = true; 
              Parent.Enabled = true;
           }
        }
      }
    }

  }

  $rect <240,490,440,530>
  property App::Popup Parent = null;

  $rect <760,40,960,80>
  object Core::SystemEventHandler SystemEventHandler
  {
    preset OnEvent = FireHide;
    preset Event = App::Devices.FireListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <770,80,970,120>
  slot FireHide
  {
    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */

    Hide( );

  }

  $rect <770,180,970,220>
  object Core::SystemEventHandler SystemEventHandler2
  {
    preset OnEvent = FireHide;
    preset Event = App::Devices.EventListChangedEvent;
  }

  $rect <780,230,980,270>
  slot EventHide
  {
    sender; /* the method is called from the sender object */

     

     
    var int32 events = 0;

    native( events )
    {
      Command cmd;

      Command0( CMD_GET_NUM_OTHER_EVENTS, &cmd );  

      events = cmd.int0;

    }

    if ( events > 0 )
    {
      Hide();
    }

     
  }

  $rect <1010,30,1210,70>
  var bool Dead = false;

  $rect <730,360,930,400>
  property slot onHide = null;

  $rect <780,120,980,160>
  slot OutsideTap
  {
    var Core::SimpleTouchHandler tap = (Core::SimpleTouchHandler) sender;   /* the method is called from the sender object */


    if ( tap.HittingPos != this.Bounds )
    {
      Hide();
    }


  }

  $rect <460,490,670,530>
  slot CatchBackgroundTap
  {
    sender; /* the method is called from the sender object */


  }

  $rect <750,0,950,40>
  object Core::SystemEventHandler SystemEventHandler1
  {
    preset OnEvent = FireHide;
    preset Event = App::Devices.GotoPriorityDisplay;
  }
}

$rect <550,300,700,340>
$output false
class DisplayPopup : App::Popup
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Bounds = <20,320,640,360>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle10
  {
    preset Bounds = <20,20,220,160>;
    preset Color = #FF0000FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle11
  {
    preset Bounds = <230,20,430,160>;
    preset Color = #00FF00FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle12
  {
    preset Bounds = <440,20,640,160>;
    preset Color = #0000FFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle13
  {
    preset Bounds = <20,170,220,310>;
    preset Color = #00FFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle14
  {
    preset Bounds = <230,170,430,310>;
    preset Color = #FF00FFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle15
  {
    preset Bounds = <440,170,640,310>;
    preset Color = #FFFF00FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <20,20,220,160>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Red";
    preset Font = Flat::FontXL;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Layout = Core::Layout[AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <230,20,430,160>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Green";
    preset Font = Flat::FontXL;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <440,20,640,160>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Blue";
    preset Font = Flat::FontXL;
  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <230,170,430,310>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Magenta";
    preset Font = Flat::FontXL;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text5
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <20,20,220,160>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Red";
    preset Font = Flat::FontXL;
  }

  $rect <20,20,160,60>
  object Views::Text Text6
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <20,170,220,310>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Cyan";
    preset Font = Flat::FontXL;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text7
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <440,170,640,310>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Yellow";
    preset Font = Flat::FontXL;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle16
  {
    preset Bounds = <20,320,640,360>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle23
  {
    preset Bounds = <440,280,640,310>;
    preset ColorBL = #FFFF00FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #FFFF00FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle24
  {
    preset Bounds = <230,280,430,310>;
    preset ColorBL = #FF00FFFF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #FF00FFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle25
  {
    preset Bounds = <20,280,220,310>;
    preset ColorBL = #00FFFFFF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #00FFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle26
  {
    preset Bounds = <440,130,640,160>;
    preset ColorBL = #0000FFFF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #0000FFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle27
  {
    preset Bounds = <230,130,430,160>;
    preset ColorBL = #00FF00FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #00FF00FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle28
  {
    preset Bounds = <20,130,220,160>;
    preset ColorBL = #FF0000FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #FF0000FF;
  }

  $rect <0,470,200,510>
  slot Proceed
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <250,370,400,420>;
    preset OnRelease = Proceed;
    preset Label = "Close";
    preset Appearance = App::NormalPushButton;
  }
}

$rect <0,380,110,420>
$output false
class Settings : Core::Group
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <120,940,666,1296>;
    preset Color = #353535FF;
  }

  $rect <0,505,200,545>
  inherited property Bounds = <0,0,795,350>;

  $rect <0,400,200,440>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

  }

  $rect <5,455,205,495>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    signal GetSettings;

  }

  $rect <795,125,995,165>
  slot SetPin
  {
    sender; /* the method is called from the sender object */

    var App::KeypadChangePopup kp = new App::KeypadChangePopup;

     

    kp.Show( GetRoot() );



  }

  $rect <840,310,1040,350>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font2 = App::FontVerdanaProSemiBold18;
    preset Font1 = Resources::FontMedium;
    preset Color0 = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <615,0,795,55>;
    preset OnRelease = null;
    preset OnActivate = DaySlot;
    preset Label = "Day/Night Times";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <615,59,795,114>;
    preset OnRelease = null;
    preset OnActivate = SMSSlot;
    preset Label = "SMS Settings";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <615,119,795,174>;
    preset OnRelease = null;
    preset OnActivate = SetPin;
    preset Label = "Change PIN Code";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton OutputDelaysButton
  {
    preset Bounds = <5,211,130,261>;
    preset OnSwitchOn = DelaysSlot;
    preset OnSwitchOff = DelaysSlot;
    preset LabelOn = "";
    preset LabelOff = "";
    preset Label = "Enable";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <460,525,660,565>
  slot DelaysSlot
  {
    sender; /* the method is called from the sender object */


    var App::Application app = (App::Application)GetRoot();

    if ( app != null )
    { 
       
      if ( app.LevelAccess.AccessLevel > 2 )
      {
        HorzBarSlider.Enabled = OutputDelaysButton.Checked;  
        HorzBarSlider1.Enabled  = OutputDelaysButton.Checked;
        OutputOverrideButton.Enabled = OutputDelaysButton.Checked;

        if ( OutputDelaysButton.Checked )
        {
          Text.Color = #000000FF;
          Text1.Color = #000000FF;

        }
        else
        {
          Text.Color = #555555FF;
          Text1.Color = #555555FF;
        }
      }
    }

      if ( sender == OutputDelaysButton )
      {
        signal SetSettings;   
      }
         
         

  }

  $rect <20,20,160,60>
  object Views::Text Resound
  {
    preset Bounds = <349,92,444,127>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Re-sound";
    preset Font = App::FontMediumBold;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text DelaysText
  {
    preset Bounds = <2,183,147,216>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Output Delays";
    preset Font = App::FontMediumBold;
    preset Color = #000000FF;
  }

  $rect <795,5,995,45>
  slot DaySlot
  {
    sender; /* the method is called from the sender object */



     var App::DayTimesPopup bl = new App::DayTimesPopup;

    if ( bl != null )
    {
      bl.VerticalList.InvalidateItems( 0, 6 );
      bl.Show( GetRoot() );


      var App::Application app = (App::Application)GetRoot();

      if ( app != null )
      {      
          bl.VerticalList.Enabled = ( app.LevelAccess.AccessLevel >= 3 );
          bl.InsideTouchHandler.Enabled = ( app.LevelAccess.AccessLevel < 3 );
      }
    }
  }

  $rect <795,65,995,105>
  slot SMSSlot
  {
    sender; /* the method is called from the sender object */

     
      var App::TextPopup bl = new App::TextPopup;

       var App::Application app = (App::Application)GetRoot();



       
      bl.Show( GetRoot() );
     
     

  }

  $rect <245,390,445,430>
  slot SetSettings
  {
    sender; /* the method is called from the sender object */

     

    var App::SiteSetting settings = App::SiteSetting[ ];

    native ( settings )
    {
       Command cmd;

       Command0( CMD_GET_SETTINGS, &cmd );  

       settings = cmd.int0;
    }


    if ( !SameZoneButton.Checked )
    {
        settings = settings + App::SiteSetting[ ResoundNewZone ];
    }
    else
    {
        settings = settings - App::SiteSetting[ ResoundNewZone ];
    }


    if ( Daytime.Checked )
    {
        settings = settings + App::SiteSetting[ IgnoreSecurityInDay ];
    }
    else
    {
        settings = settings - App::SiteSetting[ IgnoreSecurityInDay ];
    }

    if ( NightTime.Checked )        
    {         
        settings = settings + App::SiteSetting[ IgnoreSecurityAtNight ];
    }
    else
    {         
        settings = settings - App::SiteSetting[ IgnoreSecurityAtNight ];
    }


    if ( !OutputDelaysButton.Checked )
    {        
        settings = settings + App::SiteSetting[ DisableOutputDelays ];
    }
    else
    {        
        settings = settings - App::SiteSetting[ DisableOutputDelays ];
    }


    if ( OutputOverrideButton.Checked )
    {       
       settings = settings + App::SiteSetting[ OverrideOutputDelays ];
    }
    else
    {       
       settings = settings - App::SiteSetting[ OverrideOutputDelays ];
    }
     
      

    var int32 delay1 = HorzBarSlider.CurrentValue;
    var int32 delay2 = HorzBarSlider1.CurrentValue;
    var int32 autosi = SilenceBarSlider2.CurrentValue;

    native ( settings, delay1, delay2, autosi )
    {
       Command cmd;

        cmd.int0 = autosi;
        cmd.int1 = settings;
        cmd.short4 = delay1 * 30;
        cmd.short5 = delay2 * 30; 
         
        Command0( CMD_SET_SETTINGS, &cmd );  
    }



  }

  $rect <20,20,160,60>
  object Views::Text Panel
  {
    preset Bounds = <4,28,58,54>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel";
    preset Font = App::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Site
  {
    preset Bounds = <5,0,55,27>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Site";
    preset Font = App::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Version
  {
    preset Bounds = <4,52,84,87>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Version";
    preset Font = App::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Panel1
  {
    preset Bounds = <64,30,265,53>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Site1
  {
    preset Bounds = <64,0,265,26>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Site";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Version1
  {
    preset Bounds = <82,52,141,88>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Version";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <470,480,670,520>
  slot ResoundSlot
  {
    sender; /* the method is called from the sender object */


     

    if ( sender == SameZoneButton )
    {
      signal SetSettings;   
    }
         
        
  }

  $rect <835,175,1010,220>
  slot GSM
  {
    sender; /* the method is called from the sender object */

    var App::Popup bl = new App::GSMPopup;

    bl.Show( GetRoot() );



  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton OutputOverrideButton
  {
    preset Bounds = <147,209,510,264>;
    preset OnSwitchOn = OverrideSlot;
    preset OnSwitchOff = OverrideSlot;
    preset LabelOn = "";
    preset LabelOff = "";
    preset Label = "Use global settings for all fire alarms";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,264,275,303>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzBarSlider
  {
    preset Bounds = <275,255,580,308>;
    preset OnChange = Delay1SliderSlot;
    preset OnEnd = End;
    preset MaxValue = 20;
    preset CurrentValue = 0;
    preset Appearance = App::NormalHorizontalSlider;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <0,305,280,349>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzBarSlider1
  {
    preset Bounds = <275,305,580,350>;
    preset OnChange = Delay2SliderSlot;
    preset OnEnd = End;
    preset MaxValue = 19;
    preset CurrentValue = 0;
    preset Appearance = App::NormalHorizontalSlider;
  }

  $rect <730,465,930,505>
  slot Delay1SliderSlot
  {
    sender; /* the method is called from the sender object */
     
    var int32 i = HorzBarSlider.CurrentValue;
        
        

    var int32 i2 = HorzBarSlider1.CurrentValue;
        


    if ( i + i2 >= 20 ) i2 = 20 - i;


    if ( i == 0 )
    {
      // i2 = 0;
       HorzBarSlider1.Enabled = false;

    }
    else
    {
      HorzBarSlider1.Enabled = true;
    }

    HorzBarSlider1.CurrentValue = i2;


        var float f =  ((float)i * 0.5 ) ;
        
     var float f2 =  ((float)i2 * 0.5 ) ;


         Text.String = "First Delay (" + string( f, 2, 1 ) + " mins)";

        Text1.String = "Investigative Delay (" + string( f2, 2, 1 ) + " mins)";

      

  }

  $rect <830,505,1030,545>
  slot End
  {
    sender; /* the method is called from the sender object */

    var int32 i = HorzBarSlider.CurrentValue;
     
        if ( i == 0 ) 
        {
         HorzBarSlider1.CurrentValue = 0;
         HorzBarSlider1.Enabled = false;
        Text1.Color = #888888FF;
         }
         else  
         {
         
         HorzBarSlider1.Enabled = true;
        Text1.Color = #000000FF;
         }
      signal SetSettings;
  }

  $rect <775,420,975,460>
  slot Delay2SliderSlot
  {
    sender; /* the method is called from the sender object */
     
    var int32 i = HorzBarSlider.CurrentValue;

    var int32 i2 = HorzBarSlider1.CurrentValue;
        

    if ( i + i2 >= 20 ) i = 20 - i2;


    HorzBarSlider.CurrentValue = i;

       var float f =  ((float)i * 0.5 ) ;
        
        var float f2 =  ((float)i2 * 0.5 ) ;

         Text.String = "First Delay (" + string( f, 2, 1 ) + " mins)";

        Text1.String = "Investigative Delay (" + string( f2, 2, 1 ) + " mins)";

        
  }

  $rect <480,435,680,475>
  slot OverrideSlot
  {
    sender; /* the method is called from the sender object */

     

    if ( sender == OutputOverrideButton )
    {
      signal SetSettings;   
    }
      
  }

  $rect <20,20,160,60>
  object Views::Text Intruder
  {
    preset Bounds = <3,92,220,127>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Ignore Intruder Alerts";
    preset Font = App::FontMediumBold;
    preset Color = #000000FF;
  }

  $rect <235,440,435,480>
  slot GetSettings
  {
    sender; /* the method is called from the sender object */

    var App::Application app = (App::Application)GetRoot();

    if ( app != null )
    {
      
        Daytime.Enabled = false;
        NightTime.Enabled = false;
        SameZoneButton.Enabled = false;
        OutputOverrideButton.Enabled = false;
        OutputDelaysButton.Enabled = false;
        SetupRadio.Enabled = false;
        HorzBarSlider.Enabled = false;
        HorzBarSlider1.Enabled = false;
        SilenceBarSlider2.Enabled = false;
     
      if ( app.LevelAccess.AccessLevel >= 3 )
      {
        Daytime.Enabled = true;
        NightTime.Enabled = true;
        SameZoneButton.Enabled = true;
        OutputOverrideButton.Enabled = true;
        SetupRadio.Enabled = true;
        HorzBarSlider.Enabled = true;
        HorzBarSlider1.Enabled = true;
        SilenceBarSlider2.Enabled =  true;

      }
      if ( app.LevelAccess.AccessLevel >= 2 )
      {
          OutputDelaysButton.Enabled = true;
      }


    }
     

    var App::SiteSetting settings = App::SiteSetting[ ];

    var string site = "";
    var int32  version = 0;
    var string panel = "";
    var int32 delay1 = 0;
    var int32 delay2 = 0;
    var int32 autosilence = 0; 

    native ( settings, site, panel, version, delay1, delay2, autosilence )
    {
        Command cmd;

        Command0( CMD_GET_SETTINGS, &cmd );

        settings = cmd.int0;

        if ( capp->site != NULL && capp->panel != NULL )
        {
          site    = EwNewStringAnsi( capp->site->name );
          panel   = EwNewStringAnsi( capp->panel->name ); 
          version = capp->site->version;
          
          delay1 =  capp->panel->delay1;
          delay2 =  capp->panel->delay2;

          autosilence = capp->panel->autoSilence;
        }
    }

    SilenceBarSlider2.CurrentValue =  autosilence;

    Site1.String = site;
    Version1.String = string( (float)version, 0, 2 );
    Panel1.String = panel;
          
    HorzBarSlider.CurrentValue = delay1 / 30;
    HorzBarSlider1.CurrentValue = delay2 / 30;             
                                                                                       
    SameZoneButton.Checked = !settings.contains( App::SiteSetting[ ResoundNewZone ] );

    NightTime.Checked = settings.contains( App::SiteSetting[ IgnoreSecurityAtNight ] );
    Daytime.Checked = settings.contains( App::SiteSetting[ IgnoreSecurityInDay ] );
       

    OutputDelaysButton.Checked  = !settings.contains( App::SiteSetting[ DisableOutputDelays ] );
    OutputOverrideButton.Checked = settings.contains( App::SiteSetting[ OverrideOutputDelays ] );


    signal AutoSilenceSlotEnd;
    signal AutoSilenceSlot;
    signal ResoundSlot;
    signal OverrideSlot;
    signal Delay2SliderSlot;
    signal SecuritySlot;


  }

  $rect <490,390,630,430>
  slot SecuritySlot
  {
    sender; /* the method is called from the sender object */


     


    if ( sender == NightTime || sender == Daytime )
    {
      signal SetSettings;   
    }
        
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton SameZoneButton
  {
    preset Bounds = <348,124,498,174>;
    preset OnSwitchOn = ResoundSlot;
    preset OnSwitchOff = ResoundSlot;
    preset Label = "Same Zone";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Daytime
  {
    preset Bounds = <5,125,135,175>;
    preset OnSwitchOn = SecuritySlot;
    preset OnSwitchOff = SecuritySlot;
    preset Label = "Daytime";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton NightTime
  {
    preset Bounds = <145,125,285,175>;
    preset OnSwitchOn = SecuritySlot;
    preset OnSwitchOff = SecuritySlot;
    preset Label = "Nighttime";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SetupRadio
  {
    preset Bounds = <615,179,795,234>;
    preset OnRelease = null;
    preset OnActivate = SetupAcumesh;
    preset Label = "Setup AcuMesh Radio";
    preset Appearance = App::NormalPushButton;
  }

  $rect <825,225,1025,265>
  slot SetupAcumesh
  {
    sender; /* the method is called from the sender object */


    var App::Popup p = new App::RadioSetup;

    p.Show( GetRoot() );


  }

  $rect <870,360,1070,400>
  object Core::SystemEventHandler SiteChangeEventHandler1
  {
    preset OnEvent = SiteChange;
    preset Event = App::Devices.SiteChangedEvent;
  }

  $rect <990,400,1160,435>
  slot SiteChange
  {
    sender; /* the method is called from the sender object */

    InvalidateViewState();

  }

  $rect <985,260,1185,300>
  object Core::SystemEventHandler AccessModeChangeEventHandler2
  {
    preset OnEvent = SiteChange;
    preset Event = App::Devices.AccessModeChangeEvent;
  }

  $rect <20,20,160,60>
  object Views::Text AutoSilernce
  {
    preset Bounds = <305,5,451,41>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Auto Silence";
    preset Font = App::FontMediumBold;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider SilenceBarSlider2
  {
    preset Bounds = <305,40,585,84>;
    preset OnChange = AutoSilenceSlot;
    preset OnEnd = AutoSilenceSlotEnd;
    preset StepSize = 15;
    preset MaxValue = 120;
    preset CurrentValue = 0;
    preset Appearance = App::NormalHorizontalSlider;
  }

  $rect <20,20,160,60>
  object Views::Text silencetime
  {
    preset Bounds = <449,5,585,41>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "2 hours 15 min";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <225,490,425,530>
  slot AutoSilenceSlot
  {
    sender; /* the method is called from the sender object */

    var int32 t = SilenceBarSlider2.CurrentValue;

    if ( t == 0 )
    {
        silencetime.String = "Never";
    }
    else if ( t < 60 )
    {
      silencetime.String = string(t) + " mins";
    }
    else if ( t == 60 )
    {
     silencetime.String = "1 hour";
    }
    else if ( t < 120 )
    {
      silencetime.String = "1 hour " + string(t-60) + " mins";
    }
    else if ( t == 120 )
    {
     silencetime.String = "2 hours";
    }
    else
    {
       SilenceBarSlider2.CurrentValue = 0;
       silencetime.String = "Never";
       postsignal AutoSilenceSlotEnd;
    }

  }

  $rect <215,540,410,580>
  slot AutoSilenceSlotEnd
  {
    sender; /* the method is called from the sender object */

    Text2.Visible = ( SilenceBarSlider2.CurrentValue != 0 );


    if ( sender ==  SilenceBarSlider2 )
    {
      signal SetSettings;
    }


  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <590,235,792,275>;
    preset WrapText = true;
    preset String = "Auto silencing alarms is considered outside of EN54";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #C60003FF;
  }

  $reorder Rectangle 76
}

$rect <110,380,270,420>
$output false
class BacklightPopup : App::Popup
{
  $rect <20,20,160,60>
  inherited object Rectangle
  {
    preset Bounds = <490,10,520,160>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle1
  {
    preset Bounds = <490,160,520,190>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle2
  {
    preset Bounds = <10,160,490,190>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset Bounds = <490,0,520,10>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle5
  {
    preset Bounds = <0,160,10,190>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset Bounds = <10,0,490,10>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle8
  {
    preset Bounds = <0,10,10,160>;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <10,10,490,160>;
    preset Color = #C3C3C3FF;
  }

  $rect <20,240,160,280>
  inherited method Show()
  {
    // TO DO: Write your code here ... 


    super( rootObject );

    startVal = HorzSlider.Outlet^;

         
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <20,37,120,67>;
    preset String = "Brightness";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <0,190,150,230>
  slot Set
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <300,190,500,230>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    HorizontalSlider.Outlet^ = startVal;
    HorizontalSlider.CurrentValue = startVal;

    Hide();

  }

  $rect <170,190,280,230>
  slot Change
  {
    sender; /* the method is called from the sender object */

    var int32 val = HorizontalSlider.CurrentValue;

    native ( val )
    {
        Command1( CMD_SET_BACKLIGHT_LEVEL, val * 5 + 30 );
    }
  }

  $rect <520,30,720,70>
  var int32 startVal = 0;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <330,97,460,147>;
    preset OnActivate = Cancel;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <40,97,160,147>;
    preset OnActivate = Set;
    preset Label = "Set";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorizontalSlider
  {
    preset Bounds = <131,28,471,78>;
    preset Appearance = WidgetSet::HorizontalSlider_Medium;
  }
}

$rect <270,380,420,420>
$output false
class SetTimePopup : App::Popup
{
  $rect <660,10,800,50>
  inherited property Bounds = <0,0,530,330>;

  $rect <25,380,165,420>
  inherited method Init()
  {
    // TO DO: Write your code here ... 
    GetCurrent();

  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CDCDCDFF;
  }

  $rect <20,20,160,60>
  object App::TimePicker TimePicker
  {
    preset Bounds = <29,30,219,180>;
  }

  $rect <20,20,160,60>
  object App::DatePicker DatePicker
  {
    preset Bounds = <246,30,476,180>;
    preset Year = 2018;
  }

  $rect <0,325,200,365>
  slot Proceed
  {
    sender; /* the method is called from the sender object */

    SetCurrent();

    Hide();

  }

  $rect <240,330,440,370>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    Hide();



  }

  $rect <200,380,400,420>
  method void GetCurrent()
  {
    // TO DO: Write your code here ... 

    var Core::Time t = new Core::Time;

    t = t.CurrentTime;

    TimePicker.Hour = t.Hour;
    TimePicker.Minute = t.Minute;
    TimePicker.Second = t.Second;


    DatePicker.Year = t.Year;
    DatePicker.Month = t.Month;
    DatePicker.Day = t.Day;






  }

  $rect <450,380,650,420>
  method void SetCurrent()
  {
    var int32 h = TimePicker.Hour;
    var int32 m = TimePicker.Minute;
    var int32 s = TimePicker.Second;

    var int32 d = DatePicker.Day;
    var int32 M = DatePicker.Month;
    var int32 y = DatePicker.Year;



    native ( h, m, s, d, M, y )
    {
       Command3( CMD_SET_TIME, h, m, s );
       Command3( CMD_SET_DATE, d, M, y );
    }

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <30,240,180,290>;
    preset OnRelease = null;
    preset OnActivate = Proceed;
    preset Label = "OK";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <330,240,480,290>;
    preset OnRelease = null;
    preset OnActivate = Cancel;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }
}

// This is a GUI component.
$rect <560,480,700,520>
$output false
class TimePicker : Templates::PickerControl
{
  $rect <250,400,450,440>
  inherited property Bounds = <0,0,190,150>;

  $rect <480,280,680,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the time picker widget.
    //
    // isEnabled  --> the time picker can react to user inputs.
    // isSelected --> the time picker can receive keyboard events.
    // isSliding  --> the user interacts with the time picker.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isSliding  = TouchHandlerHour.Sliding   || 
                          TouchHandlerMinute.Sliding ||
                          TouchHandlerSecond.Sliding;

    /*

      TO DO:

      Depending on your time picker design, you have surely added some new 
      views  to your time picker. In the below code you should update the
      properties of these views. For example, when your picker has an image
      which you want to show only while the user is changing the time, than
      following can be done:

        theImage.Visible = isSliding;

      Depending on the state of the time picker, you can alternate any property 
      of your views. You can change their visibility, colors, opacity, bitmaps
      shown in image views, fonts used to render text, the position and the
      size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the picker
      (e.g. 'isSliding') with its preceding state (e.g. variable 'sliding').

      Assuming you have already added to your time picker component a new
      effect member, named it 'slidingEffect' and configured it to animate
      e.g. the opacity of an image within the time picker. Then following is
      sufficient to trigger the animation:

        if ( isSliding && !sliding )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isSliding && sliding )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( isSliding )
      BorderCurrent.Color = #C1C1C1FF;

    else
      BorderCurrent.Color = #E1E1E1FF;

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // sliding <<-->> not sliding transition.
    enabled  = isEnabled;
    selected = isSelected;
    sliding  = isSliding;
  }

  // To do:
  // 
  // - Adjust the visible size of your picker (the thick blue border). This will \
  // be the picker's default size.
  // - Remove the 'Background', 'Border', 'BorderCurrent', 'Separator1', 'Separator2', \
  // 'ShineAtTop' and 'ShineAtBottom' members if you want other views to be shown \
  // instead these in your picker.
  // - According to your desired picker design add and configure new views (e.g. \
  // text views as captions for Hour, Minute, etc).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the picker's current state.
  // - You can also add and configure animation effects to your picker. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your picker.
  // - Similarly you can arrange the 3 lists 'ListHour', 'ListMinute' and 'ListSecond' \
  // and the corresponding touch handlers 'TouchHandlerHour', TouchHandlerMinute' \
  // and 'TouchHandlerSecond'. Note, the touch handler should always cover the area \
  // of the corresponding list.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the picker itself is resized.
  // - If you want other fonts, colors, etc. to be displayed in the 3 lists, adapt \
  // the implementation of the corresponding slot methods 'OnLoadHourItem', 'OnLoadMinuteItem' \
  // and 'OnLoadSecondItem'.
  // - If you want the items to be displayed with other height, adapt the property \
  // 'ItemHeight' of the 3 'ListHour', 'ListMinute' and 'ListSecond'. Similarly adapt \
  // the property 'SnapNext' of the corresponding touch handlers 'TouchHandlerHour', \
  // TouchHandlerMinute' and 'TouchHandlerSecond'.
  // - From the Gallery folder 'Chora' add properties to your picker. One property \
  // for every picker specific setting (e.g. 'Caption', 'Icon', 'Color', 'Font', \
  // ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Caption' should update the text view in your picker where \
  // some caption is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note4
  {
    attr Bounds = <10,460,1020,900>;
  }

  // State Management
  note group Note3
  {
    attr Bounds = <470,240,690,450>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <240,240,460,370>;
  }

  // List Management
  note group Note1
  {
    attr Bounds = <10,240,230,410>;
  }

  // This variable stores the current state of the time picker.
  $rect <480,400,680,440>
  var bool sliding;

  // This variable stores the current state of the time picker.
  $rect <480,360,680,400>
  var bool selected;

  // This variable stores the current state of the time picker.
  $rect <480,320,680,360>
  var bool enabled;

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has finished the slide animation. \
  // Thereupon the owner of the time picker is notified, that the time has been changed.
  $rect <250,320,450,360>
  slot onEndSlide
  {
    // The user has finished the interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();

    // Notify the owner of the time picker, that the user has selected another time.
    // Do this however only after the last list has finished the slide animation.
    if ( !TouchHandlerHour.Sliding && !TouchHandlerMinute.Sliding && !TouchHandlerSecond.Sliding )
      postsignal OnChange;
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has begun the slide animation.
  $rect <250,280,450,320>
  slot onStartSlide
  {
    // The user has begun an interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();
  }

  // This method is called by 'ListSecond' vertical list every time the list loads \
  // or updates an item.
  $rect <20,360,220,400>
  slot OnLoadSecondItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListSecond.Item;
    var Views::Text itemView = (Views::Text)ListSecond.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your time picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListSecond.Bounds.w, ListSecond.ItemHeight );
  }

  // This method is called by 'ListMinute' vertical list every time the list loads \
  // or updates an item.
  $rect <20,320,220,360>
  slot OnLoadMinuteItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListMinute.Item;
    var Views::Text itemView = (Views::Text)ListMinute.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your time picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListMinute.Bounds.w, ListMinute.ItemHeight );
  }

  // This method is called by 'ListHour' vertical list every time the list loads \
  // or updates an item.
  $rect <20,280,220,320>
  slot OnLoadHourItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListHour.Item;
    var Views::Text itemView = (Views::Text)ListHour.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your time picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListHour.Bounds.w, ListHour.ItemHeight );
  }

  $rect <620,90,820,130>
  onget Second
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListSecond.ScrollOffset / ListSecond.ItemHeight ) + 2 ) % 60;
  }

  $rect <620,50,820,90>
  onset Second
  {
    // Limit the assigned value to the valid range 0 .. 59
    if ( value < 0  ) value = 0;
    if ( value > 59 ) value = 59;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListSecond.ScrollOffset = ( value - 2 ) * -ListSecond.ItemHeight;
  }

  $rect <420,90,620,130>
  onget Minute
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListMinute.ScrollOffset / ListMinute.ItemHeight ) + 2 ) % 60;
  }

  $rect <420,50,620,90>
  onset Minute
  {
    // Limit the assigned value to the valid range 0 .. 59
    if ( value < 0  ) value = 0;
    if ( value > 59 ) value = 59;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListMinute.ScrollOffset = ( value - 2 ) * -ListMinute.ItemHeight;
  }

  $rect <220,90,420,130>
  onget Hour
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListHour.ScrollOffset / ListHour.ItemHeight ) + 2 ) % 24;
  }

  $rect <220,50,420,90>
  onset Hour
  {
    // Limit the assigned value to the valid range 0 .. 23
    if ( value < 0  ) value = 0;
    if ( value > 23 ) value = 23;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListHour.ScrollOffset = ( value - 2 ) * -ListHour.ItemHeight;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,190,150>;
  }

  $rect <20,20,160,60>
  object Views::Border BorderCurrent
  {
    preset Bounds = <10,59,180,91>;
    preset Width = 3;
    preset Color = #E1E1E1FF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerSecond
  {
    preset Bounds = <130,0,180,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerMinute
  {
    preset Bounds = <70,0,120,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerHour
  {
    preset Bounds = <10,0,60,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListSecond
  {
    preset Bounds = <130,0,180,150>;
    preset OnLoadItem = OnLoadSecondItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerSecond;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListMinute
  {
    preset Bounds = <70,0,120,150>;
    preset OnLoadItem = OnLoadMinuteItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerMinute;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListHour
  {
    preset Bounds = <10,0,60,150>;
    preset OnLoadItem = OnLoadHourItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerHour;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 24;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,10,150>;
    preset Width = 2;
    preset ColorL = #1BFF5200;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel1
  {
    preset Bounds = <60,0,70,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel2
  {
    preset Bounds = <120,0,130,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel3
  {
    preset Bounds = <180,0,190,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #1BFF5200;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Rectangle ShineAtBottom
  {
    preset Bounds = <0,88,190,150>;
    preset ColorBL = #CCCCCCFF;
    preset ColorBR = #C6C6C6FF;
    preset ColorTR = #FFFFFF22;
    preset ColorTL = #FFFFFF22;
  }

  $rect <20,20,160,60>
  object Views::Rectangle ShineAtTop
  {
    preset Bounds = <0,0,190,58>;
    preset ColorBL = #FFFFFF22;
    preset ColorBR = #FFFFFF22;
  }

  $rect <20,20,160,60>
  object Views::Text Separator2
  {
    preset Bounds = <113,57,136,89>;
    preset String = ":";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #838083FF;
  }

  $rect <20,20,160,60>
  object Views::Text Separator1
  {
    preset Bounds = <53,57,76,89>;
    preset String = ":";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #838083FF;
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user select another time. Thereupon the method's logic will be \
  // executed. In the associated slot method you can evaluate the time picker properties \
  // @Hour, @Minute and @Second.
  $rect <220,150,420,190>
  property slot OnChange = null;

  // The property 'Second' stores the number of seconds after the minute. The value \
  // is valid in range 0 .. 59.
  $rect <620,10,820,50>
  property int32 Second = 0;

  // The property 'Minute' stores the number of minutes after the hour. The value \
  // is valid in range 0 .. 59.
  $rect <420,10,620,50>
  property int32 Minute = 0;

  // The property 'Hour' stores the number of hours since midnight. The value is \
  // valid in range 0 .. 23.
  $rect <220,10,420,50>
  property int32 Hour = 0;

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,0,190,150>;
    preset Color = #000000FF;
  }
}

// This is a GUI component.
$rect <690,480,820,520>
$output false
class DatePicker : Templates::PickerControl
{
  $rect <250,400,450,440>
  inherited property Bounds = <0,0,230,150>;

  $rect <480,280,680,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the date picker widget.
    //
    // isEnabled  --> the date picker can react to user inputs.
    // isSelected --> the date picker can receive keyboard events.
    // isSliding  --> the user interacts with the date picker.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isSliding  = TouchHandlerDay.Sliding   || 
                          TouchHandlerMonth.Sliding ||
                          TouchHandlerYear.Sliding;

    /*

      TO DO:

      Depending on your date picker design, you have surely added some new 
      views  to your date picker. In the below code you should update the
      properties of these views. For example, when your picker has an image
      which you want to show only while the user is changing the date, than
      following can be done:

        theImage.Visible = isSliding;

      Depending on the state of the date picker, you can alternate any property 
      of your views. You can change their visibility, colors, opacity, bitmaps
      shown in image views, fonts used to render text, the position and the
      size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the picker
      (e.g. 'isSliding') with its preceding state (e.g. variable 'sliding').

      Assuming you have already added to your date picker component a new
      effect member, named it 'slidingEffect' and configured it to animate
      e.g. the opacity of an image within the date picker. Then following is
      sufficient to trigger the animation:

        if ( isSliding && !sliding )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isSliding && sliding )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( isSliding )
      BorderCurrent.Color = #C1C1C1FF;

    else
      BorderCurrent.Color = #E1E1E1FF;

    // Remember the current state. Next date when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // sliding <<-->> not sliding transition.
    enabled  = isEnabled;
    selected = isSelected;
    sliding  = isSliding;
  }

  // To do:
  // 
  // - Adjust the visible size of your picker (the thick blue border). This will \
  // be the picker's default size.
  // - Remove the 'Background', 'Border', 'BorderCurrent', 'ShineAtTop' and 'ShineAtBottom' \
  // members if you want other views to be shown instead these in your picker.
  // - According to your desired picker design add and configure new views (e.g. \
  // text views as captions for Day, Month, etc).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the picker's current state.
  // - You can also add and configure animation effects to your picker. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your picker.
  // - Similarly you can arrange the 3 lists 'ListDay', 'ListMonth' and 'ListYear' \
  // and the corresponding touch handlers 'TouchHandlerDay', TouchHandlerMonth' and \
  // 'TouchHandlerYear'. Note, the touch handler should always cover the area of \
  // the corresponding list.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the picker itself is resized.
  // - If you want other fonts, colors, etc. to be displayed in the 3 lists, adapt \
  // the implementation of the corresponding slot methods 'OnLoadDayItem', 'OnLoadMonthItem' \
  // and 'OnLoadYearItem'.
  // - If you want the items to be displayed with other height, adapt the property \
  // 'ItemHeight' of the 3 'ListDay', 'ListMonth' and 'ListYear'. Similarly adapt \
  // the property 'SnapNext' of the corresponding touch handlers 'TouchHandlerDay', \
  // TouchHandlerMonth' and 'TouchHandlerYear'.
  // - From the Gallery folder 'Chora' add properties to your picker. One property \
  // for every picker specific setting (e.g. 'Caption', 'Icon', 'Color', 'Font', \
  // ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Caption' should update the text view in your picker where \
  // some caption is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,460,1020,900>;
  }

  // Utility Functionality
  note group Note4
  {
    attr Bounds = <700,240,920,330>;
  }

  // State Management
  note group Note3
  {
    attr Bounds = <470,240,690,450>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <240,240,460,370>;
  }

  // List Management
  note group Note1
  {
    attr Bounds = <10,240,230,410>;
  }

  // This variable stores the current state of the date picker.
  $rect <480,400,680,440>
  var bool sliding;

  // This variable stores the current state of the date picker.
  $rect <480,360,680,400>
  var bool selected;

  // This variable stores the current state of the date picker.
  $rect <480,320,680,360>
  var bool enabled;

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has finished the slide animation. Thereupon \
  // the owner of the date picker is notified, that the date has been changed.
  $rect <250,320,450,360>
  slot onEndSlide
  {
    // The user has finished the interaction with the date picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the date picker appearance.
    InvalidateViewState();

    // The last list has finished the slide animation. Adjust the day and notify the owner
    // about the made selection
    if ( !TouchHandlerDay.Sliding && !TouchHandlerMonth.Sliding && !TouchHandlerYear.Sliding )
    {
      // Changing the month may affect the actually selected day.
      var int32 daysInMonth = getDaysInMonth( Month, Year );
      var int32 day         = Day;

      // Ensure the list displays the right number of days
      ListDay.NoOfItems = daysInMonth;

      // Adjust the day if necessary
      if ( day > daysInMonth )
        Day = daysInMonth;

      // Notify the owner of the date picker, that the user has selected another date.
      postsignal OnChange;
    }
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has begun the slide animation.
  $rect <250,280,450,320>
  slot onStartSlide
  {
    // The user has begun an interaction with the date picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the date picker appearance.
    InvalidateViewState();
  }

  // This method is called by 'ListYear' vertical list every time the list loads \
  // or updates an item.
  $rect <20,360,220,400>
  slot OnLoadYearItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListYear.Item;
    var Views::Text itemView = (Views::Text)ListYear.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your date picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo + 1900, 4 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListYear.Bounds.w, ListYear.ItemHeight );
  }

  // This method is called by 'ListMonth' vertical list every time the list loads \
  // or updates an item.
  $rect <20,320,220,360>
  slot OnLoadMonthItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListMonth.Item;
    var Views::Text itemView = (Views::Text)ListMonth.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your date picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Select the text to display in the 'Month' list
    switch ( itemNo )
    {
      case 1  : itemView.String = Resources::FebruaryAbbr;
      case 2  : itemView.String = Resources::MarchAbbr;
      case 3  : itemView.String = Resources::AprilAbbr;
      case 4  : itemView.String = Resources::MayAbbr;
      case 5  : itemView.String = Resources::JuneAbbr;
      case 6  : itemView.String = Resources::JulyAbbr;
      case 7  : itemView.String = Resources::AugustAbbr;
      case 8  : itemView.String = Resources::SeptemberAbbr;
      case 9  : itemView.String = Resources::OctoberAbbr;
      case 10 : itemView.String = Resources::NovemberAbbr;
      case 11 : itemView.String = Resources::DecemberAbbr;
      default : itemView.String = Resources::JanuaryAbbr;
    }

    // Configure the item view ...
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListMonth.Bounds.w, ListMonth.ItemHeight );
  }

  // This method is called by 'ListDay' vertical list every time the list loads or \
  // updates an item.
  $rect <20,280,220,320>
  slot OnLoadDayItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListDay.Item;
    var Views::Text itemView = (Views::Text)ListDay.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your date picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo + 1, 2 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListDay.Bounds.w, ListDay.ItemHeight );
  }

  $rect <650,90,850,130>
  onget Year
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected date at the
    // third position (index 2). Additionally the first item starts with year 1900
    return 1900 + (( -ListYear.ScrollOffset / ListYear.ItemHeight ) + 2 ) % 200;
  }

  $rect <650,50,850,90>
  onset Year
  {
    // Limit the assigned value to the valid range.
    if ( value < 1900 ) value = 1900;
    if ( value > 2100 ) value = 2100;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected date scrolled by two items.
    // Take this displacement in account. Additionally the first item
    // starts with year 1900
    ListYear.ScrollOffset = ( value - 1900 - 2 ) * -ListYear.ItemHeight;

    // Changing the year may affect the actually selected day (February
    // and the leap year).
    var int32 daysInMonth = getDaysInMonth( Month, value );

    // Ensure the list displays the right number of days
    ListDay.NoOfItems = daysInMonth;

    // Adjust the day if necessary
    if ( Day > daysInMonth )
      Day = daysInMonth;
  }

  $rect <450,90,650,130>
  onget Month
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected date at the
    // third position (index 2). Additionally the first item starts with
    // month 1: January
    return 1 + (( -ListMonth.ScrollOffset / ListMonth.ItemHeight ) + 2 ) % 12;
  }

  $rect <450,50,650,90>
  onset Month
  {
    // Limit the assigned value to the valid range 1 .. 12
    if ( value < 1  ) value = 1;
    if ( value > 12 ) value = 12;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected date scrolled by two items.
    // Take this displacement in account. Additionally the first item
    // starts with month 1: January
    ListMonth.ScrollOffset = ( value - 1 - 2 ) * -ListMonth.ItemHeight;

    // Changing the month may affect the actually selected day.
    var int32 daysInMonth = getDaysInMonth( value, Year );

    // Ensure the list displays the right number of days
    ListDay.NoOfItems = daysInMonth;

    // Adjust the day if necessary
    if ( Day > daysInMonth )
      Day = daysInMonth;

  }

  $rect <250,90,450,130>
  onget Day
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected date at the
    // third position (index 2). Additionally the first item starts with day 1.
    return 1 + (( -ListDay.ScrollOffset / ListDay.ItemHeight ) + 2 ) % ListDay.NoOfItems;
  }

  $rect <250,50,450,90>
  onset Day
  {
    // How many days are in the actually selected month?
    var int32 daysInMonth = getDaysInMonth( Month, Year );

    // Limit the assigned value to the valid range 1 .. { 28, 29, 30, 31 }
    if ( value < 1           ) value = 1;
    if ( value > daysInMonth ) value = daysInMonth;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected date scrolled by two items.
    // Take this displacement in account. Additionally the first item
    // starts with day 1
    ListDay.ScrollOffset = ( value - 2 - 1 ) * -ListDay.ItemHeight;
  }

  // This function returns the number of days in the month and year specified in \
  // the method parameters aMonth and aYear. The function takes care of the February \
  // and its dependency of the leap year.
  $rect <710,280,910,320>
  method int32 getDaysInMonth( arg int32 aMonth, arg int32 aYear )
  {
    // The number of days in February depends on the leap year.
    if ( aMonth == 2 )
      if ((( aYear % 4 ) == 0 ) && ((( aYear % 100 ) != 0 ) || (( aYear % 400 ) == 0 )))
        return 29;
      else
        return 28;

    // A month with 30 days?
    else if (( aMonth == 4 ) || ( aMonth == 6 ) || ( aMonth == 9 ) || ( aMonth == 11 ))
      return 30;

    // Every other month has 31 days.
    else
      return 31;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,230,150>;
  }

  $rect <20,20,160,60>
  object Views::Border BorderCurrent
  {
    preset Bounds = <10,59,220,91>;
    preset Width = 3;
    preset Color = #E1E1E1FF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerYear
  {
    preset Bounds = <150,0,220,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerMonth
  {
    preset Bounds = <70,0,140,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerDay
  {
    preset Bounds = <10,0,60,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListYear
  {
    preset Bounds = <150,0,220,150>;
    preset OnLoadItem = OnLoadYearItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerYear;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 200;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListMonth
  {
    preset Bounds = <70,0,140,150>;
    preset OnLoadItem = OnLoadMonthItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerMonth;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 12;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListDay
  {
    preset Bounds = <10,0,60,150>;
    preset OnLoadItem = OnLoadDayItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerDay;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 31;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,10,150>;
    preset Width = 2;
    preset ColorL = #FFFFFF00;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel1
  {
    preset Bounds = <60,0,70,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel2
  {
    preset Bounds = <140,0,150,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel3
  {
    preset Bounds = <220,0,230,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #1BFF5200;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Rectangle ShineAtBottom
  {
    preset Bounds = <0,88,230,150>;
    preset ColorBL = #D7D7D7FF;
    preset ColorBR = #CFCFCFFF;
    preset ColorTR = #FFFFFF22;
    preset ColorTL = #FFFFFF22;
  }

  $rect <20,20,160,60>
  object Views::Rectangle ShineAtTop
  {
    preset Bounds = <0,0,230,58>;
    preset ColorBL = #FFFFFF22;
    preset ColorBR = #FFFFFF22;
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user select another date. Thereupon the method's logic will be \
  // executed. In the associated slot method you can evaluate the date picker properties \
  // @Day, @Month and @Year.
  $rect <250,150,450,190>
  property slot OnChange = null;

  // The property 'Year' stores the year. The value is valid in range 1900 .. 2100.
  $rect <650,10,850,50>
  property int32 Year = 1900;

  // The property 'Month' store the month of the year. The valid value lies in the \
  // range 1 .. 12.
  $rect <450,10,650,50>
  property int32 Month = 1;

  // The property 'Day' stores the day of the month. The valid value lies in range \
  // 1 .. 31 depending on the actually selected month.
  $rect <250,10,450,50>
  property int32 Day = 0;

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,0,230,150>;
    preset Color = #000000FF;
  }
}

$rect <390,90,550,130>
$output false
class ConfirmPopup : App::Popup
{
  $rect <20,20,160,60>
  inherited property Bounds = <0,0,630,340>;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #3755AFFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <30,110,580,190>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
  }

  $rect <0,360,200,400>
  slot Proceed
  {
    sender; /* the method is called from the sender object */

    signal meth;

    Hide();


  }

  $rect <400,370,600,410>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <0,410,200,450>
  method void ShowThen( arg Core::Root rootObject, arg slot method )
  {
    // Create a new instance of some alert panel component.
    mask = new Views::Rectangle;
    touch = new Core::SimpleTouchHandler;
    root = rootObject;

    meth = method;



    touch.Point1 = <0,0>;
    touch.Point2 = <0,480>;
    touch.Point3 = <800,480>;
    touch.Point4 = <800,0>;

    rootObject.Add( touch, 0 );


    mask.Color = #00000030;
    mask.Bounds = <0,0,800,480>;

    rootObject.Add( mask, 0 );

    var point m = point( (800 - this.Bounds.size.x) / 2, (480 - this.Bounds.size.y) / 2);

        
    this.Bounds.point1 = m;
    this.Bounds.point2 = <800,480> - m;


    rootObject.Add( this, 0 );

    return;

  }

  $rect <270,420,470,460>
  var slot meth = null;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <30,250,180,300>;
    preset OnRelease = Proceed;
    preset Label = "OK";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <425,250,575,300>;
    preset OnRelease = Cancel;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }
}

$rect <990,120,1140,160>
$output false
class KeypadPopup : App::Popup
{
  $rect <20,20,160,60>
  inherited property Bounds = <0,0,480,400>;

  $rect <500,460,640,500>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    accept.Visible = false;
    deny.Visible = false;
    deny2.Visible = false;

    AcceptTimer.Enabled = false;
    DenyTimer.Enabled = false;

    Writable.TextEditor.Text.String = "";
    passkey = "";
    Writable.TextEditor.ObtainFocus();






  }

  $rect <20,20,160,60>
  inherited object InsideTouchHandler
  {
    preset Point4 = <-680,-90>;
    preset Point3 = <520,-90>;
    preset Point2 = <520,790>;
    preset Point1 = <-680,790>;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CBCBCBFF;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey
  {
    preset Bounds = <290,100,350,150>;
    preset NumProperty = "5";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey1
  {
    preset Bounds = <360,40,420,90>;
    preset NumProperty = "9";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey2
  {
    preset Bounds = <220,40,280,90>;
    preset NumProperty = "7";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey3
  {
    preset Bounds = <220,100,280,150>;
    preset NumProperty = "4";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey4
  {
    preset Bounds = <290,40,350,90>;
    preset NumProperty = "8";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey5
  {
    preset Bounds = <360,100,420,150>;
    preset NumProperty = "6";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey6
  {
    preset Bounds = <220,160,280,210>;
    preset NumProperty = "1";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey7
  {
    preset Bounds = <290,160,350,210>;
    preset NumProperty = "2";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey8
  {
    preset Bounds = <360,160,420,210>;
    preset NumProperty = "3";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey9
  {
    preset Bounds = <220,220,280,270>;
    preset NumProperty = "0";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey10
  {
    preset Bounds = <290,220,420,270>;
    preset NumProperty = "Del";
    preset UserPress = Press;
  }

  $rect <30,80,170,120>
  object App::Writable Writable
  {
    preset Bounds = <40,84,140,124>;
    preset Focus = null;
    preset MaxLength = 4;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <40,51,130,80>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Enter PIN";
    preset Font = Resources::FontMedium;
    preset Color = #020202FF;
  }

  $rect <510,220,710,260>
  slot Press
  {
    sender; /* the method is called from the sender object */

    var App::KeypadKey key = (App::KeypadKey) sender;

    if (passkey.length < 4 )
    {
        if ( key.NumProperty.length == 1 )
        {
             passkey = passkey + key.NumProperty[0];
            Update();
        }
    }

    if ( key.NumProperty == "Del" && passkey.length > 0 )
    {
        passkey = passkey.left( passkey.length - 1 );
        Update();
    }


  }

  $rect <30,460,230,500>
  slot Proceeed
  {
    sender; /* the method is called from the sender object */

    var App::Application ap = (App::Application) GetRoot();


    if ( getting )
    {
        var int32 level = -1;
        var int32 key = passkey.parse_int32( -1 );
        var int32 user = 0;

        native( level, key, user )
        {
            Command cmd;

            cmd.int0 = key;

            Command0( CMD_CHECK_PASSKEY, &cmd );

            level = cmd.int0;
            user  = cmd.int1;
        }
        
        if ( level == -1 )
        {
            accept.Visible = false;
            deny.Visible = true;
            DenyTimer.restart( 0, 600 );
        }
        else
        {
            ap.LevelAccess.AccessLevel = level;
            ap.LevelAccess.UserIndex = user;
            deny.Visible = false;
            accept.Visible = true;
            AcceptTimer.Enabled = true;
            AcceptTimer.restart( 0, 600 );
            ap.Settings.PushButton3.Enabled = false;
            
            if(ap.LevelAccess.AccessLevel == 4)
            {
              ap.Settings.PushButton3.Enabled = true;
            }

            native( level, key, user )
            {
              Command3( CMD_LOGON_ACCESS, level, user, 1 );
            }  
        }
    }
    else  // setting
    {
      var int32 userindex = ap.LevelAccess.UserIndex;
      
      if ( userindex != -1 )
      { 
          if ( passkey.length == 4 )
          {
              var int32 level;
            
              var int32 key = passkey.parse_int32( -1 );
           
              var bool ok = false;

              native( key, userindex )
              {
                  if ( Command2( CMD_SET_PASSKEY, key, userindex ) == CMD_OK )
                  {
                      ok = 1;
                  }
              } 
              if ( ok )
              {   
                  accept2.Visible = true;
                  AcceptTimer.Enabled = true;
                  AcceptTimer.restart( 0, 800 );
              }
          }
          else
          {
              deny2.Visible = true;
              DenyTimer.Enabled = true;
              DenyTimer.restart( 0, 2000);
          }
       }  
    }


  }

  $rect <30,510,230,550>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <510,20,710,60>
  property string EngLevel = "1234";

  $rect <510,70,710,110>
  property string SupLevel = "0000";

  $rect <20,20,160,60>
  object Views::Text accept
  {
    preset Bounds = <40,134,140,164>;
    preset String = "Accepted";
    preset Font = Flat::FontM;
    preset Color = #079E1DFF;
    preset Visible = false;
  }

  $rect <550,150,750,190>
  object Core::Timer AcceptTimer
  {
    preset OnTrigger = AcceptSlot;
    preset Period = 1000;
  }

  $rect <20,20,160,60>
  object Views::Text deny
  {
    preset Bounds = <40,134,140,164>;
    preset String = "Denied";
    preset Font = Flat::FontM;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <540,290,740,330>
  slot AcceptSlot
  {
    sender; /* the method is called from the sender object */

    AcceptTimer.Enabled = false;  
    Hide();



  }

  $rect <520,340,720,380>
  object Core::Timer DenyTimer
  {
    preset OnTrigger = DenySlot;
    preset Period = 3000;
  }

  $rect <530,390,730,430>
  slot DenySlot
  {
    sender; /* the method is called from the sender object */

    DenyTimer.Enabled = false;  
    deny.Visible = false;
    deny2.Visible = false;




  }

  $rect <750,60,950,100>
  object Core::Timer StarTimer
  {
    preset OnTrigger = StarSlot;
  }

  $rect <780,100,980,140>
  slot StarSlot
  {
    sender; /* the method is called from the sender object */


    if ( !getting ) return;

    StarTimer.Enabled = false;



    var int32 n;
    var string s = "";

    for( n = 0; n < passkey.length; n=n+1 )
    {
        s = s + "*";
    }

    Writable.TextEditor.String = s;

  }

  $rect <810,170,1010,210>
  property string passkey = 0;

  $rect <840,260,1040,300>
  method void Update()
  {
             var int32 n;
             if ( StarTimer.Enabled ) StarTimer.Enabled = false;

            
           
             Writable.TextEditor.String = "";
          
             for( n = 0; n < passkey.length; n=n+1)
             {
                if ( n ==  passkey.length-1 || !getting )
                {
                   Writable.TextEditor.String = Writable.TextEditor.String + passkey[n];
                }
                else
                {
                    Writable.TextEditor.String = Writable.TextEditor.String + '*';
                }
              }
              
             StarTimer.Enabled = true;
             StarTimer.restart( 0, 1000 );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <280,300,420,350>;
    preset OnRelease = null;
    preset OnActivate = Cancel;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <40,300,180,350>;
    preset OnRelease = null;
    preset OnActivate = Proceeed;
    preset Label = "OK";
    preset Appearance = App::NormalPushButton;
  }

  $rect <1000,50,1200,90>
  property bool getting = false;

  $rect <20,20,160,60>
  object Views::Text deny1
  {
    preset Bounds = <40,134,140,164>;
    preset String = "Denied";
    preset Font = Flat::FontM;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text deny2
  {
    preset Bounds = <40,132,210,162>;
    preset String = "4 digits required";
    preset Font = Flat::FontM;
    preset Color = #3651AAFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text accept2
  {
    preset Bounds = <30,132,210,162>;
    preset String = "Passkey changed";
    preset Font = Flat::FontM;
    preset Color = #3651AAFF;
    preset Visible = false;
  }

  // OK and Cancel
  note group Note
  {
    attr Bounds = <20,420,250,570>;
  }

  $reorder KeypadKey 3
  $reorder KeypadKey1 3
  $reorder KeypadKey2 3
  $reorder KeypadKey3 3
  $reorder KeypadKey4 3
  $reorder KeypadKey5 3
  $reorder KeypadKey6 3
  $reorder KeypadKey7 3
  $reorder KeypadKey8 3
  $reorder KeypadKey9 3
  $reorder KeypadKey10 3
  $reorder Writable 3
  $reorder Text 3
  $reorder Press 3
  $reorder Proceeed 3
  $reorder Cancel 3
  $reorder EngLevel 3
  $reorder SupLevel 3
  $reorder accept 3
  $reorder AcceptTimer 3
  $reorder deny 3
  $reorder AcceptSlot 3
  $reorder DenyTimer 3
  $reorder DenySlot 3
  $reorder StarTimer 3
  $reorder StarSlot 3
  $reorder passkey 3
  $reorder Update 3
  $reorder PushButton 3
  $reorder PushButton1 3
}

$rect <1140,120,1280,160>
$output false
class KeypadKey : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,60,50>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );


    //SimpleTouchHandler.Point1 = Bounds.point1;
    //SimpleTouchHandler.Point3 = Bounds.point2;
    //SimpleTouchHandler.Point2 = point( Bounds.point2.x, Bounds.point1.y );
    //SimpleTouchHandler.Point4 = point( Bounds.point1.x, Bounds.point2.y );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


    Text.String = NumProperty ;



    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <5,5,55,45>;
    preset Color = #BABABAFF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,60,50>;
    preset OnRelease = Release;
    preset OnPress = Press;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,60,50>;
    preset String = "8";
    preset Font = Resources::FontMedium;
    preset Color = #424242FF;
  }

  $rect <25,85,180,125>
  property string NumProperty = "0";

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,60,50>;
    preset Color = #A6D2FF92;
    preset Visible = false;
  }

  $rect <270,100,470,140>
  slot Release
  {
    sender; /* the method is called from the sender object */

     
  }

  $rect <270,140,470,180>
  slot Press
  {
    sender; /* the method is called from the sender object */

     

    postsignal UserPress;


  }

  $rect <550,70,750,110>
  property slot UserPress = null;
}

$rect <390,440,540,480>
$output false
class Writable : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,150,50>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <260,60,400,100>
  inherited method Init()
  {
    // TO DO: Write your code here ... 
     
    Property = ^this.TextEditor.Text.String;


  }

  $rect <200,0,340,40>
  inherited property Focus = TextEditor;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,150,50>;
    preset Width = 2;
    preset ColorL = #333333FF;
    preset ColorR = #C9C9C9FF;
    preset ColorB = #CCCCCCFF;
    preset ColorT = #333333FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <3,3,147,47>;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object App::TextEditor TextEditor
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <3,3,147,47>;
    preset Focus = null;
    preset OnChange = null;
    preset WrapText = false;
    preset String = "";
  }

  $rect <20,70,220,110>
  property ^string Property = null;

  $rect <20,110,220,150>
  onset Property
  {
    // The value doesn't change - nothing to do.
    if ( pure Property == value )
      return;

    // Remember the property's new value.
    pure Property = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,150,220,190>
  onget Property
  {
    return pure Property;
  }

  $rect <270,120,470,160>
  property int32 MaxLength = 0;

  $rect <270,170,470,210>
  onset MaxLength
  {
    // The value doesn't change - nothing to do.
    if ( pure MaxLength == value )
      return;

    // Remember the property's new value.
    pure MaxLength = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <150,0>;
    preset Point2 = <150,50>;
    preset Point1 = <0,50>;
    preset OnPress = Press;
  }

  $rect <410,30,610,70>
  slot Press
  {
    sender; /* the method is called from the sender object */

    signal onPress;

  }

  $rect <520,70,720,110>
  property slot onPress = null;
}

// This component implements an editor.
$rect <1190,80,1310,120>
$output false
class TextEditor : Templates::TextEditor
{
  $rect <670,620,870,660>
  inherited property Bounds = <0,0,160,120>;

  $rect <680,280,880,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited version of the method
    super( aState );

    // Activate the caret blinking if the editor component has the input focus
    if ( aState.contains( Core::ViewState[ Focused ]))
      blinkEffect.Enabled = true;

    // ... otherwise hide the caret
    else
    {
      blinkEffect.Enabled = false;
      Caret.Visible       = false;
    }
  }

  // To do:
  // 
  // - Adjust the visible size of the text editor (the thick blue border). This will \
  // be the editor's default size.
  // - Resize and arrange the member 'Text' so it covers the area where you intend \
  // to display the text. This is usually the entire area.
  // - Adjust the position and the size of the 'SimpleTouchHandler' and 'SlideTouchHandler', \
  // so they cover the 'Text' view.
  // - If your design it expects, add and configure more views in the component, \
  // e.g. views to display background, borders, etc.
  // - The editor implements several handler to process keyboard inputs. See the \
  // annotation 'Keyboard events'. Feel free to add more handler for other key events \
  // or remove the handler you don't need in your version.
  // - The editor displays a magnifying glass when the user touches and holds the \
  // finger for a while (see the method 'onHoldTouch'). If you don't want it, remove \
  // the contents within the annotation 'Magnifying glass' and the slot method 'onHoldTouch'.
  // - The editor reacts to touch interactions. See the annotation 'Touch screen \
  // events'. If your device is not touch driven, you can remove the both handlers \
  // 'SimpleTouchHandler', 'SlideTouchHandler' and the methods from the annotation \
  // 'Touch screen events'.
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the editor's current state (e.g. focused editor \
  // may appear with other colors, etc.)
  // - The editor is implemented with various properties allowing the configuration \
  // of the text (e.g. 'Font', 'Color', ...). If your version of the editor doesn't \
  // need such configuration, remove the properties and the associated OnSet methods.
  // - If you need other properties to configure the editor, add from the Gallery \
  // folder 'Chora' new properties. One property for every new setting (e.g. 'BorderWidth', \
  // etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'BorderWidth' should update the eventually used 'Border' \
  // view, etc.).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note6
  {
    attr Bounds = <10,690,990,1150>;
  }

  // Magnifying glass
  note group Note5
  {
    attr Bounds = <440,500,660,670>;
  }

  // Caret
  note group Note4
  {
    attr Bounds = <10,500,430,670>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <670,240,890,330>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <440,240,660,450>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <10,240,430,490>;
  }

  // This internal variable refers to a temporary Views::Image object used to show \
  // the background for the augmented text content around the caret. This view appears \
  // during the user is moving this caret by touching the caret with the finger.
  $rect <450,620,650,660>
  var Views::Rectangle magnifyingBack = null;

  // This internal variable refers to a temporary Views::WarpGroup object used to \
  // show the augmented text content around the caret. This view appears during the \
  // user is moving this caret by touching the caret with the finger.
  $rect <450,580,650,620>
  var Views::WarpGroup magnifyingView = null;

  // This flag is set if it is evtl. necessary to scroll the editor content in order \
  // to ensure that the caret is still visible.
  $rect <220,620,420,660>
  var bool autoScroll;

  // This internal variable stores the current caret index. This is the position \
  // within Text.String property where the user can input text or delete signs.
  $rect <20,620,220,660>
  var int32 caretIndex = 0;

  // This slot method is called after the caret has been adjusted. Its job is to \
  // adjust too the position of the magnifying glass view where the augmented text \
  // content around the caret is shown.
  $rect <450,540,650,580>
  slot updateMagnifyingView
  {
    // There is actually no magnifying glass displayed. Nothing to do.
    if ( magnifyingView == null )
      return;

    var rect  srcArea = magnifyingView.SourceArea;
    var rect  extent  = magnifyingView.GetExtent();
    var rect  bounds  = Bounds;
    var point caret   = Caret.Point1;

    // Calculate the start position of the area to show in the magnifying
    // view. Preferably the caret should appear in the center of this area.
    var int32 srcX = caret.x - ( srcArea.w / 2 );

    // However, the part of magnifying glass displaying the caret should 
    // remain arranged horizontally within the editor area.
    if ( srcX < 0 )
      srcX = 0;

    if (( srcX + srcArea.w ) > bounds.w )
      srcX = bounds.w - srcArea.w;

    // The resulting start position of the area to augment
    magnifyingView.SourceArea.origin = point( srcX, caret.y );

    // Now calculate the position for the magnifyingView. Preferably the
    // the view should be arranged so it shows the augmented caret 
    // exactly above the origin caret
    var int32 dstX = ( bounds.x1 + caret.x ) - ( caret.x - srcX ) * 2;

    // From the new magnifyingView position and its current position calculate
    // an offset.
    var point ofs = point( dstX - extent.x1, bounds.y1 + caret.y - extent.y2 );

    // Move the magnifyingView and its background by the just calculated offset
    magnifyingView.MoveView( ofs, false );
    magnifyingBack.MoveView( ofs, false );
  }

  // This slot method is called after a short delay when the user has moved the caret \
  // or modified the text. Its job is to ensure that the caret is still visible. \
  // If necessary, the editor content is scrolled.
  $rect <220,540,420,580>
  slot updateScrollOffset
  {
    // Get the visible area of the text view
    var rect  bounds = Text.Bounds;
    var int32 ofsX   = 0;
    var int32 ofsY   = 0;

    // Calculate an offset to scroll the text content if the caret lies
    // outside the visible area
    if ( Caret.Point1.x < bounds.x1 ) ofsX = bounds.x1 - Caret.Point1.x;
    if ( Caret.Point1.x > bounds.x2 ) ofsX = bounds.x2 - Caret.Point1.x;
    if ( Caret.Point1.y < bounds.y1 ) ofsY = bounds.y1 - Caret.Point1.y;
    if ( Caret.Point2.y > bounds.y2 ) ofsY = bounds.y2 - Caret.Point2.y;

    // Should the cont be scrolled?
    if (( ofsX != 0 ) || ( ofsY != 0 ))
      Text.ScrollOffset = Text.ScrollOffset + point( ofsX, ofsY );

    // The following code takes care of the automatic adjustment of the
    // text scroll position if after modifying the text, its area is small
    // enough to be completely visible.
    ofsX = Text.ScrollOffset.x;
    ofsY = Text.ScrollOffset.y;

    // Get the current text area of the 
    var point size = Text.GetContentArea().size;

    // Does the area fit completely within the text editor?
    if ( size.x <= Text.Bounds.w ) ofsX = 0;
    if ( size.y <= Text.Bounds.h ) ofsY = 0;

    // If possible arrange the text so it fits within the text editor.
    Text.ScrollOffset = point( ofsX, ofsY );
  }

  // This slot method is attached to the Text view. Each time the Text view has rearranged \
  // the text, this method is called. Its job is to adjust the caret to the evtl. \
  // new position.
  $rect <20,540,220,580>
  slot updateCaret
  {
    // Without the font we don't know the height of the caret
    if ( Font == null )
      return;

    // Get the pixel position of the sign right to the caret
    var point rowCol = Text.StringIndex2RowCol( caretIndex );
    var point pos    = Text.RowCol2Position( rowCol );

    // Arrange the caret at the just determined position. The height of 
    // the caret corresponds to the height of a text row drawn with the
    // font
    Caret.Point1 = pos - point( 0, Font.Ascent  );
    Caret.Point2 = pos + point( 0, Font.Descent );

    // Restart the blink effect -> this ensures that the user can see the
    // caret while it is moved or the text is modified
    if ( blinkEffect.Enabled )
    {
      blinkEffect.Enabled = false;
      blinkEffect.Enabled = true;
    }

    // Should adjust the scroll position so that the caret remains in the visible
    // area? Finally clear the 'autoScroll' flag again.
    if ( autoScroll )
    {
      postsignal updateScrollOffset;
      autoScroll = false;
    }

    // If there is a magnifying glass view visible -> arrange it also to the
    // current caret position.
    if ( magnifyingView != null )
      postsignal updateMagnifyingView;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to hide the magnifying glass view again.
  $rect <450,400,650,440>
  slot onReleaseTouch
  {
    // Hide the views used temporarily to show the augmented editor content
    if ( magnifyingView != null )
    {
      Owner.Remove( magnifyingView );
      Owner.Remove( magnifyingBack );
      magnifyingView = null;
      magnifyingBack = null;

      // Free the temporary used off-screen memory
      Buffered = false;
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to move the caret accordingly to the user's finger movement.
  $rect <450,360,650,400>
  slot onDragTouch
  {
    // Does the user currently drag the caret?
    if ( magnifyingView != null )
    {
      // From the touched screen position estimate the corresponding position
      // within the text string.
      var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
      var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

      // Does the caret position change? Force the editor to update the
      // position of the blinking caret
      if ( newCaretIndex != caretIndex )
      {
        caretIndex = newCaretIndex;
        postsignal updateCaret;

        // Ensure the caret is still visible later in the updateText slot method
        autoScroll = true;
      }
    }

    // No, then redirect the touch interaction to the slide touch handler when the
    // user moved the finger a little bit. In this manner the user can scroll the text.
    else
    {
      var point ofs   = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;
      var int32 limit = GetRoot().CursorDragLimit;

      // Start the slide mode if the user has dragged the finger a little bit
      if (( ofs.x < -limit ) || ( ofs.x > limit ) ||
          ( ofs.y < -limit ) || ( ofs.y > limit ))
        GetRoot().DeflectCursor( SlideTouchHandler, <0,0>);
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to activate the caret movement mode if the user has pressed the finger on the \
  // screen for a while. The method also shows a small magnifying glass where the \
  // text around the caret is shown. This should help the user to navigate the caret \
  // with the finger.
  $rect <450,320,650,360>
  slot onHoldTouch
  {
    // When the user presses the finger within the text editor area,
    // the editor enters the caret dragging mode. In this mode the
    // user can move the caret with the finger. For convenience the
    // area below the finger is displayed in a kind of magnifying glass.
    // Does enter the mode?
    if (( SimpleTouchHandler.HoldPeriod >= 300 ) && ( magnifyingView == null ))
    {
      // Calculate the size of the area to augment
      var int32 height = Caret.Point2.y - Caret.Point1.y;
      var int32 width  = height * 3;

      // Limit to the available size of the editor component
      if ( height > Bounds.h ) height = Bounds.h;
      if ( width  > Bounds.w ) width  = Bounds.w;

      // The editor component should store its content in an off-screen bitmap
      // in order to be able to to show it augmented in an overlay 'magnifyingView'
      Buffered = true;

      // Create a temporary view to show the augmented content and to show the
      // 'magnifying glass' background
      magnifyingView = new Views::WarpGroup;
      magnifyingBack = new Views::Rectangle;

      // Prepare a magnifyingView to show an augmented content of the edited text
      // row. The content is augmented by the factor x 2
      magnifyingView.Group       = this;
      magnifyingView.Quality     = true;
      magnifyingView.Opacity     = 200;
      magnifyingView.SourceArea  = rect( 0, 0, width, height );
      magnifyingView.Point2.x    = width  * 2;
      magnifyingView.Point3.x    = width  * 2;
      magnifyingView.Point3.y    = height * 2;
      magnifyingView.Point4.y    = height * 2;

      // Also prepare the magnifying glass background view. It is a semitransparent
      // rectangle.
      magnifyingBack.Bounds.size   = point( width * 2, height * 2 ) + <20,20>;
      magnifyingBack.Bounds.origin = <-10,-10>;
      magnifyingBack.Color         = #EEEEEECC;

      // Make the just created views visible on the screen
      Owner.Add( magnifyingBack, 0 );
      Owner.Add( magnifyingView, 0 );

      // Arrange the 'magnifying glass' views at the correct position
      postsignal updateMagnifyingView;
    }

    // Even if the user is not moving the cursor (finger) continue the scrolling when
    // the user holds the finger near an edge of the text editor.
    if ( magnifyingView != null )
      signal onDragTouch;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to obtain the focused state for the editor so the user can interact with the \
  // editor content and to place the caret at the touched position.
  $rect <450,280,650,320>
  slot onPressTouch
  {
    // With the first touch focus the text editor
    if ( !HasViewState( Core::ViewState[ Focused ]))
      ObtainFocus();

    // Estimate the position within the text string corresponding to the
    // position touched on the screen.
    var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the text editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // move the caret up/down/left or right in the editor text.
  $rect <220,440,420,480>
  slot onCursorKey
  {
    // No font specified to show the text -> no navigation
    // possible
    if ( Font == null )
      return;

    // Knowing the position of the caret within the string, get the
    // corresponding row/column position in the displayed text.
    var point rc = Text.StringIndex2RowCol( caretIndex );

    // Has the user moved the caret to the left? Get the new resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Left )
    {
      // Navigate to the previous column
      rc.x = rc.x - 1;

      // Skip to the end of the preceding row?
      if ( rc.x < 0 )
      {
        rc.y = rc.y - 1;
        rc.x = Text.GetRowString( rc.y ).length;
      }
    }

    // Has the user moved the caret to the right? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Right )
    {
      // Navigate to the next column
      rc.x = rc.x + 1;

      // Skip to the begin of the next row?
      if ( rc.x == Text.GetRowString( rc.y ).length )
      {
        rc.y = rc.y + 1;
        rc.x = 0;
      }
    }

    // Has the user moved the caret one row up? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Up )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just above
      rc = Text.Position2RowCol( pos - point( 0, rowHeight ));
    }

    // Has the user moved the caret one row down? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Down )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just below
      rc = Text.Position2RowCol( pos + point( 0, rowHeight ));
    }

    // From the just determined new row/column position get the corresponding
    // position within the text string
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign preceding the current caret position and to move the caret accordingly.
  $rect <220,400,420,440>
  slot onBackspaceKey
  {
    // No signs preceding the caret -> Nothing to delete
    if ( caretIndex == 0 )
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex - 1 ];
    var int32 count = 1;

    // Is this a space sign? Usually space signs are eliminated by the
    // text view unless we use the non-breakable space sign \xA0. However,
    // to perform the text wrap, a silent break sign '^' is placed behind
    // the space sign. Consider the both signs '\xA0^' as a unit
    if (( caretIndex > 1 ) && ( ch == '^' ) && 
        ( Text.String[ caretIndex - 2 ] == '\xA0' ))
      count = 2;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    else if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      count = 2;

    // Remove the affected text portion and adjust the caret position
    Text.String = Text.String.remove( caretIndex - count, count );
    caretIndex  = caretIndex - count;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign at the current caret position.
  $rect <220,360,420,400>
  slot onDeleteKey
  {
    // No signs following the caret -> Nothing to delete
    if ( caretIndex >= ( Text.String.length - 1 ))
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if ( ch == '%' )
      count = 2;

    // Is this a space sign? Usually space signs are eliminated by the
    // text view unless we use the non-breakable space sign \xA0. However,
    // to perform the text wrap, a silent break sign '^' is placed behind
    // the space sign. Consider the both signs '\xA0^' as a unit
    else if ( ch == '\xA0' )
      count = 2;

    // Remove the affected text fragment
    Text.String = Text.String.remove( caretIndex, count );

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the <new line> sign and to move the caret \
  // to the next row.
  $rect <220,320,420,360>
  slot onNewlineKey
  {
    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( '\n', caretIndex );
    caretIndex  = caretIndex + 1;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the sign which has been input by the user \
  // and to move the caret to the next column.
  $rect <220,280,420,320>
  slot onCharacterKey
  {
    var char   ch  = CharacterKeyHandler.CharCode;
    var string str = ch;

    // Precede all special control signs with the '%' escape sign. Otherwise
    // the user can't input nor see them
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '\xAD' ) || ( ch == '%' ))
      str = "%" + ch;

    // To avoid the elimination of space signs at the end of a wrapped row
    // use the non-breakable space signs mit the additional 'silent' break
    // sign to perform the wrapping
    else if ( ch == ' ' )
      str = "\xA0^";

    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( str, caretIndex );
    caretIndex  = caretIndex + str.length;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  $rect <390,180,590,220>
  onset WrapText
  {
    // The value doesn't change - nothing to do.
    if ( pure WrapText == value )
      return;

    // Remember the new value ...
    pure WrapText = value;
    Text.WrapText = value;

    // If the text is warp automatically in rows, there is no need to
    // scroll the text horizontally.
    SlideTouchHandler.SlideHorz = !value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <190,180,390,220>
  onset Alignment
  {
    // The value doesn't change - nothing to do.
    if ( pure Alignment == value )
      return;

    // The justified mode is not supported by the editor.
    if ( value.contains( Views::TextAlignment[ AlignHorzJustified ]))
      value = value - Views::TextAlignment[ AlignHorzJustified ]
                    + Views::TextAlignment[ AlignHorzLeft ];

    // Remember the new value ...
    pure Alignment = value;
    Text.Alignment = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <590,90,790,130>
  onget String
  {
    // Get the current text view content
    var string str = Text.String;

    // In the following steps remove any special text view control signs
    // which are usually used to control the text flow. The resulting string
    // should contain the 'pure' text only.
    var int32  inx = str.find( '\xA0', 0 );

    // Internally the text editor works with the sign sequence '\xA0^' as
    // the space ' ' sign. This is because the text view tends to eliminate
    // regular space signs at the end of a text row.
    // Convert all '\xA0^' sign sequences to a regular space ' '
    while ( inx >= 0 )
    {
      if ( str[ inx + 1 ] == '^' )
      {
        str = str.remove( inx, 1 );
        str[ inx ] = ' ';
      }

      inx = str.find( '\xA0', inx + 1 );
    }

    inx = str.find( '%', 0 );

    // The special control/escape signs are not visible until there is a
    // '%' sign in front of them. Remove all superfluous '%' signs
    while ( inx >= 0 )
    {
      str = str.remove( inx, 1 );
      inx = str.find( '%', inx + 1 );
    }

    // Finally remove the <new line> sign at the end of text which was used
    // as workaround for a text flow parser issue
    return str.left( str.length - 1 );
  }

  $rect <590,50,790,90>
  onset String
  {
    // The value doesn't change - nothing to do.
    if ( pure String == value )
      return;

    // Remember the new string ...
    pure String = value;

    // In the following steps disarm in the assigned Unicode string the special
    // control and escape signs, which usually control the text flow in a  text
    // view. Without this conversion step, signs like '%' couldn't be seen in
    // the editor.
    var string str = value;
    var int32  inx = str.find( '%', 0 );

    // The special '%' escape sign is not visible until there is other
    // '%' sign in front of it. Convert all '%' signs into '%%' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '%', inx + 2 );
    }

    inx = str.find( '^', 0 );

    // The special '^' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '^' signs into '%^' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '^', inx + 2 );
    }

    inx = str.find( '~', 0 );

    // The special '~' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '~' signs into '%~' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '~', inx + 2 );
    }

    inx = str.find( '\xAD', 0 );

    // The special '\xAD' hyphen sign is not visible until there is a '%'
    // sign in front of it. Convert all '\xAD' hyphen signs into '%\xAD'
    // sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '\xAD', inx + 2 );
    }

    inx = str.find( ' ', 0 );

    // The text view tends to eliminate space signs at the end of a text row.
    // To avoid it, the editor will work internally with the non-breakable
    // space \xA0 sign. To perform the line wrap, an additional '^' silent
    // break control sign is placed behind the non-breakable space.
    // Convert all ' ' space signs to '\xA0^' sequence
    while ( inx >= 0 )
    {
      str[ inx ] = '\xA0';
      str = str.insert( "^", inx + 1 );
      inx = str.find( ' ', inx + 2 );
    }

    // Ensure that the caret still refers to a sign within the string
    //if ( caretIndex > str.length )
      caretIndex = str.length;

    // Now show the new string in the editor's text view. The additional
    // <new line> is a workaround for a flow text parser issue
    Text.String = str + "\n";

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <390,50,590,90>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Store the new Color
    pure Color  = value;
    Text.Color  = value;
    Caret.Color = value;
  }

  $rect <190,50,390,90>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Store the new font...
    pure Font = value;
    Text.Font = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  // This bool change effect is used to blink the caret.
  $rect <20,580,220,620>
  object Effects::BoolEffect blinkEffect
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Caret.Visible;
    preset CycleDuration = 500;
    preset InterCycleDelay = 500;
  }

  // This key handler reacts to user inputs if the user has pressed the 'up', 'down', \
  // 'left' or 'right' key. In this case the associated onCursorKey method is called.
  $rect <20,440,220,480>
  object Core::KeyPressHandler CursorKeyHandler
  {
    preset OnPress = onCursorKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onCursorKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'backspace' \
  // key. In this case the associated onBackspaceKey method is called.
  $rect <20,400,220,440>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = onBackspaceKey;
    preset Filter = Core::KeyCode.Backspace;
    preset OnHold = onBackspaceKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'delete' \
  // key. In this case the associated onDeleteKey method is called.
  $rect <20,360,220,400>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = onDeleteKey;
    preset Filter = Core::KeyCode.Delete;
    preset OnHold = onDeleteKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'enter' key. \
  // In this case the associated onNewlineKey method is called.
  $rect <20,320,220,360>
  object Core::KeyPressHandler NewlineKeyHandler
  {
    preset OnPress = onNewlineKey;
    preset Filter = Core::KeyCode.Enter;
    preset OnHold = onNewlineKey;
  }

  // This key handler reacts to user inputs if the user has pressed a key corresponding \
  // to character/digit. In this case the associated onCharacterKey method is called.
  $rect <20,280,220,320>
  object Core::KeyPressHandler CharacterKeyHandler
  {
    preset OnPress = onCharacterKey;
    preset Filter = Core::KeyCode.CharacterKeys;
    preset OnHold = onCharacterKey;
  }

  // This slide gesture handler is used to scroll the text content.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,160,120>;
    preset SlideHorz = false;
    preset Friction = 0.05;
  }

  // This generic touch handler is used to move the caret.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,120>;
    preset Point3 = <160,120>;
    preset Point2 = <160,0>;
    preset Point1 = <0,0>;
    preset OnDrag = onDragTouch;
    preset OnHold = onHoldTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset MaxStrikeCount = 3;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,2,157,117>;
    preset OnUpdate = updateCaret;
    preset SlideHandler = SlideTouchHandler;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text\n";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Caret
  {
    preset Point2 = <50,70>;
    preset Point1 = <50,50>;
    preset Width2 = 2;
    preset Width1 = 2;
    preset Color = #000000FF;
    preset Visible = false;
  }

  // The property 'OnChange' can refer to a slot method, which should be invoked \
  // by the text editor when the user modifies the text.
  $rect <590,140,790,180>
  property slot OnChange = null;

  // The property 'WrapText' determines whether long text rows should be wrapped \
  // automatically.
  $rect <390,140,590,180>
  property bool WrapText = true;

  // The property 'Alignment' determines how the editor should display the text rows \
  // if their size differ from the size of the editor. 
  // In this manner the rows can be aligned horizontally. The entire text block can \
  // be aligned vertically.
  $rect <190,140,390,180>
  property Views::TextAlignment Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];

  // The property 'String' stores the text of the editor.
  $rect <590,10,790,50>
  property string String = "Text";

  // The property 'Color' controls the color of the text.
  $rect <390,10,590,50>
  property color Color = #000000FF;

  // The property 'Font' refers to the font object used to display the text. The \
  // text is determined by the property @String.
  $rect <190,10,390,50>
  property Resources::Font Font = Resources::FontMedium;
}

$rect <680,80,830,120>
$output false
class AccesssPopup : Core::Group
{
  $rect <225,480,425,520>
  inherited property Bounds = <0,0,520,190>;

  $rect <0,460,200,500>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <380,290,580,330>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <60,190,210,230>
  inherited method Init()
  {
    // TO DO: Write your code here ... 


  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <490,10,520,160>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight];
    preset Bounds = <490,160,520,190>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, ResizeHorz];
    preset Bounds = <10,160,490,190>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,10,490,160>;
    preset Color = #7F3731FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <490,0,520,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle5
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <0,160,10,190>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle6
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <10,0,490,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle7
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,0,10,10>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle8
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <0,10,10,160>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <5,410,205,450>
  method void Show( arg Core::Root rootObject )
  {
    /* The template just returns the given argument... */

    // Obtain access to the root object.
    //var Core::Root rootObject = GetRoot();

    // Create a new instance of some alert panel component.
    mask = new Views::Rectangle;
    touch = new Core::SimpleTouchHandler;
    root = rootObject;

    touch.Point1 = <0,0>;
    touch.Point2 = <0,480>;
    touch.Point3 = <800,480>;
    touch.Point4 = <800,0>;

    rootObject.Add( touch, 0 );


    mask.Color = #00000020;
    mask.Bounds = <0,0,800,480>;

    rootObject.Add( mask, 0 );

    var point m = point( (800 - this.Bounds.size.x) / 2, (480 - this.Bounds.size.y) / 2);

        
    this.Bounds.point1 = m;
    this.Bounds.point2 = <800,480> - m;


    rootObject.Add( this, 0 );
    Timer.restart( 0, 1000 );
    Timer.Enabled = true;

    return;
  }

  $rect <30,270,230,310>
  var Views::Rectangle mask = null;

  $rect <30,230,230,270>
  var Core::SimpleTouchHandler touch = null;

  $rect <30,310,230,350>
  var Core::Root root = null;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,55,470,100>;
    preset String = "Logon required";
    preset Font = Resources::FontMedium;
  }

  $rect <310,220,510,260>
  object Core::Timer Timer
  {
    preset OnTrigger = Hide;
    preset Period = 2500;
  }

  $rect <340,340,540,380>
  slot Hide
  {
    /* The template just returns the given argument... */

    // Obtain access to the root object.
    //var Core::Root rootObject = GetRoot();

    // Create a new instance of some alert panel component.
    root.Remove( mask );
    root.Remove( touch );
    root.Remove( this );
    Timer.Enabled = false;

    return;

  }
}

$rect <389,289,549,329>
$output false
class TestDeviceItem : App::DeviceItem
{
  $rect <20,20,160,60>
  inherited object FlatCheckBox0
  {
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  inherited object Image
  {
    preset Bounds = <474,5,514,45>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <375,5,465,45>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <375,10,465,40>;
    preset String = "Normal";
    preset Font = OldResources::FontVerdana18;
  }
}

$rect <1220,510,1420,550>
$output false
resource Resources::Bitmap Key2Bitmap
{
  attr bitmapfile FileName = .\Images\logon40d.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <930,480,1080,520>
$output false
class LogPopup : App::Popup
{
  $rect <880,10,1020,50>
  inherited property Bounds = <0,0,800,470>;

  $rect <540,510,680,550>
  inherited method Init()
  {
    signal ChckOnOff;


    if ( ( ListViewer.NoOfItems * ListViewer.ItemHeight ) >  ListViewer.Bounds.h )
    {
      ListViewer.ScrollOffset = ListViewer.NoOfItems * ListViewer.ItemHeight - ListViewer.Bounds.h;
    } 


  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CBCBCBFF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,360,770,440>;
    preset Color = #C6C6C6FF;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <870,200,1070,240>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;
    var App::LogItem i= (App::LogItem)ListViewer.VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( i == null )
      return;

     if ( itemNo <0 || itemNo >= ListViewer.NoOfItems) 
     {
      i.Visible = false;
      return;
     }

     i.Visible = true;

    var int32 t = -1;
    var int32 filter = GetFilter();
    var string msg = "---";


     
      
      native( t, itemNo, filter, msg )
        {
          char buff[ 128 ];
          Command cmd;
      
          cmd.int0 = itemNo;
          cmd.int1 = filter;
          cmd.int2 = (int) buff;
      
          if ( Command0( CMD_GET_LOG_LINE, &cmd ) == CMD_OK )
          {
        
            t = cmd.int3;

            msg = EwNewStringAnsi( buff );
          }
       
        }

      

        switch (t )
        {
           case 4 :   i.Image.Bitmap = App::LogAccess;
           case 1 :   i.Image.Bitmap = App::LogEvents;
           case 5 :   i.Image.Bitmap = App::LogFaults;
           case 6 :   i.Image.Bitmap = App::LogFire;
           case 0 :   i.Image.Bitmap = App::LogMisc;
           case 3 :   i.Image.Bitmap = App::LogSettings;
           case 2 :   i.Image.Bitmap = App::LogSystem;
           case 7 :   i.Image.Bitmap = App::LogTest;
           default :    i.Image.Bitmap = null;
        }

        switch (t )
        {
           case 4 :   i.TypeText.String = "Access";
           case 1 :   i.TypeText.String = "Event";
           case 5 :   i.TypeText.String = "Fault";
           case 6 :   i.TypeText.String = "Fire";
           case 0 :   i.TypeText.String = "Misc";
           case 3 :   i.TypeText.String = "Setting";
           case 2 :   i.TypeText.String = "System";
           case 7 :   i.TypeText.String = "Test";
           default:  i.TypeText.String = ""; 
        }

     

    i.DescripText.String = msg;

                                                                                                              
  }

  $rect <900,270,1100,310>
  slot Close
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <599,376,749,426>;
    preset OnRelease = Close;
    preset Label = "Close";
    preset Appearance = App::NormalPushButton;
  }

  $rect <840,500,960,540>
  method int32 GetFilter()
  {
    /* The template just returns the given argument... */

    var int32 filter = 0;

    if ( Events.Checked )   filter = filter | 2;
    if ( Faults.Checked )   filter = filter | 32;
    if ( System.Checked )   filter = filter | 4;
    if ( Fire.Checked )     filter = filter | 64;
    if ( Misc.Checked )     filter = filter | 1;
    if ( Access.Checked )   filter = filter | 16;
    if ( Settings.Checked ) filter = filter | 8;
    if ( Testing.Checked )  filter = filter | 128;

    return filter;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Events
  {
    preset Bounds = <30,360,138,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Events";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Faults
  {
    preset Bounds = <160,360,268,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Faults";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton System
  {
    preset Bounds = <290,360,398,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "System";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Fire
  {
    preset Bounds = <430,360,538,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Fires";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Settings
  {
    preset Bounds = <30,400,138,440>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Settings";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Access
  {
    preset Bounds = <160,400,268,440>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Access";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Testing
  {
    preset Bounds = <290,400,398,440>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Testing";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Misc
  {
    preset Bounds = <430,400,538,440>;
    preset Enabled = false;
    preset Visible = false;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Misc.";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <880,320,1080,360>
  object Core::SystemEventHandler LogEventHandler
  {
    preset OnEvent = null;
    preset Event = App::Devices.LogListChangeEvent;
  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <20,20,750,345>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::LogItem;
    preset ItemHeight = 25;
    preset NoOfItems = 10;
    preset onRefreshAll = RefreshAll;
    preset onScrollRefresh = ScrollRefresh;
  }

  $rect <860,160,1060,200>
  slot ScrollRefresh
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;


    var int32 filter = GetFilter();

    // if span up / scroll down
    if ( ListViewer.StartRow < itemNo )
    {  
      var App::LogItem i = (App::LogItem)ListViewer.VerticalList.first;
      var App::LogItem j = i;

      var int32 diff = itemNo - ListViewer.StartRow;
      var int32 n = 0;

      while ( j != null && n < diff )
      {
         j = (App::LogItem) j.next;
         n = n + 1;
      }

      while ( i != null && j != null )
      { 
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          i.Image.Bitmap = j.Image.Bitmap;
          i.DescripText.String = j.DescripText.String;
          i.TypeText.String = j.TypeText.String;
          i.Visible = true;
        }
        else
        {
          i.Visible = false;
        }
        i.InvalidateViewState();
        itemNo = itemNo + 1;
        j = (App::LogItem) j.next;
        i = (App::LogItem) i.next; 
      }
      while ( i != null )
      {
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          var int32 t = -1;

          var string msg = "---";

          i.Visible = true;

          native( t, itemNo, filter, msg )
          {
            char buff[ 129 ];
            Command cmd;
      
            cmd.int0 = itemNo;
            cmd.int1 = filter;
            cmd.int2 = (int) buff;
      
            if ( Command0( CMD_GET_LOG_LINE, &cmd ) == CMD_OK )
            {
        
              t = cmd.int3;

              msg = EwNewStringAnsi( buff );
            }
        
          }  

          switch (t )
          {  
             case 4 :   i.Image.Bitmap = App::LogAccess;
             case 1 :   i.Image.Bitmap = App::LogEvents;
             case 5 :   i.Image.Bitmap = App::LogFaults;
             case 6 :   i.Image.Bitmap = App::LogFire;
             case 0 :   i.Image.Bitmap = App::LogMisc;
             case 3 :   i.Image.Bitmap = App::LogSettings;
             case 2 :   i.Image.Bitmap = App::LogSystem;
             case 7 :   i.Image.Bitmap = App::LogTest;
             default :    i.Image.Bitmap = null;
          }

          switch (t )
          {
             case 4 :   i.TypeText.String = "Access";
             case 1 :   i.TypeText.String = "Event";
             case 5 :   i.TypeText.String = "Fault";
             case 6 :   i.TypeText.String = "Fire";
             case 0 :   i.TypeText.String = "Misc";
             case 3 :   i.TypeText.String = "Setting";
             case 2 :   i.TypeText.String = "System";
             case 7 :   i.TypeText.String = "Test";
             default:  i.TypeText.String = ""; 
          }
        
          i.DescripText.String = msg;
        
        }
        else
        {
        
           i.Visible = false;
        }
        itemNo = itemNo + 1;
        i.InvalidateViewState();
        i = (App::LogItem) i.next;
      }
    }
    else  // scroll up / pan down
    {
      var App::LogItem i = (App::LogItem) ListViewer.VerticalList.last;
      var App::LogItem j = i;

      var int32 diff = ListViewer.StartRow - itemNo;
      var int32 n = 0;

      while ( j != null && n < diff )
      {
         j = (App::LogItem) j.prev;
         n = n + 1;
      }

      itemNo = itemNo + 12;

      while ( i != null && j != null )
      { 
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          i.Image.Bitmap = j.Image.Bitmap;
          i.DescripText.String = j.DescripText.String;
          i.TypeText.String = j.TypeText.String;
          i.Visible = true;
        }
        else
        {
          i.Visible = false;
        }
        i.InvalidateViewState();
        itemNo = itemNo - 1;
        j = (App::LogItem) j.prev;
        i = (App::LogItem) i.prev; 
      }
      while ( i != null )
      {
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          var int32 t = -1;

          var string msg = "---";

          i.Visible = true;

          native( t, itemNo, filter, msg )
          {
            char buff[ 129 ];
            Command cmd;
      
            cmd.int0 = itemNo;
            cmd.int1 = filter;
            cmd.int2 = (int) buff;
      
            if ( Command0( CMD_GET_LOG_LINE, &cmd ) == CMD_OK )
            {
        
              t = cmd.int3;

              msg = EwNewStringAnsi( buff );
            }
        
          }  

          switch (t )
          {  
             case 4 :   i.Image.Bitmap = App::LogAccess;
             case 1 :   i.Image.Bitmap = App::LogEvents;
             case 5 :   i.Image.Bitmap = App::LogFaults;
             case 6 :   i.Image.Bitmap = App::LogFire;
             case 0 :   i.Image.Bitmap = App::LogMisc;
             case 3 :   i.Image.Bitmap = App::LogSettings;
             case 2 :   i.Image.Bitmap = App::LogSystem;
             case 7 :   i.Image.Bitmap = App::LogTest;
             default :    i.Image.Bitmap = null;
          }

          switch (t )
          {
             case 4 :   i.TypeText.String = "Access";
             case 1 :   i.TypeText.String = "Event";
             case 5 :   i.TypeText.String = "Fault";
             case 6 :   i.TypeText.String = "Fire";
             case 0 :   i.TypeText.String = "Misc";
             case 3 :   i.TypeText.String = "Setting";
             case 2 :   i.TypeText.String = "System";
             case 7 :   i.TypeText.String = "Test";
             default:  i.TypeText.String = ""; 
          }
        
          i.DescripText.String = msg;
        
        }
        else
        {   
           i.Visible = false;
        }
        itemNo = itemNo - 1;
        i.InvalidateViewState();
        i = (App::LogItem) i.prev;
      }                     
    }

  }

  $rect <0,510,130,550>
  slot ChckOnOff
  {
    sender; /* the method is called from the sender object */

     

    var int32 n = GetFilter( );

    native( n )
    {
        Command cmd;
        cmd.int0 = n;

        Command0( CMD_GET_LOG_LENGTH, &cmd );

        n = cmd.int0;
    }

    ListViewer.NoOfItems = n;


  }

  $rect <870,120,1070,160>
  slot RefreshAll
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;
    var App::LogItem i= (App::LogItem)ListViewer.VerticalList.first;

    var int32 filter = GetFilter();
    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    while ( i != null )
    { 
      if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
      {
        i.Visible = true;
        var int32 t = -1;

        var string msg = "---";


        native( t, itemNo, filter, msg )
        {
          char buff[ 129 ];
          Command cmd;
      
          cmd.int0 = itemNo;
          cmd.int1 = filter;
          cmd.int2 = (int) buff;
      
          if ( Command0( CMD_GET_LOG_LINE, &cmd ) == CMD_OK )
          {
        
            t = cmd.int3;

            msg = EwNewStringAnsi( buff );
          }
        
        }  

        switch (t )
        {  
           case 4 :   i.Image.Bitmap = App::LogAccess;
           case 1 :   i.Image.Bitmap = App::LogEvents;
           case 5 :   i.Image.Bitmap = App::LogFaults;
           case 6 :   i.Image.Bitmap = App::LogFire;
           case 0 :   i.Image.Bitmap = App::LogMisc;
           case 3 :   i.Image.Bitmap = App::LogSettings;
           case 2 :   i.Image.Bitmap = App::LogSystem;
           case 7 :   i.Image.Bitmap = App::LogTest;
           default :    i.Image.Bitmap = null;
        }

        switch (t )
        {
           case 4 :   i.TypeText.String = "Access";
           case 1 :   i.TypeText.String = "Event";
           case 5 :   i.TypeText.String = "Fault";
           case 6 :   i.TypeText.String = "Fire";
           case 0 :   i.TypeText.String = "Misc";
           case 3 :   i.TypeText.String = "Setting";
           case 2 :   i.TypeText.String = "System";
           case 7 :   i.TypeText.String = "Test";
           default:  i.TypeText.String = ""; 
        }
        

        i.DescripText.String = msg;
        
      }
      else
      {
        
         i.Visible = false;
      }
      itemNo = itemNo + 1;
       i.InvalidateViewState();
       i = (App::LogItem) i.next;
    }
                         
  }

  $reorder Rectangle9 3
  $reorder OnLoadItem 3
  $reorder Close 3
  $reorder PushButton 1
  $reorder GetFilter 1
  $reorder Events 1
  $reorder Faults 1
  $reorder System 1
  $reorder Fire 1
  $reorder Settings 1
  $reorder Access 1
  $reorder Testing 1
  $reorder Misc 1
}

$rect <1080,480,1230,520>
$output false
class LogItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,710,25>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop];
    preset Bounds = <0,0,30,25>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text DescripText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <95,0,710,25>;
    preset RowDistance = 15;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = App::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TypeText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <37,0,100,25>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }
}

$rect <860,300,1010,340>
$output false
class LEDPopup : App::Popup
{
  $rect <30,280,170,320>
  inherited property Bounds = <0,0,370,210>;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #B1B1B1FF;
  }

  $rect <20,20,160,60>
  inherited property onHide = Stop;

  $rect <330,320,530,360>
  slot Close
  {
    Hide();



  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <110,110,240,160>;
    preset OnRelease = Close;
    preset Label = "Stop";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <10,35,340,80>;
    preset String = "Running LED lamp test";
    preset Font = Resources::FontMedium;
  }

  $rect <440,230,640,270>
  slot Stop
  {
    sender; /* the method is called from the sender object */

     native
      {
        Command cmd;
        cmd.int0 = 0;
         Command0( CMD_LEDS_TEST, &cmd ); 
       }


  }
}

$rect <710,300,860,340>
$output false
class WeeklyPopup : App::Popup
{
  $rect <30,360,170,400>
  inherited property Bounds = <0,0,400,320>;

  $rect <20,20,160,60>
  object Flat::Gauge Gauge
  {
    preset Bounds = <120,93,270,213>;
    preset CurrentValue = 5;
    preset Caption = "minutes";
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <70,30,290,70>;
    preset String = "Time left in test mode";
    preset Font = OldResources::FontVerdana18;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton
  {
    preset Bounds = <130,250,250,280>;
    preset Caption = "Finish";
  }
}

$rect <0,480,140,520>
$output false
class SystemPage : Core::Group
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,570,250>;
    preset Color = #E5E5E5FF;
  }

  $rect <0,550,200,590>
  inherited property Bounds = <0,0,795,350>;

  $rect <0,415,200,455>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*
    VertScrollbar.ViewArea = 360;

    var int32 size = 0;
    var Core::View   v = (Core::View) first;

    while ( v != null )
    {
        var Core::Group g = (Core::Group) v;
         
        if ( g != null )
        {
            if ( g.Embedded && g.Visible ) 
            {
                size = size + g.Bounds.h;
            }
        }
        v = v.next;
    }

    //Outline.GetViewAtIndex( Outline.CountViews()-1 );

    VertScrollbar.ContentArea = size;
        */

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,460,200,500>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var uint16 temp = 0;
    var int16 on_charge = 0;
    var int16 on_load = 0;
    var int16 off_load = 0;
    var int16 resistance = 0;
    var int8 status = 0;
    var int8 psu_type = 2;
    var int32 gsm_signal = -1;
    var uint32 timestamp = 0;
    var int32 vbacklight = 0;
    var uint32 rightnow = 0;
    var int32 netstate = 0;
    var uint32 ncufw = 0;
    var int32 sysid = 0;
    var int32 index = 0; 

    var int32 numpanels = 0;
    array uint32 rx[ 5];
    array uint32 time[ 5];
    array string name[ 5];
    var int32 sent = 0;
    var string mcu_id = "(Unknown??)";
    var string netname = "<Unknown>";

    var int32 mqtt_connected = 0;
    var int32 mqtt_queue = 0;

    time[0] = 0;
    time[1] = 0;
    time[2] = 0;
    time[3] = 0;
    time[4] = 0;

    rx[ 0] = 0;
    rx[ 1] = 0;
    rx[ 2] = 0;
    rx[ 3] = 0;
    rx[ 4] = 0;

    name[0] = "";
    name[1] = "";
    name[2] = "";
    name[3] = "";
    name[4] = "";

    var string b64_uid = "";
    var string cloud_url = "";
    var int32 gsm_state;

    native( temp, gsm_signal, gsm_state, on_charge, on_load, off_load, resistance, status, psu_type, timestamp, rightnow, netstate, netname, ncufw, mcu_id )
    {
        Command c;

        rightnow = now();

        Command0( CMD_GET_PSU_STATUS, &c );

        timestamp  = c.uint3;

        temp        = c.ushort0;
        on_charge   = c.short1;
        on_load     = c.short2;
        off_load    = c.short3;
        resistance  = c.short4;          
        status      = c.charA;
        psu_type    = c.charB;
      
        Command0( CMD_GSM_SIGNAL_QUALITY, &c );

        gsm_signal = c.int0;
        netstate = c.int1;
        gsm_state = c.int2;
        netname = EwNewStringAnsi( (char*) c.int3 );

     //   Command0( CMD_GET_BACKLIGHT_VOLTAGE, &c );

     //   vbacklight = c.int0;

        Command0( CMD_GET_CLOUD_DETAILS, &c );

        b64_uid = EwNewStringAnsi( (char*) c.int0 );
        cloud_url = EwNewStringAnsi( (char*) c.int1 );
        mqtt_connected = c.int2;
        mqtt_queue = c.int3;
        
        Command0( CMD_GET_NCU_FW_VERSION, &c );

        ncufw = c.int0;

        Command0( CMD_GET_PANEL, &c );

        if ( c.int3 != 0 )
        {
          mcu_id = EwNewStringAnsi( (char*) c.int3 );
        }

        if ( c.int0 != 0 && c.int2 != 0 )
        {
            Panel* p = (Panel*) c.int0;
            Site* s = (Site*) c.int2;
            sysid = p->systemId;
            numpanels = s->numPanels;
            index = c.int1;
        

            for( int p = 0; p < numpanels && p < 5; p++ )
            {         
               c.int0 = p;
               Command0( CMD_GET_NET_STATS, &c );

               rx[ p] = c.int1;
               time[ p] = c.int2;
               name[ p] = EwNewStringAnsi( s->panels[ p ].name );                  
           } 
        }   
    }






    var string fw  = string( (float)fwversion / 100.0, 0, 2 );
    //var string os  = string( (float)osversion/100.0, 0, 2 );
    var string ncu = string( (ncufw >> 16) & 255 ) + "." + string( (ncufw >> 8) & 255 ) + "." + string( (ncufw) & 255 );

    var string muid = string( sysid );


    if ( sysid == 0) muid = "(No site)";

    var string v = "{lay210,*}{col}{fnt2}{clr1}Panel UID{col}{fnt3}{clr1}"+mcu_id+
              "{end}{lay210,*}{col}{fnt2}{clr1}Mesh UID{col}{fnt3}{clr1}"+muid+
              "{end}{lay210,*}{col}{fnt2}{clr1}MQTT UID{col}{fnt3}{clr1}"+b64_uid+
              "{end}{lay210,*}{col}{fnt2}{clr1}CIE Firmware{col}{fnt3}{clr1}"+fw+
              "{end}{lay210,*}{col}{fnt2}{clr1}NCU Firmware{col}{fnt3}{clr1}"+ncu+
               "{end}{lay210,*}{col}{fnt2}{clr1}Panel Spec{col}{fnt3}{clr1}"+string(zones)+
               " Zones / "+string(leds)+" LEDs / "+string(devs)+ " Devs"+
              "{end}\n";

    AttrText.String = v;

    var string s = ""; 

    if ( rightnow - timestamp > 10 )
    {
        s = "{lay210,*}{col}{fnt2}{clr1}PSU Temperature{col}{fnt3}{clr1}(unknown){end}" +  
              "{lay210,*}{col}{fnt2}{clr1}Output Voltage{col}{fnt3}{clr1}(unknown){end}" + 
              "{lay210,*}{col}{fnt2}{clr1}Loaded Voltage{col}{fnt3}{clr1}(unknown){end}" + 
              "{lay210,*}{col}{fnt2}{clr1}Unloaded Voltage{col}{fnt3}{clr1}(unknown){end}" + 
              "{lay210,*}{col}{fnt2}{clr1}Battery resistance{col}{fnt3}{clr1}(unknown){end}" +
              "{lay210,*}{col}{fnt2}{clr1}Battery status{col}{fnt3}{clr1}Comms lost{end}";
       
    }
    else 
    {
      var string st = "";
      switch ( status )
      {
          case 0 : st = "Good";
          case 1 : st = "Low";
          case 2 : st = "Critical";
          case 3 : st = "High resistance";
          case 4 : st = "Charge fail";
      } 
        
    var string off_load_str;
    var string resistance_str;

    if(psu_type == 0)
    {
    if ( resistance == 0 )
    {
     off_load_str = "(undetermined)";
     resistance_str = "(undetermined)";
     }
     else
     {
       off_load_str = string( (float)off_load/1000.0, 0, 2 ) + "V";
       resistance_str =  string( resistance ) + "m\U03a9";
     }

      s = "{lay210,*}{col}{fnt2}{clr1}PSU Temperature{col}{fnt3}{clr1}" +   string( (float)temp / 1000.0, 0, 2 ) + "C{end}" +  
              "{lay210,*}{col}{fnt2}{clr1}Output Voltage{col}{fnt3}{clr1}" + string( (float)on_charge/1000.0, 0, 2 ) + "V{end}" + 
              "{lay210,*}{col}{fnt2}{clr1}Loaded Voltage{col}{fnt3}{clr1}" + string( (float)on_load/1000.0, 0, 2 ) + "V{end}" + 
              "{lay210,*}{col}{fnt2}{clr1}Unloaded Voltage{col}{fnt3}{clr1}" + off_load_str + "{end}" +
              "{lay210,*}{col}{fnt2}{clr1}Battery resistance{col}{fnt3}{clr1}" + resistance_str + "{end}" +
              "{lay210,*}{col}{fnt2}{clr1}Battery status{col}{fnt3}{clr1}" + st + "{end}";
    }

    if(psu_type == 1)
    {
    var string temperature_str;
    if ( status == 0 )
    {
     off_load_str   = "Good";
     resistance_str = "Good";
     temperature_str = "Good";
     st = "Good";
    }
    else
    {
      off_load_str   = " - ";
      resistance_str = " - ";
      temperature_str = " - ";
      st = " Critical ";
    }

      s = "{lay210,*}{col}{fnt2}{clr1}PSU Temperature{col}{fnt3}{clr1}" +  temperature_str + "{end}" +  
              "{lay210,*}{col}{fnt2}{clr1}Output Voltage{col}{fnt3}{clr1}" + string( (float)on_charge/1000.0, 0, 2 ) + "V{end}" + 
              "{lay210,*}{col}{fnt2}{clr1}Loaded Voltage{col}{fnt3}{clr1}" + string( (float)on_load/1000.0, 0, 2 ) + "V{end}" + 
              "{lay210,*}{col}{fnt2}{clr1}Unloaded Voltage{col}{fnt3}{clr1}" + off_load_str + "{end}" +
              "{lay210,*}{col}{fnt2}{clr1}Battery resistance{col}{fnt3}{clr1}" + resistance_str + "{end}" +
              "{lay210,*}{col}{fnt2}{clr1}Battery status{col}{fnt3}{clr1}" + st + "{end}";
    }
     
    }

    if ( sysid != 0 && numpanels > 1 )
    {

      var string netstats = "{par}\n{lay210,*}{col}{fnt2}{clr1}Packets sent{col}{fnt3}{clr1}" + string( rx[ index] ) + "{end}";

      var int32 pan = 0;

      for( pan = 0; pan < 5; pan = pan + 1 )
      {
          if ( pan != index && pan < numpanels )
          {
            var string t = "";

            if ( rx[ pan] == 0 )
            {
               t = "?)";
            }
            else if ( time[ pan] < 60 ) 
            {
               t = string( time[ pan] ) + " seconds ago)";
            }
            else if ( time[ pan] < 60*60 ) 
            {
              t = string( time[ pan]/60 ) + " minutes ago)";
            }
            else if ( time[ pan] < (60*60*24 ) ) 
            {
              t = string( time[ pan]/(60*60) ) + " hours ago)";
            }
            else  if ( time[ pan] < (60*60*24*7 ) ) 
            {
              t = string( time[ pan]/(60*60*24 ) ) + " days ago)";
            }
            else  if ( time[ pan] < 60*60*24*7*9 )
            {
              t = string( time[ pan]/(60*60*24*7) ) + " weeks ago)";
            }
            else
            {
              t = "months ago)";
            }

            netstats = netstats + "{lay210,*}{col}{fnt2}{clr1}" + name[ pan ] + "{col}{fnt3}{clr1}" + string( rx[ pan] ) + " packets   (" + t + "{end}";
         }
      }
      s = s + netstats;
    }

    if ( ( netstate > 1 && netstate < 5 ) || netstate == 11 ) gsm_signal = 99;

    var int32 gsmval =  -113+gsm_signal*2;

    var string gsm = string(gsmval) + "dBm"; 

    var string bar = "4";

    if ( gsm_signal == 0 )
    {  
        gsm = "\U2264" + gsm;
    }
    else if ( gsm_signal == 31 ) 
    {
        gsm = "\U2265" + gsm;
    }
    else if ( gsm_signal == 99 )
    {
        gsm = "(unknown)";
    }
    else if ( gsm_signal == -1 )
    {
        gsm = "waiting...";
    }
    else
    {
      if (  gsmval < -110 ) bar = "0";
      else if (  gsmval < -100 ) bar = "1";
      else if (  gsmval < -90 ) bar = "2";
      else if (  gsmval < -80 ) bar = "3";

      gsm = string(gsmval) + "dBm            {imgm" + bar + "}"; 
    }

    var string gsm_state_name = "";

    native ( gsm_state, gsm_state_name )      
    {
    // extract from MM_GSM.h
      typedef enum
      {
        GSM_RESET_COMS,
      	GSM_ECHO_OFF,				  // ATE0
      	GSM_SET_MNO_PROFILE,      // AT+UMNOPROF=100
      	GSM_GET_MNO_PROFILE,	     // AT+UMNOPROF?
      	GSM_SELECT_2G_4G,		      // AT+URAT=8/9\r\n
      	GSM_CHECK_REGISTRATION,	  // AT+CGREG
      	GSM_SET_DOMAIN,           // AT+USVCDOMAIN=2
      	GSM_CHECK_DOMAIN,         // AT+USVCDOMAIN?
      	GSM_CHECK_NETWORK,        // AT+COPS?	
      	GSM_SEARCH_NETWORK,	     // AT+COPS=0
      	GSM_CHECK_NETWORKS,		
      	GSM_ADD_ACCESS_POINT,     // AT+CGDCONT=1,"IP","x.com"
      	GSM_SET_ACCESS_POINT,     // AT+CGACT=1,1
      	GSM_CHECK_ATTATCHMENT,    // AT+CGATT?
      	GSM_ATTACH_GPRS,          // AT+CGATT=1
      	GSM_GET_IP,               // AT+CGPADDR=2
      	GSM_LOOKUP_IP,            // AT+UDNSRN=0,"x.com"
      } State;

      char * p = NULL;



      switch ( gsm_state )
      {
        case GSM_RESET_COMS                 : p = "Resetting COMs";             break;
        case GSM_ECHO_OFF					          : p = "Removing echo";				      break;;
        case GSM_SET_MNO_PROFILE            : p = "Setting MNO profile";        break;
        case GSM_GET_MNO_PROFILE	          : p = "Getting MNO profile";        break;
        case GSM_SELECT_2G_4G		            : p = "Selecting 2G/4G";            break;
        case GSM_CHECK_REGISTRATION	        : p = "Checking registration..";    break;
        case GSM_SET_DOMAIN                 : p = "Setting domaim";             break;
        case GSM_CHECK_DOMAIN               : p = "Checking domaim";            break;
        case GSM_CHECK_NETWORK              : p = "Getting network";            break;
        case GSM_SEARCH_NETWORK	            : p = "Searching network";          break;
        case GSM_ADD_ACCESS_POINT           : p = "Adding access point";        break;
        case GSM_SET_ACCESS_POINT           : p = "Setting access point";       break;
        case GSM_CHECK_ATTATCHMENT          : p = "Checking attachment..";      break;
        case GSM_GET_IP                     : p = "Getting IP";                 break;
        case GSM_LOOKUP_IP                  : p = "Resolving address";          break;
        default: p = "...";
      }

      gsm_state_name = EwNewStringAnsi( p );
    }


    var string network = "Unknown";
    switch ( netstate )
    {
      case 0: network = "Not searching";
      case 1 : network = "Registered (home network)";
      case 2 : network = "Searching..";
      case 3 : network = "Registration denied";
      case 5 : network = "Registered (Roaming)";
      case 6 : network = "Registered (SMS only)";
      case 7 : network = "Registered (Roaming/SMS only)";
      case 9 : network = "CSFB not preferred";
      case 10 : network = "CSFB not preferred (Roaming)";
      case 11 : network = "SIM error";
      case 20 : network = "WiFi";
    } 

    var string mqtt_status = "Disconnected";

    if ( mqtt_connected != 0 )
    {
       mqtt_status = "Connected";
    }

    s = s + "{par}\n{lay210,*}{col}{fnt2}{clr1}GSM Setup{col}{fnt3}{clr1}" + gsm_state_name + "{end}";  
    s = s + "{lay210,*}{col}{fnt2}{clr1}GSM Signal{col}{fnt3}{clr1}" + gsm + "{end}";        
    s = s + "{lay210,*}{col}{fnt2}{clr1}GSM Network{col}{fnt3}{clr1}" + network + "{end}";
    s = s + "{lay210,*}{col}{fnt2}{clr1}Network Name{col}{fnt3}{clr1}" + netname + "{end}";
    s = s + "{lay210,*}{col}{fnt2}{clr1}IOT Cloud Hub{col}{fnt3}{clr1}" + cloud_url + "{end}";
    s = s + "{lay210,*}{col}{fnt2}{clr1}IOT Status{col}{fnt3}{clr1}" + mqtt_status + "{end}";
    s = s + "{lay210,*}{col}{fnt2}{clr1}IOT Queue size{col}{fnt3}{clr1}" + string(mqtt_queue) + "{end}";

    //var string voltage = string( (float)vbacklight/100.0, 0, 2 );

    //s = s + "{par}\n{lay210,*}{col}{fnt2}{clr1}Backlight voltage{col}{fnt3}{clr1}" + voltage + "V{end}";      
                                  
    AttrText1.String = s;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <10,370,150,410>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    var int32 fw_version = 100;
    var int32 os_version = 100;
    var int32 level = 0;
    var bool sms = false;
    var bool app = false;
    var uint8 p_zones = 0;
    var uint8 p_leds = 0;
    var uint16 p_devs = 0;

    native( fw_version, os_version, level, sms, app, p_zones, p_leds, p_devs )
    {
        Command c;

        Command0( CMD_GET_VERSION_NUMBERS, &c );

        fw_version = c.int0;
        os_version = c.int1;

        Command0( CMD_GET_BACKLIGHT_LEVEL, &c );
                                  
        level = c.int0;

        Command0( CMD_GET_APP_SUPP, &c );

        app = c.int0;

         Command0( CMD_GET_SMS, &c );

        sms = c.int0;

        p_zones = *(char*)  0x90C00000;
        p_leds  = *(char*)  0x90C00001;
        p_devs  = *(short*)  0x90C00002;
    }

    HorzSlider.CurrentValue = level;

    SMSEnable.Checked = sms;
    AppSuppEnable.Checked = app;

    osversion = os_version;
    fwversion = fw_version;

    zones = p_zones;
    leds = p_leds;
    devs = p_devs;



  }

  $rect <390,370,590,410>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -Outline.ScrollOffset.y;
  }

  $rect <390,410,590,450>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    Outline.ScrollOffset.y = -VertScrollbar.Position;


  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <2,2,570,250>;
    preset SlideHandler = SlideTouchHandler;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,570,250>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2C2C2CFF;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <790,0,990,40>
  slot ViewLog
  {
    var App::Popup pop = new App::LogChoice;

    pop.Show( GetRoot() );

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <810,35,1010,75>
  slot Calibrate
  {
    var App::Popup pop = new App::CalibratePopup;

    pop.Show( GetRoot() );



  }

  $rect <20,20,160,60>
  object Views::AttrText AttrText
  {
    preset Bounds = <8,5,550,130>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertTop];
    preset String = "{lay200,*}{col}{fnt2}{clr1}Firmware version{col}{fnt3}{clr1}1.00{end}{lay200,*}{col}{fnt2}{clr1}Cygnus OS version{col}{fnt3}{clr1}1.00{end}\n";
    preset AttrSet = AttrSet;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Views::AttrText AttrText1
  {
    preset Bounds = <8,140,560,674>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertTop];
    preset String = "";
    preset AttrSet = AttrSet1;
    preset Embedded = true;
  }

  $rect <924,335,1124,375>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font3 = App::FontVerdanaProSemiBold20;
    preset Font2 = OldResources::FontVerdana20;
    preset Font1 = App::FontVerdana16;
    preset Font0 = App::FontVerdana14;
    preset Bitmap3 = null;
    preset Bitmap2 = null;
    preset Bitmap1 = null;
    preset Bitmap0 = null;
    preset Color1 = #000000FF;
  }

  $rect <920,371,1120,411>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateSlot;
    preset Enabled = false;
  }

  $rect <930,411,1130,451>
  slot UpdateSlot
  {
    sender; /* the method is called from the sender object */

    InvalidateViewState();

  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <565,0,615,255>;
    preset OnScroll = ScrollPressSlot;
    preset ViewArea = 290;
    preset ContentArea = 650;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,570,250>;
    preset OnSlide = ScrollDragSlot;
    preset SlideHorz = false;
  }

  $rect <1040,10,1240,50>
  property int16 osversion = 0;

  $rect <1050,50,1250,90>
  property int16 fwversion = 0;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <615,0,795,50>;
    preset OnRelease = ViewLog;
    preset Label = "View Logs";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <615,167,795,217>;
    preset OnRelease = Restore;
    preset Label = "System Restore";
    preset Appearance = App::NormalPushButton;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <800,165,1000,205>
  slot Restore
  {
     var App::ConfirmPopup popup = new App::ConfirmPopup;

      popup.Text1.String = "Restore all system settings to defaults?";

      popup.ShowThen( GetRoot(), DoRestore );



  }

  $rect <985,160,1185,200>
  slot DoRestore
  {
    sender; /* the method is called from the sender object */


    native
    {
       Command c;
       Command0( CMD_RESET_EEPROM, &c );
    }

  }

  $rect <800,75,1000,115>
  slot SetTime
  {
    sender; /* the method is called from the sender object */

    var App::Popup bl = new App::SetTimePopup;

    bl.Show( GetRoot() );



  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <615,56,795,106>;
    preset OnRelease = null;
    preset OnActivate = SetTime;
    preset Label = "Set Time";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <7,315,107,345>;
    preset String = "Brightness";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <265,410,375,450>
  slot Change
  {
    sender; /* the method is called from the sender object */

    var int32 val = HorzSlider.CurrentValue;

    native ( val )
    {
        val = val*10 + 2;
    		app.backlight_timer->Instance->CMP = 0x1A00 - val;
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzSlider
  {
    preset Bounds = <167,305,545,349>;
    preset OnChange = Change;
    preset OnEnd = ChangeEnd;
    preset MinValue = 10;
    preset Appearance = WidgetSet::HorizontalSlider_Medium;
  }

  $rect <265,365,395,405>
  slot ChangeEnd
  {
    sender; /* the method is called from the sender object */
    sender; /* the method is called from the sender object */

    var int32 val = HorzSlider.CurrentValue;

    native ( val )
    {
        Command1( CMD_SET_BACKLIGHT_LEVEL, val );
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton5
  {
    preset Bounds = <615,223,795,273>;
    preset OnRelease = FactoryReset;
    preset Label = "Factory Reset";
    preset Appearance = App::NormalPushButton;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <795,225,995,265>
  slot FactoryReset
  {
     var App::ConfirmTimerPopup popup = new App::ConfirmTimerPopup;

      popup.Text1.String = "WARNING. This will clear ALL system and site data";

      popup.ShowThen( GetRoot(), DoFactoryReset );



  }

  $rect <980,220,1180,260>
  slot DoFactoryReset
  {
    sender; /* the method is called from the sender object */


    native
    {
       Command c;
       Command0( CMD_FACTORY_RESET, &c );
    }

  }

  $rect <410,450,650,490>
  object WidgetSet::HorizontalValueBarConfig HorizontalValueBarConfig;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton AppSuppEnable
  {
    preset Bounds = <290,255,545,301>;
    preset Checked = true;
    preset OnSwitchOn = AppSupp;
    preset OnSwitchOff = AppSupp;
    preset Label = "Phone App Enabled";
    preset Appearance = App::NotmalToggleButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton SMSEnable
  {
    preset Bounds = <8,255,235,299>;
    preset Checked = true;
    preset OnSwitchOn = SMS;
    preset OnSwitchOff = SMS;
    preset Label = "SMS Enabled";
    preset Appearance = App::NotmalToggleButton;
  }

  $rect <660,475,765,520>
  slot SMS
  {
    var bool on = SMSEnable.Checked;

    // if ( on )  AppSuppEnable.Checked = false;

    native( on )
    {  
      Command1( CMD_SET_SMS, (int) on );
    }

  }

  $rect <785,485,970,525>
  slot AppSupp
  {
    sender; /* the method is called from the sender object */

    var bool on = AppSuppEnable.Checked;

    // if ( on )  SMSEnable.Checked = false;

    native( on )
    {
      Command1( CMD_SET_APP_SUPP, (int)on );
    }

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton6
  {
    preset Bounds = <615,111,795,161>;
    preset OnRelease = null;
    preset OnActivate = AppSupport;
    preset Label = "GSM App Support";
    preset Appearance = App::NormalPushButton;
  }

  $rect <815,120,965,160>
  slot AppSupport
  {
    sender; /* the method is called from the sender object */

    var App::AppSupportPopup ap = new App::AppSupportPopup;

    ap.Show( GetRoot() );


  }

  $rect <924,335,1124,375>
  $output true
  object Graphics::AttrSet AttrSet1
  {
    preset Font3 = App::FontVerdanaProSemiBold20;
    preset Font2 = OldResources::FontVerdana20;
    preset Font1 = App::FontVerdana16;
    preset Font0 = App::FontVerdana14;
    preset Bitmap4 = App::Bmp_4bar;
    preset Bitmap3 = App::Bmp_3bar;
    preset Bitmap2 = App::Bmp_2bar;
    preset Bitmap1 = App::Bmp_1bar;
    preset Bitmap0 = App::Bmp_0bar;
    preset Color1 = #000000FF;
  }

  $rect <670,340,870,380>
  property uint8 zones = 0;

  $rect <670,390,870,430>
  property uint16 devs = 0;

  $rect <680,430,880,470>
  property uint8 leds = 0;

  $reorder Rectangle 76
}

$rect <140,480,290,520>
$output false
class MemTestPopup : App::Popup
{
  $rect <10,260,150,300>
  inherited property Bounds = <0,0,540,240>;

  $rect <20,20,160,60>
  object Steel::HorzBar HorzBar0
  {
    preset Bounds = <30,85,480,125>;
    preset Type = Steel::LedType.Blue;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton
  {
    preset Bounds = <200,154,320,184>;
    preset OnAction = CloseSlot;
    preset Caption = "Close";
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <38,43,138,73>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Checking...";
    preset Font = OldResources::FontVerdana18;
  }

  $rect <180,280,380,320>
  slot CloseSlot
  {
    sender; /* the method is called from the sender object */

    Hide();

  }
}

$rect <430,480,560,520>
$output false
class CalibratePopup : App::Popup
{
  $rect <710,460,850,500>
  inherited property Bounds = <0,0,800,480>;

  $rect <840,10,980,50>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    signal Setup;


     



  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <10,10,650,430>;
  }

  $rect <20,20,160,60>
  object Views::Image Image0
  {
    preset Bounds = <10,10,60,60>;
    preset Bitmap = App::XBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <720,10,770,60>;
    preset Bitmap = App::XBitmap;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <10,400,60,450>;
    preset Bitmap = App::XBitmap;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image Image3
  {
    preset Bounds = <720,400,770,450>;
    preset Bitmap = App::XBitmap;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <800,0>;
    preset Point2 = <800,480>;
    preset Point1 = <0,480>;
    preset OnPress = TouchSlot;
  }

  $rect <870,100,1070,140>
  slot TouchSlot
  {
    sender; /* the method is called from the sender object */

    var uint16 x = 0;
    var uint16 y = 0;

    native ( x, y )
    {
        Command cmd;

        Command0( CMD_GET_LAST_RAW_TOUCH, &cmd );

        x = cmd.ushort0;
        y = cmd.ushort1; 
    }

    if ( order < 4 )
    {
      coord[ order ].x = x;
      coord[ order ].y = y;
    }

    switch( order )
    {
        case 0 :
        {
            Image0.Visible = false;
            Image1.Visible = true;
        }
        case 1:
        {
            Image1.Visible = false;
            Image2.Visible = true;
        }
        case 2 :
        {
            Image2.Visible = false;
            Image3.Visible = true;
        }
        case 3:
        {
           Image3.Visible = false;
     
            var uint16 xmin = (uint16) ( coord[0].x + coord[2].x ) / 2;
            var uint16 ymin = (uint16) ( coord[0].y + coord[1].y ) / 2; 
            var uint16 xmax = (uint16) ( coord[1].x + coord[3].x ) / 2;  
            var uint16 ymax = (uint16) ( coord[2].y + coord[3].y ) / 2;  

            var uint16 x_xmin = (uint16) X[0].x; 
            var uint16 x_ymin = (uint16) X[0].y; 
            var uint16 x_xmax = (uint16) X[3].x; 
            var uint16 x_ymax = (uint16) X[3].y; 

            native ( xmin, ymin, xmax, ymax, x_xmin, x_ymin, x_xmax, x_ymax )
            {
                 Command8U( CMD_SET_CALIB_VALUES, xmin, ymin, xmax, ymax, x_xmin, x_ymin, x_xmax, x_ymax );
            }
            Text.String = "Now tap on targets.";
            TargetImage1.Visible = true;
         }
         
          case 4, 5, 6:
          {
             if (order == 4 )
             {            
                 TargetImage2.Visible = true;
              }
              if ( order == 5 )
              {
                  TargetImage3.Visible = true;
               }
               if ( order == 6 )
               {   
                  Text.Visible = false;
                  FinishButton.Visible = true;
                  FinishButton.Enabled = true;

                  RetryButton.Visible = true;
                  RetryButton.Enabled = true;
              }

                                     
              h[ order-4].Point1 = point( 0, InsideTouchHandler.CurrentPos.y );
              h[ order-4].Point2 = point( 800, InsideTouchHandler.CurrentPos.y );
              v[ order-4].Point1 = point( InsideTouchHandler.CurrentPos.x, 0 );
              v[ order-4].Point2 = point( InsideTouchHandler.CurrentPos.x, 480 );

              v[ order-4].Visible = true;
              h[ order-4].Visible = true;

          }
          default: signal ProceedSlot;
         
        
    }

    order=order + 1;
  }

  $rect <820,220,1020,260>
  var int32 order = 0;

  $rect <850,320,1050,360>
  array point coord[ 4 ];

  $rect <850,365,975,435>
  array point X[ 4 ];

  $rect <845,150,930,195>
  array Views::Line h[ 3 ] =
  (
    Default[0] = Line;
    Default[1] = Line1;
    Default[2] = Line2;
  );

  $rect <920,150,1015,190>
  array Views::Line v[ 3 ] =
  (
    Default[0] = Line3;
    Default[1] = Line4;
    Default[2] = Line5;
  );

  $rect <20,20,160,60>
  object Views::Image TargetImage1
  {
    preset Bounds = <130,30,258,158>;
    preset Bitmap = App::TargetBitmap;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image TargetImage2
  {
    preset Bounds = <230,300,358,428>;
    preset Bitmap = App::TargetBitmap;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image TargetImage3
  {
    preset Bounds = <610,170,738,298>;
    preset Bitmap = App::TargetBitmap;
    preset Visible = false;
  }

  $rect <815,50,1015,90>
  slot ProceedSlot
  {
    sender; /* the method is called from the sender object */

      

     Hide();

  }

  $rect <840,420,1040,460>
  slot Setup
  {
    sender; /* the method is called from the sender object */


    Image0.Visible = true;
    Image1.Visible = false;
    Image2.Visible = false;
    Image3.Visible = false;

      RetryButton.Visible = false;
       FinishButton.Visible = false;
      RetryButton.Enabled = false;
       FinishButton.Enabled = false;      

               TargetImage1.Visible = false;
               TargetImage2.Visible = false;
               TargetImage3.Visible = false;

    order = 0;
    var int32 n;

    for( n = 0; n < 3; n = n + 1 )
    {
      h[n].Visible = false;
      v[n].Visible = false;
    }

    X[0] = Image0.Bounds.center;
    X[1] = Image1.Bounds.center;
    X[2] = Image2.Bounds.center;
    X[3] = Image3.Bounds.center;

  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <200,450>;
    preset Point1 = <200,10>;
    preset Color = #FF0086FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <300,460>;
    preset Point1 = <300,20>;
    preset Color = #FF0086FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <670,490>;
    preset Point1 = <670,50>;
    preset Color = #FF0086FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <200,450>;
    preset Point1 = <200,10>;
    preset Color = #FF0086FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <200,450>;
    preset Point1 = <200,10>;
    preset Color = #FF0086FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line5
  {
    preset Point2 = <200,450>;
    preset Point1 = <200,10>;
    preset Color = #FF0086FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <250,170,540,210>;
    preset String = "Tap on each X";
    preset Font = Templates::DefaultFontPicker;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FinishButton
  {
    preset Bounds = <130,200,320,257>;
    preset Visible = false;
    preset OnActivate = ProceedSlot;
    preset Label = "Finish";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton RetryButton
  {
    preset Bounds = <410,200,595,257>;
    preset Visible = false;
    preset OnActivate = Setup;
    preset Label = "Retry";
    preset Appearance = App::NormalPushButton;
  }
}

$rect <10,580,110,620>
$output false
class Modify : Core::Group
{
  $rect <0,550,200,590>
  inherited property Bounds = <0,0,795,365>;

  $rect <250,480,390,520>
  inherited onset Visible
  {
    // TO DO: Write your code here ... 

    super( value );

    if ( Visible )
        ListViewer.NoOfItems = ListViewer.NoOfItems;

  }

  $rect <0,410,200,450>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );


  }

  $rect <0,480,200,520>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*
      var int32 numZones = 32;

       native( numZones )
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }
       VerticalList.NoOfItems = numZones;
       VerticalList.InvalidateItems( 0, numZones );

      VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;
      VertScrollbar.ViewArea = VerticalList.Bounds.h;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <790,380,930,420>
  inherited method Init()
  {
    InitSite();

  }

  $rect <250,380,390,420>
  inherited property AlphaBlended = true;

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <490,360,630,400>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    var Core::VerticalList vlist = ListViewer.VerticalList;

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;

     
    var App::ZoneToggle item = (App::ZoneToggle) vlist.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    if ( itemNo < 0 )
    {
       item.Visible = false;
       item.InvalidateViewState();
       return;
    }

    item.Visible = true;

    //var Application::ModifyZoneItem currentZone = null;

    var uint8 curZone = 1;


       var int32 i = 0;
       var int32 numZones = 2;

       native( numZones ) 
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }
       
       
       while ( numZones > 0 )
       {
          var int32 numdevs = 4;
           
          native( numdevs, curZone )
          {  
             numdevs = get_num_devs_in_zone( curZone );
          }

          if ( numdevs > 0 )
          {
            
            numZones = numZones - 1;

            if ( itemNo == i )
            {
              item.ZoneNum = curZone;
              item.isDevice = false;
              item.isZone = true;
               
              item.InvalidateViewState();
              return;
            }
            else
            {
               i = i + 1;
            }

            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );

            if ( zf.contains( App::ZoneFlags[ ModifyExpanded ] ) )
            {                    
              if ( itemNo < numdevs + i )
              {
                var int32 dev = itemNo - i;
                var string location = "????";
                var uint16 unitno = dev + 1;
                var uint8 zoneno = curZone;

                var App::DeviceConfig dc = App::Lib.GetConfigNumInZone( curZone, dev );

                 
                
                item.isDevice = true;
                item.isZone = false;
                item.UnitNum = dc.unitnum;
                item.ZoneNum = dc.zonenum;
                item.DescriptionText.String = dc.location;       

                item.InvalidateViewState(); 
                 

                return;
              }
              else
              {
                 i = i + numdevs;
              }
           }
         }
         curZone = curZone + 1;
       }

     
        item.Visible = false;
        item.InvalidateViewState(); 

  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <0,0,615,365>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::ZoneToggle;
    preset ItemHeight = 50;
    preset onRefreshAll = RefreshAll;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <480,420,620,460>
  slot RefreshAll
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */
                                                                 

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;

     
    var App::ZoneToggle item = (App::ZoneToggle) ListViewer.VerticalList.first;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    while ( itemNo < 0 )
    {
       item.Visible = false;
       item.InvalidateViewState();

       item = (App::ZoneToggle) item.next; 
       if ( item == null ) return;

       itemNo = itemNo + 1;
    }


    //var Application::ModifyZoneItem currentZone = null;

    var uint8 curZone = 1;


    var int32 i = 0;
    var int32 numZones = 2;

    native( numZones ) 
    {
      Command cmd;
      Command0( CMD_GET_NUM_ZONES, &cmd );
      numZones = cmd.int0;
    }


    while ( numZones > 0 )
    {
        var int32 numdevs = 4;
     
        native( numdevs, curZone )
        {  
           numdevs = get_num_devs_in_zone( curZone );
        }

        if ( numdevs > 0 )
        {
            numZones = numZones - 1;

            if ( itemNo == i )
            {
                item.Visible = true;

                item.ZoneNum = curZone;
                item.isDevice = false;
                item.isZone = true;

                item.InvalidateViewState();
                item = (App::ZoneToggle) item.next; 
                if ( item == null ) return;

            }
            else
            {
                i = i + 1;
            }

            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );

            if ( zf.contains( App::ZoneFlags[ ModifyExpanded ] ) )
            {                    
                if ( itemNo < numdevs + i )
                {
                    var int32 dev = 0;

                    while ( dev < numdevs )
                    {
                        if ( i == itemNo )
                        {
                            var string location = "????";
                            var uint16 unitno = dev + 1;
                            var uint8 zoneno = curZone;

                            var App::DeviceConfig dc = App::Lib.GetConfigNumInZone( curZone, dev );
                            
                            
              
                            item.Visible = true;
                            item.isDevice = true;
                            item.isZone = false;
                            item.UnitNum = dc.unitnum;
                            item.ZoneNum = dc.zonenum;
                            item.DescriptionText.String = dc.location;
                            
                            item.InvalidateViewState(); 
                            
                            item = (App::ZoneToggle) item.next; 
                            if ( item == null ) return;
                        }
                        else
                        {
                            i = i + 1;
                        }
                        dev = dev + 1;
                    }
                }
                else
                {
                    i = i + numdevs;
                }
            }     
        }
        curZone = curZone + 1;
    }

    while ( item != null )
    { 
        item.Visible = false;
        item.InvalidateViewState();
        item = (App::ZoneToggle) item.next; 
    }
         

  }

  $rect <840,100,1040,140>
  object Core::SystemEventHandler SiteChangedEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = App::Devices.SiteChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <830,140,1030,180>
  slot onEvent
  {
     

    InitSite();

  }

  $rect <840,240,970,280>
  method void InitSite()
  {
    // TO DO: Write your code here ...
     var int32 num = 2;

       native( num )
       {
          Command cmd;
          Command0( CMD_GET_NUM_MODIFY, &cmd );
          num = cmd.int0;
        }

     ListViewer.NoOfItems = num ;
      

  }

  $rect <810,10,1070,50>
  object Core::SystemEventHandler MeshListChangeEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = App::Devices.MeshListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <810,50,1010,90>
  slot onEvent1
  {
    if ( Visible )
        ListViewer.NoOfItems = ListViewer.NoOfItems;

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <615,0,795,55>;
    preset Enabled = true;
    preset Visible = true;
    preset OnRelease = AddDevices;
    preset Label = "Add Device";
    preset Appearance = App::NormalPushButton;
  }

  $rect <620,60,770,100>
  slot AddDevices
  {
    sender; /* the method is called from the sender object */


    var App::AddDevicePopup add = new App::AddDevicePopup;

    add.Show( GetRoot() );

    native
    {
      Command1( CMD_DETECT_RBU, 0 );
    }
       









     
  }
}

$rect <90,580,260,620>
$output false
class ModifyDeviceItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

     

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <70,80,270,120>
  property int32 UnitNum = 0;

  $rect <20,20,160,60>
  object Views::Text UnitNumberText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <6,2,146,19>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = App::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <5,16,420,41>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Hallway, Front building 2";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <505,1,545,41>;
    preset Bitmap = App::FireAlarmBitmap;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <430,5,500,35>;
    preset OnAction = EditSlot;
    preset Caption = "Edit";
  }

  $rect <570,0,770,40>
  slot EditSlot
  {
    sender; /* the method is called from the sender object */

    var App::ModifyPopup p = new App::ModifyPopup;

    var Core::Root r = GetRoot();

    p.zone = ZoneNum;
    p.unitnum = UnitNum;
    p.ZoneText.String = string( ZoneNum );


    p.Show( GetRoot() );

  }

  $rect <70,130,270,170>
  property int32 ZoneNum = 0;
}

$rect <250,580,420,620>
$output false
class ModifyZoneItem : Core::Group
{
  $rect <20,460,220,500>
  inherited property Bounds = <0,0,550,40>;

  $rect <0,350,200,390>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,310,200,350>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
           


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <7,5,37,35>;
    preset Bitmap = App::ExpandBitmap;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <50,0>;
    preset Point2 = <50,40>;
    preset Point1 = <0,40>;
    preset OnPress = ToggleHandler;
  }

  $rect <670,180,870,220>
  slot ToggleHandler
  {
    sender; /* the method is called from the sender object */

    var App::Modify modify = (App::Modify) Owner.Owner.Owner;

    modify.zoneExpanded[ ZoneNum ] = !modify.zoneExpanded[ ZoneNum ];

    var Core::VerticalList lst = (Core::VerticalList) this.Owner.Owner;

      var int32 devs = 4;
      var int32 zone = ZoneNum;

      native( devs, zone )
      {
        Command cmd;
        cmd.int0 = zone;

        Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
        devs = cmd.int0;
      }


    if ( modify.zoneExpanded[ ZoneNum ] )
    {
      lst.NoOfItems = lst.NoOfItems + devs;
    }
    else
    {
      lst.NoOfItems = lst.NoOfItems - devs;
    }


    lst.InvalidateItems( 0, lst.NoOfItems );

    lst.InvalidateViewState();

     modify.VertScrollbar.ContentArea = lst.NoOfItems * lst.ItemHeight;
      modify.VertScrollbar.ViewArea = lst.Bounds.h;
     modify.VertScrollbar.InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <60,6,160,36>;
    preset String = "Zone 1";
    preset Font = Templates::DefaultFontPicker;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Image 6
  $reorder SimpleTouchHandler 6
  $reorder ToggleHandler 6
  $reorder Enabled 5
}

// This component implements a virtual keyboard.
$rect <330,660,530,700>
$output false
class AlphaNumKeyboard : Templates::AlphaNumKeyboard
{
  $rect <250,370,450,410>
  inherited property Bounds = <0,0,470,170>;

  $rect <480,250,680,290>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the affected keyboard.
    //
    // isKeyView --> the 'text' or 'image' view representing the pressed key.
    // isPressed --> the affected key should appear pressed.
    //
    var Core::View isKeyView = null;
    var bool       isPressed = ( TouchHandler.Down && TouchHandler.Inside ) || 
                                 FlashTimer.Enabled;

    // Search for the view representing the key at the recent touch position.
    // Do this however only when the position is valid - it lies inside the
    // area where keys are found (here the area of the TouchHandler) and the
    // key should appear pressed (isPressed == true)
    if ( isPressed && ( recentPosition == TouchHandler.GetExtent()))
      isKeyView = FindViewAtPosition( null, recentPosition, Core::ViewState[]);

    /*
       In this template, the keys are represented by simple 'text' and 'image'
       views. Any other view is considered as not corresponding to a key. Thus
       ignore every view, which is not an instance of 'text' or 'image'.
     
       TO DO:

       If you are using other views (not image nor text) to represent the keys,
       adapt the object runtime cast operations in the condition below to react
       on your particular views only. After this condition, 'isKeyView' should
       be either 'null' if the user is not pressing a key or it should refer to
       the view which represents the affected key.
    */

    if (((Views::Text)isKeyView == null ) && ((Views::Image)isKeyView == null ))
      isKeyView = null;

    /*

      TO DO:

      Depending on your keyboard design, you have surely added some new views
      to your keyboard. In the below code you should update the properties of
      these views. For example, when the user drags the finger between two keys
      one key should appear pressed while the other released.

      Whether the user has pressed/released a key can be estimated by comparing
      the variable 'isKeyView' with 'keyView'. If they differ, the user has
      pressed/released a key.

        if ( isKeyView != keyView )
          ...

      In practice, the variable 'isKeyView' represents the just pressed key.
      Your implementation should thus ensure, that the affected key appears
      pressed. If the user is not pressing any key, the variable is 'null'.

      The variable 'keyView' represents the key pressed in the preceding
      interaction. This key has thus to appear released. If there was no key
      pressed, the variable is 'null'.

      In the simplest case you modify the properties of the affected views, so
      they reflect their new state. Please note, the variables 'isKeyView' and
      'keyView' are declared with the generic Core::View class. In order to
      modify view specific properties you have to apply an object runtime cast
      operation on them. For example, if you are using 'text' views to represent
      keys, cast the variable to (Views::Text).

        if ( isKeyView != null )
          ((Views::Text)isKeyView).Color = color for a pressed key

        if ( keyView != null )
          ((Views::Text)keyView).Color = color for a released key

      Or you use, as demonstrated below, another views to highlight the area
      occupied by the affected key. For example, arrange some 'border' view
      to appear at the position of the pressed key with additional 5 pixel 
      padding:

        if ( isKeyView != null )
          BorderView.Bounds = isKeyView.GetExtent() * <5,5>;

      HINT:

      Instead of instantly alternate the views properties you can also start
      here effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the keyboard
      (e.g. 'isKeyView') with its preceding state (e.g. variable 'keyView').

      Assuming you have already added to your keyboard component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image lying behind the pressed key. Then following is 
      sufficient to trigger the animation:

        if (( isKeyView != null ) && ( keyView == null ))
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if (( isKeyView == null ) && ( keyView != null ))
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    // Detect a state alternation when the user presses a new or releases a
    // previously pressed key.
    if ( isKeyView != keyView )
    {
      var Views::Text isTextKeyView = (Views::Text)isKeyView;
      var Views::Text textKeyView   = (Views::Text)keyView;

      // If the user is actually pressing a key, arrange the background view
      // just behind the affected key view so it appears selected. If no key
      // is pressed, the background should disappear.
      if ( isKeyView != null )
      {
        Highlight.Bounds  = isKeyView.GetExtent();
        Highlight.Visible = true;
      }
      else
        Highlight.Visible = false;

      // If the user has pressed a key represented by a 'text' view, change the
      // color of the text to appear highlighted.
      if ( isTextKeyView != null )
        isTextKeyView.Color = #FFFFFFFF;

      // If the user has released a key represented by a 'text' view, restore
      // the color of the text.
      if ( textKeyView != null )
        textKeyView.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    keyView = isKeyView;
  }

  $rect <710,290,910,330>
  inherited method Init()
  {
    // Just at the creation time of the virtual keyboard instance
    // load the default keyboard layout.
    loadLayoutFromString( layoutShiftOff );
  }

  // To do:
  // 
  // - Adjust the visible size of your keyboard (the thick blue border). This will \
  // be the keyboard's default size.
  // - Resize and arrange the member 'TouchHandler' so it covers the area where you \
  // intend to place the keys.
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your keyboard.
  // - In this template, the individual keys are represented by text views 'TextKey01' \
  // .. 'TextKey47'.
  // - Special keys like the 'clear', 'enter' or 'shift' key are represented by image \
  // views 'ImageKeyClear', 'ImageKeyEnter', etc.
  // - The area for the 'space' key is displayed by a 'border' view 'AreaKeySpace'.
  // - Similarly, the 'shift' and 'caps-lock' keys have additional 'border' views \
  // 'ActiveKeyShiftLeft', 'ActiveCapsLock', which are displayed when the affected \
  // key has been activated.
  // - Remove the above described 'text', 'image' and 'border' views if you don't \
  // want them.
  // - Add more 'text', 'image', etc. views to represent more keys.
  // - Arrange the 'text' and 'image' views within the area of the 'TouchHandler'. \
  // The position of a view determines the area of the corresponding key.
  // - According to your desired keyboard design add and configure new decoration \
  // views (e.g. an image view to show some icon, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the keyboard's current state.
  // - Adapt the implementation of the 'activateKey' slot method. This method evaluates \
  // which key the user has pressed and feeds the corresponding key event to the \
  // application.
  // - The keyboard layout is determined by the strings in the variables 'layoutShiftOff' \
  // and 'layoutShiftOn'. Modify the strings accordingly to your desired layout. \
  // Every sign in the string corresponds to one key in the keyboard according the \
  // z-order in which the 'text' views 'TextKey01' .. 'TextKey47' are arranged.
  // - In the slot method 'activateKey' take a look at the code to switch the keyboard \
  // layout. In particular, when the user presses the 'shift' or 'caps-lock' keys \
  // the method switches the layout.
  // - You can also add and configure animation effects to your keyboard. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the keyboard itself is resized.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your keyboard. One property \
  // for every keyboard specific setting (e.g. 'Caption', 'Color', 'Font', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Font' should update the key related 'text' views in your \
  // component).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,430,990,1030>;
  }

  // Keyboard layout
  note group Note4
  {
    attr Bounds = <700,210,920,420>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <470,210,690,380>;
  }

  // Feedback flash effect
  note group Note2
  {
    attr Bounds = <240,210,460,340>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,210,230,420>;
  }

  // This string variable stores the keyboard layout for the case, there is a shift \
  // key pressed. Each character within this string does correspond to one key on \
  // the keyboard. By modifying this variable, the layout is changed.
  // The order in which the characters are listed in the string corresponds to the \
  // z-order of the 'text' views 'TextKey01' .. 'TextKey47'.
  $rect <710,370,910,410>
  var string layoutShiftOn = "!\"$$%&/()=?QWERTZUIOP*ASDFGHJKL\'>YXCVBNM;:_ ";

  // This string variable stores the keyboard layout for the case, there is no shift \
  // key pressed. Each character within this string does correspond to one key on \
  // the keyboard. By modifying this variable, the layout is changed.
  // The order in which the characters are listed in the string corresponds to the \
  // z-order of the 'text' views 'TextKey01' .. 'TextKey47'.
  $rect <710,330,910,370>
  var string layoutShiftOff = "1234567890qwertzuiop+asdfghjkl#<yxcvbnm,.- ";

  // This variable refers to the view representing the actually pressed key or it \
  // is 'null' if the user is not touching a key.
  $rect <480,330,680,370>
  var Core::View keyView;

  // This variable stores the recent position inside the keyboard area where the \
  // user is touching the screen.
  $rect <20,370,220,410>
  var point recentPosition;

  // This timer object is used to flash the pressed key when the user has tapped \
  // it very quickly. This is just a visual feedback effect.
  $rect <250,250,450,290>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This method loads new keyboard layout. The layout is determined by the passed \
  // string parameter aLayoutString. The characters within the string correspond \
  // to the keys accordingly their order.
  // The order in which the characters are listed in the string corresponds to the \
  // z-order of the 'text' views 'TextKey01' .. 'TextKey47'.
  $rect <710,250,910,290>
  method void loadLayoutFromString( arg string aLayoutString )
  {
    var Core::View view  = TextKey01;
    var int32      keyNo = 0;

    // Traverse the entire list of views available within the keyboard component
    while ( view != null )
    {
      var Views::Text textKeyView = (Views::Text)view;

      // Is this a 'text' view representing a key?
      if ( textKeyView != null )
      {
        // From the layout string get the character corresponding to the key
        var string s = aLayoutString[ keyNo ];

        // Note, for text views, some characters have a special control function. 
        // To display those signs prefix them by a percent % sign
        if (( s == "%" ) || ( s == "^" ) || ( s == "~" ))
          s = '%' + s;

        // Let the 'text' view display the corresponding sign
        textKeyView.String = s;
        keyNo = keyNo + 1;
      }

      // Search for next view
      view = FindNextView( view, Core::ViewState[]);
    }
  }

  // This internal slot method is called when the recently pressed key should be \
  // activated. This is when the user presses on a key and then releases the finger \
  // again.
  $rect <480,290,680,330>
  slot activateKey
  {
    // Applying the object runtime casting test whether the user is
    // touching a key with 'text' caption.
    var Views::Text textKeyView = (Views::Text)keyView;

    // Depending on the pressed key, the following variables will be
    // initialized with the corresponding code.
    var char          charCode = '\0';
    var Core::KeyCode keyCode  = Core::KeyCode.NoKey;

    // Has the user touched (activated) one of the keys with text
    // as caption? Use the text as character code to feed the application 
    // with a keyboard event.
    if ( textKeyView != null )
      charCode = textKeyView.String[0];

    // Has the user touched the 'Tab' key?
    else if ( keyView == ImageKeyTab )
      keyCode = Core::KeyCode.Tab;

    // Has the user touched the 'Enter' key?
    else if ( keyView == ImageKeyEnter )
      keyCode = Core::KeyCode.Enter;

    // Has the user touched the 'Clear' key?
    else if ( keyView == ImageKeyClear )
      keyCode = Core::KeyCode.Backspace;

    // Has the user touched a 'Shift' key? This switches the layout for
    // the next sign
    else if (( keyView == ImageKeyShiftLeft ) || 
             ( keyView == ImageKeyShiftRight ))
    {
      // Toggle the highlight of the both 'Shift' keys. The 'CapsLock' key,
      // in turn, is de-highlighted.
      ActiveKeyShiftLeft.Visible  = !ActiveKeyShiftLeft.Visible;
      ActiveKeyShiftRight.Visible = ActiveKeyShiftLeft.Visible;
      ActiveKeyCapsLock.Visible   = false;

      // Depending on the actual 'Shift' key state -> load the right layout
      // version of the keyboard
      if ( ActiveKeyShiftLeft.Visible )
        loadLayoutFromString( layoutShiftOn );
      else
        loadLayoutFromString( layoutShiftOff );
    }

    // Has the user touched a 'CapsLock' key? This switches the layout
    // permanently
    else if ( keyView == ImageKeyCapsLock )
    {
      // Toggle the highlight of the 'CapsLock' key. The both 'Shift' keys,
      // in turn, are de-highlighted.
      ActiveKeyCapsLock.Visible   = !ActiveKeyCapsLock.Visible;
      ActiveKeyShiftLeft.Visible  = false;
      ActiveKeyShiftRight.Visible = false;

      // Depending on the actual 'Shift' key state -> load the right layout
      // version of the keyboard
      if ( ActiveKeyCapsLock.Visible )
        loadLayoutFromString( layoutShiftOn );
      else
        loadLayoutFromString( layoutShiftOff );
    }

    // Pressing a key while after the 'Shift' keys have been activated restores
    // the 'Shift' keys and switches back to the normal keyboard layout.
    if ((( charCode != '\0' ) || ( keyCode != Core::KeyCode.NoKey )) &&
           ActiveKeyShiftLeft.Visible )
    {
      ActiveKeyShiftLeft.Visible  = false;
      ActiveKeyShiftRight.Visible = false;
      loadLayoutFromString( layoutShiftOff );
    }

    // The user has pressed a regular character/digit key. Feed it as keyboard
    // event to the application.
    if ( charCode != '\0' )
    {
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, charCode, true );
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, charCode, false );
    }

    // The user has pressed a special key (e.g. Enter). Feed it as keyboard
    // event to the application.
    if ( keyCode != Core::KeyCode.NoKey )
    {
      GetRoot().DriveKeyboardHitting( keyCode, '\0', true );
      GetRoot().DriveKeyboardHitting( keyCode, '\0', false );
    }
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <250,290,450,330>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the keyboard to update 
    // its appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the key is activated.
    signal activateKey;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the keyboard. This updates the keyboard to highlight the key at the new touch \
  // position.
  $rect <20,330,220,370>
  slot onDragTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // Remember the new position where the user recently touched the screen
    recentPosition = TouchHandler.CurrentPos;
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the keyboard area. This activates the key the user has touched.
  $rect <20,290,220,330>
  slot onReleaseTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // Did the user moved the finger outside the keyboard's area? In such case
    // the keyboard is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user has pressed and held a key for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The keyboard can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      signal activateKey;

    // The user has tapped the keyboard very quickly. Defer the key activation
    // to give the user first a short visual feedback that the key has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the keyboard area.
  $rect <20,250,220,290>
  slot onPressTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // The keyboard is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the keyboard in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new key interaction.
    if ( FlashTimer.Enabled )
    {
      signal activateKey;
      FlashTimer.Enabled = false;
    }

    // Remember the new position where the user has touched the screen
    recentPosition = TouchHandler.CurrentPos;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,470,170>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,470,170>;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <10,160>;
    preset Point3 = <460,160>;
    preset Point2 = <460,10>;
    preset Point1 = <10,10>;
    preset OnDrag = onDragTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset EnableMultiTouch = true;
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Border AreaKeySpace
  {
    preset Bounds = <160,130,310,160>;
    preset Width = 2;
    preset Color = #A5A3A2FF;
  }

  $rect <20,20,160,60>
  object Views::Border ActiveKeyShiftRight
  {
    preset Bounds = <400,100,460,130>;
    preset Width = 3;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Border ActiveKeyShiftLeft
  {
    preset Bounds = <10,100,70,130>;
    preset Width = 3;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Border ActiveKeyCapsLock
  {
    preset Bounds = <10,70,60,100>;
    preset Width = 3;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Highlight
  {
    preset Bounds = <160,130,310,160>;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey01
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,10,70,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey02
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <70,10,100,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey03
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,10,130,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey04
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <130,10,160,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey05
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <160,10,190,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey06
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <190,10,220,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey07
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <220,10,250,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey08
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,10,280,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey09
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <280,10,310,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey10
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <310,10,340,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey11
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <340,10,370,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey12
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <50,40,80,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey13
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,40,110,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey14
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <110,40,140,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey15
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <140,40,170,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey16
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <170,40,200,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey17
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <200,40,230,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey18
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <230,40,260,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey19
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <260,40,290,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey20
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <290,40,320,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey21
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <320,40,350,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey22
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <350,40,380,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey23
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <380,40,410,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey24
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <60,70,90,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey25
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <90,70,120,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey26
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,70,150,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey27
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <150,70,180,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey28
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <180,70,210,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey29
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <210,70,240,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey30
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <240,70,270,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey31
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <270,70,300,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey32
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <300,70,330,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey33
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <330,70,360,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey34
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <360,70,390,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey35
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <390,70,420,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey36
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <70,100,100,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey37
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,100,130,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey38
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <130,100,160,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey39
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <160,100,190,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey40
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <190,100,220,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey41
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <220,100,250,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey42
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,100,280,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey43
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <280,100,310,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey44
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <310,100,340,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey45
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <340,100,370,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey46
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <370,100,400,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey47
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <160,130,310,160>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyTab
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,40,50,70>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyTab;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyCapsLock
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,70,60,100>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyCapsShift;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyShiftLeft
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,100,70,130>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyShift;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyClear
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <400,10,460,40>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyBackspace;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyEnter
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <420,40,460,100>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyEnter;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyShiftRight
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <400,100,460,130>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyShift;
  }
}

$rect <140,660,280,700>
$output false
class IconButton : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,40,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,2,38,38>;
    preset Color = #A383AFFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,40,40>;
    preset Bitmap = App::PopupBitmap;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,40,40>;
    preset Width = 2;
    preset ColorL = #CDA9D3FF;
    preset ColorR = #4B3B4DFF;
    preset ColorB = #4B3B4DFF;
    preset ColorT = #CDA9D3FF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <40,0>;
    preset Point2 = <40,40>;
    preset Point1 = <0,40>;
    preset OnPress = Slot;
  }

  $rect <0,60,220,100>
  property App::Popup Popup = null;

  $rect <0,100,200,140>
  slot Slot
  {
    sender; /* the method is called from the sender object */



    if ( Popup != null )
    {
      if ( Owner != null )
      {
        Owner.Visible = false;
        Owner.Enabled = false;
        Popup.Parent = (App::Popup) Owner;
      }
      Popup.Show( GetRoot() );
    }



  }
}

$rect <1420,790,1570,830>
$output false
resource Resources::Bitmap PopupBitmap
{
  attr bitmapfile FileName = .\Images\popup.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <690,580,840,620>
$output false
class ModifyPopup : App::Popup
{
  $rect <770,200,910,240>
  inherited property Bounds = <0,0,725,445>;

  $rect <770,150,910,190>
  inherited method Init()
  {
    // TO DO: Write your code here ... 


    Writable.TextEditor.ObtainFocus();



      /*
    if (   HorzBarSlider.CurrentValue == 0 )
    {
     RadioButton10.Enabled = false;
      RadioButton11.Enabled = false;
    }
    else
    {
     RadioButton10.Enabled = true;
      RadioButton11.Enabled = true;
     }
        */

  }

  $rect <20,20,160,60>
  inherited object Rectangle
  {
    preset Bounds = <680,10,710,400>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle1
  {
    preset Bounds = <680,400,710,430>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle2
  {
    preset Bounds = <10,400,680,435>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <680,0,710,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle5
  {
    preset Bounds = <0,400,10,430>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset Bounds = <10,0,680,10>;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle7
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle8
  {
    preset Bounds = <0,10,10,400>;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <10,10,680,400>;
    preset Color = #C7C7C7FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object App::MattsKeyboard MattsKeyboard
  {
    preset Bounds = <21,160,579,368>;
  }

  $rect <20,20,160,60>
  object App::Writable Writable
  {
    preset Bounds = <128,100,610,137>;
    preset Focus = null;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <31,108,118,132>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Location";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <760,260,960,300>
  slot ProceedSlot
  {
    sender; /* the method is called from the sender object */

    if ( device != null )
    {
        device.location = Writable.TextEditor.Text.String;

        if ( device.location.right( 1 ) == "\n" )
        {
          device.location = device.location.left( device.location.length - 1 );
        }

        var int32 c;
        var string s = device.location;
        var int32 i = 0;

        do
        {
          i = s.find( "\x00A0\x005E", 0 );
          if ( i >= 0 )
          {
            s = s.remove( i, 1 );
            s[ i] = '\x0020';
          }
        } while ( i >= 0 );

        device.location = s;


         
         write = new App::UpdateDevicePopup;
          

         write.HorizontalValueBar.CurrentValue = 0;
         write.PushButton.Label = "Cancel";
         write.Show( GetRoot() );
          
            
        if ( WriteButton.Label == "Write To Device" )
        {
            postsignal write.SetConfigTrue;
       
        }
        else
        {
            postsignal write.SetConfigFalse;
        }
    }

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton CloseButton
  {
    preset Bounds = <508,329,673,380>;
    preset OnRelease = CancelSlot;
    preset Label = "Close";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton InputChanButton
  {
    preset Bounds = <30,28,235,83>;
    preset OnRelease = InputChannels;
    preset Label = "Input Channels...";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton OutputChanButton
  {
    preset Bounds = <466,28,671,83>;
    preset OnRelease = OutputChannels;
    preset Label = "Output Channels...";
    preset Appearance = App::NormalPushButton;
  }

  $rect <740,20,910,60>
  slot InputChannels
  {
    sender; /* the method is called from the sender object */

    var App::InputChannels inputs = new App::InputChannels;

    if (device != null )
    {
      inputs.device = device;
     
      inputs.ChanIndex = 0;

      inputs.Show( GetRoot() );
    }


  }

  $rect <930,20,1100,60>
  slot OutputChannels
  {
    sender; /* the method is called from the sender object */

    var App::OutputChannels outputs = new App::OutputChannels;

    if (device != null )
    {
      outputs.device = device;

      outputs.ChanIndex = 0;

      outputs.Show( GetRoot() );
    }

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton WriteButton
  {
    preset Bounds = <507,262,672,313>;
    preset OnRelease = ProceedSlot;
    preset Label = "Write To Device";
    preset Appearance = App::NormalPushButton;
  }

  $rect <760,330,960,370>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */
               


    Hide();

  }

  $rect <770,370,970,410>
  property App::DeviceConfig device = App::DummyConfig;

  $rect <770,420,970,460>
  onset device
  {
    // The value doesn't change - nothing to do.
     

    // Remember the property's new value.
    pure device = value;

    if ( device != null )
    {
      Writable.TextEditor.String = device.location;

      InputChanButton.Enabled = ( device.numinputs != 0 );
     
      OutputChanButton.Enabled = ( device.numoutputs != 0 );
    }


  }

  $rect <960,160,1160,200>
  slot SetFocus
  {
    sender; /* the method is called from the sender object */


    Writable.TextEditor.ObtainFocus();



  }

  $rect <960,270,1160,310>
  property App::Modify modify = null;

  $rect <30,470,280,510>
  object Core::SystemEventHandler MeshChangeEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = App::Devices.MeshListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler1' \
  // receives an event.
  $rect <280,470,480,510>
  slot onEvent
  {
     

    if ( device != null )
    {
      var App::Device d = App::Lib.GetDevice( device.unitnum );

       WriteButton.Enabled = d != null;
    }

  }

  $rect <580,480,780,520>
  property App::UpdateDevicePopup write = null;
}

$rect <410,580,560,620>
$output false
class TestPopup : App::Popup
{
  $rect <640,5,780,45>
  inherited property Bounds = <0,0,660,460>;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object App::Test Test
  {
    preset Bounds = <15,14,625,374>;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton Cancel
  {
    preset Bounds = <499,384,619,419>;
    preset AlphaBlended = false;
    preset OnAction = CancelSlot;
    preset Caption = "Cancel";
  }

  $rect <20,20,160,60>
  object Flat::ActionButton Proceed
  {
    preset Bounds = <19,385,144,420>;
    preset AlphaBlended = false;
    preset OnAction = ProceedSlot;
    preset Caption = "OK";
  }

  $rect <470,450,670,490>
  slot CancelSlot
  {
    Hide();


  }

  $rect <20,450,220,490>
  slot ProceedSlot
  {
    Hide();


  }

  $reorder Test 1
  $reorder Cancel 1
  $reorder Proceed 1
  $reorder CancelSlot 1
  $reorder ProceedSlot 1
}

$rect <720,380,870,420>
$output false
class PhoneNumber : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,710,30>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,720,30>;
    preset Color = #DBDBDBFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,180,30>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "+447890123456";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <150,0,700,30>;
    preset OnLoadItem = OnLoadItem;
    preset ItemWidth = 70;
    preset NoOfItems = 8;
    preset ItemClass = App::ToggleItem;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <230,40,430,80>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = HorizontalList.Item;
    var App::ToggleItem itemView = (App::ToggleItem) HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    itemView.ToggleButton.Checked = (( BitField >> itemNo ) & 1 ) != 0;


     
  }

  $rect <40,130,240,170>
  property uint8 BitField = 0;

  $rect <370,150,570,190>
  property string Name = 0;

  $rect <330,210,530,250>
  property string Number = 0;

  $reorder Rectangle 6
}

$rect <620,380,750,420>
$output false
class TextPopup : App::Popup
{
  $rect <865,35,1005,75>
  inherited property Bounds = <0,0,800,440>;

  $rect <855,430,995,470>
  inherited method Init()
  {
     

    postsignal Refresh;

     


  }

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset Bounds = <770,0,800,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
    preset Color;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CDCDCDFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <182,10,232,30>;
    preset String = "Fire";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <312,10,387,30>;
    preset String = "Evacuate";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text8
  {
    preset Bounds = <236,10,312,30>;
    preset String = "First-Aid";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text10
  {
    preset Bounds = <529,10,585,30>;
    preset String = "Fault";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text11
  {
    preset Bounds = <383,10,453,30>;
    preset String = "Security";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <15,40,715,340>;
    preset OnSlide = Slide;
    preset SlideHorz = false;
    preset SlideVert = true;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <20,40>;
    preset Point3 = <720,40>;
    preset Point2 = <720,340>;
    preset Point1 = <20,340>;
    preset OnPress = SelectSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <17,40,725,340>;
    preset Enabled = true;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 30;
    preset NoOfItems = 30;
    preset ItemClass = App::PhoneNumber;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <830,190,1030,230>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var App::PhoneNumber itemView = (App::PhoneNumber)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    var string number = "+4478901234567";
    var string name = "Matt ABCDEFGHJILK";

    var uint8 bits = math_rand( 0, 127 );

    native ( itemNo, number, name, bits )
    { 
        Command cmd;

        cmd.int0 = itemNo;

        if ( Command0( CMD_GET_SMS_NUMBER, &cmd ) == CMD_OK )
        {
            name   = EwNewStringAnsi( (char*) cmd.int1 );
            number = EwNewStringAnsi( (char*) cmd.int2 );
            bits   = cmd.int3;         
        }
    }

    if ( itemNo == VerticalList.SelectedItem )
    {
      itemView.Rectangle.Color = #666688FF;
      itemView.Text.Color =  #CCCCCCFF;
    }
    else
    {
       itemView.Rectangle.Color = #CCCCCCFF;
       itemView.Text.Color = #000000FF;
    }

    itemView.Text.Font = App::FontVerdanaProCondSemiBold18;
    itemView.Text.String = name;
    itemView.Name = name;
    itemView.Number = number;
    itemView.BitField = bits;
    itemView.HorizontalList.InvalidateItems( 0, 6 );



  }

  $rect <620,440,820,480>
  slot ClosePopup
  {
    sender; /* the method is called from the sender object */

    this.Hide();

  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <449,10,523,30>;
    preset String = "General";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <590,10,665,30>;
    preset String = "Rout. Ack";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Bounds = <730,40,769,340>;
    preset OnScroll = Scroll;
    preset ViewArea = 300;
    preset ContentArea = VerticalList.NoOfItems*VerticalList.ItemHeight;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <895,315,1095,355>
  slot Slide
  {
    sender; /* the method is called from the sender object */


    VerticalScrollbar.Position =  -SlideTouchHandler.Offset.y;
  }

  $rect <880,260,1080,300>
  slot Scroll
  {
    sender; /* the method is called from the sender object */

    VerticalList.ScrollOffset = -VerticalScrollbar.Position;


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <600,350,750,400>;
    preset OnRelease = null;
    preset OnActivate = OK;
    preset Label = "OK";
    preset Appearance = App::NormalPushButton;
  }

  $rect <965,75,1165,115>
  object Core::Timer Timer
  {
    preset OnTrigger = Tick;
    preset Period = 2500;
    preset Enabled = true;
  }

  $rect <960,115,1160,155>
  property bool ShowName = false;

  $rect <1060,150,1160,190>
  slot Tick
  {
    sender; /* the method is called from the sender object */

    ShowName = !ShowName;

    var App::PhoneNumber r = (App::PhoneNumber) VerticalList.first;


    while ( r != null )
    {
        if ( ShowName )
        {
            r.Text.Font = OldResources::FontVerdana18;
            r.Text.String = r.Number;
        }
        else
        {
            r.Text.Font = App::FontVerdanaProCondSemiBold18;
            r.Text.String = r.Name;
        }

        r = (App::PhoneNumber) r.next;
    }

  }

  $rect <410,440,610,480>
  slot OK
  {
    sender; /* the method is called from the sender object */

    var int32 n = 0;

    var App::PhoneNumber sms = (App::PhoneNumber) VerticalList.first;

    while ( sms != null )
    {
        var App::ToggleItem itm = (App::ToggleItem) sms.HorizontalList.first;
        var int32 bits = 0;
        var int32 shift = 0;

        while ( itm != null )
        {
           if ( itm.ToggleButton.Checked ) bits = bits + ( 1 << shift );
           shift = shift + 1;
           itm = (App::ToggleItem) itm.next;
        }
          
        native ( bits, n )
        {
            
            Command cmd;
            cmd.int0 = n;
            cmd.int1 = bits;

            Command0( CMD_SET_SMS_NUMBER, &cmd );
        }

        n = n + 1;
        sms = (App::PhoneNumber) sms.next;
    }


    this.Hide();

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <20,350,200,400>;
    preset OnRelease = null;
    preset OnActivate = AddSlot;
    preset Label = "Add number";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <220,350,400,400>;
    preset OnRelease = null;
    preset OnActivate = RemoveSlot;
    preset Label = "Remove number";
    preset Appearance = App::NormalPushButton;
  }

  $rect <0,510,200,550>
  slot SelectSlot
  {
    sender; /* the method is called from the sender object */


    var int32 tapy = SimpleTouchHandler.CurrentPos.y - VerticalList.Bounds.y1 + VerticalScrollbar.Position ;

    var int32 prev =  VerticalList.SelectedItem;

    VerticalList.SelectedItem = tapy / VerticalList.ItemHeight;

    if ( VerticalList.SelectedItem == prev )
    {
        VerticalList.SelectedItem = -1;
    }

    if ( prev != -1 )
    {
      VerticalList.InvalidateItems( prev, prev );
    }

    VerticalList.InvalidateItems( VerticalList.SelectedItem, VerticalList.SelectedItem );

  }

  $rect <210,440,410,480>
  slot RemoveSlot
  {
    sender; /* the method is called from the sender object */

    var int32 n = VerticalList.SelectedItem;
    var int32 items = 20;

    if (  n != -1 )
    {
        native ( n, items )
        {
            Command cmd;
            cmd.int0 = n;
         
            Command0( CMD_REMOVE_SMS_NUMBER, &cmd );
            
            Command0( CMD_GET_NUM_SMS_CONTACTS, &cmd );

            items = cmd.int0;
        }
        VerticalList.NoOfItems = items;
        VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );
    }



      
     
  }

  $rect <10,440,210,480>
  slot AddSlot
  {
    sender; /* the method is called from the sender object */

    var int32 n = 0;

    if ( VerticalList.NoOfItems < 30 )
    {

      var App::NewNumberPopup p = (App::NewNumberPopup)  new App::NewNumberPopup;

      p.Parent = this;

      var Core::Root v = GetRoot();

      if ( v != null )
      {
        p.Show( v );

        p.ObtainFocus();
      } 
    }
    else
    {
      var App::AccesssPopup ll = new App::AccesssPopup;

      ll.Text.String = "Maximum of 30 SMS contacts";

      ll.Show( GetRoot() );  
    }
  }

  $rect <340,500,540,540>
  slot Refresh
  {
    // TO DO: Write your code here ... 

    var int32 items = 20;

    var App::Application app = (App::Application) GetRoot();

    if ( app != null )
    {   
      VerticalList.Enabled = ( app.LevelAccess.AccessLevel >= 3 ) ;
      SimpleTouchHandler1.Enabled = ( app.LevelAccess.AccessLevel < 3 ) ;
      GreyOutRect.Visible = ( app.LevelAccess.AccessLevel < 3 ) ;
        
       PushButton2.Enabled = app.LevelAccess.AccessLevel >= 3;
       PushButton3.Enabled = app.LevelAccess.AccessLevel >= 3;
    }


    native( items )
    {
        Command cmd;

        Command0( CMD_GET_NUM_SMS_CONTACTS, &cmd );

        items = cmd.int0;
    }

    VerticalList.NoOfItems = items;

    var int32 sz = VerticalList.NoOfItems * VerticalList.ItemHeight;

    if ( sz > VerticalList.Bounds.h)
    {
      VerticalScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;
      VerticalScrollbar.ViewArea =  VerticalList.Bounds.h;
      VerticalScrollbar.Visible = true;
    }
    else
    {
      VerticalScrollbar.Visible = false;
    }

    VerticalList.ScrollOffset = 0; 


  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler1
  {
    preset Point4 = <10,30>;
    preset Point3 = <720,30>;
    preset Point2 = <720,340>;
    preset Point1 = <10,340>;
    preset OnPress = LowLevelTouch;
  }

  $rect <660,510,860,550>
  slot LowLevelTouch
  {
    sender; /* the method is called from the sender object */

    var App::Application ap = (App::Application) GetRoot();

    if ( ap != null ) ap.LowLevel( 3 );

  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Bounds = <665,10,733,30>;
    preset String = "Mesh";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle GreyOutRect
  {
    preset Bounds = <190,40,710,340>;
    preset Color = #CDCDCD93;
  }

  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder Bounds1 1
  $reorder Rectangle 1
  $reorder Rectangle1 1
  $reorder Rectangle2 1
  $reorder Rectangle4 1
  $reorder Rectangle5 1
  $reorder Rectangle6 1
  $reorder Rectangle7 1
  $reorder Rectangle8 1
  $reorder Show 1
  $reorder mask 1
  $reorder touch 1
  $reorder root 1
  $reorder Hide 1
  $reorder Parent 1
  $reorder SystemEventHandler 1
  $reorder FireHide 1
  $reorder SystemEventHandler2 1
  $reorder EventHide 1
  $reorder Dead 1
  $reorder onHide 1
  $reorder Text 1
  $reorder Text1 1
  $reorder Text8 1
  $reorder Text10 1
  $reorder Text11 1
  $reorder SlideTouchHandler 1
  $reorder SimpleTouchHandler 1
  $reorder VerticalList 1
  $reorder OnLoadItem 1
  $reorder ClosePopup 1
  $reorder Text2 1
  $reorder Text3 1
  $reorder VerticalScrollbar 1
  $reorder Slide 1
  $reorder Scroll 1
  $reorder PushButton1 1
  $reorder Timer 1
  $reorder ShowName 1
  $reorder Tick 1
  $reorder OK 1
  $reorder PushButton2 1
  $reorder PushButton3 1
  $reorder SelectSlot 1
}

$rect <850,530,1000,570>
$output false
resource Resources::Bitmap TargetBitmap
{
  attr bitmapfile FileName = .\Images\target.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1500,1330,1740,1370>
$output false
resource Resources::Font FontVerdanaProSemiBold18
{
  attr fontname FontName = Verdana Pro SemiBold;
  attr fontheight Height = 18;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7E;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
}

$rect <1250,1330,1490,1370>
$output false
resource Resources::Font FontVerdanaProSemiBold20
{
  attr fontname FontName = Verdana Pro SemiBold;
  attr fontheight Height = 20;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xBB,0x4A9,2264,2265,2126,0x3A9;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
}

$rect <550,80,670,120>
$output false
class Glow : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,200,100>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,50,100,100>;
    preset ColorBL = #BC00FF07;
    preset ColorBR = #BC00FF07;
    preset ColorTR = #BC00FFFF;
    preset ColorTL = #BC00FF07;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,100,50>;
    preset ColorBL = #BC00FF07;
    preset ColorBR = #BC00FFFF;
    preset ColorTR = #BC00FF07;
    preset ColorTL = #BC00FF07;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,50,200,100>;
    preset ColorBL = #BC00FF07;
    preset ColorBR = #BC00FF07;
    preset ColorTR = #BC00FF07;
    preset ColorTL = #BC00FFFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,0,200,50>;
    preset ColorBL = #BC00FFFF;
    preset ColorBR = #BC00FF07;
    preset ColorTR = #BC00FF07;
    preset ColorTL = #BC00FF07;
    preset Visible = false;
  }

  $rect <230,35,430,75>
  slot Press
  {
    sender; /* the method is called from the sender object */

    this.Rectangle.Visible = true;
    this.Rectangle1.Visible = true;
    this.Rectangle2.Visible = true;
    this.Rectangle3.Visible = true;


  }

  $rect <220,75,420,115>
  slot Release
  {
    sender; /* the method is called from the sender object */

    this.Rectangle.Visible = false;
    this.Rectangle1.Visible = false;
    this.Rectangle2.Visible = false;
    this.Rectangle3.Visible = false;

    if ( !SimpleTouchHandler.Down && SimpleTouchHandler.Inside )
    {
        idlesignal action;
    }


  }

  $rect <235,160,435,200>
  property slot action = null;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <10,10>;
    preset Point3 = <190,10>;
    preset Point2 = <190,90>;
    preset Point1 = <10,90>;
    preset OnRelease = Release;
    preset OnPress = Press;
  }
}

$rect <1400,830,1550,870>
$output false
resource Resources::Bitmap LogAccess
{
  attr bitmapfile FileName = .\Images\log_access.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1550,830,1700,870>
$output false
resource Resources::Bitmap LogMisc
{
  attr bitmapfile FileName = .\Images\log_misc.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1700,830,1850,870>
$output false
resource Resources::Bitmap LogFaults
{
  attr bitmapfile FileName = .\Images\log_faults.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1260,830,1410,870>
$output false
resource Resources::Bitmap LogEvents
{
  attr bitmapfile FileName = .\Images\log_events.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1250,870,1400,910>
$output false
resource Resources::Bitmap LogFire
{
  attr bitmapfile FileName = .\Images\log_fire.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1400,870,1550,910>
$output false
resource Resources::Bitmap LogSettings
{
  attr bitmapfile FileName = .\Images\log_settings.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1550,870,1700,910>
$output false
resource Resources::Bitmap LogSystem
{
  attr bitmapfile FileName = .\Images\log_system.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1700,870,1850,910>
$output false
resource Resources::Bitmap LogTest
{
  attr bitmapfile FileName = .\Images\log_tests.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

note arrow Note
{
  attr Point1 = <350,240>;
  attr Point2 = <260,240>;
}

$rect <310,260,510,300>
$output false
class CAEName : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,500,30>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var Core::VerticalList list;

    if ( aState.contains( Core::ViewState[ Selected ]))
    {
      Bevel.ColorB = #777777FF;
      Bevel.ColorL =  #111111FF;
      Bevel.ColorT = #111111FF;
      Bevel.ColorR = #777777FF;
      NameText.Bounds.point1 = <31,2>;

    }
    else
    {
      NameText.Bounds.point1 = <30,0>;
      Bevel.ColorB = #111111FF;
      Bevel.ColorL = #777777FF;
      Bevel.ColorT = #777777FF;
      Bevel.ColorR = #111111FF;
    }   
      

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,500,30>;
    preset Width = 2;
    preset ColorL = #CCCCCCFF;
    preset ColorR = #222222FF;
    preset ColorB = #222222FF;
    preset ColorT = #CCCCCCFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <2,2,496,28>;
    preset Color = #818181FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text NameText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,0,500,30>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = App::FontVerdanaProCondSemiBold18;
  }

  $rect <70,95,270,135>
  property bool Selected = false;

  $rect <20,20,160,60>
  object Views::Text NumText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop];
    preset Bounds = <0,0,25,20>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "999";
    preset Font = App::FontVerdana14;
  }
}

$rect <600,200,800,240>
$output false
class Keyboard : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,450,160>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <440,320,1220,640>;
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,40,40>;
    preset KeyChar = 'Q';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,0,80,40>;
    preset KeyChar = 'W';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,0,120,40>;
    preset KeyChar = 'E';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,0,160,40>;
    preset KeyChar = 'R';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key4
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <160,0,200,40>;
    preset KeyChar = 'T';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key5
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <200,0,240,40>;
    preset KeyChar = 'Y';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key6
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <240,0,280,40>;
    preset KeyChar = 'U';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key7
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <280,0,320,40>;
    preset KeyChar = 'I';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key8
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <320,0,360,40>;
    preset KeyChar = 'O';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key9
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <360,0,400,40>;
    preset KeyChar = 'P';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key10
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <20,40,60,80>;
    preset KeyChar = 'A';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key11
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <60,40,100,80>;
    preset KeyChar = 'S';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key12
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,40,140,80>;
    preset KeyChar = 'D';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key13
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <140,40,180,80>;
    preset KeyChar = 'F';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key14
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <180,40,220,80>;
    preset KeyChar = 'G';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key15
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <220,40,260,80>;
    preset KeyChar = 'H';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key16
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <260,40,300,80>;
    preset KeyChar = 'J';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key17
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <300,40,340,80>;
    preset KeyChar = 'K';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key18
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <340,40,380,80>;
    preset KeyChar = 'L';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key20
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,80,80,120>;
    preset KeyChar = 'Z';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key21
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,80,120,120>;
    preset KeyChar = 'X';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key22
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,80,160,120>;
    preset KeyChar = 'C';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key23
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <160,80,200,120>;
    preset KeyChar = 'V';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key24
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <200,80,240,120>;
    preset KeyChar = 'B';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key25
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <240,80,280,120>;
    preset KeyChar = 'N';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key26
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <280,80,320,120>;
    preset KeyChar = 'M';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key28
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,120,340,160>;
    preset KeyChar = ' ';
  }

  $rect <20,20,160,60>
  object App::KeyBmp KeybBmp1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <320,80,370,120>;
    preset Bitmap = OldResources::KeyCapsShift;
  }

  $rect <20,20,160,60>
  object App::KeyBmp KeybBmp2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <400,0,450,40>;
    preset Bitmap = OldResources::KeyBackspace;
  }

  $rect <20,20,160,60>
  object App::KeySwitch KeySwitch
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,120,80,160>;
    preset Word = "Num/Sym";
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Touch
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <450,0>;
    preset Point2 = <450,160>;
    preset Point1 = <0,160>;
    preset OnHold = HoldSlot;
    preset OnRelease = ReleaseSlot;
    preset OnPress = PressSlot;
  }

  $rect <360,230,560,270>
  property int32 Time = 0;

  $rect <710,250,910,290>
  object Core::Timer timer
  {
    preset Period = 10000;
    preset Enabled = true;
  }

  $rect <0,270,200,310>
  property App::Key key = null;

  $rect <470,30,670,70>
  slot PressSlot
  {
    sender; /* the method is called from the sender object */

    timer.Enabled = true;
    timer.restart( 0, 200 );

    Time = timer.Time;

    key = (App::Key) this.first;

    while ( key != null )
    {
        if ( key.Bounds == Touch.HittingPos )
        {
            key.Pressed = true;
            key.InvalidateViewState();
            return;
        }
        key = (App::Key) key.next;
    }

            



  }

  $rect <460,100,660,140>
  slot ReleaseSlot
  {
    sender; /* the method is called from the sender object */

    timer.Enabled = false;

    if ( key != null )
    {
            key.Pressed = false;
            key.InvalidateViewState();
            key = null;
     }

            



  }

  $rect <500,160,630,200>
  slot HoldSlot
  {
    sender; /* the method is called from the sender object */

    var int32 t = timer.Time;

    if ( t - Time > 550 )
    {
       if ( key != null )
       {
           key.Pressed = true;
           key.Pressed = false;
       }
    }


  }
}

$rect <750,260,890,300>
$output false
class Key : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,300,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    if ( Pressed )
    {
        Rectangle.Color = #88CCFFFF;
    }
    else
    {
        Rectangle.Color = #DDDDDDFF; 
    }   

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <4,0,296,196>;
    preset Color = #DDDDDDFF;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,-10,300,200>;
    preset Width = 4;
    preset ColorL = #FFFFFFFF;
    preset ColorR = #999999FF;
    preset ColorB = #999999FF;
  }

  $rect <580,30,780,70>
  property bool Pressed = false;

  $rect <590,80,790,120>
  onset Pressed
  {
    // The value doesn't change - nothing to do.
    if ( pure Pressed == value )
      return;

    // Remember the property's new value.
    pure Pressed = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <600,130,800,170>
  onget Pressed
  {
    return pure Pressed;
  }
}

$rect <1420,980,1600,1020>
$output false
resource Resources::Bitmap Fire4Bitmap
{
  attr bitmapfile FileName = .\Images\fire4.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <840,260,960,300>
$output false
class KeyLetter : App::Key
{
  $rect <40,260,350,300>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 


    super( aState);

    Text.String = KeyChar;

  }

  $rect <420,140,610,180>
  inherited onset Pressed
  {
    // TO DO: Write your code here ... 


    if (  value == true )
    {
      {
        GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, KeyChar, true );
        GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, KeyChar, false );
      }
    }

    pure Pressed = value;

  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,300,200>;
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #3A3A3AFF;
  }

  $rect <340,0,540,40>
  property char KeyChar = 'A';

  $reorder Text 1
}

$rect <960,260,1080,300>
$output false
class KeyBmp : App::Key
{
  $rect <20,240,160,280>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 

    super( aState);


    Image.Bitmap = Bitmap;


  }

  $rect <240,270,380,310>
  inherited onset Pressed
  {
    // TO DO: Write your code here ... 

    if ( value == true )
    {


      if ( Bitmap == OldResources::KeyBackspace )
      {
         GetRoot().DriveKeyboardHitting( Core::KeyCode.Backspace, '\0', true );
         GetRoot().DriveKeyboardHitting( Core::KeyCode.Backspace, '\0', false );
      }
      else if ( Bitmap == OldResources::KeyCapsShift )
      {

        var App::Key k = (App::Key) this.Owner.first;

        while ( k != null )
        {
            var App::KeyLetter lk = ( App::KeyLetter )  k;

            if ( lk != null )
            {
                 if (  lk.KeyChar < 'a' )
                 {
                    lk.KeyChar = lk.KeyChar.lower;
                  }
                  else
                  {
                     lk.KeyChar = lk.KeyChar.upper;
                   }
                lk.InvalidateViewState();
            }

            k = (App::Key) k.next;
        }   
      }
    }  

    pure Pressed = value;

         
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,300,200>;
    preset FrameNumber = 1;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <350,0,550,40>
  property Resources::Bitmap Bitmap = OldResources::InformationIcon;
}

$rect <810,230,950,270>
$output false
class KeySwitch : App::Key
{
  $rect <20,250,160,290>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ...

    super( aState);
     


    Text.String = Word;
  }

  $rect <250,290,390,330>
  inherited onset Pressed
  {
    // TO DO: Write your code here ... 

    if ( value == true )
    {
        var App::MattsKeyboard kbd = (App::MattsKeyboard) Owner.Owner;
        
        if ( kbd.Numboard.Visible == true )
        {
            kbd.Keyboard.Visible = true;
            kbd.Numboard.Visible = false;
            kbd.Keyboard.Enabled = true;
            kbd.Numboard.Enabled = false;

        }
        else
        {
            kbd.Keyboard.Visible = false;
            kbd.Numboard.Visible = true;
            kbd.Keyboard.Enabled = false;
            kbd.Numboard.Enabled = true;
        } 
    }





    pure Pressed = value;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,300,200>;
    preset String = "Text";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <340,30,540,70>
  property string Word = "?";
}

$rect <600,240,800,280>
$output false
class Numboard : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,400,160>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,0,80,40>;
    preset KeyChar = '7';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,0,120,40>;
    preset KeyChar = '8';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,0,160,40>;
    preset KeyChar = '9';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <210,0,250,40>;
    preset KeyChar = '+';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key10
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,40,80,80>;
    preset KeyChar = '4';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key11
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,40,120,80>;
    preset KeyChar = '5';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key12
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,40,160,80>;
    preset KeyChar = '6';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key13
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <210,40,250,80>;
    preset KeyChar = '-';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key14
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,120,160,160>;
    preset KeyChar = '0';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key15
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,40,290,80>;
    preset KeyChar = '=';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key20
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,80,80,120>;
    preset KeyChar = '1';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key21
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,80,120,120>;
    preset KeyChar = '2';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key22
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,80,160,120>;
    preset KeyChar = '3';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key23
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,80,290,120>;
    preset KeyChar = '*';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key24
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <290,40,330,80>;
    preset KeyChar = '/';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key25
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <210,120,250,160>;
    preset KeyChar = '&';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key26
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <210,80,250,120>;
    preset KeyChar = '.';
  }

  $rect <20,20,160,60>
  object App::KeyBmp KeybBmp1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <410,80,460,120>;
    preset Bitmap = OldResources::KeyShift;
  }

  $rect <20,20,160,60>
  object App::KeySwitch KeySwitch
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,120,80,160>;
    preset Word = "Letters";
  }

  $rect <450,30,650,70>
  slot PressSlot
  {
    sender; /* the method is called from the sender object */

    timer.Enabled = true;
    timer.restart( 0, 200 );

    Time = timer.Time;

    key = (App::Key) this.first;

    while ( key != null )
    {
        if ( key.Bounds == Touch.HittingPos )
        {
            key.Pressed = true;
            key.InvalidateViewState();
            return;
        }
        key = (App::Key) key.next;
    }

            



  }

  $rect <460,100,660,140>
  slot ReleaseSlot
  {
    sender; /* the method is called from the sender object */


    timer.Enabled = false;
     

    if ( key != null )
    {
            key.Pressed = false;
            key.InvalidateViewState();
            key = null;
     }

            



  }

  $rect <20,20,160,60>
  object App::KeyLetter Key27
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,120,290,160>;
    preset KeyChar = '';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key16
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <290,0,330,40>;
    preset KeyChar = ')';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key28
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <290,80,330,120>;
    preset KeyChar = '#';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key29
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,0,290,40>;
    preset KeyChar = '(';
  }

  $rect <20,20,160,60>
  object App::KeyBmp KeybBmp2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <355,0,400,40>;
    preset Bitmap = OldResources::KeyBackspace;
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key30
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <290,120,330,160>;
    preset KeyChar = '@';
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Touch
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <400,0>;
    preset Point2 = <400,160>;
    preset Point1 = <0,160>;
    preset OnHold = HoldSlot;
    preset OnRelease = ReleaseSlot;
    preset OnPress = PressSlot;
  }

  $rect <500,160,630,200>
  slot HoldSlot
  {
    sender; /* the method is called from the sender object */

    var int32 t = timer.Time;

    if ( t - Time > 550 )
    {
       if ( key != null )
       {
           key.Pressed = true;
           key.Pressed = false;
       }
    }


  }

  $rect <360,230,560,270>
  property int32 Time = 0;

  $rect <710,250,910,290>
  object Core::Timer timer
  {
    preset Period = 10000;
    preset Enabled = true;
  }

  $rect <0,270,200,310>
  property App::Key key = null;
}

$rect <950,220,1150,260>
$output false
class MattsKeyboard : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,450,160>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object App::Keyboard Keyboard
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,450,160>;
  }

  $rect <20,20,160,60>
  object App::Numboard Numboard
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,450,160>;
    preset Enabled = false;
    preset Visible = false;
  }
}

$rect <160,800,340,840>
$output false
class ImportConfigPopup : App::Popup
{
  $rect <630,10,770,50>
  inherited property Bounds = <0,0,500,330>;

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset Bounds = <470,0,500,10>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset Bounds = <10,0,470,10>;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CDCDCDFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <290,50,395,135>;
    preset Bitmap = App::LaptopBitmap;
  }

  $rect <220,410,360,450>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

     
    /*
    if ( PushButton.CaptionText.String == "Cancel" )
    {
      native
      {
          Command cmd;
          Command0( CMD_CANCEL_LOAD_SETTINGS, &cmd );  
      }
    }
    */

    this.Hide();


  }

  $rect <80,350,210,390>
  slot USBSlot
  {
    sender; /* the method is called from the sender object */

     

          
  }

  $rect <350,350,505,400>
  slot ConfigSlot
  {
    sender; /* the method is called from the sender object */

    Hide(); 

    native
    {
        Command cmd;
        Command0( CMD_LOAD_SETTINGS_USB_SERIAL, &cmd );  
    }
        
          
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <80,50,185,125>;
    preset Bitmap = App::USBStick;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <170,240,310,290>;
    preset OnRelease = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <50,150,200,195>;
    preset OnRelease = USBSlot;
    preset Label = "USB Storage";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <270,150,420,195>;
    preset OnRelease = ConfigSlot;
    preset Label = "USB Host";
    preset Appearance = App::NormalPushButton;
  }
}

$rect <1393,909,1543,949>
$output false
resource Resources::Bitmap USBStick
{
  attr bitmapfile FileName = .\Images\usb_stick.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <510,800,690,840>
$output false
class LoadFilePopup : App::Popup
{
  $rect <360,0,500,40>
  inherited property Bounds = <0,0,340,340>;

  $rect <20,20,160,60>
  object XFlat::AnalogDisplay AnalogDisplay
  {
    preset Bounds = <10,10,310,270>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <10,260,310,310>;
    preset String = "Loading...";
    preset Font = App::FontVerdanaProSemiBold18;
  }
}

$rect <1690,910,1840,950>
$output false
resource Resources::Bitmap LaptopBitmap
{
  attr bitmapfile FileName = .\Images\laptop.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <810,480,960,520>
$output false
class SysRestorePopup : App::Popup;

$rect <340,800,510,840>
$output false
class ExportConfigPopup : App::Popup
{
  $rect <630,10,770,50>
  inherited property Bounds = <0,0,500,330>;

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset Bounds = <470,0,500,10>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset Bounds = <10,0,470,10>;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CDCDCDFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <303,38,408,123>;
    preset Bitmap = App::LaptopBitmap;
  }

  $rect <220,410,360,450>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

     

    native
    {
        Command cmd;
        Command0( CMD_CANCEL_LOAD_SETTINGS, &cmd );  
    }

    this.Hide();


  }

  $rect <200,350,330,390>
  slot SDCardSlot
  {
    sender; /* the method is called from the sender object */
  }

  $rect <350,350,505,400>
  slot ConfigSlot
  {
    sender; /* the method is called from the sender object */

    HorizontalValueBar.CurrentValue = 0;
     
     

    native
    {
        Command cmd;
        Command0( CMD_SAVE_SETTINGS_USB_SERIAL, &cmd );  
    }
        
          
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <70,43,175,118>;
    preset Bitmap = App::USBStick;
  }

  $rect <30,350,160,390>
  slot USBSlot
  {
    sender;


     var App::SaveSitePopup ss = new  App::SaveSitePopup ;
         ss.Show( this.GetRoot() );
         ss.Writable.TextEditor.ObtainFocus() ;
  }

  $rect <550,370,750,410>
  object Core::SystemEventHandler SystemEventHandler
  {
    preset OnEvent = FireHide;
    preset Event = App::Devices.ExportProgressEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <560,420,760,460>
  slot onEvent
  {
    var App::Progress p = (App::Progress) SystemEventHandler.Context;

    HorizontalValueBar.CurrentValue = p.amount;
     

    if ( 100 == p.amount )
    {
       PushButton2.Label = "OK";
        
        
    }


    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <49,138,189,178>;
    preset OnRelease = USBSlot;
    preset Label = "To USB Devie";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <285,138,425,178>;
    preset OnRelease = ConfigSlot;
    preset Label = "To USB Host";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <42,191,432,236>;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <162,243,312,293>;
    preset OnRelease = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }
}

$rect <10,1010,210,1050>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <420,60,620,100>
  onset Property
  {
    // The property doesn't change -> nothing to do.
    if ( pure Property == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Property = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Property;
  }

  // This property represents an individual setting or state value existing within \
  // the device.
  $rect <220,60,420,100>
  property int32 Property = 0;

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <20,60,220,100>
  $output true
  method void UpdateProperty( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Property )
    {
      // Remember the new value in the internal memory of the property.
      pure Property = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Property;
    }
  }

  // This object represents an individual system event.
  $rect <340,190,580,230>
  object Core::SystemEvent MeshListChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,190,280,230>
  $output true
  method void TriggerMeshListChangeEvent( arg int16 total, arg int16 active, arg int16 meshed, arg int16 extra )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::MeshStatus status = new App::MeshStatus;

    status.total = total;
    status.active = active;
    status.meshed = meshed;
    status.extra = extra;


    MeshListChangeEvent.Trigger( status, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  // Example of an interface to read and modify a device setting or state value
  note group Note1
  {
    attr Bounds = <10,10,630,110>;
  }

  // Example of an interface to react to a system event
  note group Note2
  {
    attr Bounds = <-20,90,670,2010>;
  }

  // The property 'Property' represents an individual setting or state value existing \
  // within the device. Through the associated 'onset' method all write operations \
  // to the property can be directed to your particular device API. The read accesses, \
  // in contrast, are handled internally by using the last known value of the property. \
  // See inline documentation inside the 'onset' method 'OnSetProperty'.
  // 
  // The method 'UpdateProperty', in turn, is intended to be called by the device \
  // to notify the GUI application about an alternation of a setting or state value \
  // represented by the property 'Property'. See inline documentation inside the \
  // method.
  // 
  // You will eventually need to change the data type of the property to match the \
  // data in your device (e.g. to 'bool', 'uint32', or 'string', etc.). Use for this \
  // purpose the attribute 'Type' of the property itself. Accordingly the declaration \
  // of the 'UpdateProperty' method may need an adaptation.
  note legend Note4
  {
    attr Bounds = <700,10,1540,220>;
  }

  note arrow Note5
  {
    attr Point1 = <630,60>;
    attr Point2 = <700,60>;
  }

  // The object 'SystemEvent' represents an individual system event. When the system \
  // event is triggered all associated system event handler are notified automatically.
  // 
  // The method 'TriggerEvent' method is intended to be called by the device to notify \
  // the GUI application about the particular system event represented by the object \
  // 'SystemEvent'. This method exists for your convenience only and is optional. \
  // See inline documentation inside the method.
  note legend Note6
  {
    attr Bounds = <700,230,1540,370>;
  }

  note arrow Note7
  {
    attr Point1 = <630,280>;
    attr Point2 = <700,280>;
  }

  $rect <340,230,540,270>
  object Core::SystemEvent SiteChangedEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,231,260,271>
  $output true
  method void TriggerSiteChangedEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    SiteChangedEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent1.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent1.Trigger( null, true );
    */
  }

  $rect <340,270,570,310>
  object Core::SystemEvent MeshStatusChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,270,310,310>
  $output true
  method void TriggerMeshStatusChangeEvent( arg int16 wantedstage, arg int16 currentstage )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::MeshStage stage = new App::MeshStage;

    stage.currentstage = currentstage;
    stage.wantedstage  = wantedstage;

    MeshStatusChangeEvent.Trigger( stage, false );



    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,310,540,350>
  object Core::SystemEvent FireEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,310,260,350>
  $output true
  method void TriggerFireEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FireEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,350,540,390>
  object Core::SystemEvent FirstAidEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,350,260,390>
  $output true
  method void TriggerFirstAidEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FireEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,390,540,430>
  object Core::SystemEvent ResetEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,390,260,430>
  $output true
  method void TriggerResetEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    ResetEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,430,540,470>
  object Core::SystemEvent EvacuateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,430,260,470>
  $output true
  method void TriggerEvacuateEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FireEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,470,540,510>
  object Core::SystemEvent SecurityEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,470,260,510>
  $output true
  method void TriggerSecurityEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    SecurityEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,510,540,550>
  object Core::SystemEvent DisableEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,510,230,550>
  $output true
  method void TriggerDisableEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    DisableEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,550,540,590>
  object Core::SystemEvent TestEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,550,230,590>
  $output true
  method void TriggerTestEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    TestEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,590,540,630>
  object Core::SystemEvent FaultEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,590,230,630>
  $output true
  method void TriggerFaultEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FaultEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,670,540,710>
  object Core::SystemEvent FireListChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,670,270,710>
  $output true
  method void TriggerFireListChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FireListChangeEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,630,540,670>
  object Core::SystemEvent ExportProgressEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,630,270,670>
  $output true
  method void TriggerExportProgressEvent( arg int32 amount )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::Progress p = new App::Progress;

    p.amount = amount;

    ExportProgressEvent.Trigger( p, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <350,710,550,750>
  object Core::SystemEvent StartProgressEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,710,290,750>
  $output true
  method void TriggerStartProgressEvent( arg int32 amount )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::Progress p = new App::Progress;

    p.amount = amount;

    StartProgressEvent.Trigger( p, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,750,540,790>
  object Core::SystemEvent EndProgressEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,750,280,790>
  $output true
  method void TriggerEndProgressEvent( arg int32 amount )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::Progress p = new App::Progress;

    p.amount = amount;

    EndProgressEvent.Trigger( p, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,790,540,830>
  object Core::SystemEvent OnTestChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,790,270,830>
  $output true
  method void TriggerOnTestChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    OnTestChangeEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <350,830,550,870>
  object Core::SystemEvent FaultListChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,830,270,870>
  $output true
  method void TriggerFaultListChangeEvent( arg bool jumpToPage )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    var App::FaultListChange ch = new App::FaultListChange ;

    ch.jump = jumpToPage;

    FaultListChangeEvent.Trigger( ch, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <350,870,550,910>
  object Core::SystemEvent EventListChangedEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,870,290,910>
  $output true
  method void TriggerEventListChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    EventListChangedEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <350,910,550,950>
  object Core::SystemEvent LogListChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,910,290,950>
  $output true
  method void TriggerLogListChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    LogListChangeEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <360,950,560,990>
  object Core::SystemEvent AccessModeChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,950,280,990>
  $output true
  method void TriggerAccessModeChangeEvent( arg int32 level )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::Access access = new  App::Access;

    access.Level = level;

    AccessModeChangeEvent.Trigger( access, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <370,990,570,1030>
  object Core::SystemEvent WriteProtectedEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <50,990,300,1030>
  $output true
  method void TriggerWriteProtectedEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    WriteProtectedEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <320,1030,520,1070>
  object Core::SystemEvent DFUEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,1030,230,1070>
  $output true
  method void TriggerDFUEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    DFUEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <320,1070,520,1110>
  object Core::SystemEvent GotoPriorityDisplay;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,1070,250,1110>
  $output true
  method void TriggerGotoPriorityDisplay()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    GotoPriorityDisplay.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <320,1110,520,1150>
  object Core::SystemEvent ConfirmFireAvailable;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,1110,290,1150>
  $output true
  method void TriggerConfirmFireAvailable( arg bool on )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::ButtonState conf = new App::ButtonState;

    conf.on = on;

    ConfirmFireAvailable.Trigger( conf, false );


    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <320,1150,550,1190>
  object Core::SystemEvent AcknowledgeFireAvailable;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,1150,310,1190>
  $output true
  method void TriggerAcknowledgeFireAvailable( arg bool on )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::ButtonState conf = new App::ButtonState;

    conf.on = on;

    AcknowledgeFireAvailable.Trigger( conf, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <320,1200,520,1240>
  object Core::SystemEvent TimeChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,1200,250,1240>
  $output true
  method void TriggerTimeChangeEvent( arg bool daytime )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::Boolean conf = new App::Boolean;

    conf.State = daytime;

    TimeChangeEvent.Trigger( conf, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <320,1240,520,1280>
  object Core::SystemEvent ConfirmEventAvailable;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,1240,280,1280>
  $output true
  method void TriggerConfirmEventAvailable( arg bool on )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::ButtonState conf = new App::ButtonState;

    conf.on = on;

    ConfirmEventAvailable.Trigger( conf, false );


    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <320,1280,570,1320>
  object Core::SystemEvent AcknowledgeEventAvailable;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,1280,310,1320>
  $output true
  method void TriggerAcknowledgeEventAvailable( arg bool on )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::ButtonState conf = new App::ButtonState;

    conf.on = on;

    AcknowledgeEventAvailable.Trigger( conf, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <320,1320,520,1360>
  object Core::SystemEvent SafeStateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,1320,220,1360>
  $output true
  method void TriggerSafeStateEvent( arg bool on )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::Boolean b = new App::Boolean;

    b.State = on;


    SafeStateEvent.Trigger( b, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <320,1360,520,1400>
  object Core::SystemEvent RBUDetectedEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,1360,270,1400>
  $output true
  method void TriggerRBUDetectedEvent( arg int32 device_ptr )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::PtrClass p = new App::PtrClass;

    p.ptr = device_ptr;

    RBUDetectedEvent.Trigger( p, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <330,1400,530,1440>
  object Core::SystemEvent RBUProgressEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,1400,250,1440>
  $output true
  method void TriggerRBUProgressEvent( arg int32 progress, arg int32 char_ptr )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::RBUProgress p = new App::RBUProgress;

    var string errmsg = "";

    if ( char_ptr != 0 ) native( errmsg, char_ptr )
    {
        errmsg = EwNewStringAnsi( (const char*) char_ptr );
    }

    p.progress = progress;
    p.errmsg = errmsg;

    RBUProgressEvent.Trigger( p, false );



    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <300,1440,550,1480>
  object Core::SystemEvent DisablementChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <10,1450,280,1490>
  $output true
  method void TriggerDisablementChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    DisablementChangeEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <230,1500,430,1540>
  object Core::SystemEvent NewZoneAndCombi;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,1500,230,1540>
  $output true
  method void TriggerNewZoneAndCombi( arg char zone, arg char combination )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::ZoneAndCombi zc = new App::ZoneAndCombi;

    zc.Zone = zone;
    zc.Combination = combination;

    NewZoneAndCombi.Trigger( zc, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <200,1540,400,1580>
  object Core::SystemEvent NewBitmapLogoEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <0,1540,200,1580>
  $output true
  method void TriggerNewBitmapLogoEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    NewBitmapLogoEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <200,1590,400,1630>
  object Core::SystemEvent AcumeshEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <0,1590,200,1630>
  $output true
  method void TriggerAcumeshEvent( arg int32 stage )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::Progress obj = new App::Progress;

    obj.amount = stage;

    AcumeshEvent.Trigger( obj, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <210,1640,410,1680>
  object Core::SystemEvent ResoudStateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <10,1640,210,1680>
  $output true
  method void TriggerResoundStateEvent( arg bool enabled )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    if ( enabled )
    {
        ResoudStateEvent.Trigger( this, false );
    }
    else
    {
        ResoudStateEvent.Trigger( null, false );
    }

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <190,1690,390,1730>
  object Core::SystemEvent UpdateDeviceEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <0,1680,200,1720>
  $output true
  method void TriggerUpdateDeviceEvent( arg int32 val )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::Progress p = new App::Progress;

    p.amount = val;

    UpdateDeviceEvent.Trigger(p, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <290,1750,530,1790>
  object Core::SystemEvent MeshUnitChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,1750,290,1790>
  $output true
  method void TriggerMeshUnitChangeEvent( arg int16 unit_num )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var App::UnitNumber u = new  App::UnitNumber;

    u.num = unit_num;


    MeshUnitChangeEvent.Trigger( u, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <270,1800,510,1840>
  object Core::SystemEvent GotoSysPageEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <0,1800,270,1840>
  $output true
  method void TriggerGotoSysPageEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

     
    GotoSysPageEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }
}

$rect <330,999,530,1039>
autoobject App::DeviceClass Devices;

$rect <0,1090,140,1130>
$output false
class MeshDevice
{
  $rect <30,60,230,100>
  property int16 Zone = 0;

  $rect <30,10,230,50>
  property int16 Device = 0;

  $rect <30,110,230,150>
  property string Serial = 0;

  $rect <30,160,230,200>
  property int16 Combination = 0;

  $rect <30,210,230,250>
  property Core::Time TimeStamp = null;
}

$rect <690,800,890,840>
$output false
class MeshDeviceComponent : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,480,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,480,45>;
    preset Color = #DEDEDEFF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <369,26,432,42>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "12:33";
    preset Font = App::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <3,2,76,24>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 96";
    preset Font = App::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <2,22,370,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Hallway, Front building 2";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <438,2,477,45>;
    preset FrameNumber = 0;
    preset Bitmap = App::GreenTickBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text DeviceText
  {
    preset Bounds = <82,2,171,24>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Device 1";
    preset Font = App::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text SerialText
  {
    preset Bounds = <198,1,310,26>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "xxx-yy-12345";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ComboText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <318,1,431,22>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "xxx-yy";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ComboTextFound
  {
    preset Bounds = <301,0,340,25>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $reorder Rectangle 2
}

$rect <1250,943,1430,983>
$output false
resource Resources::Bitmap GreenTickBitmap
{
  attr bitmapfile FileName = .\Images\greentick.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1420,940,1600,980>
$output false
resource Resources::Bitmap RedCrossBitmap
{
  attr bitmapfile FileName = .\Images\redcross.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1590,943,1780,983>
$output false
resource Resources::Bitmap BlueQuestionBitmap
{
  attr bitmapfile FileName = .\Images\bluequestion.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <940,800,1040,840>
$output false
enum Enum
{
  $rect <10,10,210,50>
  item FirstItem;

  $rect <220,10,420,50>
  item SecondItem;

  $rect <430,10,630,50>
  item ThirdItem;
}

$rect <1770,950,1960,990>
$output false
resource Resources::Bitmap PurplePlusBitmap
{
  attr bitmapfile FileName = .\Images\purpleplus.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1250,980,1430,1020>
$output false
resource Resources::Bitmap DoubleTickBitmap
{
  attr bitmapfile FileName = .\Images\doubletick.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1590,980,1770,1020>
$output false
resource Resources::Bitmap Mute2Bitmap
{
  attr bitmapfile FileName = .\Images\mute40_2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <250,1050,450,1090>
$output false
class Progress
{
  $rect <0,0,200,40>
  property int32 amount = 0;
}

$rect <820,900,990,940>
$output false
class SaveSitePopup : App::Popup
{
  $rect <780,30,920,70>
  inherited property Bounds = <0,0,710,410>;

  $rect <760,140,900,180>
  inherited property Focus = Writable;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CDCDCDFF;
  }

  $rect <20,20,160,60>
  object App::MattsKeyboard MattsKeyboard
  {
    preset Bounds = <39,124,649,354>;
  }

  $rect <20,20,160,60>
  object App::Writable Writable
  {
    preset Bounds = <39,43,530,93>;
    preset Property = ^FileName;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <553,41,663,93>;
    preset OnActivate = SaveSlot;
    preset IconFrameDefault = 1;
    preset Icon = null;
    preset Label = "Save";
    preset Appearance = App::NormalPushButton;
  }

  $rect <730,90,910,130>
  property string FileName = "";

  $rect <750,200,950,240>
  slot SaveSlot
  {
    sender; /* the method is called from the sender object */

    var string fname = Writable.TextEditor.String;

    var int32 success = 0;

    native ( fname )
    {
       char file[ 256];

       EwStringToAnsi( fname, file, 256, '-' );

       success = Command1( CMD_SAVE_SETTINGS_USB_HOST, (int) file );

    }

    if ( success != 0 )
    {
      var App::AccesssPopup ll = new App::AccesssPopup;

      ll.Text.String = "Save failed - Check USB device.";

      ll.Show( GetRoot() );
    }


    Hide( );

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <550,310,660,362>;
    preset OnActivate = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <820,340,1060,380>
  object WidgetSet::PushButtonConfig PushButtonConfig
  {
    preset LabelColorActive = #151515FF;
    preset LabelFont = Flat::FontM;
    preset FaceFrameActive = 2;
    preset FaceFrameDefault = 1;
    preset FaceFocused = WidgetSet::PushButtonMedium;
    preset FaceDefault = WidgetSet::PushButtonMedium;
  }

  $rect <800,290,1040,330>
  object WidgetSet::PushButtonConfig PushButtonConfig1
  {
    preset LabelColorActive = #151515FF;
    preset LabelColorDefault = #F5F5F5FF;
    preset LabelFont = Flat::FontM;
    preset FaceFrameActive = 2;
    preset FaceFrameDefault = 2;
    preset FaceFocused = WidgetSet::PushButtonMedium;
    preset FaceDefault = WidgetSet::PushButtonMedium;
  }

  $rect <530,440,730,480>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

     

    Hide( );

  }
}

$rect <1770,990,1960,1030>
$output false
resource Resources::Bitmap MagentaTickBitmap
{
  attr bitmapfile FileName = .\Images\magentatick.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

// This autoobject provides the default customization for the 'radio button' widget \
// (WidgetSet::RadioButton) in its medium size variant.
$rect <540,1350,730,1390>
$output false
autoobject WidgetSet::RadioButtonConfig NormalRadioButton
{
  preset LabelOnColorActive = #000000FF;
  preset LabelOnColorFocused = #000000FF;
  preset LabelOnColorDisabled = #000000FF;
  preset LabelOnColorDefault = #000000FF;
  preset LabelOffColorActive = #000000FF;
  preset LabelOffColorFocused = #000000FF;
  preset LabelOffColorDisabled = #000000FF;
  preset LabelOffColorDefault = #000000FF;
  preset LabelMarginLeft = 45;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #A8ABABAA;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #A8ABABAA;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 45;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToLeft];
  preset FaceOnFrameActive = 7;
  preset FaceOnFrameFocused = 5;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 3;
  preset FaceOnActive = WidgetSet::RadioButtonMedium;
  preset FaceOnFocused = WidgetSet::RadioButtonMedium;
  preset FaceOnDisabled = WidgetSet::RadioButtonMedium;
  preset FaceOnDefault = WidgetSet::RadioButtonMedium;
  preset FaceOffFrameActive = 6;
  preset FaceOffFrameFocused = 4;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 2;
  preset FaceOffActive = WidgetSet::RadioButtonMedium;
  preset FaceOffFocused = WidgetSet::RadioButtonMedium;
  preset FaceOffDisabled = WidgetSet::RadioButtonMedium;
  preset FaceOffDefault = WidgetSet::RadioButtonMedium;
  preset WidgetMinSize = <39,39>;
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'check box'.
$rect <500,1430,680,1470>
$output false
autoobject WidgetSet::ToggleButtonConfig NormalCheckBox
{
  preset LabelOnColorActive = #000000FF;
  preset LabelOnColorFocused = #000000FF;
  preset LabelOnColorDisabled = #000000FF;
  preset LabelOnColorDefault = #000000FF;
  preset LabelOffColorActive = #000000FF;
  preset LabelOffColorFocused = #000000FF;
  preset LabelOffColorDisabled = #000000FF;
  preset LabelOffColorDefault = #000000FF;
  preset LabelMarginLeft = 45;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #A8ABABAA;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #A8ABABAA;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 40;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToLeft];
  preset FaceOnFrameActive = 7;
  preset FaceOnFrameFocused = 5;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 3;
  preset FaceOnActive = WidgetSet::CheckBoxMedium;
  preset FaceOnFocused = WidgetSet::CheckBoxMedium;
  preset FaceOnDisabled = WidgetSet::CheckBoxMedium;
  preset FaceOnDefault = WidgetSet::CheckBoxMedium;
  preset FaceOffFrameActive = 6;
  preset FaceOffFrameFocused = 4;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 2;
  preset FaceOffActive = WidgetSet::CheckBoxMedium;
  preset FaceOffFocused = WidgetSet::CheckBoxMedium;
  preset FaceOffDisabled = WidgetSet::CheckBoxMedium;
  preset FaceOffDefault = WidgetSet::CheckBoxMedium;
  preset WidgetMinSize = <39,39>;
}

// This autoobject provides the default customization for the 'horizontal slider' \
// widget (WidgetSet::HorizontalSlider) in its medium size variant.
$rect <530,1310,740,1350>
$output false
autoobject WidgetSet::HorizontalSliderConfig NormalHorizontalSlider
{
  preset KeyRepeatPeriod = 100;
  preset KeyRepeatDelay = 500;
  preset CoverTintDisabled = #AEAEAEB0;
  preset ThumbMarginRight = -2;
  preset ThumbMarginLeft = -2;
  preset ThumbFrameActive = 3;
  preset ThumbFrameFocused = 2;
  preset ThumbFrameDisabled = 0;
  preset ThumbFrameDefault = 1;
  preset ThumbActive = WidgetSet::ThumbKnobMedium;
  preset ThumbFocused = WidgetSet::ThumbKnobMedium;
  preset ThumbDisabled = WidgetSet::ThumbKnobMedium;
  preset ThumbDefault = WidgetSet::ThumbKnobMedium;
  preset TrackRightTintDisabled = #AEAEAEB0;
  preset TrackRightFrameActive = 0;
  preset TrackRightFrameFocused = 0;
  preset TrackRightFrameDisabled = 0;
  preset TrackRightFrameDefault = 0;
  preset TrackRightActive = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackRightFocused = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackRightDisabled = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackRightDefault = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackLeftTintActive = #FF007AFF;
  preset TrackLeftTintDisabled = #B2B2B2B1;
  preset TrackLeftFrameActive = 1;
  preset TrackLeftFrameFocused = 1;
  preset TrackLeftFrameDisabled = 1;
  preset TrackLeftFrameDefault = 1;
  preset TrackLeftActive = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackLeftFocused = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackLeftDisabled = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackLeftDefault = WidgetSet::HorizontalSliderTrackMedium;
  preset FaceTintDisabled = #B1B1B1B3;
  preset WidgetMinSize = <45,39>;
}

$rect <1060,570,1210,610>
$output false
class InputChannels : App::Popup
{
  $rect <820,431,960,471>
  inherited property Bounds = <0,0,800,480>;

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle7
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <10,10,770,450>;
    preset Color = #C3C3C3FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <24,20,130,50>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Channel";
    preset Font = Resources::FontMedium;
    preset Embedded = false;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Cancel
  {
    preset Bounds = <30,370,155,425>;
    preset OnRelease = null;
    preset OnActivate = CancelSlot;
    preset Label = "Close";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object App::InputAction InputAction
  {
    preset Bounds = <174,10,764,198>;
    preset Embedded = false;
  }

  $rect <20,20,160,60>
  object App::DropDownMenu DropDownMenu
  {
    preset Bounds = <15,20,170,360>;
    preset onSelection = Select;
    preset GetItemCallback = LoadMenu;
  }

  $rect <20,20,160,60>
  object App::InputSignal InputSignal
  {
    preset Bounds = <178,194,770,284>;
    preset Embedded = false;
  }

  $rect <20,20,160,60>
  object App::InputDelay InputDelay
  {
    preset Bounds = <174,285,780,450>;
    preset Embedded = false;
  }

  $rect <10,80,150,120>
  slot Select
  {
     

    SaveData( );

    ChanIndex = DropDownMenu.VerticalList.SelectedItem;


  }

  $rect <10,130,150,170>
  slot LoadMenu
  {
     
    var App::DropDownMenu m = ( App::DropDownMenu) sender;
     
    var int32 i = m.itemIndex;

    if ( device != null )
    {
      m.itemName = App::Lib.TypeName( device.inputs[ i ].type );
    }
    else 
    {
      m.itemName = "??";
    }


  }

  $rect <830,110,1030,150>
  property int32 ChanIndex = 0;

  $rect <830,150,1030,190>
  onset ChanIndex
  {
     
    if ( device != null && value < device.numinputs )
    {

      // Remember the property's new value.
      pure ChanIndex = value;

      var App::InputChannel i = device.inputs[ ChanIndex ];

      if ( i != null )
      {
        InputAction.inputAction = (int32) i.action;

        InputSignal.BypassDelay.Checked = i.flags.contains( App::Options[ IgnoreDelay ] );
        signal InputSignal.OnBypass;

        InputSignal.Inverted.Checked    = i.flags.contains( App::Options[ Inverted ] );
        InputSignal.Latching.Checked    = i.flags.contains( App::Options[ Latching] );
        InputSignal.Coincidence.Checked = i.flags.contains( App::Options[ Coincidence ] );

        InputSignal.Inverted.Enabled = false;

        if (  i.type == App::ChannelType.FireCallpoint || 
          i.type == App::ChannelType.PanelCallpoint || 
         i.type == App::ChannelType.PanelEvacuate )
         {
             InputSignal.Coincidence.Checked = false;
             InputSignal.Coincidence.Enabled = false;
        }
       
        if ( i.type == App::ChannelType.HeatA1R ||  i.type == App::ChannelType.HeatB ||
          i.type ==  App::ChannelType.Smoke ||  i.type == App::ChannelType.CO )
        {
          InputSignal.Latching.Checked = true;
          InputSignal.Latching.Enabled = false;
        }

        signal InputSignal.OnLatching;

        switch ( i.type )
        {
          case App::ChannelType.PanelAlarmInput, App::ChannelType.PanelCallpoint,
            App::ChannelType.PanelFaultInput, App::ChannelType.PanelSilenceInput, App::ChannelType.PanelRoutingAck :
          
              InputSignal.Inverted.Enabled = true;
        }




        InputDelay.DelaySecs = i.delay;

        DropDownMenu.VerticalList.SelectedItem = ChanIndex;
        DropDownMenu.MenuSelectionText.String = App::Lib.TypeName( i.type );
        DropDownMenu.numItems = device.numinputs;
       }        
    }








     
  }

  $rect <830,299,1030,339>
  property App::DeviceConfig device = null;

  $rect <10,490,210,530>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */


    SaveData( );

    Hide();

  }

  $rect <850,360,1050,400>
  method void SaveData()
  {
    var App::InputChannel i = device.inputs[ ChanIndex ];
        
    if ( i != null )
    {
        i.action = (App::Action) InputAction.inputAction;


        i.flags = i.flags - App::Options[ IgnoreDelay];
        i.flags = i.flags - App::Options[ Inverted ];     
        i.flags = i.flags - App::Options[ Coincidence ];
        i.flags = i.flags - App::Options[ Latching];

        if ( InputSignal.BypassDelay.Checked ) i.flags = i.flags + App::Options[ IgnoreDelay];
        if ( InputSignal.Inverted.Checked )    i.flags = i.flags + App::Options[ Inverted ]; 
        
        if ( InputSignal.Coincidence.Checked ) i.flags = i.flags + App::Options[ Coincidence ];
        if ( InputSignal.Latching.Checked )    i.flags = i.flags + App::Options[ Latching];
     
        i.delay = InputDelay.DelaySecs;
    }
  }

  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder Bounds1 1
  $reorder Rectangle 1
  $reorder Rectangle1 1
  $reorder Rectangle2 1
  $reorder Rectangle4 1
  $reorder Rectangle5 1
  $reorder Rectangle6 1
  $reorder Rectangle7 1
  $reorder Rectangle8 1
  $reorder Show 1
  $reorder mask 1
  $reorder touch 1
  $reorder root 1
  $reorder Hide 1
  $reorder Parent 1
}

$rect <0,1240,200,1280>
$output false
class DropDownMenu : Core::Group
{
  $rect <360,130,560,170>
  inherited property Bounds = <0,0,240,480>;

  $rect <410,240,610,280>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );



    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <400,190,600,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    if ( aState.contains( Core::ViewState[ Enabled ]))
    {
      Rectangle1.Visible = false;
    }
    else
    {
      Rectangle1.Visible = true;
    }

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <520,390,1300,710>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <2,7,188,47>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <0,5,190,49>;
    preset Width = 2;
    preset ColorL = #1C1C1CFF;
    preset ColorR = #BFBFBFFF;
    preset ColorB = #BFBFBFFF;
    preset ColorT = #1C1C1CFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Point4 = <0,1>;
    preset Point3 = <240,1>;
    preset Point2 = <240,50>;
    preset Point1 = <0,50>;
    preset OnRelease = Release;
    preset OnPress = Press;
    preset Enabled = false;
    preset Embedded = true;
  }

  $rect <290,10,490,50>
  slot Press
  {
    sender; /* the method is called from the sender object */

    VerticalList.Visible = !VerticalList.Visible;
    VerticalList.Enabled  = VerticalList.Visible;

    SimpleTouchHandler1.Enabled = VerticalList.Visible;
    SlideTouchHandler.Enabled = VerticalList.Visible;





     
    /*
     Rectangle1.Color = #8BB8E8FF;

        
     Bevel1.ColorB = #BFBFBFFF;
    Bevel1.ColorL = #1C1C1CFF;
     Bevel1.ColorR = #BFBFBFFF;
      Bevel1.ColorT = #1C1C1CFF;   */

  }

  $rect <290,50,490,90>
  slot Release
  {
    sender; /* the method is called from the sender object */

     
     //Rectangle1.Color = #DBDBDBFF;

    // Bevel1.ColorB = #1C1C1CFF;
    //Bevel1.ColorL = #BFBFBFFF;
    // Bevel1.ColorR = #1C1C1CFF;
      //Bevel1.ColorT = #BFBFBFFF;
      
  }

  $rect <20,20,160,60>
  object Views::Text MenuSelectionText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <8,11,185,43>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <250,85,450,125>
  slot Select
  {
    var App::DropMenuItem itm = (App::DropMenuItem) sender;

    MenuSelectionText.String = itm.CaptionText.String;



    VerticalList.Visible = false;
    VerticalList.Enabled = false;
    SimpleTouchHandler1.Enabled = VerticalList.Visible;
    SlideTouchHandler.Enabled = VerticalList.Visible;

    postsignal onSelection;




  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,50,200,480>;
    preset SlideHorz = false;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <0,48,200,480>;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 40;
    preset NoOfItems = 10;
    preset ItemClass = App::DropMenuItem;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler1
  {
    preset Point4 = <0,47>;
    preset Point3 = <200,47>;
    preset Point2 = <200,480>;
    preset Point1 = <0,480>;
    preset OnRelease = ItemRelease;
    preset OnPress = ItemSelect;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset Enabled = false;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <250,175,400,215>
  slot OnLoadItem
  {
    /*


      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var App::DropMenuItem itemView = (App::DropMenuItem)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;
                      
                      
    if ( itemNo == VerticalList.SelectedItem )
    {
      itemView.pressed = true;
     } 
     else
     {
       itemView.pressed = false;
     }
                                    
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );

    if ( GetItemCallback != null )
    {
        itemIndex = itemNo;
        signal GetItemCallback;

      // Configure the item view ...
      if ( itemName != "" )
      {
        itemView.CaptionText.String = itemName;
        itemView.MenuValue = itemValue;
        return;
      }
    }

    itemView.CaptionText.String = "Item "+string(itemNo);






     

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.

  }

  $rect <245,410,445,450>
  property slot onSelection = null;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <189,0,239,55>;
    preset OnPress = Press;
    preset Icon = App::DropDownSimpleBitmap;
    preset Label = "";
    preset Appearance = App::NormalPushButton;
  }

  $rect <700,250,900,290>
  property string itemName = 0;

  $rect <700,290,900,330>
  property slot GetItemCallback = null;

  $rect <890,290,1090,330>
  property int32 itemIndex = 0;

  $rect <530,0,730,40>
  property uint8 numItems = 0;

  $rect <530,40,730,80>
  onset numItems
  {
    // The value doesn't change - nothing to do.
    if ( pure numItems == value )
      return;

    // Remember the property's new value.
    pure numItems = value;

    VerticalList.NoOfItems = numItems;

    var int32 size = VerticalList.ItemHeight * numItems;

    VerticalList.Bounds.y2 = VerticalList.Bounds.y1 + size + 20;

    if ( VerticalList.Bounds.y2 > 480 ) VerticalList.Bounds.y2 = 480;
    SimpleTouchHandler1.Point1.y = VerticalList.Bounds.y2;
    SimpleTouchHandler1.Point2.y = VerticalList.Bounds.y2; 

    Bounds.y2 = VerticalList.Bounds.y2 ;
    VerticalList.Bounds.w = Bounds.w - 20;
     

    // TO DO:
    // 
    // Now you can handle the alternation of the property.ou can handle the alternation of the property.
  }

  $rect <255,310,455,350>
  slot ItemSelect
  {
    sender; /* the method is called from the sender object */

    var int32 itemNo = VerticalList.GetItemAtPosition( SimpleTouchHandler1.CurrentPos );

    //var Application::DropMenuItem v = (Application::DropMenuItem) VerticalList.GetViewForItem( itemNo );

    //if ( v != null ) 
    //{
        VerticalList.SelectedItem = itemNo;
       //v.InvalidateViewState();
                                
      VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );
    //}

  }

  $rect <260,345,460,385>
  slot ItemRelease
  {
    sender; /* the method is called from the sender object */

    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !SimpleTouchHandler1.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( SimpleTouchHandler1.AutoDeflected )
      return;

    var int32 itemNo = VerticalList.GetItemAtPosition( SimpleTouchHandler1.CurrentPos );

     var App::DropMenuItem v = (App::DropMenuItem) VerticalList.GetViewForItem( itemNo );



    if ( itemNo >= 0 )
    {
      // Select the item in the Vertical List. Thereupon the item appears
      // highlighted
      
      VerticalList.SelectedItem = itemNo;
                              
      VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );
     
      MenuSelectionText.String = v.CaptionText.String;
     
      VerticalList.Visible = false;
      VerticalList.Enabled = false;
      SimpleTouchHandler1.Enabled = false;
      SlideTouchHandler.Enabled = false;

      postsignal onSelection;

    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,0,240,55>;
    preset Color = #D9D9D9A3;
  }

  $rect <840,110,1040,150>
  method void SetIndex( arg int32 index )
  {
    itemIndex = index;



    signal GetItemCallback;

      
                                                                                             
    MenuSelectionText.String = itemName;
    VerticalList.SelectedItem = index;
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );

    postsignal onSelection;




  }

  $rect <890,250,1090,290>
  property int32 itemValue = 0;
}

$rect <1300,1210,1520,1250>
$output false
resource Resources::Bitmap DropDownSimpleBitmap
{
  attr bitmapfile FileName = .\Images\dropdown_simple.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1050,620,1200,660>
$output false
class InputActionnop : App::Popup
{
  $rect <820,440,960,480>
  inherited property Bounds = <0,0,800,480>;

  $rect <866,38,1006,78>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 
  }

  $rect <860,235,1000,275>
  inherited method Init()
  {
    // TO DO: Write your code here ... 


    //Writable.TextEditor.ObtainFocus();

    //signal DelaySlot;

      /*
    if (   HorzBarSlider.CurrentValue == 0 )
    {
     RadioButton10.Enabled = false;
      RadioButton11.Enabled = false;
    }
    else
    {
     RadioButton10.Enabled = true;
      RadioButton11.Enabled = true;
     }
        */

  }

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle7
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <10,10,770,450>;
    preset AlphaBlended = false;
  }

  $rect <735,490,935,530>
  property int32 InputAction = 0;

  $rect <470,520,670,560>
  onset InputAction
  {
    // The value doesn't change - nothing to do.
    if ( pure InputAction == value )
      return;

    // Remember the property's new value.
    pure InputAction = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    notifyobservers ^InputAction;

  }

  $rect <450,570,650,610>
  onget InputAction
  {
    return pure InputAction;
  }

  $rect <245,480,445,520>
  slot ChangeInputAction
  {
    Writable.TextEditor.String =  ((Flat::RadioButton)sender).Caption;
    ((Flat::RadioButton)sender).Selected = true;
  }

  $rect <0,525,200,565>
  slot DelaySlot
  {
    sender; /* the method is called from the sender object */

    var int32 i = HorzBarSlider.CurrentValue;
        
    if ( i == 0 )
    {
     RadioButton10.Enabled = false;
    RadioButton11.Enabled = false;
    }   
    else
    {
      RadioButton10.Enabled = true;
    RadioButton11.Enabled = true; 
    }      

    if ( i < 6 )
    {
        Text.String = "Input Delay (" + string( i*10) + " secs)";
    }
    else
    {
        var float f = ( ((float)i - 4.0) * 0.5 ) ;
        Text.String = "Input Delay (" + string( f ) + " mins)";
    }


  }

  $rect <5,495,205,535>
  slot ProceedSlot
  {
    sender; /* the method is called from the sender object */

    var int32 action = InputAction;
    var string location = Writable.TextEditor.String;
    var int32 flags = DelayChoice;

    if ( BypassDelay.Checked )  flags |= 32;
    if ( Inverted.Checked )     flags |= 4;
    if ( Latching.Checked )     flags |= 1;

    var int32 delaytime;
    var int32 i = HorzBarSlider.CurrentValue;

    if ( i < 6 )
    {
        delaytime = i * 10;
    }
    else
    {
        delaytime = ((i - 4) * 30 );

    }


    native ( action, location, flags, delaytime ) 
    {
        Command4( CMD_SET_INPUT_DE



    Hide();

  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton
  {
    preset Bounds = <30,20,180,65>;
    preset Outlet = ^InputAction;
    preset Selected = true;
    preset Label = "Fire";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton1
  {
    preset Bounds = <210,20,360,65>;
    preset OutletSelector = 3;
    preset Outlet = ^InputAction;
    preset Label = "Evacuate";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton2
  {
    preset Bounds = <20,101,170,146>;
    preset OutletSelector = 8;
    preset Outlet = ^InputAction;
    preset Label = "Undefined";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton3
  {
    preset Bounds = <20,144,170,189>;
    preset OutletSelector = 5;
    preset Outlet = ^InputAction;
    preset Label = "Pre Alarm";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton4
  {
    preset Bounds = <20,187,170,232>;
    preset OutletSelector = 2;
    preset Outlet = ^InputAction;
    preset Label = "Fault";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton5
  {
    preset Bounds = <20,360,170,405>;
    preset OutletSelector = 4;
    preset Outlet = ^InputAction;
    preset Label = "Security";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton6
  {
    preset Bounds = <20,317,220,362>;
    preset OutletSelector = 9;
    preset Outlet = ^InputAction;
    preset Label = "Fire Routing Ack";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton7
  {
    preset Bounds = <20,402,170,447>;
    preset OutletSelector = 7;
    preset Outlet = ^InputAction;
    preset Label = "Reset";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton8
  {
    preset Bounds = <20,273,170,318>;
    preset OutletSelector = 1;
    preset Outlet = ^InputAction;
    preset Label = "First Aid";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton9
  {
    preset Bounds = <20,230,195,275>;
    preset OutletSelector = 6;
    preset Outlet = ^InputAction;
    preset Label = "Ack / Silence";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <820,330,1020,370>
  property int32 DelayChoice = 1;

  $rect <820,370,1020,410>
  onset DelayChoice
  {
    // The value doesn't change - nothing to do.
    if ( pure DelayChoice == value )
      return;

    // Remember the property's new value.
    pure DelayChoice = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }
}

$rect <1040,670,1240,710>
$output false
class InputAction : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,595,180>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <80,350,860,670>;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton
  {
    preset Bounds = <10,29,120,77>;
    preset OutletSelector = (int32)App::Action.Fire;
    preset Outlet = ^inputAction;
    preset Selected = true;
    preset Label = "Fire";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton1
  {
    preset Bounds = <139,32,269,77>;
    preset OutletSelector = (int32)App::Action.Evacuation;
    preset Outlet = ^inputAction;
    preset Label = "Evacuate";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton2
  {
    preset Bounds = <452,85,592,132>;
    preset OutletSelector = (int32)App::Action.Undefined;
    preset Outlet = ^inputAction;
    preset Label = "Undefined";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton3
  {
    preset Bounds = <452,29,592,74>;
    preset OutletSelector = (int32)App::Action.General;
    preset Outlet = ^inputAction;
    preset Label = "General";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton4
  {
    preset Bounds = <10,85,160,130>;
    preset OutletSelector = (int32)App::Action.Fault;
    preset Outlet = ^inputAction;
    preset Label = "Fault";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton5
  {
    preset Bounds = <297,29,427,74>;
    preset OutletSelector = (int32)App::Action.Security;
    preset Outlet = ^inputAction;
    preset Label = "Intruder";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton6
  {
    preset Bounds = <140,136,340,181>;
    preset OutletSelector = (int32)App::Action.RoutingAck;
    preset Outlet = ^inputAction;
    preset Label = "Fire Routing Ack";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton7
  {
    preset Bounds = <298,85,448,130>;
    preset OutletSelector = (int32)App::Action.Reset;
    preset Outlet = ^inputAction;
    preset Label = "Reset";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton8
  {
    preset Bounds = <138,85,288,130>;
    preset OutletSelector = (int32)App::Action.FirstAid;
    preset Outlet = ^inputAction;
    preset Label = "First Aid";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton9
  {
    preset Bounds = <10,133,130,181>;
    preset OutletSelector = (int32)App::Action.Silence;
    preset Outlet = ^inputAction;
    preset Label = "Silence";
    preset Appearance = App::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <9,0,290,29>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Input Action";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <590,15>;
    preset Point1 = <150,15>;
    preset Color = #000000FF;
  }

  $rect <600,270,800,310>
  property int32 inputAction = 0;

  $rect <610,230,810,270>
  onset inputAction
  {
    // Remember the property's new value.
    pure inputAction = value;

    var WidgetSet::RadioButton v = (WidgetSet::RadioButton) this.first;

     
      ((App::InputChannels) Owner).InputDelay.TextWarn1.Visible =  ( (App::Action)pure inputAction == App::Action.Silence );
      ((App::InputChannels) Owner).InputDelay.TextWarn4.Visible =  ( (App::Action)pure inputAction == App::Action.Reset );



    while ( v != null )
    {
      if ( v.OutletSelector == value )
      {
          v.Selected = true;
      }
      else
      {
          v.Selected = false;
      }

      v = (WidgetSet::RadioButton) v.next;
    }
         
                                                      

  }
}

$rect <1040,710,1240,750>
$output false
class InputSignal : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,595,80>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <30,300,810,620>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <9,1,180,30>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Input Signal";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <590,16>;
    preset Point1 = <150,16>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Inverted
  {
    preset Bounds = <142,36,264,81>;
    preset Label = "Inverted";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Latching
  {
    preset Bounds = <291,36,411,81>;
    preset OnSwitchOn = OnLatching;
    preset OnSwitchOff = OnLatching;
    preset Label = "Latching";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton BypassDelay
  {
    preset Bounds = <6,36,116,81>;
    preset OnSwitchOn = OnBypass;
    preset OnSwitchOff = OnBypass;
    preset Label = "Bypass Delays";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Coincidence
  {
    preset Bounds = <438,36,588,81>;
    preset Label = "Coincidence only";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <0,150,200,190>
  slot OnBypass
  {
    sender; /* the method is called from the sender object */

    var App::InputChannels i = (App::InputChannels) Owner;

     
    i.InputDelay.TextWarn2.Visible = ( !BypassDelay.Checked && ( i.device.inputs[ i.ChanIndex ].type == App::ChannelType.FireCallpoint || 
          i.device.inputs[ i.ChanIndex ].type == App::ChannelType.PanelCallpoint || 
         i.device.inputs[ i.ChanIndex ].type == App::ChannelType.PanelEvacuate ));
     
  }

  $rect <270,140,470,180>
  slot OnLatching
  {
    sender; /* the method is called from the sender object */

    var App::InputChannels i = (App::InputChannels) Owner;

     
    if ( i != null )
    {

       var App::Action a = (App::Action) i.InputAction.inputAction ;
      i.InputDelay.TextWarn3.Visible = ( !Latching.Checked && ( a == App::Action.Fire ) );
           
    }
     
  }
}

$rect <1040,750,1240,790>
$output false
class InputDelay : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,595,170>;

  $rect <630,130,830,170>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <760,80,960,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <30,300,810,620>;
  }

  $rect <20,20,160,60>
  object Views::Text TitleText
  {
    preset Bounds = <9,-1,140,29>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Input Delay";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <590,14>;
    preset Point1 = <140,14>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <13,31,215,61>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Sustain (0 secs)";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzBarSlider
  {
    preset Bounds = <226,24,585,68>;
    preset OnChange = DelaySlot;
    preset OnEnd = OnSetEnd;
    preset StepSize = 1;
    preset MaxValue = 12;
    preset CurrentValue = 0;
    preset Appearance = App::NormalHorizontalSlider;
  }

  $rect <230,250,390,290>
  slot DelaySlot
  {
    sender; /* the method is called from the sender object */

    var int32 i = HorzBarSlider.CurrentValue;
        
        

    if ( i < 6 )                          
    {
        pure DelaySecs =  i * 10;
        Text.String = "Sustain (" + string( DelaySecs ) + " secs)";
        
    }
    else
    {
        
        pure DelaySecs =  (i - 4) * 30;
        Text.String = "Sustain (" + string( (float)DelaySecs/60.0, 2, 1 ) + " mins)";
    }


  }

  $rect <400,210,600,250>
  property int32 DelaySecs = 0;

  $rect <390,260,590,300>
  onset DelaySecs
  {
     

    // Remember the property's new value.
    pure DelaySecs = value;


    if ( value < 60 )                          
    {
        HorzBarSlider.CurrentValue = value / 10;

        Text.String = "Sustain (" + string( value ) + " secs)";
        
    }
    else
    {
        HorzBarSlider.CurrentValue = ( value / 30 ) + 4;

        Text.String = "Input Delay (" + string( value / 60, 2, 1 ) + " mins)";
    }


    signal OnSetEnd;



    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <45,175,245,215>
  slot OnSetEnd
  {
    sender; /* the method is called from the sender object */

    TextWarn.Visible = ( DelaySecs != 0 );
      
  }

  $rect <20,20,160,60>
  object Views::Text TextWarn
  {
    preset Bounds = <2,72,478,92>;
    preset String = "NOTE: Input delays to fire alarms are outside the specification of EN54.";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #FF0000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextWarn1
  {
    preset Bounds = <-3,91,592,110>;
    preset String = "NOTE: Enabling Silence at level 1 access is considered outside the specification of EN54.";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #FF0000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextWarn2
  {
    preset Bounds = <5,109,580,129>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "NOTE: Disabling 'Bypass Delays' to callpoints is outside the specification of EN54.";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #FF0000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextWarn3
  {
    preset Bounds = <6,129,580,147>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "NOTE: Non latching fire indicators are outside the specification of EN54.";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #FF0000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextWarn4
  {
    preset Bounds = <6,147,580,165>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "NOTE: Allowing Reset at Level 1 is considered outside EN54.";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #FF0000FF;
  }
}

$rect <0,1380,200,1420>
$output false
class BootMenuRes
{
  $rect <20,60,220,100>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font0 = Resources::FontSmall;
  }

  $rect <50,200,250,240>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <40,300,240,340>
  object WidgetSet::PushButton PushButton
  {
    preset IconFrameDisabled = 0;
    preset IconFrame = 0;
    preset Label = "Caption";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <340,100,540,140>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <10,350,210,390>
  object Views::Text Text
  {
    preset Bounds = <0,0,100,30>;
    preset String = "T";
    preset Font = Resources::FontSmall;
  }
}

$rect <200,1380,400,1420>
$output false
autoobject App::BootMenuRes BootMenuRes1;

$rect <0,1430,200,1470>
$output false
class BootMenuComponent : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,300,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    HorizontalValueBar.CurrentValue = 0;
    PushButton.IconFrame = 0;
    PushButton.IconFrameDisabled = -1;
    VerticalScrollbar.ContentArea = 100;
    VerticalScrollbar.ViewArea = 10;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,15,100,45>;
    preset String = "Text";
    preset Font = Resources::FontSmall;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <0,75,200,125>;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Bounds = <231,0,270,190>;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,145,150,195>;
    preset Label = "Caption";
    preset Appearance = WidgetSet::PushButton_Medium;
  }
}

$rect <700,670,900,710>
$output false
class EditDeviceItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,470,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object App::ModifyZoneItem DynamicAreaHead
  {
    preset Bounds = <0,0,470,40>;
    preset Embedded = true;
    preset ZoneNum = 16;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,50,470,200>;
    preset Embedded = false;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 50;
    preset NoOfItems = 10;
    preset ItemClass = App::ModifyDeviceItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <50,310,190,350>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    var Core::VerticalList vlist = (Core::VerticalList) sender;

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = vlist.Item;

     
    var App::ModifyDeviceItem item = (App::ModifyDeviceItem) vlist.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    // Configure the item view ...
    item.UnitNum = itemNo + 1;


    //ZoneText.String = "Zone 15 Unit " + string( itemNo + 1 );

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    item.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );

    var int32 z = zoneNum;
    var int32 u = item.UnitNum;
    var string s = "Somewhere..";
     
    native( z, u )
    {
      Command cmd;

      cmd.int0 = z;
      cmd.int1 = u; 

      Command0( CMD_GET_ZONE_DEVICE, &cmd );
     
      DeviceConfig* d = (DeviceConfig*) cmd.int3;
      
      s = EwNewStringAnsi( d->location );
    }

    item.DescriptionText.String = s;
        
  }

  $rect <690,10,890,50>
  method void LoadZone()
  {
    /* The template just returns the given argument... */

    var string zone;

    if ( OnSetzoneNum == 0 )
    {
      zone = "Panel I/O";
    }
    else
    {
      zone = "Zone " + OnSetzoneNum;
    }

    return;
  }

  $rect <490,30,690,70>
  property int32 zoneNum = 0;

  $rect <490,70,690,110>
  onset zoneNum
  {
    // The value doesn't change - nothing to do.
    if ( pure zoneNum == value )
      return;

    // Remember the property's new value.
    pure zoneNum = value;

    if ( OnSetzoneNum == 0 )
    {
      DynamicAreaHead.Text.String = "Panel I/O";
    }
    else
    {
      DynamicAreaHead.Text.String = "Zone " + OnSetzoneNum;
    }

    var int32 zn = zoneNum;
    var int32 devs = 1;

    native
    {
       Command cmd;

       cmd.int0 = zn

       Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );

       devs = cmd.int1;
    }

    VerticalList.NoOfItems = devs;
    VerticalList.InvalidateItems( 0, devs - 1 );
    VerticalList.InvalidateViewState();

  }
}

$rect <480,1470,720,1510>
$output false
autoobject WidgetSet::ToggleButtonConfig NotmalToggleButton
{
  preset LabelOnColorActive = #000000FF;
  preset LabelOnColorFocused = #000000FF;
  preset LabelOnColorDisabled = #939393FF;
  preset LabelOnColorDefault = #000000FF;
  preset LabelOffColorActive = #000000FF;
  preset LabelOffColorFocused = #000000FF;
  preset LabelOffColorDisabled = #939393FF;
  preset LabelOffColorDefault = #000000FF;
  preset LabelMarginRight = 75;
  preset IconMarginRight = 75;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = Resources::FontMedium;
  preset LabelOffFont = Resources::FontMedium;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToRight];
  preset FaceOnFrameActive = 7;
  preset FaceOnFrameFocused = 5;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 3;
  preset FaceOnActive = WidgetSet::SwitchMedium;
  preset FaceOnFocused = WidgetSet::SwitchMedium;
  preset FaceOnDisabled = WidgetSet::SwitchMedium;
  preset FaceOnDefault = WidgetSet::SwitchMedium;
  preset FaceOffFrameActive = 6;
  preset FaceOffFrameFocused = 4;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 2;
  preset FaceOffActive = WidgetSet::SwitchMedium;
  preset FaceOffFocused = WidgetSet::SwitchMedium;
  preset FaceOffDisabled = WidgetSet::SwitchMedium;
  preset FaceOffDefault = WidgetSet::SwitchMedium;
  preset WidgetMinSize = <70,39>;
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'switch'.
$rect <720,1460,1020,1500>
$output false
autoobject WidgetSet::ToggleButtonConfig Switch_Medium
{
  preset LabelOnColorActive = #6C6E70FF;
  preset LabelOnColorFocused = #6C6E70FF;
  preset LabelOnColorDisabled = #A8ABABFF;
  preset LabelOnColorDefault = #000000FF;
  preset LabelOffColorActive = #6C6E70FF;
  preset LabelOffColorFocused = #6C6E70FF;
  preset LabelOffColorDisabled = #A8ABABFF;
  preset LabelOffColorDefault = #000000FF;
  preset LabelMarginRight = 75;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #A8ABABAA;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #A8ABABAA;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginRight = 75;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = Resources::FontMedium;
  preset LabelOffFont = Resources::FontMedium;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToRight];
  preset FaceOnFrameActive = 7;
  preset FaceOnFrameFocused = 5;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 3;
  preset FaceOnActive = WidgetSet::SwitchMedium;
  preset FaceOnFocused = WidgetSet::SwitchMedium;
  preset FaceOnDisabled = WidgetSet::SwitchMedium;
  preset FaceOnDefault = WidgetSet::SwitchMedium;
  preset FaceOffFrameActive = 6;
  preset FaceOffFrameFocused = 4;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 2;
  preset FaceOffActive = WidgetSet::SwitchMedium;
  preset FaceOffFocused = WidgetSet::SwitchMedium;
  preset FaceOffDisabled = WidgetSet::SwitchMedium;
  preset FaceOffDefault = WidgetSet::SwitchMedium;
  preset WidgetMinSize = <70,39>;
}

$rect <700,630,900,670>
$output false
class ZoneToggle : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    if ( isDevice )
    {
                Image.Visible = true;
                Image1.Visible = false;
                DescriptionText.Visible = true;
                UnitNumberText.Visible = true;
                Text.Visible = false;

                var App::Device device = App::Lib.GetDevice( UnitNum );

                ActionButton.Enabled = device != null;
                ActionButton.Visible = true;
                Timer.Enabled = true;
                             
                UnitNumberText.String = "Zone " + string(ZoneNum) + "  " + App::Lib.Unit( UnitNum );
                
    }
    else if ( isZone )
    {
           Image.Visible = false;
           Image1.Visible = true;
           DescriptionText.Visible = false;
           UnitNumberText.Visible = false;
           Text.Visible = true;
           ActionButton.Enabled = false;
           ActionButton.Visible = false;
           Timer.Enabled = false;

           Text.String = "Zone " + string(ZoneNum) ;
           
          var App::ZoneFlags zf = App::Lib.GetZoneFlags( ZoneNum );

            if ( zf.contains( App::ZoneFlags[ ModifyExpanded ] ) )
          {
             Image1.Bitmap = App::CollapseBitmap;
          }
          else
          {
              Image1.Bitmap = App::ExpandBitmap;
          }   
     }
     else    // neither
     {
               Image.Visible = false;
                Image1.Visible = false;
                DescriptionText.Visible = false;
                UnitNumberText.Visible = false;
                Text.Visible = false;
                ActionButton.Enabled = false;
                ActionButton.Visible = false;
                
                UnitNumberText.String = "";
     }           
    /*
      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Text UnitNumberText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <60,0,200,17>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = App::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <60,15,415,40>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Hallway, Front building 2";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <7,5,37,35>;
    preset Bitmap = App::ExpandBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <60,5,230,36>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 1";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <50,0>;
    preset Point2 = <50,40>;
    preset Point1 = <0,40>;
    preset OnPress = ToggleHandler;
  }

  $rect <670,180,870,220>
  slot ToggleHandler
  {
    sender; /* the method is called from the sender object */

    var App::Modify modify = (App::Modify) Owner.Owner.Owner;

    var App::ZoneFlags zf = App::Lib.GetZoneFlags( ZoneNum );

    if ( zf.contains( App::ZoneFlags[ ModifyExpanded ]) )
    {
       zf = zf - App::ZoneFlags[ ModifyExpanded ];
    }
    else
    {   
       zf = zf + App::ZoneFlags[ ModifyExpanded ];
    }

    App::Lib.SetZoneFlags( ZoneNum, zf );

     
                                                  
      var int32 devs = 4;
      var int32 zone = ZoneNum;

      native( devs, zone )
      {
         devs = get_num_devs_in_zone( zone );
      }


    if ( zf.contains( App::ZoneFlags[ ModifyExpanded ] ) )
    {
      modify.ListViewer.NoOfItems = modify.ListViewer.NoOfItems + devs;
    }
    else
    {
      modify.ListViewer.NoOfItems = modify.ListViewer.NoOfItems - devs;
    }

     
  }

  $rect <690,20,890,60>
  slot EditSlot
  {
    sender; /* the method is called from the sender object */

    var App::ModifyPopup p = new App::ModifyPopup;

    var Core::Root r = GetRoot();

    p.device = App::Lib.GetConfig( UnitNum );
    p.modify = (App::Modify) Owner.Owner;

    if ( p.device != null )
    {
      postsignal p.SetFocus;

      p.Show( GetRoot() );  
    }

    /*

    var string location = "??";
    var uint16 dev = UnitNum;
    var uint8 flags = 0;
    var uint8 vol = 0;
    var uint8 frate = 0;
    var    int32 icount = 0;
    var    int32 ocount = 0;
    var int32 numzones = 32;

    native( location, dev, flags, frate, vol, ocount, icount )
    {
       Command cmd;
       
       Command0( CMD_GET_NUM_ZONE_LEDS, &cmd );
       numzones = cmd.int0;

       cmd.int0 = (int)dev & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );

       if ( cmd.int0 != 0 )
       {
          InputChannel* input;
          OutputChannel* output;

          DeviceConfig* d = (DeviceConfig*) cmd.int0;
       
          location = EwNewStringAnsi( d->location );

          flags = d->flags;
      //    frate = d->flashRate;
      //    vol = d->volume;
         
          for( input = d->input; input < d->input + 16; input++ )
          {
             if ( input->type != 0 ) icount = icount + 1;
          }
          for( output = d->output; output < d->output + 16; output++ )
          {
             if ( output->type != 0 ) ocount = ocount + 1;
          }

        }
        else
        {
          location = EwNewStringAnsi( "???" );
        }
         
     }
    p.DropDownMenu.numItems = numzones;
    p.DropDownMenu.VerticalList.SelectedItem = ZoneNum - 1;

    p.DropDownMenu.MenuSelectionText.String = "Zone " + string( ZoneNum );


    if ( (flags & 1) == 1 )
    { 
      p.ToggleButton.Enabled = true;
      p.SecondsText.Color = #FFFFFFFF;
    }
    else
    {
      p.ToggleButton.Enabled = false;
      p.SecondsText.Color = #999999FF;
    }

    if ((flags & 2) == 2 )
    {
      p.HorizontalSlider.Enabled = true;
      p.VolumeText.Color = #FFFFFFFF;
    }
    else
    {
      p.HorizontalSlider.Enabled = false;
      p.VolumeText.Color = #999999FF;
    }

    //p.Writable.TextEditor.Text.String = location;
    p.Writable.TextEditor.String = location;

    p.HorizontalSlider.CurrentValue = vol;
    p.ToggleButton.Checked = frate == 0;

    if ( icount == 0 )
    {
      p.InputChanButton.Enabled = false;
    }
    else
    {
      p.InputChanButton.Enabled = true;
    }

    if ( ocount == 0 )
    {
      p.OutputChanButton.Enabled = false;
    }
    else
    {
      p.OutputChanButton.Enabled = true;
    }

    //p.Writable.TextEditor.ObtainFocus();
    postsignal p.GetFocus;

    p.Show( GetRoot() );                       */

  }

  $rect <70,80,270,120>
  property uint16 UnitNum = 0;

  $rect <70,130,270,170>
  property uint8 ZoneNum = 0;

  $rect <320,80,520,120>
  property bool isDevice = false;

  $rect <320,125,520,165>
  property bool isZone = false;

  $rect <20,20,160,60>
  object WidgetSet::PushButton ActionButton
  {
    preset Bounds = <420,0,505,40>;
    preset OnRelease = EditSlot;
    preset Label = "Edit";
    preset Appearance = App::NormalPushButton;
  }

  $rect <360,270,560,310>
  object Core::Timer Timer
  {
    preset OnTrigger = TimerSlot;
    preset Period = 1200;
    preset Enabled = true;
  }

  $rect <360,310,560,350>
  slot TimerSlot
  {
    sender; /* the method is called from the sender object */

     if ( Dev != null )
    {
       var int32 chans = Dev.numinputs + Dev.numoutputs;

       if ( chans != 0 )
       {
          imagenum = imagenum + 1;

          imagenum = imagenum % ( Dev.numinputs + Dev.numoutputs );

          if ( imagenum < Dev.numinputs )
          {   
             Image.Bitmap = Dev.inputs[ imagenum ].type;
          }
          else
          {
            var uint8 i = imagenum - Dev.numinputs;
            Image.Bitmap = Dev.outputs[ i ].type;
          }
       }
    }

  }

  $rect <330,200,530,240>
  property App::DeviceConfig Dev = null;

  $rect <630,100,790,140>
  property uint8 imagenum = 0;

  $rect <20,20,160,60>
  object App::ChannelImage Image
  {
    preset Bounds = <512,2,548,38>;
    preset Bitmap = App::ChannelType.None;
  }
}

$rect <260,1220,460,1260>
$output false
class DropMenuItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,220,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <650,60,850,100>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
     
    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    //var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) ;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color  = #AAAAAAFF;
      Border.Visible    = false;
      CaptionText.Color = #888888FF;
    }

    else if ( pressed )
    {
      Background.Color  = #8BB8E8FF;
      Border.Color      = #000000FF;
      Border.Visible    = true;
      CaptionText.Color = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Color  = #FFFFFFFF;
      Border.Color      = #444444FF;
      Border.Visible    = true;
      CaptionText.Color = #000000FF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color  = #FFFFFFFF;
      Border.Visible    = false;
      CaptionText.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    //pressed  = isPressed;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <370,20,590,190>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
    preset Width = 1;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,210,40>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  // State management
  note group Note4
  {
    attr Bounds = <640,30,860,240>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,190,850,230>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,150,850,190>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,110,850,150>
  var bool enabled = true;

  $rect <10,70,210,110>
  property int32 MenuValue = 0;
}

$rect <10,1490,190,1530>
$output false
class ProgressPopup : App::Popup
{
  $rect <0,250,140,290>
  inherited property Bounds = <0,0,430,230>;

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <38,80,368,125>;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <38,43,218,68>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Progress";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <148,149,260,190>;
    preset OnRelease = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <460,20,630,60>
  object Core::Timer UnusedTimer
  {
    preset OnTrigger = CatchBackgroundTap;
    preset Period = 1200;
  }

  $rect <460,60,620,100>
  slot Slot
  {
    sender; /* the method is called from the sender object */


    var int16 prog;

    native ( prog )
    {
      Command cmd;

      Command0( CMD_GET_PROGRESS, &cmd );

      prog = cmd.int0;
    }

    HorizontalValueBar.CurrentValue = prog;


  }

  $rect <170,250,310,290>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

    Visible = false;

    Enabled = false;

    UnusedTimer.Enabled = false;

    if ( PushButton.Label == "Cancel" )
    {
      native  
      {
        Command cmd;

        Command0( CMD_CANCEL_PROGRESS, &cmd );
      }
    }

  }

  $rect <520,140,720,180>
  object Core::SystemEventHandler EndEventHandler
  {
    preset OnEvent = EndProgressEvent;
    preset Event = App::Devices.EndProgressEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <510,220,710,260>
  slot EndProgressEvent
  {
    UnusedTimer.Enabled = false;

    var App::Progress p = (App::Progress) EndEventHandler.Context;


    if ( p.amount == -1  )
    {
     PushButton.Label = "Failed";
     HorizontalValueBar.CurrentValue = 0;
     
    }
    else  
    {
     PushButton.Label = "Success";  
     HorizontalValueBar.CurrentValue = 100; 
    }

     


    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }
}

$rect <1000,540,1200,580>
$output false
class OutputChannels : App::Popup
{
  $rect <820,440,960,480>
  inherited property Bounds = <0,0,800,480>;

  $rect <920,90,1090,130>
  inherited method UpdateLayout()
  {
    // TO DO: Write your code here ... 


    VerticalScrollbar.ContentArea = Outline.GetContentArea( Core::ViewState[ Enabled] ).h + (Outline.CountViews()-1) * Outline.Space;

    VerticalScrollbar.ViewArea = Outline.Bounds.h;

  }

  $rect <860,235,1000,275>
  inherited method Init()
  {
    /*

    var int32 d = DevNumber;
    var int32 c = ChanIndex;
    var int32 z = ZoneNumber;

    var bool bypass = false;
    var bool invert = false;
    var bool latch = false;
    var bool pre = false;

    var int32 delay = 0;
    var int32 action = 0;
    var int32 device;

     native ( z, d, c, bypass, invert, latch, pre, action, delay, device )
     {
        Command cmd;

        cmd.int0 = d;  
        cmd.int1 = z; 

        Command0( CMD_GET_DEVICE, &cmd );

        DEVCONFIG* d = (DEVCONFIG*) cmd.int1;

        INPUTSET* input = d->inputSetting + c;

        bypass = input->flags & DEVICE_OPTION_IGNORE_DELAY;
        invert = input->flags & DEVICE_OPTION_INVERTED;
        latch  = input->flags & DEVICE_OPTION_LATCHING;
        pre    = input->flags & DEVICE_OPTION_HAS_PRE_ALARM;

       
        delay = input->delay;   
        action = input->action;
        device = (int) d;
     }

    this.InputAction1.inputAction = action;
    this.InputSignal.BypassDelay.Checked = bypass;
    this.InputSignal.Inverted.Checked = invert;
    this.InputSignal.Latching.Checked = latch;
    this.InputSignal.PreAlarm.Checked = pre;

    this.InputDelay.HorzBarSlider.CurrentValue = 0; // ?

    var int16 i = 0;
    */
    /*
    while ( i < 16 )
    {
      var int16 type = i + 1;
       native (type, device, i )
       {
          DEVCONFIG* d = (DEVCONFIG*) device;

          INPUTSET* input = d->inputSetting + i;

          type = input->type;
       }
         
       switch ( type )
       {
          case 0 : 
          {
            this.DropDownMenu.numItems = i;
            i = 16;
          }
          case 1 : DropDownMenu.Array[ i] = "Smoke";
          case 2 : DropDownMenu.Array[ i] = "Heat A1R";
          case 3 : DropDownMenu.Array[ i] = "Heat B" ;
          case 4 : DropDownMenu.Array[ i] = "PIR";
          case 5 : DropDownMenu.Array[ i] = "Call point";
          
          default :  DropDownMenu.Array[ i] = "Channel " + string( i + 1);
        }
        i = i + 1;
    }                               
    */ 

  }

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle7
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <10,10,770,450>;
    preset Color = #C3C3C3FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <24,20,130,50>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Channel";
    preset Font = Resources::FontMedium;
    preset Embedded = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Bounds = <177,20,727,440>;
    preset Color = #737373FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Bounds = <729,20,769,440>;
    preset OnScroll = Scroll;
    preset ViewArea = 1000;
    preset ContentArea = 1000;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <177,20,727,440>;
    preset OnSlide = TouchScroll;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <177,20,727,440>;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <30,379,155,434>;
    preset OnRelease = CancelSlot;
    preset Label = "Close";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <177,20,727,440>;
    preset SlideHandler = SlideTouchHandler;
    preset Space = 0;
    preset Formation = Core::Formation.TopToBottom;
  }

  $rect <850,150,1000,190>
  slot Scroll
  {
    sender; /* the method is called from the sender object */

    Outline.ScrollOffset.y = -VerticalScrollbar.Position;

  }

  $rect <20,20,160,60>
  object App::DropDownMenu DropDownMenu
  {
    preset Bounds = <17,20,172,360>;
    preset onSelection = Select;
    preset GetItemCallback = LoadMenu;
  }

  $rect <840,190,990,230>
  slot TouchScroll
  {
    sender; /* the method is called from the sender object */

    VerticalScrollbar.Position = -Outline.ScrollOffset.y;

  }

  $rect <30,80,140,120>
  slot Select
  {
    SaveData( );
     
    ChanIndex = DropDownMenu.VerticalList.SelectedItem;



  }

  $rect <10,130,150,170>
  slot LoadMenu
  {
     
    var App::DropDownMenu m = ( App::DropDownMenu) sender;
     
    if ( device != null )
    { 
      m.itemName = App::Lib.TypeName( device.outputs[ m.itemIndex ].type );
    }
    else m.itemName = "";



  }

  $rect <960,0,1160,40>
  property int32 ChanIndex = 0;

  $rect <960,40,1160,80>
  onset ChanIndex
  {
     

    if ( device != null && value < device.numoutputs )
    {
      // Remember the property's new value.
      pure ChanIndex = value;

      var App::OutputChannel ch = device.outputs[ ChanIndex ];

      if ( ch != null )
      {
         OutputAction.fire.Checked   = ch.actions.contains( App::ActionBits[ Fire ] );
         OutputAction.evac.Checked   = ch.actions.contains( App::ActionBits[ Evacuation ] );
         OutputAction.fault.Checked  = ch.actions.contains( App::ActionBits[ Fault ] );
         OutputAction.aid.Checked    = ch.actions.contains( App::ActionBits[ FirstAid ] );
         OutputAction.pre.Checked    = ch.actions.contains( App::ActionBits[ General ] );
         OutputAction.secure.Checked = ch.actions.contains( App::ActionBits[ Security ] );
         OutputAction.routAck.Checked= ch.actions.contains(  App::ActionBits[ RoutingAck ] );
         
         OutputSignal.ignore.Checked   = ch.flags.contains( App::Options[ NoNightDelays ] );
         OutputSignal.inverted.Checked = ch.flags.contains( App::Options[ Inverted ] );

         if ( ch.type == App::ChannelType.PanelRoutingOutput )
         {
           OutputSignal.silenceable.Checked = false;
           OutputSignal.silenceable.Enabled = false;
         }
         else
         {   
           OutputSignal.silenceable.Checked = ch.flags.contains( App::Options[ Silenceable ] );
           OutputSignal.silenceable.Enabled = true;
         }    


         OutputAction.routAck.Enabled = ( (int32) ch.type >= (int32) App::ChannelType.Output1 && (int32) ch.type <= (int32) App::ChannelType.Output16 );

         if ( !OutputAction.routAck.Enabled )  OutputAction.routAck.Checked = false;
        

         OutputSignal.inverted.Enabled = false;

         switch ( ch.type )
         {
            case App::ChannelType.PanelAlarmRelay 
            , App::ChannelType.PanelFaultRelay 
            ,App::ChannelType.PanelFireRelay  
            ,App::ChannelType.PanelRoutingOutput :      
            {
                OutputSignal.inverted.Enabled = true;
            }
         }

         OutputDelays.globaldelay.Checked = ch.flags.contains( App::Options[ UseGlobalDelays ] );

         OutputDelays.HorzBarSlider.CurrentValue = ch.delay1 / 30;
         OutputDelays.HorzBarSlider1.CurrentValue = ch.delay2 / 30;

         postsignal OutputDelays.HorzBarSlider.OnChange;
         postsignal OutputDelays.HorzBarSlider1.OnChange;
         postsignal OutputDelays.GlobalDelay;

         DropDownMenu.VerticalList.SelectedItem = ChanIndex;
         DropDownMenu.MenuSelectionText.String = App::Lib.TypeName( ch.type );
         DropDownMenu.numItems = device.numoutputs;

         var Core::View v = (Core::View) OutputDelays;

         while ( v.next != null )
         {
            v = v.next;
         }

         while ( v != OutputDelays )
         {
            var Core::View del = v;
            v = v.prev;
            this.Remove( del );
         }

         var int32 n;
         var bool extra = false;
         for ( n = 0; n < device.numparams; n = n + 1 )
         {
            if ( device.params[n] != null )
            {
               var App::Parameter p = device.params[n];

               if ( p.code != App::ParamCode.Unused && p.channel == ChanIndex && p.max != p.min )
               {
                  if ( extra == false )
                  {
                     extra = true;
                     var App::ParamSpecific title = new App::ParamSpecific;
                     title.Embedded = true;
                     Add( title, 123 );
                  }
                  if ( p.max - p.min == 1 )
                  {     
                     var App::ParamToggle tog = new App::ParamToggle;
                     tog.Embedded = true;
                     tog.param = p;
                     tog.Text2.String = p.name;
                     if ( p.value == p.min )
                     {
                        tog.ToggleButton.Checked = false; 
                     }
                     else
                     {
                         tog.ToggleButton.Checked = true;
                     }
                     Add( tog, 123 );
                  }
                  else
                  { 
                     var App::ParamSlider slide = new App::ParamSlider;
                     slide.Embedded = true;
                     slide.param = p;
                     slide.Text2.String = p.name;
                     slide.HorzBarSlider.MinValue = p.min;
                     slide.HorzBarSlider.MaxValue = p.max;
                     slide.HorzBarSlider.CurrentValue = p.value;
                     Add( slide, 123 );
                  }
               }
              
            }        
          }
       //   Outline.ArrangeView( Outline.Bounds, Core::Formation.TopToBottom ) ;
          
          UpdateLayout( this.Bounds.size );
          Outline.EnsureVisible( OutputAction, true, null, null );
       }
    }
     





     
  }

  $rect <20,20,160,60>
  object App::OutputAction OutputAction
  {
    preset Bounds = <180,20,720,150>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object App::OutputSignal OutputSignal
  {
    preset Bounds = <180,158,730,258>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object App::OutputDelays OutputDelays
  {
    preset Bounds = <180,265,730,435>;
    preset Embedded = true;
  }

  $rect <10,500,210,540>
  slot CancelSlot
  {
    SaveData( ); 
                 
    Hide();

  }

  $rect <860,320,1060,360>
  property App::DeviceConfig device = null;

  $rect <820,370,1020,410>
  method void SaveData()
  {
    if ( device != null )
    { 
      var App::OutputChannel ch = device.outputs[ ChanIndex ];

      if ( ch != null )
      {
         ch.actions = App::ActionBits[ ];      // Clear first

         if (OutputAction.fire.Checked )   ch.actions = ch.actions + App::ActionBits[ Fire ];
         if (OutputAction.evac.Checked )   ch.actions = ch.actions + App::ActionBits[ Evacuation ];
         if (OutputAction.fault.Checked )  ch.actions = ch.actions + App::ActionBits[ Fault ];
         if (OutputAction.aid.Checked )    ch.actions = ch.actions + App::ActionBits[ FirstAid ];
         if (OutputAction.pre.Checked )    ch.actions = ch.actions + App::ActionBits[ General ];
         if (OutputAction.secure.Checked ) ch.actions = ch.actions + App::ActionBits[ Security ];
         if (OutputAction.routAck.Checked) ch.actions = ch.actions + App::ActionBits[ RoutingAck ]; 
        
         // Clear first
         ch.flags = ch.flags - App::Options[ NoNightDelays ];
         ch.flags = ch.flags - App::Options[ Inverted ];
         ch.flags = ch.flags - App::Options[ Silenceable ];
         ch.flags = ch.flags - App::Options[ UseGlobalDelays ];

         if (OutputSignal.ignore.Checked )      ch.flags = ch.flags + App::Options[ NoNightDelays ];
         if (OutputSignal.inverted.Checked )    ch.flags = ch.flags + App::Options[ Inverted ];
         if (OutputSignal.silenceable.Checked ) ch.flags = ch.flags + App::Options[ Silenceable ];
         if (OutputDelays.globaldelay.Checked ) ch.flags = ch.flags + App::Options[ UseGlobalDelays ];

         ch.delay1 = OutputDelays.HorzBarSlider.CurrentValue * 30;
         ch.delay2 = OutputDelays.HorzBarSlider1.CurrentValue * 30;

        
         var int32 n;

         var Core::View view = last;
     
         for ( n = device.numparams - 1; n >= 0; n = n - 1 )
         {   
            if ( device.params[n] != null )
            {
               var App::Parameter p = device.params[n];

               if ( p.code != App::ParamCode.Unused && p.channel == ChanIndex )
               {             
                  if ( p.max - p.min == 1 )
                  {     
                     var App::ParamToggle tog = (App::ParamToggle) view;
                     if ( tog.ToggleButton.Checked ) 
                     {
                         p.value = p.max;
                     }
                     else
                     {
                          p.value = p.min;
                     }
                  }
                  else
                  { 
                     var App::ParamSlider slide = (App::ParamSlider) view;
                     
                     p.value = slide.HorzBarSlider.CurrentValue;
                  }
                  view = view.prev;
               }          
            }
          }          
       }
    }
     





     
  }

  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder Bounds1 1
  $reorder Rectangle 1
  $reorder Rectangle1 1
  $reorder Rectangle2 1
  $reorder Rectangle4 1
  $reorder Rectangle5 1
  $reorder Rectangle6 1
  $reorder Rectangle7 1
  $reorder Rectangle8 1
  $reorder Show 1
  $reorder mask 1
  $reorder touch 1
  $reorder root 1
  $reorder Hide 1
  $reorder Parent 1
}

$rect <890,670,1030,710>
$output false
class OutputAction : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,130>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <80,350,860,670>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <9,1,210,30>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Output Action";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <540,16>;
    preset Point1 = <155,16>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton fire
  {
    preset Bounds = <10,37,110,77>;
    preset Label = "Fire";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton evac
  {
    preset Bounds = <130,38,260,78>;
    preset Label = "Evacuate";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton secure
  {
    preset Bounds = <270,35,400,75>;
    preset Label = "Security";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton pre
  {
    preset Bounds = <410,35,540,75>;
    preset Label = "General";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton fault
  {
    preset Bounds = <10,84,110,124>;
    preset Label = "Fault";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton aid
  {
    preset Bounds = <130,85,250,125>;
    preset Label = "First Aid";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton routAck
  {
    preset Bounds = <270,85,390,125>;
    preset Label = "Routing Ack.";
    preset Appearance = App::NormalCheckBox;
  }
}

$rect <900,710,1040,750>
$output false
class OutputSignal : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,100>;

  $rect <630,130,830,170>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <760,80,960,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <30,300,810,620>;
  }

  $rect <630,170,830,210>
  property int32 InputAction = 0;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <9,1,170,30>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Output Signal";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <540,16>;
    preset Point1 = <165,16>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton silenceable
  {
    preset Bounds = <203,43,353,88>;
    preset OnSwitchOn = null;
    preset OnSwitchOff = null;
    preset Label = "Silenceable";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton inverted
  {
    preset Bounds = <3,43,175,88>;
    preset Label = "Active Low / Normally High";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ignore
  {
    preset Bounds = <380,30,550,99>;
    preset OnSwitchOn = null;
    preset OnSwitchOff = null;
    preset Label = "Ignore Delays At Night";
    preset Appearance = App::NormalCheckBox;
  }
}

$rect <900,750,1050,790>
$output false
class OutputDelays : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,180>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <30,300,810,620>;
  }

  $rect <20,20,160,60>
  object Views::Text TitleText
  {
    preset Bounds = <9,-1,160,29>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Output Delays";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <540,15>;
    preset Point1 = <170,15>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <13,38,215,68>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzBarSlider
  {
    preset Bounds = <230,35,543,74>;
    preset OnChange = DelaySlot;
    preset OnEnd = End;
    preset MaxValue = 20;
    preset CurrentValue = 0;
    preset Appearance = App::NormalHorizontalSlider;
  }

  $rect <265,185,465,225>
  slot DelaySlot
  {
    sender; /* the method is called from the sender object */
     
    var int32 i = HorzBarSlider.CurrentValue;
        
        

    var int32 i2 = HorzBarSlider1.CurrentValue;
        


    if ( i + i2 >= 20 ) i2 = 20 - i;


    if ( i == 0 )
    {
      // i2 = 0;
       HorzBarSlider1.Enabled = false;

    }
    else
    {
      HorzBarSlider1.Enabled = true;
    }

    HorzBarSlider1.CurrentValue = i2;


        var float f =  ((float)i * 0.5 ) ;
        
     var float f2 =  ((float)i2 * 0.5 ) ;


         Text.String = "First Delay (" + string( f, 2, 1 ) + " mins)";

        Text1.String = "Investigative Delay (" + string( f2, 2, 1 ) + " mins)";

      

  }

  $rect <470,210,670,250>
  slot End
  {
    sender; /* the method is called from the sender object */

    var int32 i = HorzBarSlider.CurrentValue;
     
        if ( i == 0 ) 
        {
         HorzBarSlider1.CurrentValue = 0;
         HorzBarSlider1.Enabled = false;
        Text1.Color = #888888FF;
         }
         else  
         {
         
         HorzBarSlider1.Enabled = true;
        Text1.Color = #000000FF;
         }
     
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <12,87,225,116>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzBarSlider1
  {
    preset Bounds = <230,83,540,124>;
    preset OnChange = Delay2;
    preset OnEnd = null;
    preset MaxValue = 19;
    preset CurrentValue = 0;
    preset Appearance = App::NormalHorizontalSlider;
  }

  $rect <255,235,455,275>
  slot Delay2
  {
    sender; /* the method is called from the sender object */
     
    var int32 i = HorzBarSlider.CurrentValue;

    var int32 i2 = HorzBarSlider1.CurrentValue;
        

    if ( i + i2 >= 20 ) i = 20 - i2;


    HorzBarSlider.CurrentValue = i;

       var float f =  ((float)i * 0.5 ) ;
        
        var float f2 =  ((float)i2 * 0.5 ) ;

         Text.String = "First Delay (" + string( f, 2, 1 ) + " mins)";

        Text1.String = "Investigative Delay (" + string( f2, 2, 1 ) + " mins)";

        
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton globaldelay
  {
    preset Bounds = <10,130,220,174>;
    preset OnSwitchOn = GlobalDelay;
    preset OnSwitchOff = GlobalDelay;
    preset Label = "Use Global Delay";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <640,80,840,120>
  slot GlobalDelay
  {
    sender; /* the method is called from the sender object */

    HorzBarSlider.Enabled = ! globaldelay.Checked;
    HorzBarSlider1.Enabled = ! globaldelay.Checked;

    if ( globaldelay.Checked )
    {
       Text1.Color = #888888FF;
       Text.Color = #888888FF;
     }
     else
     {
       Text1.Color = #000000FF;
       Text.Color = #000000FF;
    }

    var int32 i = HorzBarSlider.CurrentValue;

    if ( i == 0 )
    {
        HorzBarSlider1.CurrentValue = 0;
        HorzBarSlider1.Enabled = false;
        Text1.Color = #888888FF;
    }    


  }
}

$rect <240,300,380,340>
$output false
class TestZoneItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,615,50>;

  $rect <20,140,220,180>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    Text.String = "Zone " + string( ZoneNum );

    $if ( !$prototyper ) 
    if ( ((App::Application)GetRoot()).LevelAccess.AccessLevel >= 3 )
    {
          PushButton1.Enabled = true;
          PushButton1.Visible = true;
    }
    else
    {
          PushButton1.Enabled = false;
          PushButton1.Visible = false;
    }

    $endif

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Views::Image ExpandImage
  {
    preset Bounds = <10,15,40,45>;
    preset Bitmap = App::ExpandBitmap;
  }

  $rect <310,150,510,190>
  property uint16 ZoneNum = 0;

  $rect <530,70,730,110>
  slot ClearAll
  {
    sender ; /* the method is called from the sender object */

                                                                                        
    var App::ZoneFlags zf = App::Lib.GetZoneFlags( ZoneNum );

     
    zf = zf - App::ZoneFlags[ OnTest];

    var int16 dev;
    var int16 devs = App::Lib.NumDevsInZone( ZoneNum );

    for( dev = 0; dev < devs; dev = dev + 1 )
    {
        var int16 unitnum = App::Lib.GetDevInZone( ZoneNum, dev );

        var App::Device d = App::Lib.GetDevice( unitnum );

        if ( d != null )
        {
           d.settings = d.settings - App::DeviceSetting[ OnTest];

           var uint8 channel;
          
           for( channel = 0; channel < d.flags.size; channel = channel + 1 )
           {
              d.flags[ channel ] = d.flags[ channel ] - App::ChannelFlags[ InputOnTest ];
           }
      
           App::Lib.SetDevice( unitnum, d );
        }
    }


    var App::TreeView testpage = (App::TreeView) Owner.Owner.Owner.Owner;
      
    if ( testpage != null )
    {
      postsignal testpage.Refresh;
      
    }




  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <446,9,531,45>;
    preset OnRelease = ClearAll;
    preset Label = "Clear All";
    preset Appearance = App::SmallPushButton;
  }

  $rect <280,70,480,110>
  slot ToggleSlot
  {
    sender; /* the method is called from the sender object */


    var App::TreeView testpage = (App::TreeView) Owner.Owner.Owner.Owner;

    var App::ZoneFlags zf = App::Lib.GetZoneFlags( ZoneNum );

    if ( ((WidgetSet::ToggleButton) sender).Checked )
    {
      zf = zf + App::ZoneFlags[ OnTest];
    }
    else
    {
      zf = zf - App::ZoneFlags[ OnTest];
    }

    App::Lib.SetZoneFlags( ZoneNum, zf );
     
    if ( testpage != null )
    {
      postsignal testpage.Refresh;
    }                                

  }

  $rect <10,70,210,110>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */

     

    if ( Visible )
    { 
        
      var App::TreeView testpage = (App::TreeView) Owner.Owner.Owner.Owner;
      
      var App::ZoneFlags zf = App::Lib.GetZoneFlags( ZoneNum );

      // if not expanded expand
      if ( !zf.contains( App::ZoneFlags[ TestExpanded ] ) )
      {
        zf = zf + App::ZoneFlags[ TestExpanded ];
      }
      else
      {   
        zf = zf - App::ZoneFlags[ TestExpanded ];
      }

      App::Lib.SetZoneFlags( ZoneNum, zf );
     
      postsignal testpage.Refresh;

      
    }

  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <50,0>;
    preset Point2 = <50,50>;
    preset Point1 = <0,50>;
    preset OnPress = ToggleExpand;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <110,15,210,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <60,0,200,60>;
    preset OnSwitchOn = ToggleSlot;
    preset OnSwitchOff = ToggleSlot;
    preset Label = "";
    preset Appearance = App::LargeCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <546,5,614,49>;
    preset OnRelease = PPUon;
    preset Label = "Drop To PPU";
    preset Appearance = App::SmallPushButton;
  }

  $rect <715,40,915,80>
  slot PPUon
  {
    sender; /* the method is called from the sender object */

    var int32 z = ZoneNum;
    var int32 u = 4095;



    native( z, u )
    {
      Command2( CMD_PPU_MODE, z, u );
    }

  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder ExpandImage 6
  $reorder Enabled 5
}

$rect <129,289,269,329>
$output false
class TestUnitItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,570,50>;

  $rect <40,135,240,175>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var App::Application app = (App::Application) GetRoot(); 

    if ( app != null )
    {
      UnitCheckBox.Enabled = ( app.LevelAccess.AccessLevel >=3 ); 
      PushButton.Enabled =  ( app.LevelAccess.AccessLevel >= 3 ); 
    }

    if ( aState.contains( Core::ViewState[ Enabled ] )  )
    {
        DescriptionText.Color = #000000FF;
        Text.Color = #000000FF;
     
      
        Image1.Visible = true;
      
        UnitCheckBox.Visible = true;

    $if (!$prototyper )  
      PushButton1.Enabled = ( ((App::Application)GetRoot()).LevelAccess.AccessLevel >= 1 );
    $endif  


    $if (!$prototyper )         
        if ( ((App::Application)GetRoot()).LevelAccess.AccessLevel >= 3 )
        {
              PushButton.Enabled =  ( UnitNum < 512 );
              PushButton.Visible = true;
        }
        else
        {
              PushButton.Enabled = false;
              PushButton.Visible = false;
        }
    $endif
    }
    else
    {
        DescriptionText.Color = #AAAAAAFF;
        Text.Color = #AAAAAAFF;
        Image1.Visible = false;
        UnitCheckBox.Enabled = false;
        UnitCheckBox.Visible = false;

       PushButton1.Enabled = false;

    $if (!$prototyper )    
        if ( ((App::Application)GetRoot()).LevelAccess.AccessLevel >= 3 )
        {
              PushButton.Enabled = false;
              PushButton.Visible = true;
        }
        else
        {
              PushButton.Enabled = false;
              PushButton.Visible = false;
        }
    $endif
    }
     

    Text.String = "Zone " + string( ZoneNum) + "  " + App::Lib.Unit( UnitNum);


  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <395,175,595,215>
  property uint16 UnitNum = 0;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <118,1,278,25>;
    preset ColorBL = #000000FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #000000FF;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = App::VerdanaProSemiBold16;
    preset Color = #3D3D3DFF;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <118,21,425,45>;
    preset Ellipsis = true;
    preset ColorBL = #000000FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #000000FF;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "0123456789012345678901234567890123456789";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <29,11,59,41>;
    preset Bitmap = App::ExpandBitmap;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <18,1>;
    preset Point3 = <68,1>;
    preset Point2 = <68,50>;
    preset Point1 = <18,50>;
    preset OnPress = ToggleExpand;
  }

  $rect <340,90,540,130>
  slot ToggleSlot
  {
    sender; /* the method is called from the sender object */


    var App::Application app = (App::Application) GetRoot(); 

    if ( app != null )
    {
      if ( app.LevelAccess.AccessLevel < 3 ) 
      {
          app.LowLevel( 3 );
          return;
      }
    }



    var App::Device d = App::Lib.GetDevice( UnitNum );

    if ( d != null )
    {
      if ( UnitCheckBox.Checked )
      {
        d.settings = d.settings + App::DeviceSetting[ OnTest];
      }
      else
      {
        d.settings = d.settings - App::DeviceSetting[ OnTest];  
      }
      App::Lib.SetDevice( UnitNum, d );
    }


    var App::TreeView testpage = (App::TreeView) Owner.Owner.Owner.Owner;


      
    if ( testpage != null )
    {
      postsignal testpage.Refresh;
    }
     
  }

  $rect <50,75,250,115>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */

     

    if ( Visible )
    {
      var App::TreeView testpage = (App::TreeView) Owner.Owner.Owner.Owner;

      if ( testpage != null )
      {    
        var App::Device d = App::Lib.GetDevice( UnitNum );

        if ( d == null ) return;

        if ( !d.settings.contains( App::DeviceSetting[ TestExpanded ] ) )    
        {          
            d.settings = d.settings + App::DeviceSetting[ TestExpanded ];
        }
        else
        {
            d.settings = d.settings - App::DeviceSetting[ TestExpanded ];    
        }   

        App::Lib.SetDevice( UnitNum, d ); 

        postsignal testpage.Refresh;
     }
    }

  }

  $rect <390,230,590,270>
  property uint8 ZoneNum = 0;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton UnitCheckBox
  {
    preset Bounds = <69,0,125,50>;
    preset Enabled = false;
    preset OnSwitchOn = ToggleSlot;
    preset OnSwitchOff = ToggleSlot;
    preset Label = "";
    preset Appearance = App::SmallCheckBox;
  }

  $rect <665,5,865,45>
  slot PPUon
  {
    sender; /* the method is called from the sender object */




    var int32 z = ZoneNum;
    var int32 u = UnitNum;



    native( z, u )
    {
      Command2( CMD_PPU_MODE, z, u );
    }

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <497,3,561,47>;
    preset Enabled = true;
    preset OnActivate = PPUon;
    preset Label = "Drop to PPU";
    preset Appearance = App::SmallPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <422,3,486,48>;
    preset Enabled = true;
    preset OnActivate = ResetFaults;
    preset Label = "Reset Faults";
    preset Appearance = App::SmallPushButton;
  }

  $rect <665,45,865,85>
  slot ResetFaults
  {
    sender; /* the method is called from the sender object */

    var int32 z = ZoneNum;
    var int32 u = UnitNum;


    native( z, u )
    {
      Command2( CMD_RESET_FAULT, z, u );
    }

  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <400,340,540,380>
$output false
class TestItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,570,50>;

  $rect <50,200,250,240>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <40,135,240,175>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

     
    if ( TestChannelItem.Visible )
    {
      TestChannelItem.InvalidateViewState();
      TestChannelItem.HorizontalLedValueBar.InvalidateViewState();
    }


  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object App::TestUnitItem TestUnitItem
  {
    preset Bounds = <0,0,570,50>;
  }

  $rect <20,20,160,60>
  object App::TestZoneItem TestZoneItem
  {
    preset Bounds = <0,0,570,50>;
  }

  $rect <20,20,160,60>
  object App::TestChannelItem TestChannelItem
  {
    preset Bounds = <0,0,570,50>;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <0,340,120,380>
$output false
class TreeView : Core::Group
{
  $rect <0,550,200,590>
  inherited property Bounds = <0,0,615,365>;

  $rect <10,420,150,460>
  inherited onset Visible
  {
    // TO DO: Write your code here ... 

    super( value );

    postsignal Refresh;

  }

  $rect <0,500,200,540>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


    signal Refresh;


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <210,420,360,460>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    signal onEvent1;

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <585,400,725,440>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */
               

    var Core::VerticalList vlist = ListViewer.VerticalList;

     

    // Get the number of the item to load. The list component takes care of the
    var int32       itemNo   = ListViewer.Item;

     
    var App::TestItem item = (App::TestItem) vlist.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;


    var App::Test test = (App::Test)this.Owner;

    var bool everything = false;

    if ( test != null )
    {
       everything = test.ToggleEverything.Checked;
    }


    native
    {
       if ( Command1( CMD_CHECK_TREE, 0 ) ) return;
    }

    if ( itemNo < 0 )
    {
       item.Visible = false;
       item.InvalidateViewState();
       return;
    }


    var uint8 curZone = 1;

    /* Nilesh added for CYG2-1707 resolution  */
    var uint8  gLastTestModeStatus = false;

    var int32 i = 0;
    var int32 numZones = App::Lib.NumZonesWithDevices();


    while ( numZones > 0 )
    {
        var int32 numdevs = App::Lib.NumDevsInZone( curZone ); 
         
        if ( numdevs > 0 )
        {
            numZones = numZones - 1;

            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );

            if ( itemNo == i )
            {
              item.TestZoneItem.ZoneNum = curZone;
              item.TestZoneItem.Visible = true;
              item.TestZoneItem.Enabled = true;

              item.TestUnitItem.Visible = false;
              item.TestUnitItem.Enabled = false;

              item.TestChannelItem.Visible = false;
              item.TestChannelItem.Enabled = false;

              item.TestZoneItem.ToggleButton.Checked = zf.contains( App::ZoneFlags[ OnTest] ) || everything;    
              item.TestZoneItem.PushButton.Enabled = !item.TestZoneItem.ToggleButton.Checked;

              if ( zf.contains( App::ZoneFlags[ TestExpanded ] ) )
              { 
                  item.TestZoneItem.ExpandImage.Bitmap = App::CollapseBitmap;
              }
              else
              {
                  item.TestZoneItem.ExpandImage.Bitmap = App::ExpandBitmap;
              }
        
              item.TestZoneItem.InvalidateViewState();
              return;
            }
            else
            {
               i = i + 1;
            }

     
            if ( zf.contains( App::ZoneFlags[ TestExpanded ] ) )    // if zone expanded
            {                             
               var int32 dev = 0;

               while ( dev < numdevs )
               {
                  var int16 unitno = App::Lib.GetDevInZone( curZone, dev );
                    
                  var App::Device device = App::Lib.GetDevice( unitno );
                  var App::DeviceConfig config = App::Lib.GetConfig( unitno ); 

                  if ( config == null ) return;

                  if ( i == itemNo )   
                  { 
                      item.TestUnitItem.Visible = true;

                      if ( device.settings.contains( App::DeviceSetting[ TestExpanded ] ) )
                      {
                          item.TestUnitItem.Image1.Bitmap = App::CollapseBitmap; 
                      }
                      else
                      {
                          item.TestUnitItem.Image1.Bitmap = App::ExpandBitmap; 
                      }

                      if ( device == null )
                      {
                          item.TestUnitItem.Enabled = false;
                      }
                      else
                      {
                           item.TestUnitItem.Enabled = true;

                           if (  config.numinputs == 0 )
                           {
                               item.TestUnitItem.UnitCheckBox.Enabled = false;
                               item.TestUnitItem.UnitCheckBox.Checked = false;
                           }
                           else
                          if ( zf.contains( App::ZoneFlags[ OnTest] ) )
                          { 
                              item.TestUnitItem.UnitCheckBox.Enabled = false;
                              item.TestUnitItem.UnitCheckBox.Checked = true;
                              gLastTestModeStatus = true;
                          }
                          else
                          {
                              item.TestUnitItem.UnitCheckBox.Enabled = true;
                              item.TestUnitItem.UnitCheckBox.Checked = device.settings.contains( App::DeviceSetting[ OnTest] );

                              if (zf.contains( App::ZoneFlags[ModifyExpanded]) )
                              {
                                 if((item.TestUnitItem.UnitCheckBox.Checked == false) && (gLastTestModeStatus))
                                 {
                                    gLastTestModeStatus = false;
                                    native
                                    {
                                      Command2(CMD_RESET_FAULT, curZone, unitno);
                                    }
                                 }

                              }

                          }
                      }

                      item.TestZoneItem.Visible = false;
                      item.TestZoneItem.Enabled = false;

                      item.TestChannelItem.Visible = false;
                      item.TestChannelItem.Enabled = false;

                      
                      item.TestUnitItem.UnitNum = unitno;
                      item.TestUnitItem.ZoneNum = curZone;


                      item.TestUnitItem.DescriptionText.String = config.location;             

                      item.TestUnitItem.InvalidateViewState(); 

                      return;
                   }
                   else
                   {
                      i = i + 1;
                   }

                   if ( device != null )
                   if ( device.settings.contains( App::DeviceSetting[ TestExpanded ] ) )   
                   {
                     var int32 chan = 0;

                     for ( chan = 0 ; chan < config.numinputs; chan = chan + 1 )
                     {                      
                        if ( i == itemNo )
                        {
                          item.TestUnitItem.Visible = false;
                          item.TestUnitItem.Enabled = false;

                          item.TestZoneItem.Visible = false;
                          item.TestZoneItem.Enabled = false;

                          item.TestChannelItem.Visible = true;
                          item.TestChannelItem.Enabled = true;


                          item.TestChannelItem.ChanNum = chan;
                          item.TestChannelItem.UnitNum = unitno;
                          item.TestChannelItem.ZoneNum = curZone;

                          item.TestChannelItem.HorizontalLedValueBar.Enabled = true;
                          item.TestChannelItem.HorizontalLedValueBar.Visible = true;

                          if ( device.flags[ chan].contains( App::ChannelFlags[ InputActiveOnTest ] ) )
                          {
                            item.TestChannelItem.HorizontalLedValueBar.CurrentValue = 100;
                          }
                          else
                          {
                            item.TestChannelItem.HorizontalLedValueBar.CurrentValue = 0;
                          }

                          item.TestChannelItem.ToggleButton.Enabled = false;
                          item.TestChannelItem.ToggleButton.Visible = false;
                          item.TestChannelItem.CheckBox.Visible = true;
                          item.TestChannelItem.CheckBox.Enabled = true;

                          item.TestChannelItem.SmallDropDownMenu.Visible = false;
                          item.TestChannelItem.SmallDropDownMenu.Enabled = false;

                          item.TestChannelItem.ChannelName.String = App::Lib.TypeName( config.inputs[ chan ].type );

                           
                          if ( zf.contains( App::ZoneFlags[ OnTest] ) || device.settings.contains( App::DeviceSetting[ OnTest] ) )
                          { 
                              item.TestChannelItem.CheckBox.Enabled = false;
                              item.TestChannelItem.CheckBox.Checked = true;
                          }
                          else
                          {
                              item.TestChannelItem.CheckBox.Enabled = true;    
                              item.TestChannelItem.CheckBox.Checked = device.flags[ chan ].contains( App::ChannelFlags[ InputOnTest] );
                          }
                      
                          if ( config.inputs[ chan ] != null ) 
                          {                    
                             item.TestChannelItem.ChannelImage.Bitmap = config.inputs[ chan ].type;
                          }

                          if (( config.inputs[ chan ].type == App::ChannelType.Smoke ||
                               config.inputs[ chan ].type == App::ChannelType.HeatB || 
                               config.inputs[ chan ].type == App::ChannelType.HeatA1R ||
                               config.inputs[ chan ].type == App::ChannelType.CO )  && chan < device.val.size )
                                 
                          {
                            item.TestChannelItem.PushButton.Visible = true;
                            item.TestChannelItem.Bevel.Visible = true;
                            item.TestChannelItem.Rectangle.Visible = true;
                            item.TestChannelItem.Text.Visible = true;
                            item.TestChannelItem.PushButton.Enabled = true;

                            var uint8 v = device.val[ chan ];

                            if ( v == 0 )
                            {
                              item.TestChannelItem.Text.String = "---";
                            }
                            else
                            {
                              if ( config.inputs[ chan ].type == App::ChannelType.Smoke ) switch ( v )
                              {
                                case 1 : item.TestChannelItem.Text.String = "Faulty Sensor";
                                case 2 : item.TestChannelItem.Text.String = "Dirty Sensor";
                                case 3 : item.TestChannelItem.Text.String = "Faulty/Dirty Sensor";
                                case 4 : item.TestChannelItem.Text.String = "Internal Fault";
                                case 8 : item.TestChannelItem.Text.String = "Internal Fault";
                                default : item.TestChannelItem.Text.String = string( v );
                              }
                              else if ( config.inputs[ chan ].type == App::ChannelType.HeatB ||
                                   config.inputs[ chan ].type == App::ChannelType.HeatA1R )
                               switch ( v )
                              {
                                 case 1 : item.TestChannelItem.Text.String = "Heat Error";
                                 default :  item.TestChannelItem.Text.String = string( v );
                              }
                              else if ( config.inputs[ chan ].type == App::ChannelType.CO ) switch ( v )
                              {
                                 default : item.TestChannelItem.Text.String = string( v );
                              }
                               
                            }
                          }
                          else
                          {
                            item.TestChannelItem.PushButton.Visible = false;
                            item.TestChannelItem.PushButton.Enabled = false;
                            item.TestChannelItem.Bevel.Visible = false;
                            item.TestChannelItem.Rectangle.Visible = false;
                            item.TestChannelItem.Text.Visible = false;
                          }

                          item.TestChannelItem.InvalidateViewState();
                         
                          return;
                        }
                        else
                        {
                           i = i + 1;
                        }
                      }
                              
                      
                      for( chan = 0; chan < config.numoutputs; chan = chan + 1 )
                      {
                         if ( i == itemNo )
                         {
                            item.TestUnitItem.Visible = false;
                            item.TestUnitItem.Enabled = false;

                            item.TestZoneItem.Visible = false;
                            item.TestZoneItem.Enabled = false;    

                            item.TestChannelItem.Visible = true;
                            item.TestChannelItem.Enabled = true;

                            item.TestChannelItem.ChanNum = chan;
                            item.TestChannelItem.UnitNum = unitno;
                            item.TestChannelItem.ZoneNum = curZone;

                            item.TestChannelItem.HorizontalLedValueBar.Visible = false;
                            item.TestChannelItem.HorizontalLedValueBar.Enabled = false;

                            item.TestChannelItem.ToggleButton.Enabled = true;
                            item.TestChannelItem.ToggleButton.Visible = true;

                            item.TestChannelItem.CheckBox.Visible = false;
                            item.TestChannelItem.CheckBox.Enabled = false;

                            item.TestChannelItem.SmallDropDownMenu.Visible = true;
                            item.TestChannelItem.SmallDropDownMenu.Enabled = true;


                            var int32 menu = (int32) device.menuSelection[ chan ];

                            item.TestChannelItem.SmallDropDownMenu.selIndex = menu;
                            item.TestChannelItem.DefaultAction = (App::Profile) menu;
                            item.TestChannelItem.SmallDropDownMenu.Text.String = App::Lib.ProfileName( (App::Profile) menu );  

                            item.TestChannelItem.ChannelName.String = App::Lib.TypeName( config.outputs[ chan].type ); 

                               
                            if ( device.flags[ chan ].contains( App::ChannelFlags[ OutputOnTest ] ) )
                            { 
                                item.TestChannelItem.ToggleButton.Checked = true;
                            }
                            else
                            {
                                item.TestChannelItem.ToggleButton.Checked = false;  
                            }             
                      
                            if ( config.outputs[ chan ] != null ) 
                            {                         
                               item.TestChannelItem.ChannelImage.Bitmap = config.outputs[ chan ].type;  
                            }

                            item.TestChannelItem.PushButton.Visible = false;
                            item.TestChannelItem.PushButton.Enabled = false;
                            item.TestChannelItem.Bevel.Visible = false;
                            item.TestChannelItem.Rectangle.Visible = false;
                            item.TestChannelItem.Text.Visible = false;

                            item.TestChannelItem.InvalidateViewState( );
                            return;
                         }
                         else
                         {
                            i = i + 1;
                         }
                      }         

                     
                  }
                  dev = dev + 1;
              }
           }
         }
         curZone = curZone + 1;
       }

        
        // EEK shouldnt be here
        item.TestUnitItem.Visible = false;
        item.TestZoneItem.Visible = false;
        item.TestChannelItem.Visible = false;
        item.TestUnitItem.Enabled = false;
        item.TestZoneItem.Enabled = false;
        item.TestChannelItem.Enabled = false;
     
     

  }

  $rect <910,340,1140,380>
  object Core::SystemEventHandler SiteLoadedEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = App::Devices.SiteChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <920,380,1070,420>
  slot onEvent1
  {
    var int32 numZones = App::Lib.NumZonesWithDevices();


    var int32 i = 0;
     
     

    ListViewer.NoOfItems = numZones ;
     
     
          
  }

  $rect <620,0,820,40>
  property uint16 unitnum = 0;

  $rect <620,40,820,80>
  property uint16 zonenum = 0;

  $rect <620,100,820,140>
  property slot ZoneSelect = null;

  $rect <620,140,820,180>
  property slot ZoneDeSelect = null;

  $rect <620,180,820,220>
  property slot DeviceDeSelect = null;

  $rect <620,220,820,260>
  property slot DeviceSelect = null;

  $rect <920,0,1120,40>
  object Core::SystemEventHandler OnTestChangeEventHandler
  {
    preset OnEvent = TestChange;
    preset Event = App::Devices.OnTestChangeEvent;
  }

  $rect <390,490,590,530>
  slot CountOnTest
  {
    sender; /* the method is called from the sender object */


    /*

    var int32 i;
    var int32 unitCount = 0;


    var Core::VerticalList lst = (Core::VerticalList) Owner.Owner;

    var int32 zone;

     var int32 numZones = 2;

       native( numZones )
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }


    for( zone = 0; zone < numZones; zone = zone + 1 )
    {   
        unitCount = unitCount + UpdateZone( zone, false );    
    }

     */
    var App::Application app = (App::Application) Owner.Owner;

    if ( app != null )
    {
       postsignal app.OnTest.Refresh;
    } 

  }

  $rect <880,190,1080,230>
  method void j()
  {
    var Core::View view = GetRoot( ).last; 

    while ( view != null )
    {
      var App::SmallDropDownMenuList list = (App::SmallDropDownMenuList) view;

      if ( list != null ) 
      {
        GetRoot().Remove( view );
        return;
       }
      view = view.prev;
    }

  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,615,365>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::TestItem;
    preset ItemHeight = 50;
    preset onScroll = RemoveMenu;
    preset onRefreshAll = RefreshAll;
  }

  $rect <850,250,1050,290>
  slot RemoveMenu
  {
    var Core::View view = GetRoot( ).last; 

    if ( MenuHandle != null && MenuHandle.Owner == GetRoot() )
    {
        GetRoot().Remove( MenuHandle );
        MenuHandle.Owner = null;          
        MenuHandle = null;
    }

  }

  $rect <680,340,880,380>
  property App::SmallDropDownMenuList MenuHandle = null;

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <500,410,640,450>
  slot RefreshAll
  {
       

    var Core::VerticalList vlist = ListViewer.VerticalList;

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo = ListViewer.Item;

     
    var App::TestItem item = (App::TestItem) vlist.first;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    var App::Test test = (App::Test)this.Owner;
    var bool everything = false;

    if ( test != null )
    {
       everything = test.ToggleEverything.Checked;
     
    	 if((everything == 0x00) && (gTestZoneLastStatus == 0x01))
    	 {
    			Command2( CMD_EXIT_TEST, 4095, 4095 );
    	 }
    	 if((everything == 0x00) || (everything == 0x01))
    	 {
    			gTestZoneLastStatus = everything;
    	 }
    }

    native
    {
       if ( Command1( CMD_CHECK_TREE, 0 ) ) return;
    }

    while ( itemNo < 0 )
    {
       item.Visible = false;
       item.InvalidateViewState( );

       item = (App::TestItem) item.next;
       if ( item == null ) return;
       itemNo = itemNo + 1;
    }



    var uint8 curZone = 1;


    var int32 i = 0;
    var int32 numZones = App::Lib.NumZonesWithDevices();


    while ( numZones > 0 )
    {
        var int32 numdevs = App::Lib.NumDevsInZone( curZone ); 
         
        if ( numdevs > 0 )
        {
            numZones = numZones - 1;

            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );

            if ( itemNo == i )
            {
              item.Visible = true;
              item.TestZoneItem.ZoneNum = curZone;
              item.TestZoneItem.Visible = true;
              item.TestZoneItem.Enabled = true;

              item.TestUnitItem.Visible = false;
              item.TestUnitItem.Enabled = false;

              item.TestChannelItem.Visible = false;
              item.TestChannelItem.Enabled = false;

              item.TestZoneItem.ToggleButton.Checked = zf.contains( App::ZoneFlags[ OnTest] ) || everything;    
              item.TestZoneItem.PushButton.Enabled = !item.TestZoneItem.ToggleButton.Checked;

              if (  zf.contains( App::ZoneFlags[ TestExpanded ] ) )
              { 
                  item.TestZoneItem.ExpandImage.Bitmap = App::CollapseBitmap;
              }
              else
              {
                  item.TestZoneItem.ExpandImage.Bitmap = App::ExpandBitmap;
              }
        
              item.TestZoneItem.InvalidateViewState();

              item = (App::TestItem) item.next;

              if ( item == null ) return;
            }
            else
            {
               i = i + 1;
            }

     
            if ( zf.contains( App::ZoneFlags[ TestExpanded ] ) )    // if zone expanded
            {                             
                var int32 dev = 0;

                while ( dev < numdevs )
                {
                  var int16 unitno = App::Lib.GetDevInZone( curZone, dev );
               
                  var App::Device device = App::Lib.GetDevice( unitno );

                  var App::DeviceConfig config = App::Lib.GetConfig( unitno ); 

                  if ( config != null )
                  {  
                      if ( i == itemNo )   
                      { 
                          item.Visible = true;
                          item.TestUnitItem.Visible = true;

                          if ( device.settings.contains( App::DeviceSetting[ TestExpanded ] ) )
                          {
                              item.TestUnitItem.Image1.Bitmap = App::CollapseBitmap; 
                          }
                          else
                          {
                              item.TestUnitItem.Image1.Bitmap = App::ExpandBitmap; 
                          }

                          if ( device == null )
                          {
                              item.TestUnitItem.Enabled = false;
                          }
                          else
                          {
                              item.TestUnitItem.Enabled = true;

                              if (  config.numinputs == 0 )
                              {
                                  item.TestUnitItem.UnitCheckBox.Enabled = false;
                                  item.TestUnitItem.UnitCheckBox.Checked = false;
                              }
                              else
                              if ( zf.contains( App::ZoneFlags[ OnTest] ) )
                              { 
                                  item.TestUnitItem.UnitCheckBox.Enabled = false;
                                  item.TestUnitItem.UnitCheckBox.Checked = true;
                              }
                              else
                              {
                                  item.TestUnitItem.UnitCheckBox.Enabled = true;
                                  item.TestUnitItem.UnitCheckBox.Checked = device.settings.contains( App::DeviceSetting[ OnTest] );
                              }
                          }

                          
                          item.TestZoneItem.Visible = false;
                          item.TestZoneItem.Enabled = false;

                          item.TestChannelItem.Visible = false;
                          item.TestChannelItem.Enabled = false;

                      
                          item.TestUnitItem.UnitNum = unitno;
                          item.TestUnitItem.ZoneNum = curZone;


                          item.TestUnitItem.DescriptionText.String = config.location;             

                          item.TestUnitItem.InvalidateViewState(); 

                          item = (App::TestItem) item.next;

                          if ( item == null ) return;
                       }
                       else
                       {
                          i = i + 1;
                       }

                       if ( device != null )
                       if ( device.settings.contains( App::DeviceSetting[ TestExpanded ] ) )   
                       {
                           var int32 chan = 0;

                           for ( chan = 0 ; chan < config.numinputs; chan = chan + 1 )
                           {                      
                              if ( i == itemNo )
                              {
                                  item.Visible = true;
                                  item.TestUnitItem.Visible = false;
                                  item.TestUnitItem.Enabled = false;

                                  item.TestZoneItem.Visible = false;
                                  item.TestZoneItem.Enabled = false;

                                  item.TestChannelItem.Visible = true;
                                  item.TestChannelItem.Enabled = true;


                                  item.TestChannelItem.ChanNum = chan;
                                  item.TestChannelItem.ChanType = config.inputs[ chan ].type;

                                  item.TestChannelItem.UnitNum = unitno;
                                  item.TestChannelItem.ZoneNum = curZone;

                                  item.TestChannelItem.HorizontalLedValueBar.Enabled = true;
                                  item.TestChannelItem.HorizontalLedValueBar.Visible = true;

                                  if ( device.flags[ chan].contains( App::ChannelFlags[ InputActiveOnTest ] ) )
                                  {
                                    item.TestChannelItem.HorizontalLedValueBar.CurrentValue = 100;
                                  }
                                  else
                                  {
                                    item.TestChannelItem.HorizontalLedValueBar.CurrentValue = 0;
                                  }

                                  item.TestChannelItem.ToggleButton.Enabled = false;
                                  item.TestChannelItem.ToggleButton.Visible = false;
                                  item.TestChannelItem.CheckBox.Visible = true;
                                  item.TestChannelItem.CheckBox.Enabled = true;

                                  item.TestChannelItem.SmallDropDownMenu.Visible = false;
                                  item.TestChannelItem.SmallDropDownMenu.Enabled = false;

                                  
                                  item.TestChannelItem.ChannelName.String = App::Lib.TypeName( item.TestChannelItem.ChanType );

                                  if (( item.TestChannelItem.ChanType == App::ChannelType.Smoke ||
                                       item.TestChannelItem.ChanType == App::ChannelType.HeatB || 
                                       item.TestChannelItem.ChanType == App::ChannelType.HeatA1R ||
                                       item.TestChannelItem.ChanType == App::ChannelType.CO )  && chan < device.val.size )
                                 
                                  {
                                    item.TestChannelItem.PushButton.Visible = true;
                                    item.TestChannelItem.Bevel.Visible = true;
                                    item.TestChannelItem.Rectangle.Visible = true;
                                    item.TestChannelItem.Text.Visible = true;
                                    item.TestChannelItem.PushButton.Enabled = true;

                                    var uint8 v = device.val[ chan ];

                                    if ( v == 0 )
                                    {
                                      item.TestChannelItem.Text.String = "---";
                                    }
                                    else
                                    {
                                      if ( config.inputs[ chan ].type == App::ChannelType.Smoke ) switch ( v )
                                      {
                                        case 1 : item.TestChannelItem.Text.String = "Faulty Sensor";
                                        case 2 : item.TestChannelItem.Text.String = "Dirty Sensor";
                                        case 3 : item.TestChannelItem.Text.String = "Faulty/Dirty Sensor";
                                        case 4 : item.TestChannelItem.Text.String = "Internal Fault";
                                        case 8 : item.TestChannelItem.Text.String = "Internal Fault";
                                        default : item.TestChannelItem.Text.String = string( v );
                                      }
                                      else if ( config.inputs[ chan ].type == App::ChannelType.HeatB ||
                                      item.TestChannelItem.ChanType == App::ChannelType.HeatA1R ) switch ( v )
                                      {
                                         case 1 : item.TestChannelItem.Text.String = "Heat Error";
                                         default :  item.TestChannelItem.Text.String = string( v ) ;
                                      }
                                      else if ( config.inputs[ chan ].type == App::ChannelType.CO ) switch ( v )
                                      {
                                         default : item.TestChannelItem.Text.String = string( v );
                                      }
                                    }
                                  }
                                  else
                                  {
                                    item.TestChannelItem.PushButton.Visible = false;
                                    item.TestChannelItem.PushButton.Enabled = false;
                                    item.TestChannelItem.Bevel.Visible = false;
                                    item.TestChannelItem.Rectangle.Visible = false;
                                    item.TestChannelItem.Text.Visible = false;
                                  }

                           
                                  if ( zf.contains( App::ZoneFlags[ OnTest] ) || device.settings.contains( App::DeviceSetting[ OnTest] ) )
                                  { 
                                      item.TestChannelItem.CheckBox.Enabled = false;
                                      item.TestChannelItem.CheckBox.Checked = true;
                                  }
                                  else
                                  {
                                      item.TestChannelItem.CheckBox.Enabled = true;    
                                      item.TestChannelItem.CheckBox.Checked = device.flags[ chan ].contains( App::ChannelFlags[ InputOnTest] );
                                  }
                      
                                  if ( config.inputs[ chan ] != null ) 
                                  {                    
                                     item.TestChannelItem.ChannelImage.Bitmap = config.inputs[ chan ].type;
                                  }

                                  item.TestChannelItem.InvalidateViewState();
                         
                                  item = (App::TestItem) item.next;

                                  if ( item == null ) return;
                              }
                              else
                              {
                                 i = i + 1;
                              }
                          }
                              
                 
                        
                          for( chan = 0; chan < config.numoutputs; chan = chan + 1 )
                          {
                             if ( i == itemNo )
                             {
                                item.Visible = true;
                                item.TestUnitItem.Visible = false;
                                item.TestUnitItem.Enabled = false;

                                item.TestZoneItem.Visible = false;
                                item.TestZoneItem.Enabled = false;    

                                item.TestChannelItem.Visible = true;
                                item.TestChannelItem.Enabled = true;

                                item.TestChannelItem.ChanNum = chan;
                                item.TestChannelItem.UnitNum = unitno;
                                item.TestChannelItem.ZoneNum = curZone;

                                item.TestChannelItem.HorizontalLedValueBar.Visible = false;
                                item.TestChannelItem.HorizontalLedValueBar.Enabled = false;

                                item.TestChannelItem.ToggleButton.Enabled = true;
                                item.TestChannelItem.ToggleButton.Visible = true;

                                item.TestChannelItem.CheckBox.Visible = false;
                                item.TestChannelItem.CheckBox.Enabled = false;

                                item.TestChannelItem.SmallDropDownMenu.Visible = true;
                                item.TestChannelItem.SmallDropDownMenu.Enabled = true;

                                item.TestChannelItem.SmallDropDownMenu.selIndex = device.menuSelection[ chan];
                                item.TestChannelItem.SmallDropDownMenu.Text.String = App::Lib.ProfileName( (App::Profile) item.TestChannelItem.SmallDropDownMenu.selIndex );
     
                                item.TestChannelItem.DefaultAction = (App::Profile) item.TestChannelItem.SmallDropDownMenu.selIndex;
                               
                                item.TestChannelItem.ChannelName.String = App::Lib.TypeName( config.outputs[ chan].type ); 

                               
                                if ( device.flags[ chan ].contains( App::ChannelFlags[ OutputOnTest ] ) )
                                { 
                                    item.TestChannelItem.ToggleButton.Checked = true;
                                }
                                else
                                {
                                    item.TestChannelItem.ToggleButton.Checked = false;  
                                }             
                      
                                if ( config.outputs[ chan ] != null ) 
                                {                         
                                   item.TestChannelItem.ChannelImage.Bitmap = config.outputs[ chan ].type;  
                                }

                                item.TestChannelItem.PushButton.Visible = false;
                                item.TestChannelItem.PushButton.Enabled = false;
                                item.TestChannelItem.Bevel.Visible = false;
                                item.TestChannelItem.Rectangle.Visible = false;
                                item.TestChannelItem.Text.Visible = false;

                                item.TestChannelItem.InvalidateViewState( );

                                item = (App::TestItem) item.next;

                                if ( item == null ) return;
                             }
                             else
                             {
                                i = i + 1;
                             }
                          }         
                      }
                     
                  }
                  dev = dev + 1;
              }
           }
        }
        curZone = curZone + 1;   
    }

    while ( item != null )
    {
       item.Visible = false;
       item.InvalidateViewState( );

       item = (App::TestItem) item.next;
     
    }

        
  }

  $rect <910,80,1170,120>
  object Core::SystemEventHandler MeshListChangeEventHandler
  {
    preset OnEvent = Refresh;
    preset Event = App::Devices.MeshListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <950,40,1150,80>
  slot TestChange
  {
    if ( Visible )
      signal ListViewer.onRefreshAll;




    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <880,120,1020,160>
  slot Refresh
  {
     

    if ( Visible )
    {
       
      var int32 num = 0;

      native( num )
      {
        Command cmd;

        Command0( CMD_GET_NUM_TEST, &cmd );

        num = cmd.int0;
      }

     
      ListViewer.NoOfItems = num;


      signal CountOnTest;

    }    
  }

  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
}

$rect <250,340,400,380>
$output false
class TestChannelItem : Core::Group
{
  $rect <25,285,225,325>
  inherited property Bounds = <0,0,570,50>;

  $rect <35,340,215,380>
  inherited method UpdateViewState()
  {
    var App::Application app = (App::Application) GetRoot();

    if ( app != null )
    {
      CheckBox.Enabled = ( app.LevelAccess.AccessLevel >=3 ); 
      ToggleButton.Enabled =  ( app.LevelAccess.AccessLevel >= 3 ); 
    }


    /*
    var App::ZoneFlags zf = App::Lib.GetZoneFlags( ZoneNum );
    var App::Device d = App::Lib.GetDevice( UnitNum );
     
    if ( d != null )
    {
       
      if ( zf.contains( App::ZoneFlags[ OnTest] ) || d.settings.contains( App::DeviceSetting[ OnTest] ) )
      { 
          this.CheckBox.Enabled = false;
          this.CheckBox.Checked = true;
      }
      else
      {
          CheckBox.Enabled = true;
        
          CheckBox.Checked = d.flags[ ChanNum ].contains( App::ChannelFlags[ OnTest] );
      }
    }

    var App::DeviceConfig conf = App::Lib.GetConfig( UnitNum );


    if ( conf != null && conf.outputs[ ChanNum ] != null ) 
    {
        if ( ToggleButton.Visible )
        {
            Image.Bitmap = App::Lib.TypeBitmap( conf.outputs[ ChanNum ].type );
        }
        else
        {
            Image.Bitmap = App::Lib.TypeBitmap( conf.inputs[ ChanNum ].type );
        }
    }
      */

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Views::Text ChannelName
  {
    preset Bounds = <90,10,280,40>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalLedValueBar
  {
    preset Bounds = <460,10,510,42>;
    preset MaxValue = 1;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <0,70,200,110>
  property uint8 ChanNum = 0;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <457,0,507,50>;
    preset OnSwitchOn = OnSlot;
    preset OnSwitchOff = OffSlot;
    preset Label = "";
    preset Appearance = WidgetSet::Switch_Small;
  }

  $rect <0,110,200,150>
  property uint16 UnitNum = 0;

  $rect <330,60,530,100>
  slot OnSlot
  {
    sender; /* the method is called from the sender object */
     
     
    if (  ToggleButton.Visible )
    {
      App::Lib.SwitchOutput( UnitNum, ChanNum, DefaultAction, true ) ;
    }



  }

  $rect <525,65,725,105>
  slot OffSlot
  {
    sender; /* the method is called from the sender object */
     
    App::Lib.SwitchOutput( UnitNum, ChanNum, DefaultAction, false );


  }

  $rect <20,20,160,60>
  object App::SmallDropDownMenu SmallDropDownMenu
  {
    preset Bounds = <300,5,425,45>;
    preset onSelection = MenuSelection;
    preset GetItemCallback = LoadNames;
    preset numItems = 8;
  }

  $rect <505,135,705,175>
  slot LoadNames
  {
    sender; /* the method is called from the sender object */

    var App::SmallDropDownMenuList menu = (App::SmallDropDownMenuList) sender;

    if ( menu != null )
    {
      menu.itemName = App::Lib.ProfileName( (App::Profile) menu.itemIndex );
    }
     
  }

  $rect <0,150,200,190>
  property App::Profile DefaultAction = App::Profile.Fire;

  $rect <315,220,515,260>
  slot ToggleChannel
  {
    sender; /* the method is called from the sender object */

     

    var App::Device d = App::Lib.GetDevice( UnitNum );

    if ( d != null )
    {
      if ( CheckBox.Checked )
      {
        d.flags[ ChanNum ] = d.flags[ ChanNum ] + App::ChannelFlags[ InputOnTest ];
      }
      else
      {
        d.flags[ ChanNum ] = d.flags[ ChanNum ] - App::ChannelFlags[ InputOnTest ];   
      }
      App::Lib.SetDevice( UnitNum, d );
    }


    var App::TreeView testpage = (App::TreeView) Owner.Owner.Owner.Owner;
      
    if ( testpage != null )                 
    {
      signal testpage.Refresh;
    }

  }

  $rect <5,190,205,230>
  property uint8 ZoneNum = 0;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton CheckBox
  {
    preset Bounds = <40,0,90,50>;
    preset OnSwitchOn = ToggleChannel;
    preset OnSwitchOff = ToggleChannel;
    preset Label = "";
    preset Appearance = App::SmallCheckBox;
  }

  $rect <310,130,510,170>
  slot MenuSelection
  {
    sender; /* the method is called from the sender object */

    var App::Device d = App::Lib.GetDevice( UnitNum );

    if ( d != null )
    {

      d.menuSelection[ ChanNum ] = (uint8) SmallDropDownMenu.list.VerticalList.SelectedItem ;

      App::Lib.SetDevice( UnitNum, d );

      DefaultAction = (App::Profile) SmallDropDownMenu.list.VerticalList.SelectedItem;
    }


  }

  $rect <20,20,160,60>
  object App::ChannelImage ChannelImage
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <530,7,566,43>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <270,7,345,42>;
    preset OnActivate = ReadSlot;
    preset Label = "Read";
    preset Appearance = App::SmallPushButton;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <350,5,450,45>;
    preset Width = 2;
    preset ColorL = #8E8E8EFF;
    preset ColorR = #FFFFFFFF;
    preset ColorB = #FFFFFFFF;
    preset ColorT = #707070FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <352,7,448,43>;
    preset Color = #E8E8E8FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <350,9,449,41>;
    preset WrapText = true;
    preset String = "";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <785,15,985,55>
  slot ReadSlot
  {
    sender; /* the method is called from the sender object */

    var string val;

    var uint8 c = (uint8) ChanType;
    var uint16 u = UnitNum;

    Text.String = ".....";

    native( c, u )
    {
       Command cmd;

       cmd.int0 = u;
       cmd.int1 = c;

       Command0( CMD_GET_ANALOGUE_VALUE, &cmd );
     
    }





  }

  $rect <15,245,215,285>
  property App::ChannelType ChanType = App::ChannelType.None;

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <0,1170,200,1210>
$output false
class SmallDropDownMenu : Core::Group
{
  $rect <360,130,560,170>
  inherited property Bounds = <0,0,135,40>;

  $rect <410,240,610,280>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );



    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <400,190,600,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <25,225,165,265>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    list = new App::SmallDropDownMenuList;

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <490,330,1270,650>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <2,5,95,35>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <0,5,95,35>;
    preset Width = 2;
    preset ColorL = #1C1C1CFF;
    preset ColorR = #BFBFBFFF;
    preset ColorB = #BFBFBFFF;
    preset ColorT = #1C1C1CFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Point4 = <0,0>;
    preset Point3 = <135,0>;
    preset Point2 = <135,40>;
    preset Point1 = <0,40>;
    preset OnRelease = null;
    preset OnPress = Press;
    preset Enabled = false;
    preset Embedded = true;
  }

  $rect <290,10,490,50>
  slot Press
  {
    sender; /* the method is called from the sender object */

    var App::TreeView test = (App::TreeView) Owner.Owner.Owner.Owner.Owner;


    if ( test.MenuHandle != null )
    {
     

      if (test.MenuHandle.Owner != null )
      {
        GetRoot().Remove( test.MenuHandle );
        test.MenuHandle.Owner = null;
      }
     }

      if ( list.Owner != GetRoot() )
      {    
         var point p = GlobalPosition( Bounds.origin );
         list.Bounds.origin.x = Bounds.origin.x + 12;

         if ( p.y > 250 )
         {
            list.Bounds.origin.y = p.y - numItems * 35;
         }
         else
         {
             list.Bounds.origin.y = p.y + 32;
         }
         list.numItems = numItems;
         list.GetItemCallback = GetItemCallback;
         list.onSelection = onSelection;
         list.VerticalList.SelectedItem = selIndex;
         list.parent = this;
         list.InvalidateViewState();

       

         test.MenuHandle = list;
         
        GetRoot().Add( list, 0 );

      
      }
      else
      {
        HideList();
      }



    //VerticalList.Visible = !VerticalList.Visible;
    //VerticalList.Enabled  = VerticalList.Visible;






     
    /*
     Rectangle1.Color = #8BB8E8FF;

        
     Bevel1.ColorB = #BFBFBFFF;
    Bevel1.ColorL = #1C1C1CFF;
     Bevel1.ColorR = #BFBFBFFF;
      Bevel1.ColorT = #1C1C1CFF;   */

  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <5,5,90,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <250,330,450,370>
  property slot onSelection = null;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <95,0,136,40>;
    preset OnPress = Press;
    preset Icon = App::DropDownSimpleBitmap;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <700,290,900,330>
  property slot GetItemCallback = null;

  $rect <530,0,730,40>
  property uint8 numItems = 0;

  $rect <20,60,390,100>
  property App::SmallDropDownMenuList list = null;

  $rect <700,130,900,170>
  method void HideList()
  {
     

    if (list.Owner != null )
    {
      GetRoot().Remove( list );
      list.Owner = null;
    }

     
  }

  $rect <20,350,220,390>
  property int32 selIndex = 0;
}

$rect <250,1150,450,1190>
$output false
class SmallDropMenuItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,90,35>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <650,60,850,100>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
     
    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) ;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color  = #AAAAAAFF;
      Border.Visible    = false;
      CaptionText.Color = #888888FF;
    }

    else if ( isPressed )
    {
      Background.Color  = #8BB8E8FF;
      Border.Color      = #000000FF;
      Border.Visible    = true;
      CaptionText.Color = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Color  = #DDDDDDFF;
      Border.Color      = #444444FF;
      Border.Visible    = true;
      CaptionText.Color = #000000FF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color  = #DDDDDDFF;
      Border.Visible    = false;
      CaptionText.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <370,20,590,190>;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <380,140,580,180>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <380,100,580,140>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;
     
     
    pressed = false;


      var Core::View v = Owner.first;
       var int32 sel = 0;

       while ( v != null )
       {
          var App::SmallDropMenuItem i = ( App::SmallDropMenuItem) v;

          if ( i != null )
          {
               if ( i == this )
               {
                   ((Core::VerticalList) Owner ).SelectedItem = sel;
               }
               else
               {
                   sel = sel + 1;
               }
          }
          v = v.next;
      }
                                  
    InvalidateViewState();
        
        postsignal OnActivate;

  }

  // This internal slot method is called when the user touches the item's area.
  $rect <380,60,580,100>
  slot onPressTouch
  {
    // Clicking on a menu item focuses (selects) the item. If you don't want it,
    // remove the following code line.
    Owner.Focus = this;

     
    pressed = true;


    InvalidateViewState();


  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,90,35>;
    preset Color = #DBDBDBFF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,90,35>;
    preset Width = 1;
    preset Color = #000000FF;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,35>;
    preset Point3 = <95,35>;
    preset Point2 = <95,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <4,0,89,35>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  // State management
  note group Note4
  {
    attr Bounds = <640,30,860,240>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,190,850,230>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,150,850,190>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,110,850,150>
  var bool enabled = true;

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <100,100,300,140>
  property slot OnActivate = null;
}

$rect <0,1130,230,1170>
$output false
class SmallDropDownMenuList : Core::Group
{
  $rect <360,130,560,170>
  inherited property Bounds = <0,0,78,320>;

  $rect <410,240,610,280>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );



    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <400,190,600,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <490,330,1270,650>;
  }

  $rect <250,85,450,125>
  slot Select
  {
    var App::SmallDropMenuItem itm = (App::SmallDropMenuItem) sender;
                                            
    if ( parent != null )
    {
      parent.Text.String = itm.CaptionText.String;
       
    }
     
    GetRoot().Remove( this );


    postsignal onSelection;




  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,78,320>;
    preset SlideHorz = false;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <250,175,400,215>
  slot OnLoadItem
  {
    /*


      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var App::SmallDropMenuItem itemView = (App::SmallDropMenuItem)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    itemView.OnActivate = Select;
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );

    if ( GetItemCallback != null )
    {
        itemIndex = (App::Profile) itemNo;
        signal GetItemCallback;

      // Configure the item view ...
      if ( itemName != "" )
      {
        itemView.CaptionText.String = itemName;
      
        return;
      }
    }

    itemView.CaptionText.String = "i" + string(itemNo) ;

     





     

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.

  }

  $rect <150,420,350,460>
  property slot onSelection = null;

  $rect <700,250,900,290>
  property string itemName = 0;

  $rect <700,290,900,330>
  property slot GetItemCallback = null;

  $rect <890,290,1090,330>
  property App::Profile itemIndex = App::Profile.Fire;

  $rect <530,0,730,40>
  property uint8 numItems = 0;

  $rect <530,40,730,80>
  onset numItems
  {
    // The value doesn't change - nothing to do.
    if ( pure numItems == value )
      return;

    // Remember the property's new value.
    pure numItems = value;

    VerticalList.NoOfItems = numItems;

    var int32 size = VerticalList.ItemHeight * numItems;

    Bounds.y2 = Bounds.y1 + size + 20;

    if ( Bounds.y2 > 480 ) Bounds.y2 = 480;

     
    VerticalList.InvalidateItems( 0, numItems-1 );
     
                                            
    // TO DO:
    // 
    // Now you can handle the alternation of the property.ou can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,78,322>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 35;
    preset NoOfItems = 10;
    preset ItemClass = App::SmallDropMenuItem;
  }

  $rect <90,0,290,40>
  property App::SmallDropDownMenu parent = null;
}

$rect <0,220,110,260>
$output false
class Faults : Core::Group
{
  $rect <10,470,210,510>
  inherited property Bounds = <0,0,795,365>;

  $rect <10,430,210,470>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var App::Application app = (App::Application) this.Owner;

    $if (!$prototyper)

    ConfirmEventButton.Enabled = ( app.LevelAccess.AccessLevel > 1);

    $endif

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <860,105,1000,145>
  inherited method Init()
  {
    // TO DO: Write your code here ... 


    postsignal onEvent;


  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <830,290,1020,330>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;
    var App::FaultItem item = (App::FaultItem) ListViewer.VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    if ( itemNo < 0 )
    {
       item.Visible = false;
       item.InvalidateViewState();
       return;
    }

    item.Visible = true;

     
    var string time = "";                            
    var string desc = "Fault.";
    var string location = "" ;
    var int32 unt = 1;
    var int32 zone = 1;
    var App::ChannelType chan = App::ChannelType.HeatA1R;

          
    native( time, desc, location, itemNo, unt, zone, item )
    {
       Command cmd;

       cmd.int0 = itemNo;
       if ( Command0( CMD_GET_FAULT_ITEM, &cmd ) == CMD_OK )
       {
         if ( cmd.int1 != 0 )
         {
            desc = EwNewStringAnsi( (char*)cmd.int1 );
         }
         else
         {
             CoreGroup_OnSetVisible((CoreGroup)item, 0 );
             CoreGroup_InvalidateViewState((CoreGroup)item );
             return;
         }
         
         if ( cmd.int3 != 0 ) time = EwNewStringAnsi( (char*)cmd.int3 );

         if ( cmd.int2 != 0 )
         {
            location = EwNewStringAnsi( (char*)cmd.int2 );
         }
         else
         { 
          location = NULL;
         }

        

         zone = cmd.char0;
         chan = cmd.char1;
         unt = cmd.ushort1;
         zone = cmd.ushort0;
       }
       else
       {
           CoreGroup_OnSetVisible((CoreGroup)item, 0 );
           CoreGroup_InvalidateViewState((CoreGroup)item );
           return;
       }
    }

    item.DescriptionText.String = desc;
    item.TimeText.String = time;
    item.LocationText.String = location;
    item.ChannelImage.Bitmap = chan;
    item.ChanText.String = App::Lib.TypeName( chan );


    if ( zone < 255 && unt != -1 )
    {  
        item.AddressText.String = "Zone " + string( zone ) + "  " + App::Lib.Unit(  unt );
    }
    else
    {
       item.AddressText.String ="CIE Fault";
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
     

  }

  $rect <830,365,1070,410>
  object Core::SystemEventHandler FaultListChangeHandler
  {
    preset OnEvent = onEvent;
    preset Event = App::Devices.FaultListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <840,420,1030,460>
  slot onEvent
  {
    var int32 numItems = 3;

    //var App::FaultListChange ch = (App::FaultListChange)  FaultListChangeHandler.Context;

    var bool jump = false;
    var bool flash = false;
       
    native( numItems )
    {
      Command cmd;

      Command0( CMD_GET_NUM_FAULTS, &cmd );

      numItems = cmd.int0;

      jump = (char) cmd.int1;
      flash =  (char)  cmd.int2;
    }  

    var int32 prevnum = ListViewer.NoOfItems;

    ListViewer.NoOfItems = numItems;

    $if (!$prototyper)

    var App::Application ap = (App::Application) Owner;

    if ( ap != null )
    {
      ap.FaultsTabButton.NumberOf = numItems;
      ap.FaultsTabButton.InvalidateViewState();

      if ( ap.AlarmsTabButton.NumberOf == 0 &&  
           ap.SelectedTab != "{fnt3}{clr1} Faults" && numItems != 0 && ap.LevelAccess.AccessLevel < 3 && jump )
      {                                               
          postsignal ap.FaultsTabButton.OnPress;   
      }
      else if ( numItems > 0 && ap.SelectedTab != "{fnt3}{clr1} Faults" && flash )
      {
         ap.FaultsTabButton.Timer.Enabled = true;
      } 

    }
    $endif 



    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <0,0,615,365>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::FaultItem;
    preset ItemHeight = 50;
    preset NoOfItems = 5;
    preset onRefreshAll = OnRefreshAll;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <840,250,1030,290>
  slot OnRefreshAll
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;
    var App::FaultItem item = (App::FaultItem) ListViewer.VerticalList.first;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    while ( itemNo < 0 )
    {
       item.Visible = false;
       item.InvalidateViewState();

       item = (App::FaultItem) item.next;

       if ( item == null ) return;

       itemNo = itemNo + 1;
    }


    var string time = "";                            
    var string desc = "Fault";
    var string location = "" ;
    var int32 unt = 1;
    var int32 zone = 1;
    var App::ChannelType chan = App::ChannelType.HeatA1R;

    while ( item != null )
    {
        native( time, desc, location, itemNo, unt, zone, item )
        {
           Command cmd;

           cmd.int0 = itemNo;
           if ( Command0( CMD_GET_FAULT_ITEM, &cmd ) == CMD_OK )
           {
             if ( cmd.int1 != 0 )
             {
                desc = EwNewStringAnsi( (char*)cmd.int1 );
             }         

             CoreGroup_OnSetVisible((CoreGroup)item, 1 );
         
             if ( cmd.int3 != 0 ) time = EwNewStringAnsi( (char*)cmd.int3 );
             if ( cmd.int2 != 0 )
             {
                location = EwNewStringAnsi( (char*)cmd.int2 );
             }
             else
             {
                location = NULL;
              }

             zone = cmd.char0;
             chan = cmd.char1;
             unt = cmd.ushort1;
             
           }
           else
           {
               CoreGroup_OnSetVisible((CoreGroup)item, 0 );
               CoreGroup_InvalidateViewState((CoreGroup)item );          
           }
        }

        item.DescriptionText.String = desc;
        item.TimeText.String = time;
        item.LocationText.String = location;
        item.ChannelImage.Bitmap = chan;
        item.ChanText.String = App::Lib.TypeName( chan );


        if ( zone < 255 && unt != -1 )
        {  
            item.AddressText.String = "Zone " + string( zone ) + "  " + App::Lib.Unit(  unt );
        }
        else
        {
           item.AddressText.String ="CIE Fault";
        }

        itemNo = itemNo + 1;

        item = (App::FaultItem) item.next;
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    //item.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );

  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <570,460,760,500>
  slot onEvent1
  {
    $if (!$prototyper)

    var App::Application app = (App::Application) Owner;

    ConfirmEventButton.Enabled = ( app.LevelAccess.AccessLevel > 1);

    $endif

    signal onEvent;


  }

  $rect <340,460,540,500>
  object Core::SystemEventHandler AccessModeChangeEvent
  {
    preset OnEvent = onEvent1;
    preset Event = App::Devices.AccessModeChangeEvent;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ConfirmEventButton
  {
    preset Bounds = <615,0,795,55>;
    preset Enabled = true;
    preset OnRelease = null;
    preset OnActivate = ManageDevFaults;
    preset Label = "Manage Device Faults";
    preset Appearance = App::NormalPushButton;
  }

  $rect <820,0,1020,40>
  slot ManageDevFaults
  {
    sender; /* the method is called from the sender object */


    var App::Application app = (App::Application) this.Owner;


    app.TabButtonPull.SetChoice( "Testing" );


  }
}

$rect <120,210,250,250>
$output false
class FaultItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,570,45>;
    preset Color = #E2E2E2FF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,45>;
    preset Color = #D4D4D4FF;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <405,5,510,20>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "12:33 31/12/18";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text LocationText
  {
    preset Bounds = <125,2,405,20>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "SYSTEM FAULTpg";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, ResizeHorz];
    preset Bounds = <5,25,395,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Device type different to site configuration.";
    preset Font = Resources::FontSmall;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text AddressText
  {
    preset Bounds = <5,4,139,19>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 55  Unit 500";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::ChannelImage ChannelImage
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <512,5,548,41>;
  }

  $rect <20,20,160,60>
  object Views::Text ChanText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <385,27,510,42>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Routing Ack Input";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }
}

$rect <560,150,710,190>
$output false
class EventItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

       
    OrderPos.String = App::Lib.Order( OrderPosition );


            
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,45>;
    preset Color = #E2E2E2FF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <68,22,508,45>;
    preset WrapWidth = Bounds.w;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Textual Description";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text OrderPos
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,65,45>;
    preset String = "555th";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <71,-1,365,20>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 1 Unit 23";
    preset Font = App::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <375,1,503,18>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "12:33 31/12/18";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, ResizeVert];
    preset Bounds = <507,0,550,45>;
    preset Color = #000000FF;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset Bitmap = App::FireBitmap;
  }

  $rect <600,60,800,100>
  object Core::Timer Timer
  {
    preset OnTrigger = Trigger;
    preset Period = 600;
    preset Enabled = true;
  }

  $rect <660,10,790,50>
  slot Trigger
  {
    sender; /* the method is called from the sender object */

    if ( OrderPosition == 1 )
    {
      OrderPos.Visible = !OrderPos.Visible;
    }



  }

  $rect <0,70,200,110>
  property int32 OrderPosition = 0;

  $rect <0,110,200,150>
  onset OrderPosition
  {
    // The value doesn't change - nothing to do.
    if ( pure OrderPosition == value )
      return;

    // Remember the property's new value.
    pure OrderPosition = value;


    InvalidateViewState();
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,45>;
    preset Color = #D4D4D4FF;
  }
}

$rect <1600,1020,1780,1060>
$output false
resource Resources::Bitmap EvacEvent
{
  attr bitmapfile FileName = .\Images\evac_event2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'check box'.
$rect <510,1630,690,1670>
$output false
autoobject WidgetSet::ToggleButtonConfig LargeCheckBox
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDisabled = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDisabled = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 45;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #A8ABABAA;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #A8ABABAA;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 40;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToLeft];
  preset FaceOnTintDisabled = #94949499;
  preset FaceOnFrameActive = 0;
  preset FaceOnFrameFocused = 0;
  preset FaceOnFrameDisabled = 2;
  preset FaceOnFrameDefault = 2;
  preset FaceOnActive = App::CheckBoxLarge;
  preset FaceOnFocused = App::CheckBoxLarge;
  preset FaceOnDisabled = App::CheckBoxLarge;
  preset FaceOnDefault = App::CheckBoxLarge;
  preset FaceOffTintDefault = #94949493;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 1;
  preset FaceOffFrameDefault = 1;
  preset FaceOffActive = App::CheckBoxLarge;
  preset FaceOffFocused = App::CheckBoxLarge;
  preset FaceOffDisabled = App::CheckBoxLarge;
  preset FaceOffDefault = App::CheckBoxLarge;
  preset WidgetMinSize = <39,39>;
}

$rect <1770,1070,1950,1110>
$output false
resource Resources::Bitmap CheckBoxLarge
{
  attr bitmapfile FileName = .\Images\Checkbox.png;
  attr alphafile AlphaName;
  attr framesize FrameSize = <36,36>;
  attr framedelay FrameDelay;
}

$rect <1770,1110,1950,1150>
$output false
resource Resources::Bitmap CheckBoxSmall
{
  attr bitmapfile FileName = .\Images\CheckboxSmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize = <20,20>;
  attr framedelay FrameDelay;
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'check box'.
$rect <680,1530,860,1570>
$output false
autoobject WidgetSet::ToggleButtonConfig SmallCheckBox
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDisabled = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDisabled = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 0;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #85858587;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #85858587;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 40;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
  preset FaceLayout = Core::Layout[];
  preset FaceOnTintDisabled = #85858587;
  preset FaceOnFrameActive = 0;
  preset FaceOnFrameFocused = 0;
  preset FaceOnFrameDisabled = 2;
  preset FaceOnFrameDefault = 2;
  preset FaceOnActive = App::CheckBoxSmall;
  preset FaceOnFocused = App::CheckBoxSmall;
  preset FaceOnDisabled = App::CheckBoxSmall;
  preset FaceOnDefault = App::CheckBoxSmall;
  preset FaceOffTintDisabled = #85858587;
  preset FaceOffTintDefault = #94949493;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 1;
  preset FaceOffFrameDefault = 1;
  preset FaceOffActive = App::CheckBoxSmall;
  preset FaceOffFocused = App::CheckBoxSmall;
  preset FaceOffDisabled = App::CheckBoxSmall;
  preset FaceOffDefault = App::CheckBoxSmall;
  preset WidgetMinSize = <30,30>;
}

$rect <0,910,150,950>
$output false
class Disablements : Core::Group
{
  $rect <10,470,210,510>
  inherited property Bounds = <0,0,790,365>;

  $rect <20,390,160,430>
  inherited onset Visible
  {
    // TO DO: Write your code here ... 

    super( value );

    if ( value )
    {
      ListViewer.NoOfItems = numDisablements + numZoneDisablements + buzzerDisabled;
    }
  }

  $rect <270,400,410,440>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    postsignal Refresh;

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <500,450,1280,770>;
  }

  $rect <710,300,910,340>
  slot Refresh
  {
    sender; /* the method is called from the sender object */

    var int32 numz = 0;
    var int32 numd = 0;
    var int32 buzzd = 0;

    native ( numz, numd )
    {
      Command cmd;

      Command0(  CMD_GET_NUM_DISABLED, &cmd );  

      numz = cmd.int0;
      numd = cmd.int1;
      buzzd = cmd.int2;
    }

    numZoneDisablements = numz;
    numDisablements = numd;
    buzzerDisabled = buzzd;

     
    var bool fire = App::Lib.GetZoneDisabledState( -1 );
    var bool routing = App::Lib.GetZoneDisabledState(  0 );


    var App::Application app = (App::Application) GetRoot();

    if ( app != null )
    {
       app.DisablementsTabButton.NumberOf = numz + numd + buzzd;

       app.DisablementsTabButton.fire.Visible = fire;
       app.DisablementsTabButton.routing.Visible = routing;

       app.DisablementsTabButton.InvalidateViewState( );

       postsignal app.Faults.onEvent;

    }     

      
    ListViewer.NoOfItems = numz + numd + buzzd;
     


  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <710,400,860,440>
  slot OnLoadItem1
  {
    var int16 itemNo   = ListViewer.Item;

    var App::DisablementItem row = (App::DisablementItem) ListViewer.VerticalList.View;

    if ( itemNo < 0 ) 
    {
       row.Visible = false;
       row.InvalidateViewState();
       return;      
    }


    if ( itemNo == 0 ) 
    {
      if ( buzzerDisabled == 1)
      {
        row.ChannelImage.Visible = true;
        row.ChannelImage.Image.Bitmap = App::MuteBitmap;
        row.ChanText.Visible = false;
        row.CAE.Visible = false;
        row.ZoneText.Color = #000000FF; 
        row.ZoneText.String = "Engineer Setting";
        row.ChannelImage.Text.String = "";
        row.Text.Visible = true;
        row.Text.Color = #000000FF;
        row.Text.String = "Panel buzzer";
        row.DescriptionText = "";
        row.Visible = true;
        row.InvalidateViewState();

        row =  (App::DisablementItem) row.next;
      
        return;
      }
    }
            
            
    if ( buzzerDisabled == 1 )
    {
      itemNo = itemNo - 1;     // hack to zero it
    }
                                    
    var App::ChannelType type = App::ChannelType.None;
    var string location = "Unknown";
     
    var int16  zone = 0;
    var int16  yunit = 0;
    var int16 fires = 0;
    var int16 inout  = 1;
    var int16 chan = 0;
    var int32 numzones =  numZoneDisablements;
    var int32 numunits =  numDisablements;

     
        native ( type, location, zone, yunit, itemNo, chan, inout, numzones, numunits, row )
        {
            Command cmd;
            int ok;

            if ( itemNo < numzones )
            {
              cmd.int0 = itemNo;
         
              ok = Command0( CMD_DISABLED_ZONE_DETAILS, &cmd );
            }
            else if ( itemNo - numzones < numunits )
            {
               cmd.int0 = itemNo - numzones;
         
               ok = Command0( CMD_GET_DISABLED_DETAILS, &cmd );

               if ( ok == CMD_OK )
               {
                  location = EwNewStringAnsi( (char*) cmd.int0 );
               }
            }
            else
            {
                CoreGroup_OnSetVisible((CoreGroup)row, 0 );
                CoreGroup_InvalidateViewState((CoreGroup)row );
                return;
            }

            if ( ok )
            {
              zone  = cmd.short2;
              yunit = cmd.short3;
              type = cmd.short4;
              chan = cmd.short5;
              inout = cmd.short6;  
            }
            else
            {
               CoreGroup_OnSetVisible((CoreGroup)row, 0 );
                CoreGroup_InvalidateViewState((CoreGroup)row );
                return;
            }
        }

        if ( yunit == -1 )
        { 
            row.ChannelImage.Visible = false;
            row.ChanText.Visible = false; 
              row.ZoneText.Color = #000000FF;
          row.Text.Color = #000000FF;
          row.ChanText.Color = #000000FF;

            if ( zone == -1 )
            {
                row.ZoneText.String = "Fire Alarm Output Devices";
                row.Text.String = "";
            }
            else if ( zone == 0 )
            {
                row.ZoneText.String = "Fire Alarm Routing Equipment";
                row.Text.String = "";
            }
            else
            {
                row.ZoneText.String = "Zone " + string( zone);
                row.Text.String = "(Entire Zone)";
            }
            return;
        }
     
     
        var string t = "";
        var string io = "";

        row.ZoneText.Color = #000000FF;
        row.Text.Color = #000000FF;
        row.ChanText.Color = #000000FF;

        if ( ( inout & 1 ) > 0 )
        {
          if ( ( inout & 2 ) > 0 )
          {
            if ( ( inout & 4 ) == 0 )
            {
              io = "(DAYTIME)";
              if ( ( inout & 8 ) == 0 )
              {
                 row.ZoneText.Color = #555555FF;
                 row.Text.Color = #555555FF;
                 row.ChanText.Color = #555555FF;
              }
            }
          }
          else
          {
            if ( ( inout & 4 ) > 0 )
            {
              io = "(NIGHTTIME)";
              if ( ( inout & 8 ) > 0 )
              {
                 row.ZoneText.Color = #555555FF;
                 row.Text.Color = #555555FF;
                 row.ChanText.Color = #555555FF;
              }
            }
          }
        }


        {
            row.ChannelImage.Visible = true;
            row.ChanText.Visible = true;

            row.ChannelImage.Bitmap = type;
            row.ChanText.String = App::Lib.TypeName( type ) + " " + io;

            row.Text.String = location;
            row.ZoneText.String = "Zone " + string( zone)+"  " + App::Lib.Unit( yunit );
        }
       
  }

  $rect <830,160,1030,200>
  property int32 numZoneDisablements = 0;

  $rect <840,200,1040,240>
  property int32 numDisablements = 0;

  $rect <950,270,1150,310>
  object Core::SystemEventHandler TimeChangedEventHandler
  {
    preset OnEvent = Refresh;
    preset Event = App::Devices.TimeChangeEvent;
  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <0,0,615,365>;
    preset OnLoadItem = OnLoadItem1;
    preset ItemClass = App::DisablementItem;
    preset ItemHeight = 50;
    preset onRefreshAll = RefreshAll;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <730,360,880,400>
  slot RefreshAll
  {
    var int16 itemNo   = ListViewer.Item;

    var App::DisablementItem row = (App::DisablementItem) ListViewer.VerticalList.first;

    if ( row == null ) return;

    while ( itemNo < 0 ) 
    {
       row.Visible = false;
       row.InvalidateViewState();
       row = (App::DisablementItem) row.next;
       if ( row == null ) return;      
       itemNo = itemNo + 1;
    }


    if ( buzzerDisabled == 1 )
    {
      row.ChannelImage.Visible = true;
      row.ChannelImage.Image.Bitmap = App::MuteBitmap;
      row.ChanText.Visible = false;
      row.CAE.Visible = false;
      row.ZoneText.Color = #000000FF; 
      row.ZoneText.String = "Engineer Setting";
      row.ChannelImage.Text.String = "";
      row.Text.Visible = true;
      row.Text.Color = #000000FF;
      row.Text.String = "Panel buzzer";
      row.DescriptionText = "";
      row.Visible = true;
      row.InvalidateViewState();
      row =  (App::DisablementItem) row.next;
    }      
                                  
    var App::ChannelType type = App::ChannelType.None;
    var string location = "Unknown";
    var int16  zone = 0;
    var int16  yunit = 0;
    var int16 fires = 0;
    var int16 inout  = 1;
    var int16 chan = 0;
    var int32 numzones =  numZoneDisablements;
    var int32 numunits =  numDisablements;

    while ( row != null )
    { 
        native ( type, location, zone, yunit, itemNo, chan, inout, numzones, numunits, row )
        {
            Command cmd;
            int ok;

            if ( itemNo < numzones )
            {
              cmd.int0 = itemNo;
         
              ok = Command0( CMD_DISABLED_ZONE_DETAILS, &cmd );
            }
            else if ( itemNo - numzones < numunits )
            {
               cmd.int0 = itemNo - numzones;
                 
               if ( ( ok = Command0( CMD_GET_DISABLED_DETAILS, &cmd ) ) == CMD_OK )
               {
                  location = EwNewStringAnsi( (char*) cmd.int0 );
               }
               else
               {
                  *location = 0;
               }
            }
            else
            {
                CoreGroup_OnSetVisible((CoreGroup)row, 0 );
                CoreGroup_InvalidateViewState((CoreGroup)row );
                
                row = EwCastObject( row->Super3.next, AppDisablementItem );

                itemNo++;
                continue;
            }
            
          
            if ( ok == CMD_OK )
            {
              zone  = cmd.short2;
              yunit = cmd.short3;
              type = cmd.short4;
              chan = cmd.short5;
              inout = cmd.short6;  
              CoreGroup_OnSetVisible((CoreGroup)row, 1 );
            }
            else
            {
                CoreGroup_OnSetVisible((CoreGroup)row, 0 );
                CoreGroup_InvalidateViewState((CoreGroup)row );
                row = EwCastObject( row->Super3.next, AppDisablementItem );
                itemNo++;
                continue;
             }
        }



        if ( yunit == -1 )
        { 
            row.ChannelImage.Visible = false;
            row.ChanText.Visible = false;
            row.CAE.Visible =  ( ( inout & 16) != 0 );
            row.ZoneText.Color = #000000FF;
            row.Text.Color = #000000FF;
            row.ChanText.Color = #000000FF;
     
            if ( zone == -1 )
            {
                row.ZoneText.String = "Fire Alarm Output Devices";
                row.Text.String = "";
            }
            else if ( zone == 0 )
            {
                row.ZoneText.String = "Fire Alarm Routing Equipment";
                row.Text.String = "";
            }
            else
            {
                row.ZoneText.String = "Zone " + string( zone);
                row.Text.String = "(Entire Zone)";
            }
        }
        else
        {
     
            var string t = "";
            var string io = "";

            row.ZoneText.Color = #000000FF;
            row.Text.Color = #000000FF;
            row.ChanText.Color = #000000FF;

            if ( ( inout & 1 ) > 0 )
            {
              if ( ( inout & 2 ) > 0 )
              {
                if ( ( inout & 4 ) == 0 )
                {
                  io = "(DAYTIME)";
                  if ( ( inout & 8 ) == 0 )
                  {
                     row.ZoneText.Color = #555555FF;
                     row.Text.Color = #555555FF;
                     row.ChanText.Color = #555555FF;
                  }
                }
              }
              else
              {
                if ( ( inout & 4 ) > 0 )
                {
                  io = "(NIGHTTIME)";
                  if ( ( inout & 8 ) > 0 )
                  {
                     row.ZoneText.Color = #555555FF;
                     row.Text.Color = #555555FF;
                     row.ChanText.Color = #555555FF;
                  }
                }
              }
            }
        
            row.CAE.Visible =  ( ( inout & 16)  > 0 );
      
            row.ChannelImage.Visible = true;
            row.ChanText.Visible = true;

            row.ChannelImage.Bitmap = type;
            row.ChanText.String = App::Lib.TypeName( type ) + " " + io;

            row.Text.String = location;
            row.ZoneText.String = "Zone " + string( zone)+"  " + App::Lib.Unit( yunit ); 
        }
        row.InvalidateViewState();

        row = (App::DisablementItem) row.next;

        itemNo = itemNo + 1;
    }

  }

  $rect <930,310,1130,350>
  object Core::SystemEventHandler SiteChangedEventHandler
  {
    preset OnEvent = Refresh;
    preset Event = App::Devices.SiteChangedEvent;
  }

  $rect <920,350,1150,390>
  object Core::SystemEventHandler DisablementsChangeEventHandler
  {
    preset OnEvent = Refresh;
    preset Event = App::Devices.DisablementChangeEvent;
  }

  $rect <820,40,1020,80>
  property int32 buzzerDisabled = 0;

  $rect <820,80,1020,120>
  onset buzzerDisabled
  {
    // The value doesn't change - nothing to do.
    if ( pure buzzerDisabled == value )
      return;

    // Remember the property's new value.
    pure buzzerDisabled = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <1040,230,1300,270>
  object Core::SystemEventHandler MeshListChangeEventHandler
  {
    preset OnEvent = Refresh;
    preset Event = App::Devices.MeshListChangeEvent;
  }
}

$rect <150,910,320,950>
$output false
class DisablementItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


            
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,45>;
    preset Color = #E2E2E2FF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <5,20,453,43>;
    preset WrapWidth = Bounds.w;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Textual Description";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <5,0,427,20>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 1 Unit 23";
    preset Font = App::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <230,80,430,120>
  property string DescriptionText = "Textual Description";

  $rect <20,20,160,60>
  object Views::Text ChanText
  {
    preset Bounds = <210,0,500,19>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = App::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::ChannelImage ChannelImage
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <511,5,547,41>;
  }

  $rect <20,20,160,60>
  object Views::Text CAE
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <458,20,508,43>;
    preset WrapWidth = Bounds.w;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "(C&E)";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'check box'.
$rect <690,1580,920,1620>
$output false
autoobject WidgetSet::ToggleButtonConfig SmallCheckBoxCaption
{
  preset LabelOnColorActive = #000000FF;
  preset LabelOnColorFocused = #000000FF;
  preset LabelOnColorDisabled = #000000FF;
  preset LabelOnColorDefault = #000000FF;
  preset LabelOffColorActive = #000000FF;
  preset LabelOffColorFocused = #000000FF;
  preset LabelOffColorDisabled = #000000FF;
  preset LabelOffColorDefault = #000000FF;
  preset LabelMarginLeft = 34;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #A8ABABAA;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #A8ABABAA;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 6;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToLeft];
  preset FaceOnTintDisabled = #94949499;
  preset FaceOnFrameActive = 0;
  preset FaceOnFrameFocused = 0;
  preset FaceOnFrameDisabled = 2;
  preset FaceOnFrameDefault = 2;
  preset FaceOnActive = App::CheckBoxSmall;
  preset FaceOnFocused = App::CheckBoxSmall;
  preset FaceOnDisabled = App::CheckBoxSmall;
  preset FaceOnDefault = App::CheckBoxSmall;
  preset FaceOffTintDefault = #94949493;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 1;
  preset FaceOffFrameDefault = 1;
  preset FaceOffActive = App::CheckBoxSmall;
  preset FaceOffFocused = App::CheckBoxSmall;
  preset FaceOffDisabled = App::CheckBoxSmall;
  preset FaceOffDefault = App::CheckBoxSmall;
  preset WidgetMinSize = <39,39>;
}

$rect <10,750,120,790>
$output false
class OnTest : Core::Group
{
  $rect <10,470,210,510>
  inherited property Bounds = <0,0,615,365>;

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <800,180,1000,220>
  slot OnLoadItem
  {
    var int16 itemNo   = ListViewer.Item;

    var App::OnTestItem row = (App::OnTestItem) ListViewer.VerticalList.View;


    if ( itemNo < 0 ) 
    {
       row.Visible = false;
       row.InvalidateViewState();
       return;
    }
    else
    {
      row.Visible = true;
    }

    var int32 numzones = 0;
    var int32 numunits = 0;


    native ( numzones, numunits )
    {
      Command cmd;

      Command0(  CMD_GET_NUM_ON_TEST, &cmd );  

      numzones = cmd.int0;
      numunits = cmd.int1;
    }

    var App::ChannelType type = App::ChannelType.None;
    var string location = "Unknown";
    var int16  zone = 0;
    var int16  yunit = 0;
                                      

    native ( type, location, zone, yunit, itemNo, numzones, numunits )
    {
        Command cmd;

        cmd.int0 = itemNo;

        if ( itemNo < numzones )
        {
          cmd.int0 = itemNo;
         
          Command0( CMD_GET_ON_TEST_ZONE_DETAILS, &cmd );
        }
        else if ( itemNo - numzones < numunits )
        {
           cmd.int0 = itemNo - numzones;
         
           Command0( CMD_GET_ON_TEST_DETAILS, &cmd );

           location = EwNewStringAnsi( (char*) cmd.int0 );
        }
        else
        {
            CoreGroup_OnSetVisible((CoreGroup)row, 0 );
            CoreGroup_InvalidateViewState((CoreGroup)row );
            return;
        }

        location = EwNewStringAnsi( (char*) cmd.int0 );
        zone  = cmd.short2;
        yunit = cmd.short3;
        type = cmd.short4;
       
    }

    if ( yunit == -1 )
    { 
        row.ChannelImage.Visible = false;
        row.ZoneText1.Visible = false;
        
        row.ZoneText.String = "Zone " + string( zone);
        row.Text.String = "(Entire Zone)";
        
        return;
    }

    row.ChannelImage.Visible = true;
    row.ZoneText1.Visible = true;

    row.ChannelImage.Bitmap = type;
    row.ZoneText1.String = App::Lib.TypeName( type );

    row.Text.String = location;
    row.ZoneText.String = "Zone " + string( zone)+"  " + App::Lib.Unit( yunit );
     
          


  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <0,0,615,365>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::OnTestItem;
    preset ItemHeight = 50;
    preset onRefreshAll = RefreshAll;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <820,140,1020,180>
  slot RefreshAll
  {
    var int16 itemNo   = ListViewer.Item;

    var App::OnTestItem row = (App::OnTestItem) ListViewer.VerticalList.first;


    while ( itemNo < 0 ) 
    {
       row.Visible = false;
       row.InvalidateViewState();
       row = (App::OnTestItem) row.next;
       if ( row == null ) return;      
       itemNo = itemNo + 1;
    }

                                                                

    var int32 numzones = 0;
    var int32 numunits = 0;


    native ( numzones, numunits )
    {
      Command cmd;

      Command0(  CMD_GET_NUM_ON_TEST, &cmd );  

      numzones = cmd.int0;
      numunits = cmd.int1;
    }
               

    var App::Application app = (App::Application) Owner;

    if ( app != null )
    {
       app.OnTestTabButton.NumberOf = numzones + numunits;
       app.OnTestTabButton.InvalidateViewState( );
    }     
       


    var App::ChannelType type = App::ChannelType.None;
    var string location = "Unknown";
    var int16  zone = 0;
    var int16  yunit = 0;
                                      

    while ( row != null )
    { 
        native ( type, location, zone, yunit, itemNo, numzones, numunits )
        {
            Command cmd;

            cmd.int0 = itemNo;

            if ( itemNo < numzones )
            {
               cmd.int0 = itemNo;
         
               Command0( CMD_GET_ON_TEST_ZONE_DETAILS, &cmd );
            }
            else if ( itemNo - numzones < numunits )
            {
               cmd.int0 = itemNo - numzones;
         
               Command0( CMD_GET_ON_TEST_DETAILS, &cmd );

               location = EwNewStringAnsi( (char*) cmd.int0 );
            }
            else
            {
                CoreGroup_OnSetVisible((CoreGroup)row, 0 );
                CoreGroup_InvalidateViewState((CoreGroup)row );

                row = EwCastObject( row->Super3.next, AppOnTestItem );
                continue;
            }
            
            CoreGroup_OnSetVisible((CoreGroup)row, 1 );
     

            location = EwNewStringAnsi( (char*) cmd.int0 );
            zone  = cmd.short2;
            yunit = cmd.short3;
            type = cmd.short4;   
        }

        if ( yunit == -1 )
        { 
            row.ChannelImage.Visible = false;
            row.ZoneText1.Visible = false;
        
            row.ZoneText.String = "Zone " + string( zone);
            row.Text.String = "(Entire Zone)";
        }
        else
        {
            row.ChannelImage.Visible = true;
            row.ZoneText1.Visible = true;

            row.ChannelImage.Bitmap = type;
            row.ZoneText1.String = App::Lib.TypeName( type );

            row.Text.String = location;
            row.ZoneText.String = "Zone " + string( zone)+"  " + App::Lib.Unit( yunit );
        }
        row.InvalidateViewState();
        row = (App::OnTestItem) row.next;
        itemNo = itemNo + 1;
    }     


  }

  $rect <800,370,1000,410>
  object Core::SystemEventHandler SiteChangedEventHandler
  {
    preset OnEvent = Refresh;
    preset Event = App::Devices.SiteChangedEvent;
  }

  $rect <790,410,1050,450>
  object Core::SystemEventHandler MeshListChangeEventHandler
  {
    preset OnEvent = Refresh;
    preset Event = App::Devices.MeshListChangeEvent;
  }

  $rect <820,450,1020,490>
  slot Refresh
  {
    sender; /* the method is called from the sender object */

    var int32 numzones = 0;
    var int32 numunits = 0;


    native ( numzones, numunits )
    {
      Command cmd;

      Command0(  CMD_GET_NUM_ON_TEST, &cmd );  

      numzones = cmd.int0;
      numunits = cmd.int1;
    }
               

    ListViewer.NoOfItems = numzones + numunits;


  }
}

$rect <130,750,280,790>
$output false
class OnTestItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

       
           
            


            
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,45>;
    preset Color = #E2E2E2FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,45>;
    preset Color = #D4D4D4FF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <5,21,455,43>;
    preset WrapWidth = Bounds.w;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Textual Description";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <5,0,185,18>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 1 Unit 23";
    preset Font = App::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <229,80,429,120>
  property string DescriptionText = "Textual Description";

  $rect <20,20,160,60>
  object Views::Text ZoneText1
  {
    preset Bounds = <220,0,460,18>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Zone 1 Unit 23";
    preset Font = App::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::ChannelImage ChannelImage
  {
    preset Bounds = <510,5,546,41>;
  }
}

$rect <300,950,500,990>
$output false
class DisableZoneItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,600,50>;

  $rect <40,135,240,175>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    if ( ZoneNum == -1 )
    {
        Text.String = "Alarm Output Devices";
    }
    else if ( ZoneNum == 0 )
    {
        Text.String = "Fire Alarm Routing Equipment";
    }
    else
    { 
        Text.String = "Zone " + string( ZoneNum );
    }
     
    var App::Disable testpage = (App::Disable) Owner.Owner.Owner;

    if ( testpage != null )
    {

       var App::ZoneFlags zf = App::Lib.GetZoneFlags( ZoneNum );

       if ( zf.contains( App::ZoneFlags[ DisableExpanded ] ) )
       { 
           ExpandImage.Bitmap = App::CollapseBitmap;
       }
       else
       {
            ExpandImage.Bitmap = App::ExpandBitmap;
       }
    }

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Views::Image ExpandImage
  {
    preset Bounds = <10,15,40,45>;
    preset Bitmap = App::ExpandBitmap;
  }

  $rect <395,170,540,220>
  property int16 ZoneNum = 0;

  $rect <495,280,695,320>
  slot ClearAll
  {
    sender ; /* the method is called from the sender object */

                                                                  
                                 

    var int16 dev;
    var int16 devs = App::Lib.NumDevsInZone( ZoneNum );

    for( dev = 0; dev < devs; dev = dev + 1 )
    {
        var int16 unitnum = App::Lib.GetDevInZone( ZoneNum, dev );

        var App::DeviceConfig d = App::Lib. GetConfig( unitnum );

        if ( d != null )
        {
           d.flags = d.flags - App::DeviceConfigFlags[ Disabled];

           var int32 channel;
          
           for( channel = 0; channel < d.numinputs; channel = channel + 1 )
           {
              d.inputs[ channel ].flags = d.inputs[ channel ].flags - App::Options[ DisabledDay, DisabledNight ];
           }
           for( channel = 0; channel < d.numoutputs; channel = channel + 1 )
           {
              d.outputs[ channel ].flags = d.outputs[ channel ].flags - App::Options[ Disabled ];
           }
      
           App::Lib.SetConfig( unitnum, true, d );
        }
    }

    var App::Disable disable = (App::Disable) Owner.Owner.Owner.Owner;
        
        
    if ( disable != null )
    {
        postsignal ((App::Application) disable.Owner).Disablements.Refresh;

        signal disable.ListViewer.onRefreshAll;
    }

    /*
      
    var App::ZoneFlags zf = App::Lib.GetZoneFlags( ZoneNum );

     
    {
        var uint16 zone = ZoneNum;

        native( zone )
        {

          Command cmd;
          cmd.int0 = zone;
          cmd.int1 = -1; // all units
          cmd.int2 = -1; // all channels
          cmd.int3 = 0;

          Command0( CMD_SET_INPUT_DISABLED, &cmd );   
          Command0( CMD_SET_OUTPUT_DISABLED, &cmd );      
        }    

        var App::Disable disable = (App::Disable) Owner.Owner.Owner;
        
        

        if ( disable != null )
        {
            postsignal ((App::Application) disable.Owner).Disablements.Refresh;

            if ( zf.contains( App::ZoneFlags[ DisableExpanded ] ) )
            {
               disable.VerticalList.InvalidateItems( 0, disable.VerticalList.NoOfItems - 1 );
            }
        }
      
         var App::DisableItem i = (App::DisableItem) Owner.next;

         while ( i != null && ( i.DisableUnitItem.Visible || i.DisableChannelItem.Visible ) )
         {
          i.DisableUnitItem.CheckBox.Checked = false;
          if (i.DisableUnitItem.Visible)  disable.SetDeviceSelected( i.DisableUnitItem.UnitNum, false );

           i.DisableChannelItem.OutputCheckBox.Checked = false;
           i.DisableChannelItem.InputCheckBox.Checked = false;
           if (i.DisableChannelItem.Visible && i.DisableChannelItem.InputCheckBox.Visible  )  disable.SetInputChanSelected( i.DisableChannelItem.UnitNum, i.DisableChannelItem.ChanNum, false );
           if (i.DisableChannelItem.Visible && i.DisableChannelItem.OutputCheckBox.Visible  )  disable.SetOutputChanSelected( i.DisableChannelItem.UnitNum, i.DisableChannelItem.ChanNum, false );
          i = (App::DisableItem) i.next;
         }
      }
      */
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <505,10,590,46>;
    preset OnRelease = ClearAll;
    preset Label = "Clear All";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <435,325,635,365>
  slot ToggleSlot
  {
    sender; /* the method is called from the sender object */

     
    App::Lib.SetZoneDisabledState( ZoneNum, ((WidgetSet::ToggleButton) sender).Checked );


    var App::Disable disablepage = (App::Disable) Owner.Owner.Owner.Owner;
     

    if ( disablepage != null )
    {
        postsignal disablepage.Recount;
    }
         
     
  }

  $rect <180,80,380,120>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */
                     

    if ( Visible )
    { 
      var Core::VerticalList lst = (Core::VerticalList) Owner.Owner;
          
      var App::Disable dispage = (App::Disable) Owner.Owner.Owner.Owner;
       


        var App::ZoneFlags zf = App::Lib.GetZoneFlags( ZoneNum );

        if ( !zf.contains( App::ZoneFlags[ DisableExpanded ] ) )
        {                                                      
            zf = zf + App::ZoneFlags[ DisableExpanded ];
        }
        else
        {
          zf = zf - App::ZoneFlags[ DisableExpanded ];
       }

       App::Lib.SetZoneFlags( ZoneNum, zf );


       signal dispage.Refresh ;
      
    }







    /*

    if ( Visible )
    {

     
    var Core::VerticalList lst = (Core::VerticalList) Owner.Owner;

      var int32 total = 0;
      var int32 devs = 4;
      var int32 zone = ZoneNum;

      native( devs, zone )
      {
        Command cmd;
        cmd.int0 = zone;

        Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
        devs = cmd.int0;
      }


    var App::Disable testpage = (App::Disable) Owner.Owner.Owner;

    var App::ZoneFlags zf = App::Lib.GetZoneFlags( ZoneNum );

    if ( !zf.contains( App::ZoneFlags[ DisableExpanded ] ) )
    {                                                      
        ExpandImage.Bitmap = App::CollapseBitmap;

        zf = zf + App::ZoneFlags[ DisableExpanded ];
       
        App::Lib.SetZoneFlags( ZoneNum, zf );

     
        var int32 dev;
        
        var int32 count = 2;

        total = total + devs;

        for( dev = 0; dev < devs; dev=dev+1 )
        {
            var int32 unity = dev + 1;

           native( zone, dev, unity, count )
           {
            Command cmd;
                    
            cmd.int0 = zone;
            cmd.int1 = dev;
            Command0( CMD_GET_DEV_IN_ZONE, &cmd );
            DeviceConfig* device = (DeviceConfig*) cmd.int0;

            if ( device != NULL )
            {
               int chan;
               count = 0;
               unity = device->unit;
               for( chan = 0; chan < 16; chan++ )
               {
                  if ( device->input[ chan].type != 0 ) count++;
                  if ( device->output[ chan].type != 0 ) count++; 
               }
            }
           }
           if ( testpage.isDeviceExpanded( unity ) )
           {
              total = total + count;
           }
        }
        lst.NoOfItems = lst.NoOfItems + total;
    }
    else
    {
        ExpandImage.Bitmap = App::ExpandBitmap;
        
        zf = zf - App::ZoneFlags[ DisableExpanded ];
       
        App::Lib.SetZoneFlags( ZoneNum, zf );

        var int32 n;
        var int32 dev;
       
        var int32 count = 2;

        total = total + devs;

        for( dev = 0; dev < devs; dev=dev+1 )
        {
           var int32 unity = dev + 1;

           native( zone, dev, unity )
           {
            Command cmd;
                    
            cmd.int0 = zone;
            cmd.int1 = dev;
            Command0( CMD_GET_DEV_IN_ZONE, &cmd );
            DeviceConfig* device = (DeviceConfig*) cmd.int0;

            if ( device != NULL )
            {
               int chan;
               count = 0;
               unity = device->unit;
               for( chan = 0; chan < 16; chan++ )
               {
                  if ( device->input[ chan].type != 0 ) count++;
                  if ( device->output[ chan].type != 0 ) count++; 
               }
            }
           }
           if ( testpage.isDeviceExpanded( unity ) )
           {
              total = total + count;
           }
        }
        lst.NoOfItems = lst.NoOfItems - total;
    }

     
    lst.InvalidateItems( 0, lst.NoOfItems - 1 );

    lst.InvalidateViewState();


     testpage.VertScrollbar.ContentArea = lst.NoOfItems * lst.ItemHeight;
      testpage.VertScrollbar.ViewArea = lst.Bounds.h;
     testpage.VertScrollbar.InvalidateViewState();

     }
      */

  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <50,0>;
    preset Point2 = <50,50>;
    preset Point1 = <0,50>;
    preset OnPress = ToggleExpand;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <120,10,490,40>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <70,0,120,50>;
    preset OnSwitchOn = ToggleSlot;
    preset OnSwitchOff = ToggleSlot;
    preset Label = "";
    preset Appearance = App::LargeDisableCheckBox;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder ExpandImage 6
  $reorder Enabled 5
}

$rect <120,950,300,990>
$output false
class DisableUnitItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,570,50>;

  $rect <40,135,240,175>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var App::Disable testpage = (App::Disable) Owner.Owner.Owner;


    if ( aState.contains( Core::ViewState[ Enabled ] )  )
    {
      DescriptionText.Color = #000000FF;
      Text.Color = #000000FF;

      var App::Device d = App::Lib.GetDevice( UnitNum );

      if ( d != null )
      {
        if ( ( ZoneGroup > 0   && d.settings.contains( App::DeviceSetting[ DisableExpanded ] ) ) ||
             ( ZoneGroup == -1 && d.settings.contains( App::DeviceSetting[ DisableFireExpanded ] ) ) ||
             ( ZoneGroup == 0  && d.settings.contains( App::DeviceSetting[ DisableRoutingExpanded ] ) ) )        
        {
           Image1.Bitmap = App::CollapseBitmap;
        }
        else
        {
           Image1.Bitmap = App::ExpandBitmap;
        }
        Image1.Visible = true;
      }

    }
    else
    {
       DescriptionText.Color = #AAAAAAFF;
       Text.Color = #AAAAAAFF;
       Image1.Visible = false;
    }
     

    Text.String = "Zone " + string( ZoneNum) + "  " + App::Lib.Unit(  UnitNum);



  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <395,175,595,215>
  property uint16 UnitNum = 0;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <135,1,295,25>;
    preset ColorBL = #000000FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #000000FF;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = App::VerdanaProSemiBold16;
    preset Color = #3D3D3DFF;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <135,20,560,46>;
    preset ColorBL = #000000FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #000000FF;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <390,220,590,260>
  property int8 ZoneNum = 0;

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <39,11,69,41>;
    preset Bitmap = App::ExpandBitmap;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <29,1>;
    preset Point3 = <79,1>;
    preset Point2 = <79,50>;
    preset Point1 = <29,50>;
    preset OnPress = ToggleExpand;
  }

  $rect <390,130,520,170>
  slot ToggleSlot
  {
    sender; /* the method is called from the sender object */


    var App::DeviceConfig d = App::Lib.GetConfig( UnitNum );

    if ( d != null )
    {
        if (CheckBox.Checked )
        {
            d.flags = d.flags + App::DeviceConfigFlags[ Disabled ];
        }
        else
        {
            d.flags = d.flags - App::DeviceConfigFlags[ Disabled ];  
        }

        App::Lib.SetConfig( UnitNum, true, d );
    }


    var App::Disable disablepage = (App::Disable) Owner.Owner.Owner.Owner;


    if ( disablepage != null )
    {
        postsignal disablepage.Recount ;
    }

     
  }

  $rect <50,75,250,115>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */

     

    if ( Visible )
    {   
      
      var App::Disable disablepage = (App::Disable) Owner.Owner.Owner.Owner;

      if ( disablepage != null )
      {    
        var App::Device d = App::Lib.GetDevice( UnitNum );

        if ( d != null )
        {
            if ( d.IsDisableExpanded( ZoneGroup ) )
            {
              //  Image1.Bitmap = App::ExpandBitmap;
                 
                if ( ZoneGroup == -1 )
                {
                  d.settings = d.settings - App::DeviceSetting[ DisableFireExpanded ];       
                }
                else if ( ZoneGroup == 0 )
                {
                  d.settings = d.settings - App::DeviceSetting[ DisableRoutingExpanded ];       
                }
                else
                {
                  d.settings = d.settings - App::DeviceSetting[ DisableExpanded ];       
                }
            }
            else  
            {
             //   Image1.Bitmap = App::CollapseBitmap;
               
                if ( ZoneGroup == -1 )
                {
                  d.settings = d.settings + App::DeviceSetting[ DisableFireExpanded ];       
                }
                else if ( ZoneGroup == 0 )
                {
                  d.settings = d.settings + App::DeviceSetting[ DisableRoutingExpanded ];       
                }
                else
                {
                  d.settings = d.settings + App::DeviceSetting[ DisableExpanded ];       
                }
            }  
            App::Lib.SetDevice( UnitNum, d );
        }
     }



     
    signal disablepage.Refresh;


     
     
    }









    /*




     
    var Core::VerticalList lst = (Core::VerticalList) Owner.Owner;


      var int32 devs = 4;
       
      var int32 dev = UnitNum;
          
      var int32 channels = 2;
                
      native( dev, channels  )
      {  
        Command cmd;
        channels = 0;
      
        cmd.int0 = dev;
        
        Command0( CMD_GET_DEVICE, &cmd );
        DeviceConfig* dev = (DeviceConfig*) cmd.int0;

        for( int n = 0 ; n < 16; n++ )
        {
            if ( dev->input[ n].type != 0  ) channels++;
            if ( dev->output[ n].type != 0 ) channels++;
        }
       }

    var App::Disable testpage = (App::Disable) Owner.Owner.Owner;

    var App::Device d = App::Lib.GetDevice( UnitNum );

    if ( !d.settings.contains( App::DeviceSetting[ DisableExpanded ] ) )   
    {
        Image1.Bitmap = App::CollapseBitmap;
        lst.NoOfItems = lst.NoOfItems + channels;
        d.settings = d.settings + App::DeviceSetting[ DisableExpanded ];
        App::Lib.SetDevice( UnitNum, d );
        testpage.SetExpanded( UnitNum, true );
    }
    else
    {
        Image1.Bitmap = App::ExpandBitmap;
        lst.NoOfItems = lst.NoOfItems - channels;
        d.settings = d.settings - App::DeviceSetting[ DisableExpanded ];
        App::Lib.SetDevice( UnitNum, d );
    }

     
    lst.InvalidateItems( 0, lst.NoOfItems - 1 );

    lst.InvalidateViewState();


     testpage.VertScrollbar.ContentArea = lst.NoOfItems * lst.ItemHeight;
      testpage.VertScrollbar.ViewArea = lst.Bounds.h;
     testpage.VertScrollbar.InvalidateViewState();

     } 
      */




  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton CheckBox
  {
    preset Bounds = <80,0,140,50>;
    preset Enabled = false;
    preset OnSwitchOn = ToggleSlot;
    preset OnSwitchOff = ToggleSlot;
    preset Label = "";
    preset Appearance = App::DisableSmallCheckBox;
  }

  $rect <390,270,590,310>
  property int8 ZoneGroup = 0;

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <650,930,790,970>
$output false
class DisableItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,570,50>;

  $rect <50,200,250,240>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <40,135,240,175>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

     

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object App::DisableUnitItem DisableUnitItem
  {
    preset Bounds = <0,0,570,50>;
  }

  $rect <20,20,160,60>
  object App::DisableZoneItem DisableZoneItem
  {
    preset Bounds = <0,0,570,50>;
  }

  $rect <20,20,160,60>
  object App::DisableChannelItem DisableChannelItem
  {
    preset Bounds = <0,0,570,50>;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <0,961,130,1001>
$output false
class Disable : Core::Group
{
  $rect <0,550,200,590>
  inherited property Bounds = <0,0,780,365>;

  $rect <20,400,160,440>
  inherited onset Visible
  {
    // TO DO: Write your code here ... 

    super( value );

    postsignal Refresh;

  }

  $rect <0,500,200,540>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    ListViewer.InvalidateViewState();


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <210,420,360,460>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    signal Refresh;

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <570,480,710,520>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */
               
              
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;

     
    var App::DisableItem item = (App::DisableItem) ListViewer.VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    //var Application::ModifyZoneItem currentZone = null;

    if ( itemNo < 0 ) 
    {
      item.Visible = false;
      item.InvalidateViewState();
      return;
    }

    item.Visible = true;

    var int16 curZone = -1;


    var int32 i = 0;
    var int32 numZones = App::Lib.NumZonesWithDevices() + 2;
    var bool firedisabled = App::Lib.GetZoneDisabledState( -1);
    var bool routingdisabled = App::Lib.GetZoneDisabledState( 0);

    while ( numZones > 0 )
    {
        var int32 numdevs = App::Lib.NumDevsInZone( curZone ); 
          
        if ( numdevs > 0 || curZone < 1 )
        {
            numZones = numZones - 1;
            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );
            var bool zonedisabled = App::Lib.GetZoneDisabledState( curZone );
            
            if ( itemNo == i )
            {          
                item.DisableZoneItem.ToggleButton.Checked = zonedisabled;

                item.DisableZoneItem.ToggleButton.Enabled =  ( numdevs != 0 );
                
                item.DisableZoneItem.ExpandImage.Visible = ( numdevs != 0 );
               
                item.DisableZoneItem.SimpleTouchHandler.Enabled = ( numdevs != 0 );
                
                item.DisableZoneItem.PushButton.Enabled = ( !zonedisabled && ( numdevs != 0 ));

                item.DisableZoneItem.ZoneNum = curZone;
                item.DisableZoneItem.Visible = true;

                item.DisableZoneItem.Enabled = ( numdevs != 0 );
          
                item.DisableUnitItem.Visible = false;
                item.DisableUnitItem.Enabled = false;

                item.DisableChannelItem.Visible = false;
                item.DisableChannelItem.Enabled = false;

                item.DisableZoneItem.InvalidateViewState();
                return;
            }
            else
            {
                i = i + 1;
            }


            if ( zf.contains( App::ZoneFlags[ DisableExpanded ] ) )    // if zone expanded
            {                             
                var int32 dev = 0;

                while ( dev < numdevs )
                {
                    var int16 unitno = App::Lib.GetDevInZone( curZone, dev );
                
                    var App::Device device = App::Lib.GetDevice( unitno );
                    var App::DeviceConfig config = App::Lib.GetConfig( unitno ); 

                    if ( config == null ) return;

                    if ( i == itemNo )   
                    { 
                        if ( curZone < 1 ) 
                        {
                            item.DisableUnitItem.CheckBox.Enabled = false;
                        }
                        else
                        {
                            item.DisableUnitItem.CheckBox.Enabled = true;
                        }

                        item.DisableUnitItem.Visible = true;

                        item.DisableZoneItem.Visible = false;
                        item.DisableZoneItem.Enabled = false;

                        item.DisableChannelItem.Visible = false;
                        item.DisableChannelItem.Enabled = false;

                        item.DisableUnitItem.UnitNum = unitno;
                        item.DisableUnitItem.ZoneNum = config.zonenum;
                        item.DisableUnitItem.ZoneGroup = curZone;
     
                        item.DisableUnitItem.DescriptionText.String = config.location;

                        if ( device == null )
                        {
                            item.DisableUnitItem.Enabled = false;
                            item.DisableUnitItem.CheckBox.Enabled = false;
                        }
                        else
                        {
                            item.DisableUnitItem.Enabled = true;
                        }

                        if ( zonedisabled )
                        {
                            item.DisableUnitItem.CheckBox.Enabled = false;
                            item.DisableUnitItem.CheckBox.Checked = true; 
                        }
                        else
                        {
                            if ( curZone > 0 ) item.DisableUnitItem.CheckBox.Enabled = true;

                            item.DisableUnitItem.CheckBox.Checked = config.flags.contains( App::DeviceConfigFlags[ Disabled ] );
                        }    
                        

                        item.DisableUnitItem.InvalidateViewState(); 

                        return;
                   }
                   else
                   {
                      i = i + 1;
                   }

                   if ( device != null )
                   if ( device.IsDisableExpanded( curZone ) )    
                   {
                       var int32 chan = 0;

                       for ( chan = 0 ; chan < config.numinputs; chan = chan + 1 )
                       {                
                          if ( curZone > 0 )
                          {    
                              if ( i == itemNo )
                              {
                                  item.DisableUnitItem.Visible = false;
                                  item.DisableUnitItem.Enabled = false;

                                  item.DisableZoneItem.Visible = false;
                                  item.DisableZoneItem.Enabled = false;

                                  item.DisableChannelItem.Visible = true;
                                  item.DisableChannelItem.Enabled = true;

                                  item.DisableChannelItem.ChanNum = chan;
                                  item.DisableChannelItem.UnitNum = unitno;
                                  item.DisableChannelItem.ZoneNum = curZone;

                                  item.DisableChannelItem.InputNightCheckBox.Visible = true;
                                  item.DisableChannelItem.InputNightCheckBox.Enabled = true;
                                  item.DisableChannelItem.InputDayCheckBox.Visible = true;
                                  item.DisableChannelItem.InputDayCheckBox.Enabled = true;
                                  item.DisableChannelItem.OutputCheckBox.Visible = false;
                                  item.DisableChannelItem.OutputCheckBox.Enabled = false;
                                  item.DisableChannelItem.Text.Visible = true;
                                  item.DisableChannelItem.Text1.Visible = true;
                                  item.DisableChannelItem.Text2.Visible = false;
     
                                  item.DisableChannelItem.ChannelName.String = App::Lib.TypeName( config.inputs[ chan].type );
                                  item.DisableChannelItem.ChannelImage.Bitmap = config.inputs[ chan].type;

                                  if ( zonedisabled || config.flags.contains( App::DeviceConfigFlags[ Disabled ] ) )
                                       
                                  {
                                      item.DisableChannelItem.InputNightCheckBox.Checked = true;
                                      item.DisableChannelItem.InputNightCheckBox.Enabled = false;
                                      item.DisableChannelItem.InputDayCheckBox.Checked = true;
                                      item.DisableChannelItem.InputDayCheckBox.Enabled = false;
                                  }
                                  else
                                  {                                                     
                                      item.DisableChannelItem.InputDayCheckBox.Checked   = config.inputs[ chan ].flags.contains( App::Options[ DisabledDay ] );
                                      item.DisableChannelItem.InputNightCheckBox.Checked = config.inputs[ chan ].flags.contains( App::Options[ DisabledNight ] );
                                  }

                                  item.DisableChannelItem.InvalidateViewState();
                         
                                  return;
                              }
                              else
                              {
                                  i = i + 1;
                              }
                          }
                       }

                       for( chan = 0; chan < config.numoutputs; chan = chan + 1 )
                       {
                          if ( curZone > 0 || ( curZone == -1 && config.IsAlarmDevice( chan ) ) ||
                                              ( curZone == 0  && ( config.outputs[ chan ].type == App::ChannelType.OutputRouting || 
                                                                 config.outputs[ chan ].type == App::ChannelType.PanelRoutingOutput ) ) )                          
                          {
                              if ( i == itemNo )
                              {
                                  item.DisableUnitItem.Visible = false;
                                  item.DisableUnitItem.Enabled = false;

                                  item.DisableZoneItem.Visible = false;
                                  item.DisableZoneItem.Enabled = false;

                                  item.DisableChannelItem.Visible = true;
                                  item.DisableChannelItem.Enabled = true;

                                  item.DisableChannelItem.ChanNum = chan;
                                  item.DisableChannelItem.UnitNum = unitno;
                                  item.DisableChannelItem.ZoneNum = curZone;

                                  item.DisableChannelItem.OutputCheckBox.Visible = true;
                                  item.DisableChannelItem.OutputCheckBox.Enabled = true;

                                  item.DisableChannelItem.InputDayCheckBox.Visible = false;
                                  item.DisableChannelItem.InputDayCheckBox.Enabled = false;
                                  item.DisableChannelItem.InputNightCheckBox.Visible = false;
                                  item.DisableChannelItem.InputNightCheckBox.Enabled = false;
                                  item.DisableChannelItem.Text.Visible = false;
                                  item.DisableChannelItem.Text1.Visible = false;
                                  item.DisableChannelItem.Text2.Visible = true;

                                  item.DisableChannelItem.ChannelName.String = App::Lib.TypeName( config.outputs[ chan].type ); 
                                  item.DisableChannelItem.ChannelImage.Bitmap = config.outputs[ chan].type;

                                  if ( zonedisabled || config.flags.contains( App::DeviceConfigFlags[ Disabled ] ) ||
                                       ( firedisabled && config.inputs[ chan].action == App::Action.Fire ) ||
                                       ( routingdisabled && config.outputs[ chan].type == App::ChannelType.PanelRoutingOutput ) ||
                                       ( routingdisabled && config.outputs[ chan].type == App::ChannelType.OutputRouting ) )  

                                  {
                                      item.DisableChannelItem.OutputCheckBox.Checked = true;
                                      item.DisableChannelItem.OutputCheckBox.Enabled = false;
                                  }
                                  else
                                  {
                                      item.DisableChannelItem.OutputCheckBox.Checked = config.outputs[ chan ].flags.contains( App::Options[ Disabled ] );
                                      item.DisableChannelItem.OutputCheckBox.Enabled = true;
                                  }

                                  item.DisableChannelItem.InvalidateViewState( );
                                  return;
                              }
                              else
                              {
                                  i = i + 1;
                              }
                          }         
                      }
      
                  }
                  dev = dev + 1;
              }
           }
        }
        curZone = curZone + 1;
    }

                       
    item.Visible = false;
    item.InvalidateViewState();
     


    /*













    var uint8 curZone = 0;


       var int32 i = 0;
       var int32 numZones = 2;

       native( numZones ) 
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }
       
       
       while ( numZones > 0 )
       {
          var int32 numdevs = 4; 
          native( numdevs, curZone )
          {  
            Command cmd;
          
            cmd.int0 = curZone;
            Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
            numdevs = cmd.int0;
          }

          if ( numdevs > 0 )
          {
            numZones = numZones - 1;
            if ( itemNo == i )
            {
              item.DisableZoneItem.ZoneNum = curZone;
              item.DisableZoneItem.Visible = true;
              item.DisableZoneItem.Enabled = true;

              item.DisableUnitItem.Visible = false;
              item.DisableUnitItem.Enabled = false;

              item.DisableChannelItem.Visible = false;
              item.DisableChannelItem.Enabled = false;
        
              item.DisableZoneItem.InvalidateViewState();
              return;
            }
            else
            {
               i = i + 1;
            }

            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );

            if ( zf.contains( App::ZoneFlags[ DisableExpanded ] ) )
            {                             
                var int32 dev = 0;

                while ( dev < numdevs )
                {
                  var string location = "~";
                  var uint16 unitno = dev + 1;
                  var uint8 zoneno = curZone;
                  var int32 devptr = 0;
                  var int32 found = 1;
                
                  native( dev, curZone, location, unitno, zoneno, devptr )
                  {  
                    Command cmd;
                    
                    cmd.int0 = curZone;
                    cmd.int1 = dev;
                    Command0( CMD_GET_DEV_IN_ZONE, &cmd );
                    DeviceConfig* device = (DeviceConfig*) cmd.int0;

                    if ( device != NULL )
                    {
                      if ( strlen( device->location ) > 40 )   device->location[ 39] = 0; 
                      location = EwNewStringAnsi( device->location );
                      unitno = device->unit;
                      zoneno = device->zone;
                      devptr = (int) device;

                      cmd.int0 = unitno;
                      Command0( CMD_FIND_DEVICE_FROM_UNIT, &cmd );
                      found = cmd.int0;
                    } 
                  }

                  if ( i == itemNo )
                  {   
                      item.DisableUnitItem.Visible = true;

                      if ( found == 0 )
                      {
                      item.DisableUnitItem.Enabled = false;
                      }
                      else
                      {
                       item.DisableUnitItem.Enabled = true;
                      }

                      item.DisableZoneItem.Visible = false;
                      item.DisableZoneItem.Enabled = false;

                      item.DisableChannelItem.Visible = false;
                      item.DisableChannelItem.Enabled = false;

                      item.DisableUnitItem.UnitNum = unitno;
                      item.DisableUnitItem.ZoneNum = curZone;
                      item.DisableUnitItem.ActualZone = zoneno;
                      item.DisableUnitItem.DescriptionText.String = location;

                      item.DisableUnitItem.InvalidateViewState(); 

                      return;
                   }
                   else
                   {
                      i = i + 1;
                   }

                   if ( isDeviceExpanded( unitno ) )
                   {
                     var int32 type = 0;
                     var string channame;
                     var int32 chan = 0;
                

                     do
                     {                
                        native( chan, channame, type, devptr ) 
                        {
                           DeviceConfig* d = (DeviceConfig*) devptr;
                           if ( d != NULL )
                           {
                              Command cmd;
                              type = d->input[ chan].type;

                              cmd.int0 = (int) d;

                              Command0( CMD_GET_DEVICE_FROM_CONFIG, &cmd );

                              Device* dev = (Device*)  cmd.int0;
                           }
                        }
    $if (!$prototyper)
                        if ( type != 0 )
                        {
    $endif                      
                          if ( i == itemNo )
                          {
                            item.DisableUnitItem.Visible = false;
                            item.DisableUnitItem.Enabled = false;

                            item.DisableZoneItem.Visible = false;
                            item.DisableZoneItem.Enabled = false;

                            item.DisableChannelItem.Visible = true;
                            item.DisableChannelItem.Enabled = true;

                            item.DisableChannelItem.ChanNum = chan;
                            item.DisableChannelItem.UnitNum = unitno;
                            item.DisableChannelItem.ZoneNum = curZone;

                            item.DisableChannelItem.InputCheckBox.Visible = true;
                            item.DisableChannelItem.InputCheckBox.Enabled = true;

                            item.DisableChannelItem.OutputCheckBox.Visible = false;
                            item.DisableChannelItem.OutputCheckBox.Enabled = false;



                            switch ( type )
                            {
                                case 1 : item.DisableChannelItem.ChannelName.String = "Smoke";
                                case 2 : item.DisableChannelItem.ChannelName.String = "Heat A1R";
                                case 3 : item.DisableChannelItem.ChannelName.String = "Heat B" ;
                                case 4 : item.DisableChannelItem.ChannelName.String = "PIR";
                                case 5 : item.DisableChannelItem.ChannelName.String = "Call point";
                                case 7 : item.DisableChannelItem.ChannelName.String = "First Aid";
        
                                default : item.DisableChannelItem.ChannelName.String = "Input " + string(chan + 1);
                            }
                            return;
                          }
                          else
                          {
                             i = i + 1;
                          }
    $if (!$prototyper)
                         }
    $endif
                         chan = chan + 1;
                      } while ( type != 0 );
                              
                      chan = 0;
                     

                     do
                     {                
                        native( chan, channame, type, devptr ) 
                        {
                           DeviceConfig* d = (DeviceConfig*) devptr;
                           if ( d != NULL )
                           {
                              int bit;
                              OutputChannel* out = d->output + chan;
                              type = out->type;
                           }
                        }
    $if (!$prototyper)
                        if ( type != 0 )
                        {
    $endif                      
                          if ( i == itemNo )
                          {
                            item.DisableUnitItem.Visible = false;
                            item.DisableUnitItem.Enabled = false;

                            item.DisableZoneItem.Visible = false;
                            item.DisableZoneItem.Enabled = false;

                            item.DisableChannelItem.Visible = true;
                            item.DisableChannelItem.Enabled = true;

                            item.DisableChannelItem.ChanNum = chan;
                            item.DisableChannelItem.UnitNum = unitno;
                            item.DisableChannelItem.ZoneNum = curZone;

                            item.DisableChannelItem.OutputCheckBox.Visible = true;
                            item.DisableChannelItem.OutputCheckBox.Enabled = true;
                            item.DisableChannelItem.InputCheckBox.Visible = false;
                            item.DisableChannelItem.InputCheckBox.Enabled = false;

                            switch ( type )
                            {
                                case 5 : item.DisableChannelItem.ChannelName.String = "Sounder";
                                case 6 : item.DisableChannelItem.ChannelName.String = "Beacon";
                                case 9 : item.DisableChannelItem.ChannelName.String = "SVI" ;
                                case 10 : item.DisableChannelItem.ChannelName.String = "Sounder/VI" ;
                                case 13 : item.DisableChannelItem.ChannelName.String = "Fire Routing" ;
                                default : item.DisableChannelItem.ChannelName.String = "Output " + string( chan + 1);
                             }
                             return;
                           }
                           else
                           {
                            i = i + 1;
                           }
    $if (!$prototyper)
                         }
    $endif
                         chan = chan + 1;
                      } while ( type != 0 );                

                     
                  }
                  dev = dev + 1;
              }
           }
         }
         curZone = curZone + 1;
       }


        // EEK shouldnt be here
        item.DisableUnitItem.Visible = false;
        item.DisableZoneItem.Visible = false;

     */
  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <0,0,615,365>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::DisableItem;
    preset ItemHeight = 50;
    preset onRefreshAll = OnRefreshAll;
  }

  $rect <780,180,1010,220>
  object Core::SystemEventHandler SiteChangedEventHandler
  {
    preset OnEvent = Refresh;
    preset Event = App::Devices.SiteChangedEvent;
  }

  $rect <420,380,570,420>
  slot Recount
  {
    sender; /* the method is called from the sender object */

    signal Refresh;
     
    var App::Application app = (App::Application) Owner;

    if ( app != null )
    {
      postsignal app.Disablements.Refresh;

    } 

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <570,430,710,470>
  slot OnRefreshAll
  {
     
    var int32       itemNo   = ListViewer.Item;

     
    var App::DisableItem item = (App::DisableItem) ListViewer.VerticalList.first;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 

    var bool firedisabled = App::Lib.GetZoneDisabledState( -1);
    var bool routingdisabled = App::Lib.GetZoneDisabledState( 0);
     
    var int32 i = 0;
    var int32 numZones = App::Lib.NumZonesWithDevices() + 2;

    if ( numZones == 2 )
    {
        while ( item != null )
        {
            item.Visible = false;
            item = (App::DisableItem) item.next;
        }
        return;
    }


    while ( item != null )
    {
        if ( itemNo < 0 ) 
        {
            item.Visible = false;
            item.InvalidateViewState();
        }
        else
        {
            var int16 curZone = -1;

            while ( numZones > 0 )
            {
                var int32 numdevs = App::Lib.NumDevsInZone( curZone ); 

                if ( numdevs > 0 || curZone < 1 )
                {
                    numZones = numZones - 1;
                    var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );
                    var bool zonedisabled = App::Lib.GetZoneDisabledState( curZone );

                    if ( itemNo == i )
                    {   
                        item.Visible = true;
           
                        item.DisableZoneItem.ToggleButton.Checked = zonedisabled;

                         item.DisableZoneItem.ToggleButton.Enabled =  ( numdevs != 0 );
                
                        item.DisableZoneItem.ExpandImage.Visible = ( numdevs != 0 );
               
                        item.DisableZoneItem.SimpleTouchHandler.Enabled = ( numdevs != 0 );
                
                        item.DisableZoneItem.PushButton.Enabled = ( !zonedisabled && ( numdevs != 0 ));

                        item.DisableZoneItem.ZoneNum = curZone;

                        if ( zf.contains( App::ZoneFlags[ DisableExpanded ] ) )    // if zone expanded
                        {
                           item.DisableZoneItem.ExpandImage.Bitmap = App::CollapseBitmap;
                        }
                        else
                        {
                           item.DisableZoneItem.ExpandImage.Bitmap = App::ExpandBitmap;
                        }

                        item.DisableZoneItem.Visible = true;

                       
                        item.DisableZoneItem.Enabled = ( numdevs != 0 );
                      

                        item.DisableUnitItem.Visible = false;
                        item.DisableUnitItem.Enabled = false;

                        item.DisableChannelItem.Visible = false;
                        item.DisableChannelItem.Enabled = false;

                        

                        item.DisableZoneItem.InvalidateViewState();
                   
                        item = (App::DisableItem) item.next;

                        if ( item == null ) return;
                    }
                    else 
                    {
                        i = i + 1;
                    }


                    if ( zf.contains( App::ZoneFlags[ DisableExpanded ] ) )    // if zone expanded
                    {                             
                        var int32 dev = 0;

                        while ( dev < numdevs )
                        {
                            var int16 unitno = App::Lib.GetDevInZone( curZone, dev );
                
                            var App::Device device = App::Lib.GetDevice( unitno );
                            var App::DeviceConfig config = App::Lib.GetConfig( unitno ); 

                            if ( config != null )  
                            {
                                if ( i == itemNo )   
                                { 
                                    item.Visible = true;
                                    if ( curZone < 1 ) 
                                    {
                                        item.DisableUnitItem.CheckBox.Enabled = false;
                                    }
                                    else
                                    {
                                        item.DisableUnitItem.CheckBox.Enabled = true;
                                    }

                                    item.DisableUnitItem.Visible = true;

                                    item.DisableZoneItem.Visible = false;
                                    item.DisableZoneItem.Enabled = false;

                                    item.DisableChannelItem.Visible = false;
                                    item.DisableChannelItem.Enabled = false;

                                    item.DisableUnitItem.UnitNum = unitno;
                                    item.DisableUnitItem.ZoneNum = config.zonenum;
                                    item.DisableUnitItem.ZoneGroup = curZone;
     
                                    item.DisableUnitItem.DescriptionText.String = config.location;

                                    if ( device == null )
                                    {
                                        item.DisableUnitItem.Enabled = false;
                                        item.DisableUnitItem.CheckBox.Enabled = false;
                                    }
                                    else
                                    {
                                        item.DisableUnitItem.Enabled = true;
                                    }

                                    if ( zonedisabled )
                                    {
                                        item.DisableUnitItem.CheckBox.Enabled = false;
                                        item.DisableUnitItem.CheckBox.Checked = true; 
                                    }
                                    else
                                    {
                                        if ( curZone > 0 ) item.DisableUnitItem.CheckBox.Enabled = true;

                                        item.DisableUnitItem.CheckBox.Checked = config.flags.contains( App::DeviceConfigFlags[ Disabled ] );
                                    }    
                        

                                    item.DisableUnitItem.InvalidateViewState(); 

                                    item = (App::DisableItem) item.next;
                          
                                    if ( item == null ) return;
                                }
                                else
                                {
                                    i = i + 1;
                                }

                                if ( device != null )
                                if ( device.IsDisableExpanded( curZone ) )    
                                {
                                    var int32 chan = 0;

                                    if ( curZone > 0 )
                                    {
                                       for ( chan = 0 ; chan < config.numinputs; chan = chan + 1 )
                                       {                
                                            if ( i == itemNo )
                                            {   
                                                item.Visible = true;
                                                item.DisableUnitItem.Visible = false;
                                                item.DisableUnitItem.Enabled = false;

                                                item.DisableZoneItem.Visible = false;
                                                item.DisableZoneItem.Enabled = false;

                                                item.DisableChannelItem.Visible = true;
                                                item.DisableChannelItem.Enabled = true;

                                                item.DisableChannelItem.ChanNum = chan;
                                                item.DisableChannelItem.UnitNum = unitno;
                                                item.DisableChannelItem.ZoneNum = curZone;

                                                item.DisableChannelItem.InputNightCheckBox.Visible = true;
                                                item.DisableChannelItem.InputNightCheckBox.Enabled = true;
                                                item.DisableChannelItem.InputDayCheckBox.Visible = true;
                                                item.DisableChannelItem.InputDayCheckBox.Enabled = true;
                                                item.DisableChannelItem.OutputCheckBox.Visible = false;
                                                item.DisableChannelItem.OutputCheckBox.Enabled = false;
                                                item.DisableChannelItem.Text.Visible = true;
                                                item.DisableChannelItem.Text1.Visible = true;
                                                item.DisableChannelItem.Text2.Visible = false;

                                                item.DisableChannelItem.ChannelName.String = App::Lib.TypeName( config.inputs[ chan].type );
                                                item.DisableChannelItem.ChannelImage.Bitmap = config.inputs[ chan].type;

                                                if ( zonedisabled || config.flags.contains( App::DeviceConfigFlags[ Disabled ] ) )

                                                {
                                                    item.DisableChannelItem.InputNightCheckBox.Checked = true;
                                                    item.DisableChannelItem.InputNightCheckBox.Enabled = false;
                                                    item.DisableChannelItem.InputDayCheckBox.Checked = true;
                                                    item.DisableChannelItem.InputDayCheckBox.Enabled = false;
                                                }
                                                else
                                                {                                                     
                                                    item.DisableChannelItem.InputDayCheckBox.Checked   = config.inputs[ chan ].flags.contains( App::Options[ DisabledDay ] );
                                                    item.DisableChannelItem.InputNightCheckBox.Checked = config.inputs[ chan ].flags.contains( App::Options[ DisabledNight ] );
                                                }

                                                item.DisableChannelItem.InvalidateViewState();

                                                item = (App::DisableItem) item.next;

                                                if ( item == null ) return;
                                            }
                                            else 
                                            {
                                                i = i + 1;
                                            }
                                        }
                                    }
                              

                                    for( chan = 0; chan < config.numoutputs; chan = chan + 1 )
                                    {
                                        if ( curZone > 0 || ( curZone == -1 && config.IsAlarmDevice( chan ) ) ||
                                              ( curZone == 0  && ( config.outputs[ chan ].type == App::ChannelType.OutputRouting || 
                                                                 config.outputs[ chan ].type == App::ChannelType.PanelRoutingOutput ) ) ) 
                                        {
           
                                            if ( i == itemNo )
                                            {
                                                item.Visible = true;
                                                item.DisableUnitItem.Visible = false;
                                                item.DisableUnitItem.Enabled = false;

                                                item.DisableZoneItem.Visible = false;
                                                item.DisableZoneItem.Enabled = false;

                                                item.DisableChannelItem.Visible = true;
                                                item.DisableChannelItem.Enabled = true;

                                                item.DisableChannelItem.ChanNum = chan;
                                                item.DisableChannelItem.UnitNum = unitno;
                                                item.DisableChannelItem.ZoneNum = curZone;

                                                item.DisableChannelItem.OutputCheckBox.Visible = true;
                                                item.DisableChannelItem.OutputCheckBox.Enabled = true;

                                                item.DisableChannelItem.InputDayCheckBox.Visible = false;
                                                item.DisableChannelItem.InputDayCheckBox.Enabled = false;
                                                item.DisableChannelItem.InputNightCheckBox.Visible = false;
                                                item.DisableChannelItem.InputNightCheckBox.Enabled = false;
                                                item.DisableChannelItem.Text.Visible = false;
                                                item.DisableChannelItem.Text1.Visible = false;
                                                item.DisableChannelItem.Text2.Visible = true;

                                                item.DisableChannelItem.ChannelName.String = App::Lib.TypeName( config.outputs[ chan].type ); 
                                                item.DisableChannelItem.ChannelImage.Bitmap = config.outputs[ chan].type;

                                                if ( zonedisabled || config.flags.contains( App::DeviceConfigFlags[ Disabled ] ) ||
                                                     ( firedisabled && config.inputs[ chan].action == App::Action.Fire ) ||
                                                     ( routingdisabled && config.outputs[ chan].type == App::ChannelType.PanelRoutingOutput ) ||
                                                     ( routingdisabled && config.outputs[ chan].type == App::ChannelType.OutputRouting ) )  

                                                {
                                                    item.DisableChannelItem.OutputCheckBox.Checked = true;
                                                    item.DisableChannelItem.OutputCheckBox.Enabled = false;
                                                }
                                                else
                                                {
                                                    item.DisableChannelItem.OutputCheckBox.Checked = config.outputs[ chan ].flags.contains( App::Options[ Disabled ] );
                                                    item.DisableChannelItem.OutputCheckBox.Enabled = true;
                                                }

                                                item.DisableChannelItem.InvalidateViewState( );

                                                item = (App::DisableItem) item.next;

                                                if ( item == null ) return;
                                            }
                                            else
                                            {
                                                i = i + 1;
                                            }
                                        }             
                                    }
                                }
                            }
                            dev = dev + 1;
                        }
                    }
                }
                curZone = curZone + 1;
            }
            while ( item != null )
            {
                item.Visible = false;
                item.InvalidateViewState();
                item = (App::DisableItem) item.next;
            }
            return;
        }       
        
        item = (App::DisableItem) item.next;
        itemNo = itemNo + 1;                
    }  


      /*













    var uint8 curZone = 0;


       var int32 i = 0;
       var int32 numZones = 2;

       native( numZones ) 
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }
       
       
       while ( numZones > 0 )
       {
          var int32 numdevs = 4; 
          native( numdevs, curZone )
          {  
            Command cmd;
          
            cmd.int0 = curZone;
            Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
            numdevs = cmd.int0;
          }

          if ( numdevs > 0 )
          {
            numZones = numZones - 1;
            if ( itemNo == i )
            {
              item.DisableZoneItem.ZoneNum = curZone;
              item.DisableZoneItem.Visible = true;
              item.DisableZoneItem.Enabled = true;

              item.DisableUnitItem.Visible = false;
              item.DisableUnitItem.Enabled = false;

              item.DisableChannelItem.Visible = false;
              item.DisableChannelItem.Enabled = false;
        
              item.DisableZoneItem.InvalidateViewState();
              return;
            }
            else
            {
               i = i + 1;
            }

            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );

            if ( zf.contains( App::ZoneFlags[ DisableExpanded ] ) )
            {                             
                var int32 dev = 0;

                while ( dev < numdevs )
                {
                  var string location = "~";
                  var uint16 unitno = dev + 1;
                  var uint8 zoneno = curZone;
                  var int32 devptr = 0;
                  var int32 found = 1;
                
                  native( dev, curZone, location, unitno, zoneno, devptr )
                  {  
                    Command cmd;
                    
                    cmd.int0 = curZone;
                    cmd.int1 = dev;
                    Command0( CMD_GET_DEV_IN_ZONE, &cmd );
                    DeviceConfig* device = (DeviceConfig*) cmd.int0;

                    if ( device != NULL )
                    {
                      if ( strlen( device->location ) > 40 )   device->location[ 39] = 0; 
                      location = EwNewStringAnsi( device->location );
                      unitno = device->unit;
                      zoneno = device->zone;
                      devptr = (int) device;

                      cmd.int0 = unitno;
                      Command0( CMD_FIND_DEVICE_FROM_UNIT, &cmd );
                      found = cmd.int0;
                    } 
                  }

                  if ( i == itemNo )
                  {   
                      item.DisableUnitItem.Visible = true;

                      if ( found == 0 )
                      {
                      item.DisableUnitItem.Enabled = false;
                      }
                      else
                      {
                       item.DisableUnitItem.Enabled = true;
                      }

                      item.DisableZoneItem.Visible = false;
                      item.DisableZoneItem.Enabled = false;

                      item.DisableChannelItem.Visible = false;
                      item.DisableChannelItem.Enabled = false;

                      item.DisableUnitItem.UnitNum = unitno;
                      item.DisableUnitItem.ZoneNum = curZone;
                      item.DisableUnitItem.ActualZone = zoneno;
                      item.DisableUnitItem.DescriptionText.String = location;

                      item.DisableUnitItem.InvalidateViewState(); 

                      return;
                   }
                   else
                   {
                      i = i + 1;
                   }

                   if ( isDeviceExpanded( unitno ) )
                   {
                     var int32 type = 0;
                     var string channame;
                     var int32 chan = 0;
                

                     do
                     {                
                        native( chan, channame, type, devptr ) 
                        {
                           DeviceConfig* d = (DeviceConfig*) devptr;
                           if ( d != NULL )
                           {
                              Command cmd;
                              type = d->input[ chan].type;

                              cmd.int0 = (int) d;

                              Command0( CMD_GET_DEVICE_FROM_CONFIG, &cmd );

                              Device* dev = (Device*)  cmd.int0;
                           }
                        }
    $if (!$prototyper)
                        if ( type != 0 )
                        {
    $endif                      
                          if ( i == itemNo )
                          {
                            item.DisableUnitItem.Visible = false;
                            item.DisableUnitItem.Enabled = false;

                            item.DisableZoneItem.Visible = false;
                            item.DisableZoneItem.Enabled = false;

                            item.DisableChannelItem.Visible = true;
                            item.DisableChannelItem.Enabled = true;

                            item.DisableChannelItem.ChanNum = chan;
                            item.DisableChannelItem.UnitNum = unitno;
                            item.DisableChannelItem.ZoneNum = curZone;

                            item.DisableChannelItem.InputCheckBox.Visible = true;
                            item.DisableChannelItem.InputCheckBox.Enabled = true;

                            item.DisableChannelItem.OutputCheckBox.Visible = false;
                            item.DisableChannelItem.OutputCheckBox.Enabled = false;



                            switch ( type )
                            {
                                case 1 : item.DisableChannelItem.ChannelName.String = "Smoke";
                                case 2 : item.DisableChannelItem.ChannelName.String = "Heat A1R";
                                case 3 : item.DisableChannelItem.ChannelName.String = "Heat B" ;
                                case 4 : item.DisableChannelItem.ChannelName.String = "PIR";
                                case 5 : item.DisableChannelItem.ChannelName.String = "Call point";
                                case 7 : item.DisableChannelItem.ChannelName.String = "First Aid";
        
                                default : item.DisableChannelItem.ChannelName.String = "Input " + string(chan + 1);
                            }
                            return;
                          }
                          else
                          {
                             i = i + 1;
                          }
    $if (!$prototyper)
                         }
    $endif
                         chan = chan + 1;
                      } while ( type != 0 );
                              
                      chan = 0;
                     

                     do
                     {                
                        native( chan, channame, type, devptr ) 
                        {
                           DeviceConfig* d = (DeviceConfig*) devptr;
                           if ( d != NULL )
                           {
                              int bit;
                              OutputChannel* out = d->output + chan;
                              type = out->type;
                           }
                        }
    $if (!$prototyper)
                        if ( type != 0 )
                        {
    $endif                      
                          if ( i == itemNo )
                          {
                            item.DisableUnitItem.Visible = false;
                            item.DisableUnitItem.Enabled = false;

                            item.DisableZoneItem.Visible = false;
                            item.DisableZoneItem.Enabled = false;

                            item.DisableChannelItem.Visible = true;
                            item.DisableChannelItem.Enabled = true;

                            item.DisableChannelItem.ChanNum = chan;
                            item.DisableChannelItem.UnitNum = unitno;
                            item.DisableChannelItem.ZoneNum = curZone;

                            item.DisableChannelItem.OutputCheckBox.Visible = true;
                            item.DisableChannelItem.OutputCheckBox.Enabled = true;
                            item.DisableChannelItem.InputCheckBox.Visible = false;
                            item.DisableChannelItem.InputCheckBox.Enabled = false;

                            switch ( type )
                            {
                                case 5 : item.DisableChannelItem.ChannelName.String = "Sounder";
                                case 6 : item.DisableChannelItem.ChannelName.String = "Beacon";
                                case 9 : item.DisableChannelItem.ChannelName.String = "SVI" ;
                                case 10 : item.DisableChannelItem.ChannelName.String = "Sounder/VI" ;
                                case 13 : item.DisableChannelItem.ChannelName.String = "Fire Routing" ;
                                default : item.DisableChannelItem.ChannelName.String = "Output " + string( chan + 1);
                             }
                             return;
                           }
                           else
                           {
                            i = i + 1;
                           }
    $if (!$prototyper)
                         }
    $endif
                         chan = chan + 1;
                      } while ( type != 0 );                

                     
                  }
                  dev = dev + 1;
              }
           }
         }
         curZone = curZone + 1;
       }


        // EEK shouldnt be here
        item.DisableUnitItem.Visible = false;
        item.DisableZoneItem.Visible = false;

     */
  }

  $rect <770,100,1030,140>
  object Core::SystemEventHandler MeshListChangeEventHandler
  {
    preset OnEvent = Refresh;
    preset Event = App::Devices.MeshListChangeEvent;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <619,14,769,64>;
    preset Enabled = false;
    preset OnSwitchOn = ToggelBuzzer;
    preset OnSwitchOff = ToggelBuzzer;
    preset Label = "Disable Buzzer";
    preset Appearance = App::Switch_Medium;
  }

  $rect <810,0,1010,40>
  slot ToggelBuzzer
  {
    sender; /* the method is called from the sender object */

    var bool dis = ToggleButton.Checked;

    native( dis )
    {
      Command cmd;
      cmd.int0 = dis;
      Command0( CMD_SET_BUZZER_STATE, &cmd ); 
    }

    signal AccessSlot;


  }

  $rect <770,420,1000,460>
  object Core::SystemEventHandler AccessLevelChange
  {
    preset OnEvent = AccessSlot;
    preset Event = App::Devices.AccessModeChangeEvent;
  }

  $rect <780,460,980,500>
  slot AccessSlot
  {
    sender; /* the method is called from the sender object */


    if ( ToggleButton.Checked )
    {
         ToggleButton.Enabled = true;
     }
     else
     {
        var App::Application app = (App::Application) GetRoot();
      
        if ( app != null )
        {
           ToggleButton.Enabled = ( app.LevelAccess.AccessLevel >= 4 );
        }
    }
      
  }

  $rect <810,140,1010,180>
  slot Refresh
  {
    sender; /* the method is called from the sender object */


    if ( Visible )
    {
      var int32 n = 0;

      native( n )
      {
        Command cmd;

        Command0( CMD_GET_NUM_ENABLE_DISABLE, &cmd );

        n = cmd.int0;
      }

      ListViewer.NoOfItems = n;

      
    }

  }

  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
}

$rect <450,920,640,960>
$output false
class DisableChannelItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,570,50>;

  $rect <35,340,215,380>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 






  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Views::Text ChannelName
  {
    preset Bounds = <350,10,505,40>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <0,70,200,110>
  property uint8 ChanNum = 0;

  $rect <0,110,200,150>
  property uint16 UnitNum = 0;

  $rect <515,200,715,240>
  slot LoadNames
  {
    sender; /* the method is called from the sender object */

    var App::SmallDropDownMenuList menu = (App::SmallDropDownMenuList) sender;

    if ( menu != null )
    {
      menu.itemName = App::Lib.ProfileName( menu.itemIndex );
    }
     
  }

  $rect <0,150,200,190>
  property int8 DefaultAction = -1;

  $rect <255,310,480,350>
  slot ToggleInputNightChannel
  {
    sender; /* the method is called from the sender object */

                      
    var App::DeviceConfig d = App::Lib.GetConfig( UnitNum );

    if ( InputNightCheckBox.Checked )
    {
        d.inputs[ ChanNum ].flags = d.inputs[ ChanNum ].flags + App::Options[ DisabledNight ];
    }
    else
    {
      
        d.inputs[ ChanNum ].flags = d.inputs[ ChanNum ].flags - App::Options[ DisabledNight ];
    }

    App::Lib.SetConfig( UnitNum, true, d );

    var App::Disable disablepage = (App::Disable) Owner.Owner.Owner.Owner;

    if ( disablepage != null )
    {
      postsignal disablepage.Recount;   
    }  
     

  }

  $rect <180,65,380,105>
  property uint8 ZoneNum = 0;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton InputNightCheckBox
  {
    preset Bounds = <120,0,170,50>;
    preset OnSwitchOn = ToggleInputNightChannel;
    preset OnSwitchOff = ToggleInputNightChannel;
    preset Label = "";
    preset Appearance = App::DisableSmallCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton OutputCheckBox
  {
    preset Bounds = <120,0,170,50>;
    preset OnSwitchOn = ToggleOutputChannel;
    preset OnSwitchOff = ToggleOutputChannel;
    preset Label = "";
    preset Appearance = App::DisableSmallCheckBox;
  }

  $rect <650,320,850,360>
  slot ToggleOutputChannel
  {
    sender; /* the method is called from the sender object */

                  
    var App::DeviceConfig d = App::Lib.GetConfig( UnitNum );

    if ( OutputCheckBox.Checked )
    {
        d.outputs[ ChanNum ].flags = d.outputs[ ChanNum ].flags + App::Options[ Disabled ];
    }
    else
    {
        d.outputs[ ChanNum ].flags = d.outputs[ ChanNum ].flags - App::Options[ Disabled ];
    }

    App::Lib.SetConfig( UnitNum, true, d );

    var App::Disable disablepage = (App::Disable) Owner.Owner.Owner.Owner;


    if ( disablepage != null )
    {
        postsignal disablepage.Recount ;
    }


  }

  $rect <20,20,160,60>
  object App::ChannelImage ChannelImage
  {
    preset Bounds = <526,8,562,44>;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton InputDayCheckBox
  {
    preset Bounds = <240,0,290,50>;
    preset OnSwitchOn = ToggleInputDayChannel;
    preset OnSwitchOff = ToggleInputDayChannel;
    preset Label = "";
    preset Appearance = App::DisableSmallCheckBox;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <280,10,350,40>;
    preset String = "Daytime";
    preset Font = App::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <160,10,230,40>;
    preset String = "Nighttime";
    preset Font = App::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $rect <260,350,470,390>
  slot ToggleInputDayChannel
  {
    sender; /* the method is called from the sender object */

                  
    var App::DeviceConfig d = App::Lib.GetConfig( UnitNum );

    if ( InputDayCheckBox.Checked )
    {
        d.inputs[ ChanNum ].flags = d.inputs[ ChanNum ].flags + App::Options[ DisabledDay ];
    }
    else
    {
        d.inputs[ ChanNum ].flags = d.inputs[ ChanNum ].flags - App::Options[ DisabledDay ];
    }

    App::Lib.SetConfig( UnitNum, true, d );

    var App::Disable disablepage = (App::Disable) Owner.Owner.Owner.Owner;

    if ( disablepage != null )
    {
      signal disablepage.Recount;
    }  

     
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <160,10,270,40>;
    preset String = "Night and day";
    preset Font = App::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <1440,1040,1620,1080>
resource Resources::Bitmap SiteNetBitmap
{
  attr bitmapfile FileName = .\Images\sitenet180.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <20,860,170,900>
$output false
class MeshTree : Core::Group
{
  $rect <495,410,695,450>
  inherited property Bounds = <0,0,795,365>;

  $rect <25,595,165,635>
  inherited onset Visible
  {
    // TO DO: Write your code here ... 

    super( value );


    if ( Visible )
    {
      ListViewer.NoOfItems = ActiveCountView.total + extra + 2;       // + ncu and gap row
     
      InvalidateViewState();
    }
  }

  $rect <715,437,915,477>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <690,380,890,420>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

     
    Path.SetMaxNoOfSubPaths(512);

                 
    SubIndex = 0;

     
    Row = 0;

    DrawBranch( 0, 0 );

    var int32 s;

    for( s = SubIndex; s < 512; s=s + 1 )
    {
      Path.InitSubPath( s, 0 );
    }

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <200,605,340,645>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    var App::Application ap = (App::Application) GetRoot();

    if ( ap != null )
    {
      PushButton3.Enabled = ( ap.LevelAccess.AccessLevel >= 3 );
    }

  }

  $rect <490,380,690,420>
  object Graphics::Path Path;

  $rect <845,-10,1015,30>
  property point Origin = <-3,26>;

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <495,460,655,500>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;
    var App::MeshUnitItem device = (App::MeshUnitItem) ListViewer.VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( device == null )
      return;

    var string s = "Panel";
    var bool no_site = false;
       
    native( no_site )
    {
      if ( Command1( CMD_CHECK_TREE, 0 ) ) return;

      Command cmd;
      Command0( CMD_GET_PANEL, &cmd );

      if ( cmd.int0 != 0 )
      {
          Panel* p = (Panel*) cmd.int0;
          s = EwNewStringAnsi( p->name );
      }
      else
      {
        no_site =  1;
      }
    }   

    if ( no_site )
    {
       device.Visible = false;
       return;
    }

    device.MeshUnit.Bounds.x1 = -10;
    device.MeshUnit.Bounds.x2 = 330;   

    if ( itemNo == 0 )
    {
        
       device.Visible = true;
     
       device.MeshUnit.NCUText.String = s;  
       device.MeshUnit.Status = App::RadioStatus.NCU; 
        
       device.InvalidateViewState();
       
       return;
    }

    device.MeshUnit.BatteryImage.Visible = true;    
    device.MeshUnit.Visible = true;
    device.Visible = true;

    var int32 selected = ListViewer.VerticalList.SelectedItem;




    pure Row = 1;

    if ( GetChildren( device, 0, itemNo, 0 ) ) return;

     

    var int32 row = pure Row;


    if ( row == itemNo )
    {
      device.Visible = false;
      return;
    }
    else
    {
        device.Visible = true;
       row = row + 1;
    }
     

    var int32 numConfig = App::Lib.GetNumSiteDevices( );
    var int32 numFound  = App::Lib.GetNumRadiosFound( );



    var int32 d;
    var int32 r;  

      
    // Devices not in config
    for( r = 0; r < numFound; r = r + 1 )
    {
      var App::RadioUnit ru = App::Lib.GetRadioNum( r );

      if ( ru != null )
      {
         var App::DeviceConfig dev = App::Lib.GetConfig( ru.unitnum );

         if ( dev == null )
         {
            if ( !App::Lib.OnTree( ru.unitnum ) )
            {
                if ( row == itemNo )
                {                
                      
                    SetupUnit( device, ru, dev, ListViewer.VerticalList.SelectedItem );
                       
                    return;
                 }
                 else row = row + 1;
              }
           }        
        }
    }



    // Devices in both

    for( r = 0; r < numFound; r = r + 1 )
    {
      var App::RadioUnit ru = App::Lib.GetRadioNum( r );

      if ( ru != null )
      {
         var App::DeviceConfig dev = App::Lib.GetConfig( ru.unitnum );

         if ( dev != null )
         {
              if( !App::Lib.OnTree( ru.unitnum ) )
              {
                if ( row == itemNo )
                {
                     SetupUnit( device, ru, dev, ListViewer.VerticalList.SelectedItem );
                
                    return;
                 }
                 else row = row + 1;
               
             } 
          }
       }
    }


    // Devices not found

    for( d = 0; d < numConfig; d = d + 1 )
    {
      var App::DeviceConfig dev = App::Lib.GetConfigNum( d );

      if ( dev != null )
      {
         if ( dev.combination < 64 )  // mesh types only!
         {
            var App::RadioUnit ru = App::Lib.GetRadio( dev.unitnum );

            if ( ru == null ) // if not found
            {
                if ( row == itemNo )
                {
                     SetupUnit( device, ru, dev, ListViewer.VerticalList.SelectedItem );
                  
                    return;
                 }
                 else row = row + 1;
              }
          
           }
        }
    }

    device.Enabled = false;
    device.Visible = false;
    //device.MeshUnit.Visible = false;
    device.InvalidateViewState();
    //device.MeshUnit.InvalidateViewState();
    //InvalidateViewState( );




    /*

    OLD VERSION

    native ( zone, younit, defcombo, itemNo, radiocombo, status, row, snr, selected )
    {
        Command cmd;
        Command0( CMD_GET_DEVICE_LISTS, &cmd );  

        if ( (void*)cmd.int0 != NULL )
        {
          DeviceConfig* dev      = (DeviceConfig*)   cmd.int0;  
          RadioUnit* rad      = (RadioUnit*)   cmd.int1;
          const char** combis = (const char**) cmd.int3;

          int numConfig = cmd.short4;
          int numFound =  cmd.short5;

       
          DeviceConfig* d;
          RadioUnit* r;

          // Devices not found

          for( d = dev; d < dev + numConfig; d++ )
          {
              if ( !FindRadioDevice( rad, numFound, d->zone, d->unit ) )
              {
                  if ( row == itemNo )
                  {               
                      zone = d->zone;
                      younit = d->unit;

                      status = 0;  // unfound 'x'

                      if ( d->type < MAX_COMBINATION_TYPE )
                      {
                         defcombo  = EwNewStringAnsi( combis[ d->type ] );
                      }
                      else
                      {
                        defcombo =  EwNewStringAnsi( "------" );
                      }
                      
                      goto done;
                  }
                  else row++;
              }
          }
          
          // Devices not in config

          if ( rad != NULL )
          {
            for( r = rad; r < rad + numFound; r++ )
            {
                if ( !FindConfigDevice( dev, numConfig, r->zone, r->unit ) )
                {
                    if ( r->primary == -1 )
                    {
                        if ( row == itemNo )
                        {
                            zone = r->zone;
                            younit = r->unit;
                            snr = r->snrprimary;

                            if ( r->combination < MAX_COMBINATION_TYPE )
                            {
                               radiocombo  = EwNewStringAnsi( combis[ r->combination ] );
                            }
                            else
                            {
                              radiocombo =  EwNewStringAnsi( "------" );
                            }
                      
                            status = 2;  // additional +

                            
                            snr = r->snrprimary;
                               
                        
                            goto done;
                        }
                        else row++;
                    }
                    
                }
            }         
         }                             
                
          // Devices in both
          if ( rad != NULL )
          {
            for( d = dev; d < dev + numConfig; d++ )
            {
                if ( r = FindRadioDevice( rad, numFound, d->zone, d->unit ) )
                {
                    if ( r->primary == -1 )
                    {
                      if ( row == itemNo )
                      {               
                          zone = d->zone;
                          younit = d->unit;
                          

                          if ( r->combination < MAX_COMBINATION_TYPE )
                          {
                             radiocombo  = EwNewStringAnsi( combis[ r->combination ] );
                          }
                          else
                          {
                            radiocombo =  EwNewStringAnsi( "------" );
                          }
                          if ( d->type < MAX_COMBINATION_TYPE )
                          {
                             defcombo  = EwNewStringAnsi( combis[ d->type ] );
                          }
                          else
                          {
                            defcombo =  EwNewStringAnsi( "------" );
                          }

                          snr = r->primary;

                         
                          if ( d->type == r->combination )
                          {
                            status = 1;  // found
                          }
                          else
                          {
                            status = 3; // different ?   
                          }    
                         
                          goto done;
                      }
                      else row++;
                    }
                }
            }
         }
            //time   = TimeStr( );
       }
    done:    ;
     
    }

          device.MeshUnit.UnitNum.String = string(younit);
          device.MeshUnit.ZoneNum.String = string(zone);
          device.MeshUnit.SNR = snr;            
          device.MeshUnit.DefinedComb = defcombo;
          device.MeshUnit.RadioComb = radiocombo;
          device.MeshUnit.Status = status;
          device.MeshNCU.Visible = false;
          device.MeshUnit.Visible = true;

          device.MeshUnit.InvalidateViewState();
          
     
    */
  }

  $rect <340,400,510,440>
  method void DrawConnector( arg int32 x, arg int32 y, arg int32 y2 )
  {
    /* The template just returns the given argument... */



    Path.InitSubPath( pure SubIndex, 4 );
     

    Path.Begin( pure SubIndex, pure Origin.x + x, pure Origin.y + y + 2);
    Path.AddArc( pure SubIndex, pure Origin.x + x + pure Radius, Origin.y + y2 + 2, pure Radius, pure Radius, 180, 90, 3 );



    SubIndex = SubIndex + 1;

     

                    
  }

  $rect <985,220,1135,260>
  array int8 Array[ 15 ] =
  (
    Default[0] = -1;
    Default[1] = 0;
    Default[2] = 0;
    Default[3] = 0;
    Default[4] = 1;
    Default[5] = 1;
    Default[6] = 1;
    Default[7] = 1;
    Default[8] = 2;
    Default[9] = 3;
    Default[10] = 2;
    Default[11] = 1;
    Default[12] = 2;
    Default[13] = 2;
    Default[14] = 10;
  );

  $rect <1075,190,1225,230>
  property point Spacing = <16,30>;

  $rect <400,80,570,120>
  property int32 Radius = 11;

  $rect <150,280,340,320>
  property int32 SubIndex = 0;

  $rect <1070,115,1270,155>
  property int32 Row = 0;

  $rect <325,360,465,400>
  method void DrawBranch( arg int32 indent, arg int32 parent )
  {
    native  
    {
      if ( capp->site == NULL || capp->panel == NULL )
      {
         return;
      }
    }



    var int32 child = FindNextChild( 0, parent );
    var int32 startrow = pure Row;
    var int32 endrow = pure Row;

    indent = indent + 1;

    while ( child != 0 )
    {   
       

       pure Row = pure Row + 1;

       endrow = pure Row;
      
       var int32 unitnum = child;

       native( child, unitnum )
       {
           RadioUnit* ru = (RadioUnit*) child;
             
           unitnum = ru->unit; 
       }    
       DrawBranch( indent, unitnum );       

       child = FindNextChild( child, parent );
    }

    if ( endrow != startrow )
    {
       DrawLine( indent * pure Spacing.x, startrow * pure Spacing.y, endrow * pure Spacing.y );
    }
  }

  $rect <830,330,1030,370>
  method int32 FindNextChild( arg int32 start, arg int32 parent )
  {
    var int32 i;

    $if ($prototyper)
    for( i = start + 1 ; i < 15; i = i + 1 )
    {
      if ( Array[ i] == parent ) return i;
    }

    return 0;

    $endif

    var int32 child = 0;

    native( start, parent, child )
    {
        child = (int) get_child_unit( (RadioUnit*) start, parent ); 
    }

    return child;
  }

  $rect <20,20,160,60>
  object Views::StrokePath BranchPath
  {
    preset Bounds = <0,0,570,365>;
    preset Color = #000000FF;
    preset Width = 3;
    preset Path = Path;
  }

  $rect <890,380,1090,420>
  method bool GetChildren( arg App::MeshUnitItem device, arg int32 parent, arg int32 itemNo, arg int32 indent )
  {
    var int32 child = FindNextChild( 0, parent );
    var int32 startrow = pure Row;

    var int32 Status = 1;
     

    indent = indent + 1;

    while ( child != 0 )
    {     
        var string radiocomb = "????";
        var string defcomb = "????";
        var App::RadioUnit ru = App::Lib.GetRadioFromPtr( child );

        if ( ru != null )
        {
            if ( Row == itemNo )
            {  
                var App::DeviceConfig dev = App::Lib.GetConfig( ru.unitnum );

                device.MeshUnit.Bounds.x1 = indent * pure Spacing.x - 4;
                device.MeshUnit.Bounds.x2 = device.MeshUnit.Bounds.x1 + 340;

                SetupUnit( device, ru, dev, ListViewer.VerticalList.SelectedItem );
           
                
                return true;
            }
        
            pure Row = pure Row + 1;

            if ( GetChildren( device, ru.unitnum, itemNo, indent ) ) return true;

            child = FindNextChild( child, parent );   
        } 
        else
        {
            device.MeshUnit.Visible = false;
        }       
    }

    return false;
  }

  $rect <1080,60,1280,100>
  property int8 Radius2 = 10;

  $rect <1110,425,1370,465>
  object Core::SystemEventHandler MeshListChangeEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = App::Devices.MeshListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1120,380,1270,420>
  slot onEvent1
  {
      var App::MeshStatus mesh = (App::MeshStatus) MeshListChangeEventHandler.Context;

      totalItems = mesh.total;
      extra = mesh.extra;

      ActiveCountView.count = mesh.active;
      DetectedCountView.count = mesh.meshed; 
     
      ActiveCountView.total = mesh.total;
      DetectedCountView.total = mesh.total;

      if ( mesh.active == mesh.total )
      {
         DetectedCountView.Timer.Enabled = false;
         ActiveCountView.Timer.Enabled = false;
         ActiveCountView.HorizontalValueBar1.Opacity = 255;
         DetectedCountView.HorizontalValueBar1.Opacity = 255;
      }
      else
      {
        if ( mesh.active > 0 )
        {
            ActiveCountView.Timer.Enabled = true;
            DetectedCountView.Timer.Enabled = false;
            DetectedCountView.HorizontalValueBar1.Opacity = 255;
        }
        else
        {
           ActiveCountView.Timer.Enabled = false;
           ActiveCountView.HorizontalValueBar1.Opacity = 255;
           DetectedCountView.Timer.Enabled = true;
        }
      }

     
    if ( Visible )
    {

      ListViewer.NoOfItems = ActiveCountView.total + extra + 2;       // + ncu and gap row
     

      InvalidateViewState();
    }






  }

  $rect <815,20,930,55>
  slot StartSync
  {
    sender; /* the method is called from the sender object */

     
      var App::ConfirmPopup cp = new App::ConfirmPopup;

      cp.Text1.String = "Restarting mesh may take a long time. Are you sure?";

      cp.ShowThen( GetRoot(), StartSyncGo );
     
  }

  $rect <1145,290,1380,330>
  object Core::SystemEventHandler MeshStatusChangeEventHandler
  {
    preset OnEvent = onEvent2;
    preset Enabled = false;
    preset Event = App::Devices.MeshStatusChangeEvent;
  }

  $rect <830,210,1030,250>
  slot ScrollSlot
  {
    sender; /* the method is called from the sender object */
     
    Origin.y = 25 + ListViewer.SlideTouchHandler.Offset.y;

    InvalidateViewState();

  }

  $rect <15,403,215,443>
  slot InfoTap
  {
    sender; /* the method is called from the sender object */

    if ( SimpleTouchHandler.AutoDeflected )
       return;

    // Get the index of the item at the tapped position
    var int32 list_item = ListViewer.VerticalList.GetItemAtPosition( SimpleTouchHandler.CurrentPos );



    var int32 itemNo = list_item + ListViewer.StartRow;


    if ( itemNo > 0  )
    {
      
       var int32 count = 0;
       
       var App::MeshUnitItem m = (App::MeshUnitItem) ListViewer.VerticalList.first;

       if ( m != null )
       {
           while ( count < list_item )
           {
               count = count + 1;
               m =  (App::MeshUnitItem) m.next;
               if ( m  == null ) return;
           }

             
          
            var int32 u = m.MeshUnit.UnitNum.String.parse_int32( -1 );


            if ( u > 0 && DeviceInfo.device != u )
            {
     //           ListViewer.VerticalList.InvalidateItems( list_item, list_item );

     //           if ( current_item != -1 )  ListViewer.VerticalList.InvalidateItems( current_item, current_item );

                 ListViewer.VerticalList.SelectedItem = u;

                 ListViewer.NoOfItems = ListViewer.NoOfItems;

                 current_item = list_item;

                 var App::Application ap = (App::Application) GetRoot();
     
                 if ( ap != null )
                 {
                   var int32 l = ap.LevelAccess.AccessLevel;

                   DeviceInfo.PushButton1.Enabled = l > 2;
                 }

                 DeviceInfo.Visible = true;
                 DeviceInfo.Enabled = true;
                 DeviceInfo.SimpleTouchHandler.Enabled = true; 
                 DeviceInfo.device = u;
     
            }
            else // if (  u > 0 )
            {
                postsignal DeviceInfo.Close;
                 ListViewer.VerticalList.SelectedItem = -1;

                 ListViewer.NoOfItems = ListViewer.NoOfItems;

            }

        }
    }


  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <0,0,615,365>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::MeshUnitItem;
    preset ItemHeight = 30;
    preset NoOfItems = 514;
    preset onScroll = ScrollSlot;
    preset onRefreshAll = RefreshAll;
  }

  $rect <855,165,1055,205>
  property int16 totalItems = 0;

  $rect <980,325,1130,365>
  slot AddDevices
  {
    sender; /* the method is called from the sender object */


    var App::AddDevicePopup add = new App::AddDevicePopup;

    add.Show( GetRoot() );

    native
    {
      Command1( CMD_DETECT_RBU, 0 );
    }
       









     
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <475,500,635,540>
  slot RefreshAll
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;
    device = (App::MeshUnitItem) ListViewer.VerticalList.first;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( device == null )
      return;

    while ( itemNo < 0 )
    {
      device.Visible = false;
      device.InvalidateViewState();

      device = (App::MeshUnitItem) device.next;

      if ( device == null ) return;

      itemNo = itemNo + 1;
    }

    var string s = "Panel";
    var bool no_site = false;
       
    native( no_site )
    {
      Command cmd;
      Command0( CMD_GET_PANEL, &cmd );

      if ( Command1( CMD_CHECK_TREE, 0 ) ) return;

      if ( cmd.int0 != 0 )
      {
          Panel* p = (Panel*) cmd.int0;
          s = EwNewStringAnsi( p->name );
      }
      else
      {
        no_site =  1;
      }
    } 


    if ( no_site )
    {
        while ( device != null )
        {
            device.Visible = false;
            device = (App::MeshUnitItem) device.next;
         }
        return;
    }

    pure Row = 0;

    device.MeshUnit.Bounds.x1 = -10;
    device.MeshUnit.Bounds.x2 = 330;

    if ( itemNo == 0 )
    { 
       device.Visible = true;
        
       device.MeshUnit.NCUText.String = s;
      
       device.MeshUnit.Status = App::RadioStatus.NCU;

        device.MeshUnit.MeshVector.Frame1.Color.alpha = 120;
       device.MeshUnit.MeshVector.Frame.Bitmap = App::meshunit_outline_thin;
       
       device.MeshUnit.MeshVector.InvalidateViewState();
       device.MeshUnit.InvalidateViewState();
       device.InvalidateViewState();
       
       device = (App::MeshUnitItem) device.next;

       if ( device == null ) return;
    }
    else
    {   
        Row = Row + 1;
    }

    if ( GetAllChildren( 0, itemNo, 0 ) ) return;


     

    if ( Row == itemNo )
    {
       device.Visible = false;
       device.InvalidateViewState();

       device = (App::MeshUnitItem) device.next;

       if ( device == null ) return;
    }
    else
    {
       Row = Row + 1;
    }

    var int32 selected = ListViewer.VerticalList.SelectedItem;

    var int32 numConfig = App::Lib.GetNumSiteDevices( );
    var int32 numFound  = App::Lib.GetNumRadiosFound( );



    var int32 d;
    var int32 r;  


      
    // Devices not in config
    for( r = 0; r < numFound; r = r + 1 )
    {
      var App::RadioUnit ru = App::Lib.GetRadioNum( r );

      if ( ru != null )
      {
         var App::DeviceConfig dev = App::Lib.GetConfig( ru.unitnum );

         if ( dev == null )
         {
            if ( !App::Lib.OnTree( ru.unitnum ) )
            {
                if ( Row == itemNo )
                {
                    device.MeshUnit.Bounds.x1 = -10;
                    device.MeshUnit.Bounds.x2 = 330;
      
                    SetupUnit( device, ru, dev, ListViewer.VerticalList.SelectedItem );
                    
                    device = (App::MeshUnitItem) device.next;

                    if ( device == null ) return;
                 }
                 else Row = Row + 1;
              }
           }        
        }
    }



    // Devices in both


    // Devices in both

    for( r = 0; r < numFound; r = r + 1 )
    {
      var App::RadioUnit ru = App::Lib.GetRadioNum( r );

      if ( ru != null )
      {
         var App::DeviceConfig dev = App::Lib.GetConfig( ru.unitnum );

         if ( dev != null )
         {
            if ( !App::Lib.OnTree( ru.unitnum ) )
            {
                if ( Row == itemNo )
                {
                    device.MeshUnit.Bounds.x1 = -10;
                    device.MeshUnit.Bounds.x2 = 330;

                    device.MeshUnit.Stage = App::NCUStage.Dropped;
                  
                    SetupUnit( device, ru, dev, ListViewer.VerticalList.SelectedItem );
                  
                    device = (App::MeshUnitItem) device.next;

                    if ( device == null ) return;
                 }
                 else Row = Row + 1;
               
             } 
          }
       }
    }


    // Devices not found
    var int32 off = 0;

    for( d = 0; d < numConfig; d = d + 1 )
    {
      var App::DeviceConfig dev = App::Lib.GetConfigNum( d );
       
      if ( dev != null ) if ( dev.combination < 64 )
      {
        var App::RadioUnit ru = App::Lib.GetRadio( dev.unitnum );

        if ( ru == null ) // if not found
        {
            if ( Row == itemNo )
            {
                device.MeshUnit.Bounds.x1 = -10;
                device.MeshUnit.Bounds.x2 = 330;

                device.MeshUnit.Stage = App::NCUStage.Unknnown;
                
                SetupUnit( device, ru, dev, ListViewer.VerticalList.SelectedItem );
                
                device = (App::MeshUnitItem) device.next;

                if ( device == null ) return;
             }
             else Row = Row + 1;
          }     
       }
    }


    while ( device != null )
    {
        device.Visible = false;
        device.Enabled = false;
        device.InvalidateViewState();

        device = (App::MeshUnitItem) device.next;
    }

     
            
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <570,0>;
    preset Point2 = <570,365>;
    preset Point1 = <0,365>;
    preset OnRelease = InfoTap;
    preset OnPress = null;
    preset RetargetDelay = 800;
    preset RetargetOffset = 5;
    preset RetargetCondition = Core::RetargetReason[LongPress, WipeDown, WipeLeft, WipeRight, WipeUp];
  }

  $rect <910,460,1110,500>
  method bool GetAllChildren( arg int32 parent, arg int32 itemNo, arg int32 indent )
  {
    var int32 child = FindNextChild( 0, parent );
    var int32 startrow = pure Row;

    var int32 Status = 1;
     

    indent = indent + 1;

    while ( child != 0 )
    {     
        var string radiocomb = "????";
        var string defcomb = "????";
        var App::RadioUnit ru = App::Lib.GetRadioFromPtr( child );

        if ( ru != null )
        {
            if ( Row == itemNo )
            {  
                var App::DeviceConfig dev = App::Lib.GetConfig( ru.unitnum );

                device.MeshUnit.Bounds.x1 = indent * pure Spacing.x - 4;
                device.MeshUnit.Bounds.x2 = device.MeshUnit.Bounds.x1 + 340;
          
                SetupUnit( device, ru, dev, ListViewer.VerticalList.SelectedItem );
                
                device = (App::MeshUnitItem) device.next;

                if ( device == null ) return true;
            }
            else
            {
                pure Row = pure Row + 1;
            }

            if ( GetAllChildren( ru.unitnum, itemNo, indent ) ) return true;

            child = FindNextChild( child, parent );   
        } 
        else
        {
            device.Visible = false;
            device.InvalidateViewState( );
            device = (App::MeshUnitItem) device.next;

            if ( device == null ) return true;
        }       
    }

    return false;
  }

  $rect <320,450,490,490>
  method void DrawLine( arg int32 x, arg int32 y, arg int32 y2 )
  {
    /* The template just returns the given argument... */



    Path.InitSubPath( pure SubIndex, 1 );
     

    Path.Begin( pure SubIndex, pure Origin.x + x, pure Origin.y + y );
    Path.AddLine( pure SubIndex, pure Origin.x + x, Origin.y + y2 - 25 );
    Path.Close( pure SubIndex );


    SubIndex = SubIndex + 1;

     

                    
  }

  $rect <5,445,205,485>
  property App::MeshUnitItem device = null;

  $rect <1130,480,1390,520>
  object Core::SystemEventHandler SiteChangeEventHandler1
  {
    preset OnEvent = onEvent3;
    preset Event = App::Devices.SiteChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1215,565,1365,605>
  slot onEvent3
  {
    var bool no_site = false;


    native  ( no_site)
    {
      if ( capp->site == NULL || capp->panel == NULL )
      {
         no_site = 1;
      }
    }

    if ( no_site )
    {
      ListViewer.NoOfItems = 0;
     
      DetectedCountView.count = 0;
      DetectedCountView.total = 0;
      ActiveCountView.count = 0;
      ActiveCountView.total = 0;
    }

    InvalidateViewState();







  }

  $rect <920,20,1070,60>
  slot StartSyncGo
  {
    sender; /* the method is called from the sender object */

         
    native 
    {
        Command1( CMD_RESTART_MESH, 0 );     
    }

     
  }

  $rect <805,265,1005,305>
  slot AdditionalSetSlot
  {
    sender; /* the method is called from the sender object */

    var App::AdditionalPopup ap = new App::AdditionalPopup;

    ap.Show( GetRoot() );


    /*

    var int32 num = 12;
    var int32 ok = 4;

    native( num, ok )
    {
      Command cmd;

      ok = Command0( CMD_ADD_ADDITIONAL, &cmd );

      num = cmd.int0;
    }

    var string d = " device";

    if ( num > 1 ) d = d + "s";

    var App::AccesssPopup ll = new App::AccesssPopup;

    if ( ok != 0 )
    {
      ll.Text.String = "Finished with errors: " + string( num ) + d + " added to site.";
    }
    else
    {
      ll.Text.String = string( num ) + d + " added to site.";
    }

    ll.Show( GetRoot() );

              */
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <650,310,765,330>;
    preset Enabled = false;
    preset Visible = false;
    preset OnRelease = null;
    preset OnActivate = AdditionalSetSlot;
    preset Label = "Add Additional Units";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <615,0,795,55>;
    preset OnActivate = StartSync;
    preset Label = "Restart Mesh";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object App::CountView DetectedCountView
  {
    preset Bounds = <610,246,795,288>;
    preset prefix = "Detected";
  }

  $rect <20,20,160,60>
  object App::CountView ActiveCountView
  {
    preset Bounds = <610,198,796,240>;
    preset prefix = "Active";
  }

  $rect <20,20,160,60>
  object App::DeviceInfo DeviceInfo
  {
    preset Bounds = <362,5,567,333>;
    preset Visible = false;
    preset Radius1 = 6;
    preset device = -1;
  }

  $rect <860,80,1060,120>
  property int32 current_item = 0;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <615,65,795,120>;
    preset OnActivate = OptimizeMesh;
    preset Label = "Optimize Mesh";
    preset Appearance = App::NormalPushButton;
  }

  $rect <825,55,940,95>
  slot native OptimizeMesh
  {
       
    Command1( CMD_OPTIMIZE_MESH, 0 );     


  }

  $rect <1170,230,1430,270>
  object Core::SystemEventHandler AccessModeChangeEventHandler1
  {
    preset OnEvent = onEvent2;
    preset Event = App::Devices.AccessModeChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1305,175,1455,215>
  slot onEvent2
  {
     
    ListViewer.NoOfItems = ListViewer.NoOfItems;       // + ncu and gap row

    var App::Application ap = (App::Application) GetRoot();

    if ( ap != null )
    {
      PushButton3.Enabled = ( ap.LevelAccess.AccessLevel >= 3 );
    }

    InvalidateViewState();






  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <615,130,795,185>;
    preset Enabled = true;
    preset Visible = true;
    preset OnRelease = null;
    preset OnActivate = CheckFW;
    preset Label = "Check Mesh FW";
    preset Appearance = App::NormalPushButton;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <845,125,1045,165>
  slot CheckFW
  {
    native
    {
      Command cmd;
      Command0( CMD_CHECK_FW, &cmd );
    }



      
  }

  $rect <225,505,475,545>
  object Core::SystemEventHandler MeshUnitChangeEventHandler
  {
    preset OnEvent = onMeshUnitChangeEvent;
    preset Event = App::Devices.MeshUnitChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <405,575,680,615>
  slot onMeshUnitChangeEvent
  {
    if ( Visible )
    { 

      var App::UnitNumber u = (App::UnitNumber) MeshUnitChangeEventHandler.Context;

      var App::MeshUnitItem item = (App::MeshUnitItem) ListViewer.VerticalList.first;

      var int32 n = 0;  

      while ( item != null )
      {
        if ( item.MeshUnit.UnitNum.String == string(u.num) )
        {        
             ListViewer.VerticalList.View = (Core::View)  item;
             ListViewer.Item = ListViewer.StartRow + n;
             signal OnLoadItem;
            
             return;
        }
         n = n + 1;
        item = (App::MeshUnitItem) item.next;
      }


    }

  }

  $rect <5,485,205,525>
  method void SetupUnit( arg App::MeshUnitItem device, arg App::RadioUnit ru, arg App::DeviceConfig dev, arg int16 selected )
  {
    var int16 u = 0;

    if ( ru != null )
    {
    	device.MeshUnit.RSSI             = ru.rssi;  
      device.MeshUnit.Stage           = ru.stage;
    	
    	if ( dev == null ) 
    	{
    	  device.MeshUnit.TypeText.String  = string( ru.combination );
    		u = ru.unitnum;
        device.MeshUnit.Status          = App::RadioStatus.Additional;
        device.MeshUnit.Extention.String = "+";
        device.MeshUnit.Extention.Color = #002222FF;
        
        if ( ru.zonenum == -1 )
        {
    	    device.MeshUnit.ZoneNum.String  = "-";
        }
        else
        {
          device.MeshUnit.ZoneNum.String  = string( ru.zonenum );
        }
    	}
      else
      {
      if (  dev.location[0] != (char)0 )
      {
        device.MeshUnit.TypeText.String = dev.location;
      }
      else
      {
           device.MeshUnit.TypeText.String = dev.combiname;
      }
        if ( ru.combination == dev.combination || ru.combination == 0 )
        {
          device.MeshUnit.Status          = App::RadioStatus.Found;
          device.MeshUnit.Extention.String = "";    
        }
        else
        {
          device.MeshUnit.Status          = App::RadioStatus.Different;
          device.MeshUnit.TypeText.String = string( ru.combination );      
          device.MeshUnit.Extention.Color = #220022FF;
          device.MeshUnit.Extention.String = "?";
        }
      }  	
    	 
    	switch ( ru.battery )
    	{
    	  case 0 : device.MeshUnit.BatteryImage.Bitmap = App::battery0;
    	  case 1 : device.MeshUnit.BatteryImage.Bitmap = App::battery1;
    	  case 2 : device.MeshUnit.BatteryImage.Bitmap = App::battery2;
    	  case 3 : device.MeshUnit.BatteryImage.Bitmap = App::battery3;
    	  default : device.MeshUnit.BatteryImage.Bitmap = null;
    	};
      device.MeshUnit.flags           = ru.valid;
    }
    else
    {
    	device.MeshUnit.BatteryImage.Bitmap = null;	
    	device.MeshUnit.RSSI     = -256;
      device.MeshUnit.flags           	= 0;
       
    }	

    	
    if ( dev != null )
    {
    	device.MeshUnit.ZoneNum.String  = string( dev.zonenum );	
     	
    	u = dev.unitnum;

      if ( ru == null )
      {
        device.MeshUnit.TypeText.String  =  dev.combiname; 
        device.MeshUnit.Stage           = App::NCUStage.Unknnown;
        device.MeshUnit.Status          = App::RadioStatus.NotFound;
        device.MeshUnit.Extention.Color = #220000FF;
        device.MeshUnit.Extention.String = "!";
        device.MeshUnit.Extention.String = "x";
     
      }
    }


      







    device.MeshUnit.UnitNum.String  = string( u );

    if ( u == selected )    // selected
    {
        device.MeshUnit.MeshVector.Frame.Bitmap = App::meshunit_outline;
        device.MeshUnit.MeshVector.Frame1.Color.alpha = 255;
    }
    else
    {
        device.MeshUnit.MeshVector.Frame.Bitmap = App::meshunit_outline_thin;
        device.MeshUnit.MeshVector.Frame1.Color.alpha = 111;
    }



    device.MeshUnit.Visible = true;
    device.Visible = true;
    device.InvalidateViewState(); 
     

  }

  $rect <1425,300,1625,340>
  property int32 extra = 0;

  $rect <970,275,1165,310>
  slot AdditionalGetSlot
  {
    sender; /* the method is called from the sender object */


    var App::AdditionalPopup ap = new App::AdditionalPopup;

    ap.Show( GetRoot() );


    /*
    var int32 num = 12;
    var int32 ok = 4;




     /
    native( num, ok )
    {
      Command cmd;

      ok = Command0( CMD_ADD_ADDITIONAL, &cmd );

      num = cmd.int0;
    }

    var string d = " device";

    if ( num > 1 ) d = d + "s";

    var App::AccesssPopup ll = new App::AccesssPopup;

    if ( ok != 0 )
    {
      ll.Text.String = "Finished with errors: " + string( num ) + d + " added to site.";
    }
    else
    {
      ll.Text.String = string( num ) + d + " added to site.";
    }

    ll.Show( GetRoot() );

      */
  }
}

$rect <180,860,330,900>
$output false
class MeshUnit : Core::Group
{
  $rect <10,250,210,290>
  inherited property Bounds = <0,0,350,25>;

  $rect <5,195,205,235>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <5,155,205,195>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


    var uint8 alpha = MeshVector.Frame1.Color.alpha;


     
    if ( Status == App::RadioStatus.NCU )
    {
        MeshVector.Frame1.ColorBL = #5FEEFF7F;
        MeshVector.Frame1.ColorTL = #ED76FF7F;
        MeshVector.Frame1.ColorBR = #5FEEFF7F;
        MeshVector.Frame1.ColorTR = #ED76FF7F;
        BatteryImage.Visible = false;
        Extention.Visible = false;

     //   MeshVector.Bounds = <-10,0,310,25>;
        
        NCUText.Visible = true;
        BatteryImage.Visible = false;
        TypeText.Visible = false;
        UnitNum.Visible = false;
        ZoneNum.Visible = false;
        ZoneText.Visible = false;
        return;
    }

    if (  Stage == App::NCUStage.Unknnown || Stage == App::NCUStage.Dropped )
    {
     //   MeshVector.Bounds = <-10,0,310,25>;
    }
    else
    {
    //  MeshVector.Bounds = <0,0,320,25>;
    }

    //Extention.Bounds.origin.x = MeshVector.Bounds.x1 + 290;
    //TypeText.Bounds.origin.x = MeshVector.Bounds.x1 + 166;
    //UnitNum.Bounds.origin.x = MeshVector.Bounds.x1 + 105;
    //ZoneNum.Bounds.origin.x = MeshVector.Bounds.x1 + 51;
    //ZoneText.Bounds.origin.x = MeshVector.Bounds.x1 + 14;
    //BatteryImage.Bounds.origin.x = MeshVector.Bounds.x1 + 262;


    NCUText.Visible = false;


    BatteryImage.Visible = true;
    TypeText.Visible = true;
    UnitNum.Visible = true;
    ZoneNum.Visible = true;
    ZoneText.Visible = true;
     

     $if ($prototyper)

     if ( (flags & 32) != 0 )
     {
           BatteryImage.Visible = false;
     }
     $endif



    switch ( Stage )
    {
       
      case App::NCUStage.Activating :   MeshVector.Frame1.Color = Hue( (int32) RSSI ); 
      case App::NCUStage.Unknnown :       MeshVector.Frame1.Color = #AAAAAAFF;        
      case App::NCUStage.Meshing:     MeshVector.Frame1.Color = #1111FFFF; 
      case App::NCUStage.Dropped:     MeshVector.Frame1.Color = #998844FF;   
    }                         
      

    if ( (flags & 16) != 0 )
    {
      var App::Application app = (App::Application) GetRoot(); 

    $if ($prototyper)
            MeshVector.Frame1.Color = #FF88BBFF;
    $endif

      if ( app != null )
      {
        if ( app.LevelAccess.AccessLevel > 2 )
        {
          MeshVector.Frame1.Color = #FF88BBFF;
        }
      }
    }

    if ( (flags & 2) != 0 )
    {
      MeshVector.Frame1.Color = #FF2277FF;
    }

     
    /*
    if ( Status == App::RadioStatus.Different )
    {
       Extention.String = "?";
       Extention.Color = #220022FF;
       
    }
    else if ( Status == App::RadioStatus.Additional )
    {
       Extention.String = "+";
       Extention.Color = #002222FF;
      // TypeText.String = RadioComb;
    }
    else  if ( Status == App::RadioStatus.NotFound )
    {
         Extention.String = "x";
       Extention.Color = #220000FF;
         
     // TypeText.String = DefinedComb;
    }
    else  if ( Status == App::RadioStatus.Found )
    {
       Extention.String = "";
          
      // TypeText.String = RadioComb; 
    }      
    */                              
                                           
    MeshVector.Frame1.Color.alpha = alpha;

    MeshVector.InvalidateViewState(); 
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object App::MeshVector MeshVector
  {
    preset Bounds = <0,0,330,25>;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  object Views::Text NCUText
  {
    preset Bounds = <15,5,325,22>;
    preset AutoSize = false;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Panel";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <13,6,113,20>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "ZONE     UNIT";
    preset Font = App::FontVerdana14;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneNum
  {
    preset Bounds = <50,6,71,21>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "55";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text UnitNum
  {
    preset Bounds = <100,6,129,21>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "-1";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text TypeText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <130,6,301,20>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "SN.VAD0.RB10ygKqp";
    preset Font = App::FontVerdana14;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Extention
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <330,0,350,25>;
    preset String = "+?";
    preset Font = Resources::FontLarge;
  }

  $rect <415,0,605,40>
  property App::RadioStatus Status = App::RadioStatus.Additional;

  $rect <20,110,165,150>
  onset Status
  {
    // The value doesn't change - nothing to do.
    if ( pure Status == value )
      return;

    // Remember the property's new value.
    pure Status = value;

    if ( pure Status == App::RadioStatus.Different ) // different
    {
      // Timer.Enabled = true;
    }
    else
    {
      // Timer.Enabled = false;
    }




    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <425,60,545,100>
  method color Hue( arg int32 h )
  {
    /* The template just returns the given argument... */

    // h = rssi level - result is #RRGGBBAA  ( 24/32 bit )


    if ( h == -256 )  return #0000AAFF;

    h = h + 122;

    if ( h < 0 ) h = 0;

    if ( h > 29 ) h = 29;

    var int32 HueRange = 15;

    var int32 val  = (h % HueRange) * 255 / HueRange;
    var int32 band = h / HueRange;
    var color res  = #000000FF;

    if ( band == 0 )        //  red -> yellow
    {
      res.red = 255;
      res.green = val;
    }
    else                 // yellow -> green                     
    {
      res.red = 255 - val;
      res.green = 255;
    }

    return res;

  }

  $rect <610,58,810,98>
  property int32 RSSI = 22;

  $rect <20,20,160,60>
  object Views::Image BatteryImage
  {
    preset Bounds = <301,5,326,20>;
    preset Animated = true;
    preset FrameNumber = 0;
    preset Bitmap = App::battery0;
  }

  $rect <350,150,550,190>
  property App::NCUStage Stage = App::NCUStage.Unknnown;

  $rect <330,260,530,300>
  property uint8 flags = 0;

  $reorder MeshVector 1
}

$rect <290,750,490,790>
$output false
enum UnitState
{
  $rect <10,10,210,50>
  item Additional;

  $rect <220,10,420,50>
  item Different;

  $rect <430,10,630,50>
  item ThirdItem;
}

$rect <350,870,500,910>
$output false
class MeshUnitItem : Core::Group
{
  $rect <10,115,210,155>
  inherited property Bounds = <0,0,550,25>;

  $rect <10,270,330,310>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 



     
    if ( MeshUnit.Status == App::RadioStatus.NCU )
    {
         
      MeshUnit.Bounds = <-10,0,340,25>;
        
    }
    else
    {
      if ( MeshUnit.Stage == App::NCUStage.Unknnown || MeshUnit.Stage == App::NCUStage.Dropped )
      {
         MeshUnit.Bounds = <-10,0,340,25>;
      }
     }

    MeshUnit.InvalidateViewState();

  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit
  {
    preset Bounds = <0,0,350,25>;
    preset AlphaBlended = true;
  }
}

$rect <500,860,650,900>
$output false
class MeshNCU : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,240,25>;

  $rect <5,195,205,235>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <5,155,205,195>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
                                         
    //DrawFillBox( 1, 1, FillPath.Bounds.w-2, FillPath.Bounds.h-2 );
    DrawBox( 1, 1, BoxPath.Bounds.w-2, BoxPath.Bounds.h-2 );

  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,240,25>;
    preset ColorBL = #5FEEFF82;
    preset ColorBR = #5FEEFF82;
    preset ColorTR = #ED76FFFF;
    preset ColorTL = #ED76FFFF;
    preset Color;
    preset Path = Path1;
  }

  $rect <635,0,835,40>
  property int8 Radius1 = 9;

  $rect <20,20,160,60>
  object Views::StrokePath BoxPath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,240,25>;
    preset Color = #000000FF;
    preset Width = 1;
    preset Path = Path1;
  }

  $rect <640,120,810,160>
  object Graphics::Path Path1;

  $rect <570,60,770,100>
  method void DrawBox( arg int32 x, arg int32 y, arg int32 width, arg int32 height )
  {
     
      Path1.InitSubPath( 0, 4 + 20  );

      Path1.Begin( 0,  x + pure Radius1, y + 0 );
      Path1.AddArc( 0,  x +  + width - pure Radius1 ,  y + pure Radius1, pure Radius1, pure Radius1, -90, 0, 5 );
      Path1.AddArc( 0,  x + width - pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 0, 90, 5 );
      Path1.AddArc( 0, x + pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 90, 180, 5 );
      Path1.AddArc( 0, x + pure Radius1, y + pure Radius1, pure Radius1, pure Radius1, 180, 270, 5 );
      Path1.Close( 0 );

     
  }

  $rect <20,20,160,60>
  object Views::Text TypeText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,5,240,20>;
    preset String = "NCU / Mesh Head";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }
}

$rect <250,1100,450,1140>
$output false
class Access
{
  $rect <0,20,200,60>
  property int32 Level = 0;
}

$rect <710,120,870,160>
$output false
class LevelAccess : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,30,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <160,0,360,40>
  property int8 AccessLevel = 1;

  $rect <160,40,350,80>
  onset AccessLevel
  {
     

    // The value doesn't change - nothing to do.
    if ( pure AccessLevel == value )
      return;



    // Remember the property's new value.
    pure AccessLevel = value;



     var int32 al = pure  AccessLevel;
     native( al)
     {
        Command1( CMD_SET_ACCESS_LEVEL, al );
     }

     
    // TO DO:
    // 
    // Now you can handle the alternation of the property.

    //LevelText.String = "Level " + string( pure AccessLevel ) + " Access";

    var App::Application app = (App::Application) Owner;

    if (app != null )
    {
      if ( pure AccessLevel > 1 ) 
      {
          Timer.Enabled = true;

          if ( buzzing )
          {
             native
             {
               Command2( CMD_BUZZER, 2, 0 );
             }
             buzzing = false;
            
           
          }
          app.LogOnButton.ButtonText = "{parc}Log Off";
          app.LogOnButton.Icon = App::Key2Bitmap;    
      }
      else 
      {
          Timer.Enabled = false;     

          if (app != null )
          {
            app.LogOnButton.ButtonText = "{parc}Log On";
            app.LogOnButton.Icon = App::KeyBitmap;

            postsignal app.GotoScreenEventHandler.OnEvent;
            
          }
      }
      app.LogOnButton.InvalidateViewState();
      app.EvacuateButton.InvalidateViewState();
      app.ResetButton.InvalidateViewState();
      app.SilenceButton.InvalidateViewState();
      app.TabButtonPull.InvalidateViewState();
    }
    /*

      native
      {
        Command cmd;
        cmd.int0 = 4;
        cmd.int1 = 0;
        Command0( CMD_LOGON_ACCESS, &cmd );
       }*/
  }

  $rect <435,-5,635,35>
  object Core::Timer Timer
  {
    preset OnTrigger = Slot;
    preset Period = 60000;
  }

  $rect <735,0,935,40>
  object Core::SystemEventHandler AccessEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = App::Devices.AccessModeChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <740,40,940,80>
  slot onEvent1
  {
    var App::Access a = (App::Access) AccessEventHandler.Context;
     var App::Application app = (App::Application) Owner;


    if ( a.Level == 0 )    // log off
    {
      if ( !KeySwitchOn ) 
      {
          AccessLevel = 1; 
          UserIndex = -1;
      }    
      else
      {
         AccessLevel = 2;
         UserIndex = -1;  
      }      
    }                              
    else if ( a.Level == 2 && AccessLevel == 1 )     // key on
    {
       KeySwitchOn = true;
       
       app.Settings.PushButton3.Enabled = false;
       UserIndex = -1;
       AccessLevel = 2;

       native
       {
        Command3( CMD_LOGON_ACCESS, 2, -1, 1 );
       }
    }
    else if ( a.Level == 1 && AccessLevel != 1 )                          // key off
    {
       AccessLevel = 1;
       app.Settings.PushButton3.Enabled = true;
       
       KeySwitchOn = false;

       var int32 user =  UserIndex;

       native (user )
       {
        Command3( CMD_LOGON_ACCESS, 1, user, 0 );
       }
       UserIndex = -1;
    }

  }

  $rect <325,140,525,180>
  property bool KeySwitchOn = false;

  $rect <430,35,630,75>
  slot Slot
  {
    sender; /* the method is called from the sender object */


    var bool logout = false;

    native ( logout )
    {
       Command cmd;

     //  Command0( CMD_GET_LAST_TOUCH_TIME, &cmd );

     //  if ( now() - cmd.int0 > 100 * 60 * 10 )
       {
     //     logout = true;
       }
    }


    if ( logout )
    {
       AccessLevel = 1;
    }
  }

  $rect <50,130,200,170>
  property int32 UserIndex = -1;

  $rect <570,100,770,140>
  property bool buzzing = false;
}

// This autoobject provides the default customization for the 'push button' widget \
// (WidgetSet::PushButton) in its small size variant.
$rect <750,1390,920,1430>
$output false
autoobject WidgetSet::PushButtonConfig SmallPushButton
{
  preset LabelColorActive = #FFFFFFFF;
  preset LabelColorFocused = #FFFFFFFF;
  preset LabelColorDisabled = #A8ABABFF;
  preset LabelColorDefault = #000000FF;
  preset LabelMarginBottom = 4;
  preset LabelMarginTop = 4;
  preset LabelMarginRight = 4;
  preset LabelMarginLeft = 4;
  preset IconTintDisabled = #A8ABABAA;
  preset IconTintDefault = #6C6E70FF;
  preset IconMarginBottom = 4;
  preset IconMarginTop = 4;
  preset IconMarginRight = 4;
  preset IconMarginLeft = 4;
  preset LabelFont = Resources::FontSmall;
  preset FaceTintDisabled = #AAAAAAAA;
  preset FaceFrameActive = 3;
  preset FaceFrameFocused = 2;
  preset FaceFrameDisabled = 0;
  preset FaceFrameDefault = 1;
  preset FaceActive = WidgetSet::PushButtonSmall;
  preset FaceFocused = WidgetSet::PushButtonSmall;
  preset FaceDisabled = WidgetSet::PushButtonSmall;
  preset FaceDefault = WidgetSet::PushButtonSmall;
  preset WidgetMinSize = <23,23>;
}

$rect <640,840,790,880>
$output false
class ProgressArrow : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,45,185>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Point2 = <15,165>;
    preset Point1 = <15,14>;
    preset Width2;
    preset Width1;
    preset Width = 5;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <0,15>;
    preset Point1 = <15,15>;
    preset Width2;
    preset Width1;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Point2 = <0,65>;
    preset Point1 = <15,65>;
    preset Width2;
    preset Width1;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Point2 = <0,115>;
    preset Point1 = <16,115>;
    preset Width2;
    preset Width1;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Arrow
  {
    preset Point2 = <44,15>;
    preset Point1 = <24,15>;
    preset Width2 = 20;
    preset Color = #FF0000FF;
  }

  $rect <120,40,245,80>
  object Core::Timer Timer
  {
    preset OnTrigger = TickSlot;
    preset Period = 500;
    preset Enabled = false;
  }

  $rect <135,0,255,40>
  slot TickSlot
  {
    sender; /* the method is called from the sender object */
     
    var App::MeshTree mesh = ( App::MeshTree) Owner;


    Arrow.Visible = !Arrow.Visible;


        /*
    if ( Count < 10 )
    {
      b = Idle  ;
    }
    else if ( Count < 20 )
    {
      b = Sync;
    }
    else if ( Count < 30 )
    {
      b = Mesh;
    }
    else if (  Count < 40 )
    {
      b = Active;
    }
    else  
    {
       Count = 0;
       return;
    }

    var int32 n = Count % 10;

    if ( (n & 1) > 0 )
    {
     b.CurrentValue = 0; 
    }
    else
    {
     b.CurrentValue = (n*10)+10;
    }

    Count = Count + 1;

                   */
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Point2 = <0,165>;
    preset Point1 = <16,165>;
    preset Width2;
    preset Width1;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <170,110,370,150>
  method void SetStage( arg App::MeshStatus s )
  {
     
      Timer.Enabled = true;
      Timer.Period = 500;
     


    //if ( s.operational > 0 )   Arrow.Point1.y = Line4.Point1.y;
    if ( s.active > 0 )   Arrow.Point1.y = Line3.Point1.y;
    else if ( s.meshed > 0 )   Arrow.Point1.y = Line2.Point1.y;
    else Arrow.Point1.y = Line1.Point1.y;

         

               

    Arrow.Point2.y = Arrow.Point1.y;
  }
}

$rect <180,1290,380,1330>
$output false
class RoundBox : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,270,210>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    StrokePath.Color = LineColour;
    FillPath.Color = FillColour;

    DrawBox(  ((int16)StrokePath.Width)/2, ((int16)StrokePath.Width)/2, Bounds.w - (int16)StrokePath.Width, Bounds.h - (int16)StrokePath.Width );
    DrawFillBox(  ((int16)StrokePath.Width)/2, ((int16)StrokePath.Width)/2, Bounds.w - (int16)StrokePath.Width, Bounds.h - (int16)StrokePath.Width );


    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

     

    StrokePath.Color = LineColour;
    FillPath.Color = FillColour;


    //, DrawFillBox, Path1, Path2

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,270,210>;
    preset Color = #FF00B2FF;
    preset Path = Path2;
  }

  $rect <20,20,160,60>
  object Views::StrokePath StrokePath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,270,210>;
    preset Color = #000000FF;
    preset Width = 2;
    preset Path = Path1;
  }

  $rect <310,100,510,140>
  method void DrawFillBox( arg int32 x, arg int32 y, arg int32 width, arg int32 height )
  {
     
      Path2.InitSubPath( 0, 4 + 20  );

      Path2.Begin( 0,  x + pure Radius1, y + 0 );
      Path2.AddArc( 0,  x +  + width - pure Radius1 ,  y + pure Radius1, pure Radius1, pure Radius1, -90, 0, 5 );
      Path2.AddArc( 0,  x + width - pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 0, 90, 5 );
      Path2.AddArc( 0, x + pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 90, 180, 5 );
      Path2.AddArc( 0, x + pure Radius1, y + pure Radius1, pure Radius1, pure Radius1, 180, 270, 5 );
      Path2.Close(0 );

      
  }

  $rect <300,150,470,190>
  object Graphics::Path Path2;

  $rect <600,80,770,120>
  object Graphics::Path Path1;

  $rect <585,20,785,60>
  method void DrawBox( arg int32 x, arg int32 y, arg int32 width, arg int32 height )
  {
     
      Path1.InitSubPath( 0, 4 + 20  );

      Path1.Begin( 0,  x + pure Radius1, y + 0 );
      Path1.AddArc( 0,  x +  + width - pure Radius1 ,  y + pure Radius1, pure Radius1, pure Radius1, -90, 0, 5 );
      Path1.AddArc( 0,  x + width - pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 0, 90, 5 );
      Path1.AddArc( 0, x + pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 90, 180, 5 );
      Path1.AddArc( 0, x + pure Radius1, y + pure Radius1, pure Radius1, pure Radius1, 180, 270, 5 );
      Path1.Close( 0 );

     
  }

  $rect <600,130,800,170>
  property int32 Radius1 = 5;

  $rect <310,10,510,50>
  property color LineColour = #000000FF;

  $rect <310,50,510,90>
  property color FillColour = #FF4399FF;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,270,210>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "....";
    preset Font = Resources::FontSmall;
    preset Color = #373737FF;
  }
}

$rect <960,860,1110,900>
$output false
class DeviceInfo : App::RoundBox
{
  $rect <285,75,425,115>
  inherited property Bounds = <0,0,200,330>;

  $rect <120,430,365,470>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 
                            
    var int32 Status = -1;
    var int32 minutes = -1;
    var int16 second = -1;                               
    var int32 RSSI = -256;
    var uint32 tx = 0;
    var uint32 received = 0;
    var int32 uny = device;
    var int32 primary = 0;
    var int32 backup = 0;
    var string location = "(Location not specified)";
    var string part = "---";

    if ( device != -1 ) native( uny, RSSI, Status, second, minutes, tx, received, primary, backup )
    {
        Command cmd;
        cmd.int0 = uny;
        Command0( CMD_GET_RADIO_UNIT, &cmd );  
         
       RadioUnit* ru = (RadioUnit*) cmd.int0;

      if ( ru != NULL )
      {

       RSSI          = ru->rssiprimary;

       if (  ru->starttime == 0 )
       {
          minutes = -1;
       }
       else
       {
           minutes = ( now( ) - ru->starttime ) / 60;
       }
       second        = ru->secondary;
       tx            = ru->sent;
       received      = ru->received;  
       
       primary = ru->battprimary;
       backup = ru->battbackup;
      }

       DeviceConfig* dc = get_dev_config( uny );

       if ( dc != NULL )
       {
          if ( dc->location[ 0] != 0 )
          {
            location = EwNewStringAnsi( dc->location ); 
          }   

          if ( dc->type == ru->combination )
          {
             Status = 1;   // ok

          }
          else
          {
             Status = 3;    // different ?
          }
       }
       else
       { 
          Status = 2;    // additional  +
       }

       part = EwNewStringAnsi( dc->typestring );
    }

    ptype.String = part;

    if ( second != -1 )
    {
       secondary.String = "Unit "+string(second);
    }
    else
    {
       secondary.String = "---";
    }  

    switch( Status )
    {
      case 0 : status.String = "Not Found";
      case 1 : status.String = "Found";
      case 2 : status.String = "Additional";
      case 3 : status.String = "Mismatched";
      default: status.String = "---";
    }

    if ( RSSI != -256 )
      rssi.String = string(RSSI);
    else
      rssi.String = "---";

    if ( tx > 10 ) tx= 10;
    if ( received > 10 ) received = 10;

    stats_sent.String = string(tx) + "/10";
    stats_lost.String = string(received) + "/10";

    battery.String = string((float)primary / 1000.0, 0, 2 ) + "V";
    battery1.String = string((float)backup / 1000.0, 0, 2 ) + "V";
     

    if ( tx == 0 )
    {
      stats_success.String = "-";
    }
    else
    {
      stats_success.String = string( (float)received * 100.0 / (float)tx, 0, 2 ) +"%%";
    }

    Text2.String = location;

    if ( minutes != -1 )
    {
       if ( minutes < 60 )
       {
          live.String = string(minutes) + "mins";
       }
       else if ( minutes < 60 * 24 )
       {
          live.String = string(minutes/60) + "hours";
       }
       else if ( minutes < 60 * 24 * 7 )
       {
          live.String = string(minutes/60/24) + "days";
       }
       else if ( minutes < 60 * 24 * 365 )
       {
          live.String = string(minutes/60/24/7) + "weeks"; 
       }
       else
       {
           live.String = string(minutes/60/24/30) + "months"; 
       }
    }
    else
    {
        live.String = "--";
    }
  }

  $rect <280,10,420,50>
  inherited property FillColour = #E0E0E0FF;

  $rect <20,20,160,60>
  inherited object Text
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <7,60,52,80>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "RSSI:";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <6,85,96,105>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Secondary:";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Bounds = <7,110,97,130>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Status:";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text5
  {
    preset Bounds = <7,135,97,155>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Battery:";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text rssi
  {
    preset Bounds = <86,60,134,80>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text secondary
  {
    preset Bounds = <86,85,183,105>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text status
  {
    preset Bounds = <86,110,183,130>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text battery
  {
    preset Bounds = <86,135,183,155>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text11
  {
    preset Bounds = <7,185,97,205>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Live:";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text live
  {
    preset Bounds = <86,185,183,205>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <285,300,485,340>
  property int32 device = 0;

  $rect <240,355,440,395>
  onset device
  {
    // The value doesn't change - nothing to do.
    if ( pure device == value )
      return;

    // Remember the property's new value.
    pure device = value;

    native
    {
       Command1( CMD_SET_CURRENT_DEVICE, value );
    }

    if ( device == -1 )
    {
      Timer.Enabled = false;
    }
    else
    {
      Timer.Enabled = true;
    }
     
    InvalidateViewState(  );
           

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Views::Text stats_4
  {
    preset Bounds = <7,235,97,255>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Received:";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text stats_sent
  {
    preset Bounds = <86,210,132,230>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "10/10";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <445,180,645,220>
  object Core::Timer Timer
  {
    preset OnTrigger = Slot;
  }

  $rect <440,225,640,265>
  slot Slot
  {
    sender; /* the method is called from the sender object */

    if ( Visible )
    {
      if ( device != -1 )
      {
        InvalidateViewState( );
      }
    }
  }

  $rect <20,20,160,60>
  object Views::Text stats_1
  {
    preset Bounds = <7,210,97,230>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Sent:";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text stats_3
  {
    preset Bounds = <7,260,97,280>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Success:";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text stats_lost
  {
    preset Bounds = <86,235,132,255>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "10/10";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text stats_success
  {
    preset Bounds = <86,260,183,280>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text6
  {
    preset Bounds = <7,160,97,180>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "- Backup:";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text battery1
  {
    preset Bounds = <86,160,183,180>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <200,0>;
    preset Point2 = <200,330>;
    preset Point1 = <0,330>;
    preset OnRelease = Close;
  }

  $rect <210,156,410,196>
  slot Reset
  {
    sender; /* the method is called from the sender object */

     var int32 u = device;

     if ( u != -1 )
     {
       native( u )
       {  
          Command1( CMD_SET_CURRENT_DEVICE,(int) u );

       }   
       stats_lost.String = "0/10";
        stats_sent.String = "0/10";
         stats_success.String = "-";         
     }
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <130,207,194,252>;
    preset OnActivate = Reset;
    preset Label = "Restart Count";
    preset Appearance = App::SmallPushButton;
  }

  $rect <210,200,410,240>
  slot Close
  {
    sender; /* the method is called from the sender object */


     
    if ( Visible )
    {
       Visible = false;
       Enabled = false;
       SimpleTouchHandler.Enabled = false;


       device = -1;
       
      var App::MeshTree mt = (App::MeshTree) Owner;

       mt.ListViewer.VerticalList.SelectedItem = -1;
        
       mt.ListViewer.VerticalList.InvalidateItems( mt.current_item, mt.current_item ); 

       mt.current_item = -1;
    }

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <40,286,160,322>;
    preset OnActivate = RemoveDevice;
    preset Label = "Remove Device";
    preset Appearance = App::SmallPushButton;
  }

  $rect <5,375,160,415>
  slot RemoveDevice
  {
    sender; /* the method is called from the sender object */

     var int32 u = device;

     if ( u != -1 )
     {
         var App::ConfirmPopup cp = new App::ConfirmPopup;

         cp.Text1.String = "Delete device permenantly! Are you sure?";
        
         cp.ShowThen( GetRoot(), RemoveDeviceGo );         
     }
  }

  $rect <15,485,185,525>
  slot RemoveDeviceGo
  {
    sender; /* the method is called from the sender object */

     var int32 u = device;

     if ( u != -1 )
     {
       native( u )
       {  
          Command1( CMD_REMOVE_DEVICE,(int) u );
       }                
     }
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <4,2,199,38>;
    preset Ellipsis = true;
    preset AutoSize = false;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "2nd Floor Meeting Room upstarts on the left side of ngh";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #202959FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text7
  {
    preset Bounds = <7,35,52,55>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Type:";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ptype
  {
    preset Bounds = <86,35,134,55>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder FillPath 1
  $reorder StrokePath 1
  $reorder DrawFillBox 1
  $reorder Path2 1
  $reorder Path1 1
  $reorder DrawBox 1
  $reorder Radius1 1
  $reorder LineColour 1
  $reorder FillColour 1
  $reorder Text 1
  $reorder Text1 1
  $reorder Text3 1
  $reorder Text4 1
  $reorder Text5 1
  $reorder rssi 1
  $reorder secondary 1
  $reorder status 1
  $reorder battery 1
  $reorder Text11 1
  $reorder live 1
  $reorder device 1
  $reorder OnSetdevice 1
  $reorder stats_4 1
  $reorder stats_sent 1
  $reorder Timer 1
  $reorder Slot 1
  $reorder stats_1 1
  $reorder stats_3 1
  $reorder stats_lost 1
  $reorder stats_success 1
  $reorder Text6 1
  $reorder battery1 1
  $reorder SimpleTouchHandler 1
  $reorder Reset 1
  $reorder PushButton 1
  $reorder Close 1
  $reorder PushButton1 1
}

$rect <0,1580,180,1620>
$output false
class DFUPopup : App::Popup
{
  $rect <0,250,140,290>
  inherited property Bounds = <0,0,430,210>;

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <37,105,367,150>;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <38,21,279,54>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Firmware Upgrade Mode";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <42,84,290,105>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "File transfer";
    preset Font = Resources::FontSmall;
  }

  $rect <230,280,430,320>
  slot Activate
  {
    sender; /* the method is called from the sender object */

    InvalidateViewState();
    Timer1.Enabled =true;
     

  }

  $rect <480,30,680,70>
  object Core::Timer Timer
  {
    preset OnTrigger = Activate;
    preset Period = 150;
  }

  $rect <480,80,680,120>
  object Core::Timer Timer1
  {
    preset OnTrigger = Activate1;
    preset Period = 150;
  }

  $rect <230,340,430,380>
  slot Activate1
  {
    sender; /* the method is called from the sender object */


     
    native
    {
      Command cmd;
    		
      Command0( CMD_DFU_MODE, &cmd );
    }


  }
}

$rect <640,1210,840,1250>
$output false
set ActionBits
{
  $rect <10,10,210,50>
  item Fire = 1;

  $rect <220,10,420,50>
  item FirstAid = 2;

  $rect <220,60,420,100>
  item Evacuation = 4;

  $rect <430,10,630,50>
  item Security = 8;

  $rect <690,130,890,170>
  item General = 16;

  $rect <690,70,890,110>
  item Fault = 32;

  $rect <460,130,660,170>
  item RoutingAck = 64;

  $rect <640,10,840,50>
  item Test = 128;

  $rect <10,60,210,100>
  item SilentTest = 256;

  $rect <10,110,210,150>
  item Reset = 512;

  $rect <210,120,410,160>
  item Silence = 1024;

  $rect <460,70,660,110>
  item Undefined = 2048;
}

$rect <230,1540,390,1580>
$output false
class LibClass
{
  $rect <0,50,200,90>
  method uint16 GetBits( arg App::ActionBits bits )
  {
    /* The template just returns the given argument... */

    var uint16 b = (uint16) bits;

    return b;


  }

  $rect <10,10,210,50>
  method App::DeviceConfig GetConfig( arg int16 unit_num )
  {
    var int32 ptr = 0;

    native( unit_num, ptr )
    {    
       ptr = (int) get_dev_config( unit_num );
    }

    return GetConfigFromPtr( ptr );
     

  }

  $rect <20,110,220,150>
  method App::InputChannel GetInput( arg int16 unitnum, arg uint8 channel )
  {
     
    var int32 ptr = 0;

    native( unitnum )
    {
       Command cmd;

       cmd.int0 = (int)unitnum & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );

       var int32 ptr = cmd.int0;
    }

    return GetInputFromPtr( ptr, channel );

  }

  $rect <20,260,220,300>
  method int32 NumZones()
  {
    var int32 numzones = 32;

    native( numzones )
    {
       Command cmd;
       
       Command0( CMD_GET_NUM_MAX_ZONES, &cmd );
       numzones = cmd.int0;
    }

    return numzones;
  }

  $rect <10,150,210,190>
  method App::OutputChannel GetOutput( arg int16 unitnum, arg uint8 channel )
  {
     
    var int32 ptr = 0;


    native( unitnum )
    {
       Command cmd;

       cmd.int0 = (int)unitnum & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );

       ptr = cmd.int0;
    }
     
    return GetOutputFromPtr( ptr, channel );

  }

  $rect <270,10,470,50>
  method string TypeName( arg App::ChannelType type )
  {
    /* The template just returns the given argument... */
       switch ( type )
       {
      	  case App::ChannelType.None : return "";								
          case App::ChannelType.Smoke : return "Smoke";				
          case App::ChannelType.HeatB : return "Heat B";				
          case App::ChannelType.CO : return "CO";					
          case App::ChannelType.PIR : return "PIR";								
          case App::ChannelType.Sounder : return "Sounder";							
          case App::ChannelType.Beacon : return "Beacon";								
          case App::ChannelType.FireCallpoint : return "Fire Callpoint";					
          case App::ChannelType.Status_indicator_led : return "lED";			
          case App::ChannelType.VisualIndicator : return "Visual Indicator";
          case App::ChannelType.SounderVisualIndicatorCombined : return "Sounder/VI";	
          case App::ChannelType.MedicalCallpoint : return "First-Aid Callpoint";
          case App::ChannelType.EvacCallpoint : return "Evac Callpoint";
          case App::ChannelType.OutputRouting : return "Output Routing";
          case App::ChannelType.HeatA1R : return "Heat A1R";

          case App::ChannelType.PanelAlarmInput : return "Alarm Input";
          case App::ChannelType.PanelAlarmRelay : return "Alarm Relay";
          case App::ChannelType.PanelCallpoint  : return "Callpoint Input";
          case App::ChannelType.PanelFaultInput : return "Fault Input";
          case App::ChannelType.PanelFaultRelay : return "Fault Relay";
          case App::ChannelType.PanelFireRelay : return "Fire Relay";
          case App::ChannelType.PanelRoutingAck : return "Routing Ack Input";
          case App::ChannelType.PanelRoutingOutput: return "Routing Output";
          case App::ChannelType.PanelSilenceInput: return "Silence Input";
          case App::ChannelType.PanelSoundersRelay: return "Sounders Relay";
          case App::ChannelType.PanelFunction1: return "Function 1";
          case App::ChannelType.PanelFunction2: return "Function 2";
          case App::ChannelType.PanelEvacuate: return "Evacuate";


    	    default :
          {
               if ( (int32) type <=  (int32) App::ChannelType.Input32 &&
                    (int32) type >=  (int32) App::ChannelType.Input1)
               {
                   return "Channel " + string( ((int32) type + 1 ) -  (int32) App::ChannelType.Input1);
               }
               if ( (int32) type <=  (int32) App::ChannelType.Output16 &&
                    (int32) type >=  (int32) App::ChannelType.Output1 )
               {
                   return "Channel " + string( ((int32) type + 1 ) -  (int32) App::ChannelType.Output1);
               }
           }
        }
    return "";

  }

  $rect <290,70,490,110>
  method bool SetConfig( arg int16 unit_num, arg bool transmit, arg App::DeviceConfig dev )
  {
    //var Application::DeviceConfig d;

     
    var int32 result = 0;

    var int32 wp = 10;
    var int32 ok = 0;

    native( dev, unit_num, wp )
    {
       wp = CMD_ERR_WRITE_PROTECTED;
       ok = CMD_OK;

       int i = 0;
     
       DeviceConfig d;
       Command cmd;
     
       d.type      = dev->combination;
       EwStringToAnsi( dev->location, d.location, SITE_MAX_STRING_LEN, '^' ); 
       EwStringToAnsi( dev->combiname, d.typestring, SITE_MAX_STRING_LEN, '^' ); 
       d.numParams = dev->numparams;
       d.unit      = dev->unitnum;
       d.zone      = dev->zonenum;
       d.numInputs = dev->numinputs;
       d.numOutputs = dev->numoutputs;
       d.flags      = dev->flags;

       while ( dev->inputs[ i] != NULL && i < d.numInputs )
       {
          d.input[ i].flags  = (uint16_t) dev->inputs[ i]->flags;
          d.input[ i].delay  = dev->inputs[ i]->delay;
          d.input[ i].action = dev->inputs[ i]->action;
          d.input[ i].type   = (ChannelType) dev->inputs[ i]->type;
          i++;
       }
       i = 0;
       while ( dev->outputs[ i] != NULL && i < d.numOutputs )
       {
          d.output[ i].flags  = (uint16_t) dev->outputs[ i]->flags;
          d.output[ i].delay1 = dev->outputs[ i]->delay1;
          d.output[ i].delay2 = dev->outputs[ i]->delay2;

          d.output[ i].actions = dev->outputs[ i]->actions;
          d.output[ i].type   = (ChannelType) dev->outputs[ i]->type;
          i++;
       }
       for( i = 0; i < d.numParams; i++ )
       {
          if ( dev->params[ i] != NULL )
          {
            d.param[ i].code = (ParamType) dev->params[ i]->code;
            d.param[ i].channel =          dev->params[ i]->channel;
            d.param[ i].value =            dev->params[ i]->value;
            d.param[ i].min =              dev->params[ i]->min;
            d.param[ i].max =              dev->params[ i]->max;
            EwStringToAnsi( dev->params[ i]->name, d.param[ i].name, SITE_MAX_STRING_LEN, '^' ); 
          }
       }
        
       cmd.int0 = unit_num;  // dest address
       cmd.int1 = (int) &d;        // new device data
       cmd.int2 = (int) transmit;
        
       result = Command0( CMD_SET_DEVICE_ALL, &cmd );   
    }

    if ( result == wp && transmit )
    {
       App::Devices.WriteProtectedEvent.Trigger( null, false );
    }

    return ( result == ok );

  }

  $rect <270,140,470,180>
  method App::Parameter GetParameter( arg int16 unitnum, arg uint8 index )
  {
    var App::Parameter param = new App::Parameter;

    var string name = "";

    if ( param != null )
    {
       native( param, unitnum, index, name )
       {
         if ( index < SITE_MAX_CHANNEL_PARAMS )
         {
           DeviceConfig* d = get_dev_config( unitnum );
           Parameter* p = d->param + index;

           if ( d != NULL ) 
           {         
             param->code = (ParamType) p->code;
             param->channel =  p->channel;
             param->value   =  p->value;
             param->min     =  p->min;
             param->max     =  p->max;
             name = EwNewStringAnsi( p->name );     
           }
           else
           {
             return NULL;
           }
         }
       }
       param.name = name;
       return param;
    }

    return null;


  }

  $rect <270,230,470,270>
  method int32 NumDevsInZone( arg int32 zone )
  {
    var int32 numdevs = 4; 

    native( numdevs, zone )
    {  
      numdevs = get_num_devs_in_zone( zone );
    }

    return numdevs;
  }

  $rect <260,300,460,340>
  $output true
  method int16 GetDevInZone( arg int32 zone, arg int32 devno )
  {
    native( zone, devno )
    {  
      Command cmd;

      cmd.int0 = zone;
      cmd.int1 = devno;
      Command0( CMD_GET_DEV_IN_ZONE, &cmd );
      DeviceConfig* device = (DeviceConfig*) cmd.int0;

      return device->unit;
    }

    return devno + 1;
  }

  $rect <20,390,220,430>
  method App::Device GetDevice( arg int16 unit_num )
  {
    //var Application::DeviceConfig d;
                            
    var App::Device dev = new App::Device;

    native( dev, unit_num )
    {
       Command cmd;
     
       cmd.int0 = (int)unit_num & 0xFFFF;
       Command0( CMD_FIND_DEVICE_FROM_UNIT, &cmd );
       
       Device* d = (Device*) cmd.int0;

       if ( d != NULL ) 
       {
         for( int n = 0; n < sizeof(dev->flags)/sizeof(*dev->flags); n++ )
         {
            dev->flags[n] = d->flags[n];    
         }
         dev->settings = d->settings;

         for( int n = 0; n < SITE_MAX_OUTPUT_CHANNELS; n++ )
         {
            dev->menuSelection[ n] = ( d->menuSelection[ n/2] >> (( n&1) * 4 )) & 15;    
         } 

         for( int n = 0; n < sizeof(d->analogue); n++ )
         {
            dev->val[ n] = d->analogue[ n];
         }
         return dev; 
       }     
    }

    return null;

  }

  $rect <530,60,730,100>
  method App::RadioUnit GetRadio( arg int32 unit_num )
  {
    var int32 ptr;

    native( unit_num, ptr )
    {
        Command cmd;

        cmd.int0 = unit_num;
        Command0( CMD_GET_RADIO_UNIT, &cmd );  

        ptr = cmd.int0;
    }

    return GetRadioFromPtr( ptr );

  }

  $rect <280,380,480,420>
  method int32 NumZonesWithDevices()
  {
    var int32 numzones = NumZones();
    var int32 z;
    var int32 usedzones = 0;

    for( z = 1; z <= 96; z = z + 1 )
    {
        if ( NumDevsInZone( z) > 0 ) usedzones = usedzones + 1;
    }

    return usedzones;
  }

  $rect <510,310,680,350>
  method App::ZoneFlags GetZoneFlags( arg int16 zone )
  {
    var App::ZoneFlags zf = App::ZoneFlags[];

    native( zone, zf )
    {
      Command cmd;
      cmd.int0 = zone;
      Command0( CMD_GET_ZONE_FLAGS, &cmd );

      zf = (AppZoneFlags) cmd.int0;
    }

    return zf;


  }

  $rect <520,360,690,400>
  method void SetZoneFlags( arg int16 zone, arg App::ZoneFlags flags )
  {
    native( zone, flags )
    {
      Command2( CMD_SET_ZONE_FLAGS, zone, flags );
    }


  }

  $rect <10,430,210,470>
  method void SetDevice( arg int16 unit_num, arg App::Device dev )
  {
    //var Application::DeviceConfig d;
                            
    native( dev, unit_num )
    {
       Command cmd;
     
       cmd.int0 = (int)unit_num & 0xFFFF;
       Command0( CMD_FIND_DEVICE_FROM_UNIT, &cmd );
       
       Device* d = (Device*) cmd.int0;

       if ( d != NULL ) 
       {
         for( int n = 0; n < sizeof(dev->flags)/sizeof(*dev->flags); n++ )
         {
            d->flags[ n] = dev->flags[ n];    
         }

         d->settings = dev->settings;

         for( int n = 0; n < (SITE_MAX_OUTPUT_CHANNELS + 1)/2; n++ )
         {
            d->menuSelection[ n] = dev->menuSelection[ n*2] | (dev->menuSelection[ n*2+1] << 4) ;    
         } 
       }     
    }
                 

  }

  $rect <670,170,870,210>
  method void SwitchOutput( arg int16 UnitNum, arg int8 ChanNum, arg App::Profile profile, arg bool state )
  {
    native( UnitNum, ChanNum, state, profile )
    {
        Command cmd;
       
        cmd.int0 = (int) UnitNum;
        cmd.int1 = (int) ChanNum;
        cmd.int2 = (int) state;
        cmd.int3 = (int) profile;

        Command0( CMD_SET_OUTPUT_CHANNEL, &cmd ) == CMD_OK;
    }

  }

  $rect <530,100,730,140>
  method string ProfileName( arg App::Profile profile )
  {
      switch ( profile )
      {
        case App::Profile.Fire :       return "Fire";
        case App::Profile.FirstAid :   return "First Aid";
        case App::Profile.Security :   return "Security";
        case App::Profile.Silent :     return "Silent";
        case App::Profile.RoutingAck : return "Routing Ack";
        case App::Profile.TestTone :   return "Test Tone";
        case App::Profile.Evacuation : return "Evacuate";
        case App::Profile.General :    return "General";
        case App::Profile.Fault :      return "Fault";
        default : return "-";
      }
  }

  $rect <530,20,730,60>
  method App::DeviceConfig GetConfigNum( arg int16 dev_num )
  {
    var int32 ptr = 0;

    native( dev_num, ptr )
    {
       Command cmd;
       Command0( CMD_GET_DEVICE_LISTS, &cmd );  

       DeviceConfig* d   = (DeviceConfig*)   cmd.int0;  

       if ( d != NULL ) 
       { 
         d += dev_num;

         ptr = (int) d;
       }
    }
     

    return GetConfigFromPtr( ptr );


     
  }

  $rect <750,0,950,40>
  method int32 GetNumSiteDevices()
  {
     
    var int32 num = 0;

    native( num )
    {
       Command cmd;
       Command0( CMD_GET_DEVICE_LISTS, &cmd );  

       num = cmd.short6;
    }

    return num;

  }

  $rect <750,40,950,80>
  method int32 GetNumRadiosFound()
  {
     
    var int32 num = 0;

    native( num )
    {
       Command cmd;
       Command0( CMD_GET_DEVICE_LISTS, &cmd );  

       num = cmd.short5;
    }

    return num;

  }

  $rect <760,90,960,130>
  method App::RadioUnit GetRadioNum( arg int16 num )
  {
    //var Application::DeviceConfig d;
    //var Application::DeviceConfig d;

    var App::RadioUnit ru = new App::RadioUnit;

    var int32 ptr = 0;

    if ( ru != null ) native( ru, num )
    {
       Command cmd;
       Command0( CMD_GET_DEVICE_LISTS, &cmd );  

       RadioUnit* rad  = (RadioUnit*)   cmd.int1;  

        ptr = (int)( rad + num ); 
    }

    return GetRadioFromPtr( ptr );




  }

  $rect <860,190,1060,230>
  method App::Alert GetAlertNum( arg App::ActionBits event, arg int32 num )
  {
    var App::Alert al = new App::Alert;

    var string desc = "";
    var string time = "";
    var int16 unitnum;
    var int16 zonenum;
    var App::AlertFlags flags;
    var string site = "";

    if ( al != null ) 
    {
      native( al, num, desc, time, unitnum, zonenum, flags )
      {
         Command cmd;

         cmd.int0 = num;
         cmd.int1 = event;
         cmd.int2 = -1;
         cmd.int3 = -1;

         Command0( CMD_GET_ALERT_DETAILS, &cmd ); 
        
         if ( cmd.int0 != NULL ) desc = EwNewStringAnsi( (char*) cmd.int0 );
         if ( cmd.int3 != NULL ) time = EwNewStringAnsi( (char*) cmd.int3 );

         al->zonenum = cmd.char4;
         al->panelnum  = cmd.char5;
         al->unitnum = cmd.short3;
         al->flags   = cmd.short4;
         al->chanimg = cmd.charA;
         al->action = cmd.charB;
      }

      al.description = desc;
      al.time = time;
    }
     
    return al;


  }

  $rect <530,140,730,180>
  method App::RadioUnit GetRadioFromPtr( arg int32 unit_ptr )
  {
    var App::RadioUnit ru = new App::RadioUnit;

    if ( ru != null ) native( unit_ptr )
    {
        RadioUnit* rad = (RadioUnit*) unit_ptr;

        if ( rad != NULL )
        {
           ru->zonenum    = rad->zone;
           ru->unitnum    = rad->unit;
           ru->combination = rad->combination;
           ru->starttime  = rad->starttime;
           ru->rssi       = rad->rssiprimary;
           ru->primary    = rad->primary;
           ru->sent       = rad->sent;
           ru->received   = rad->received;
           ru->stage      = rad->state;
           ru->battery    = rad->battery;
           ru->valid      = rad->valid;
         }
         else
         {
           ru = NULL;
         }
    }

    return ru;

            

  }

  $rect <30,220,230,260>
  method App::DeviceConfig GetConfigFromPtr( arg int32 ptr )
  {
    if ( ptr != 0 )
    { 
      var App::DeviceConfig dev = new App::DeviceConfig;

      var string location = "";
      var string combi = "??";

      if ( dev != null ) native( dev, ptr )
      {  
         DeviceConfig* d = (DeviceConfig*) ptr;

         if ( d != NULL ) 
         { 
           dev->combination = d->type;

           location = EwNewStringAnsi( d->location );
           combi    = EwNewStringAnsi( d->typestring );
     
           dev->numparams   = d->numParams;
           dev->numinputs   = d->numInputs;
           dev->numoutputs  = d->numOutputs;

           dev->unitnum     = d->unit;
           dev->zonenum     = d->zone;

           dev->flags       = d->flags;
         }
         else dev = NULL;
      }

      var uint8 i;
      var uint8 o;
      var uint8 p;

      if ( dev != null )
      {
        dev.location  = location;
        dev.combiname = combi;  

        for( i = 0; i < dev.numinputs; i = i + 1 )
        {
           dev.inputs[i] = GetInputFromPtr( ptr, i );
        }

        for( o = 0; o < dev.numoutputs; o = o + 1 )
        {
           dev.outputs[o] = GetOutputFromPtr( ptr, o );
        }

        for( p = 0; p < dev.numparams; p = p + 1 )
        {
           dev.params[p] = GetParameter( dev.unitnum, p );
        }
        return dev;
      }
    }
        
    return null;

  }

  $rect <960,10,1160,50>
  method App::DeviceConfig GetConfigNumInZone( arg int16 zone, arg int16 unitnum )
  {
    var int32 ptr = 0;

    native( unitnum, zone )
    {  
      Command cmd;

      cmd.int0 = zone;
      cmd.int1 = unitnum;
      Command0( CMD_GET_DEV_IN_ZONE, &cmd );
      ptr = cmd.int0;
    }

    return GetConfigFromPtr( ptr );

  }

  $rect <910,270,1110,310>
  method App::InputChannel GetInputFromPtr( arg int32 devptr, arg uint8 channel )
  {
    if ( devptr != 0 )
    {
      var App::InputChannel input = new App::InputChannel; 

      if ( input != null ) native( devptr, channel, input)
      {    
         DeviceConfig* d = (DeviceConfig*) devptr;
         InputChannel* i = d->input + channel;


         input->delay  = i->delay;
         input->flags  = i->flags;
         input->action = i->action;
         input->type   = i->type;

         return input;
         
      }
    }

    return null;

  }

  $rect <940,320,1140,360>
  method App::OutputChannel GetOutputFromPtr( arg int32 devptr, arg uint8 channel )
  {
     
    if ( devptr != 0 )
    {
      var App::OutputChannel output = new App::OutputChannel;

      if ( output != null ) native( devptr, channel, output )
      {  
         DeviceConfig* d = (DeviceConfig*) devptr;
         OutputChannel* o = d->output + channel;
     
         output->delay1  = o->delay1;
         output->delay2  = o->delay2;
         output->flags   = o->flags;
         output->actions = o->actions;
         output->type    = o->type;

         return output;    
      }
    }

    return null;

  }

  $rect <970,140,1170,180>
  method App::Alert GetAlertNumInZone( arg App::ActionBits event, arg int32 num, arg int32 zone, arg int32 panel )
  {
    var App::Alert al = new App::Alert;

    var string desc = "";
    var string time = "";
    var int16 unitnum;
    var int16 zonenum;
    var App::AlertFlags flags;
    var string site = "";

    if ( al != null ) 
    {
      native( al, num, desc, time, unitnum, zonenum, flags )
      {
         Command cmd;

         cmd.int0 = num;
         cmd.int1 = event;
         cmd.int2 = zone;
         cmd.int3 = panel;

         Command0( CMD_GET_ALERT_DETAILS, &cmd ); 
        
         if ( cmd.int0 != NULL ) desc = EwNewStringAnsi( (char*) cmd.int0 );
         if ( cmd.int3 != NULL ) time = EwNewStringAnsi( (char*) cmd.int3 );

         al->zonenum = cmd.short2;
         al->unitnum = cmd.short3;
         al->flags   = cmd.short4;
         al->chanimg = cmd.short5;

      }

      al.description = desc;
      al.time = time;
    }
     
    return al;


  }

  $rect <960,90,1160,130>
  method App::ZoneAlert GetZoneAlert( arg int32 num )
  {
    var App::ZoneAlert al = new App::ZoneAlert;

    var int32 panel = 0;
    var int32 zone = 0; 

    if ( al != null ) 
    {
      native( panel, zone )
      {
         Command cmd;

         cmd.int0 = num;

         if ( Command0( CMD_GET_NTH_ZONE, &cmd ) == CMD_OK )
         {
           panel = cmd.int1;
           zone  = cmd.int0;
         }
      }

      al.panel = panel;
      al.zone  = zone;
    }
     
    return al;


  }

  $rect <720,390,920,430>
  method int32 GetNumZoneAlerts()
  {
    var int32 n = 0;

    native( n )
    {
      Command cmd;

      Command0( CMD_GET_NUM_ZONES_IN_FIRE, &cmd );

      n = cmd.int0;
    }

    return n;
     
  }

  $rect <720,450,920,490>
  method int32 GetNumAlertsInZone( arg int32 zone, arg int32 panel )
  {
    var int32 n = 0;

    native( n )
    {
      Command cmd;
      cmd.int0 = zone;
      cmd.int1 = panel;
      Command0( CMD_GET_NUM_ALERTS_IN_ZONE, &cmd );

      n = cmd.int0;
    }

    return n;
     
  }

  $rect <960,390,1160,430>
  method string GetPanelName( arg int32 index )
  {
    var string name = "";

    if ( index >= 0 && index < 5 )
    {

      native( name )
      {    
          Command cmd;
          cmd.int0 = index;
          Command0( CMD_GET_PANEL_NAME, &cmd );

          if ( cmd.int0 != NULL )
          {
            name = EwNewStringAnsi( (char*) cmd.int0 );
          }
        }
     }
     
     return name;
     
     

  }

  $rect <680,310,850,350>
  method App::ZoneFlags GetPanelZoneFlags( arg int16 zone, arg int16 panel )
  {
    var App::ZoneFlags zf = App::ZoneFlags[];

     

    native( zf )
    {
      Command cmd;
      cmd.int0 = zone;
      cmd.int1 = panel;
      Command0( CMD_GET_PANEL_ZONE_FLAGS, &cmd );

      zf = (AppZoneFlags) cmd.int0;
    }

    return zf;


  }

  $rect <700,350,880,390>
  method void SetPanelZoneFlags( arg int16 zone, arg int16 panel, arg App::ZoneFlags flags )
  {
    native
    {
      Command3( CMD_SET_PANEL_ZONE_FLAGS, zone, panel, flags );
    }


  }

  $rect <300,500,500,540>
  method bool GetZoneDisabledState( arg int32 zone )
  {
    var bool state = false;

    native( zone, state )
    {
        Command cmd;

        cmd.int0 = zone;
        
        Command0( CMD_GET_ZONE_DISABLED, &cmd );

        state = cmd.int1;
    }

    return state;

  }

  $rect <310,540,530,580>
  method void SetZoneDisabledState( arg int32 zone, arg bool state )
  {
    native( zone, state )
    {
      Command2( CMD_SET_ZONE_DISABLED, zone, state );
    }


  }

  $rect <480,460,680,500>
  method bool OnTree( arg int32 unitnum )
  {
    /* The template just returns the given argument... */

    var bool res = false;

    native( unitnum )
    {
      Command cmd;

      cmd.int0 = unitnum;

      Command0( CMD_CHECK_ON_TREE, &cmd );
      
      res = cmd.int0; 
    }

    return res;


  }

  $rect <260,180,460,220>
  method string Order( arg int32 order )
  {
      var string s = string( order );

      order = order % 100;

      if ( order > 3 && order < 21 ) 
      {
          s = s + "th";
      }
      else switch( order % 10 )
      {
        case 1: s = s + "st";
        case 2: s = s + "nd";
        case 3: s = s + "rd";
        default: s = s + "th";
      }

     
    return s;
  }

  $rect <0,530,200,570>
  method string GetCombiName( arg int32 type )
  {
    /* The template just returns the given argument... */

    var string name = "";

    native ( type, name )
    {
      Command cmd;

      cmd.int0 = type;
      Command0( CMD_SEACH_DEV_TYPE_STRING, &cmd );

      if ( cmd.int1 != 0 )
      {
         name = EwNewStringAnsi( (char*) cmd.int1 );
      }
    }
     
    return name;
     

    /*
    switch( type )
    {
        case 0  : return  "--";
        case 1  : return  "SN.DTS0.RB00.1";
        case 2  : return  "SN.DTH0.RB00.1";
        case 3  : return  "SN.DTH1.RB00.1";
        case 4  : return  "SN.DTC0.RB00.1";
        case 5  : return  "SN.DTC1.RB00.1";
        case 6  : return  "SN.VAD1.RB00.1";
        case 7  : return  "BEACON.W.3";
        case 8  : return  "SN.VAD0.RB00.1";
        case 9  : return  "BEACON.C.3";
        case 10 : return  "REMOTE.IND";
        case 11 : return  "SN.BLP0.RB10.1";
        case 12 : return  "SN.DTS0.RB10.1";
        case 13 : return  "SN.DTH0.RB10.1";
        case 14 : return  "SN.DTH1.RB10.1";
        case 15 : return  "SN.DTC0.RB10.1";
        case 16 : return  "SN.DTC1.RB10.1";
        case 17 : return  "SN.VAD1.RB10.1";
        case 18 : return  "BEACON.W.2";
        case 19 : return  "SN.VAD0.RB10.1";
        case 20 : return  "BEACON.C.3";
        case 21 : return  "SN.BLP0.RB20.1";
        case 22 : return  "SN.DTS0.RB20.1";
        case 23 : return  "SN.DTH0.RB20.1";
        case 24 : return  "SN.DTH1.RB20.1";
        case 25 : return  "SN.DTC0.RB20.1";
        case 26 : return  "SN.DTC1.RB20.1";
        case 27 : return  "FIRE.CP";
        case 28 : return  "SN.IOU00.1";
        case 29 : return  "CN.FAP000";
        case 30 : return  "CN.FAP100";
        case 31 : return  "CN.FAP110";
        case 32 : return  "CN.FAC100";
        case 33 : return  "CN.FFP100";
        case 34 : return  "CN.FFP110";
        case 35 : return  "CN.DTC000.2";
        case 36 : return  "SN.MCP0.RB30.2";
        case 37 : return  "FA.CP";
        case 38 : return  "CN.FAP010";
        case 39 : return  "CN.FAC110";
        case 40 : return  "CN.DTC010.2";
        case 41 : return  "SN.BLP0.RB00.1";
        case 64 : return  "Panel I/O";
        case 65 : return  "Functions";
        case 66 : return "Evacuate";
        default: return "Type " + string(type);
    }
    return  "Unknown";
    */

  }

  $rect <760,510,960,550>
  method int32 NumDevTypes()
  {
    /* The template just returns the given argument... */
    return 41;

  }

  $rect <500,230,640,270>
  method Resources::Bitmap TypeBitmap( arg App::ChannelType Bitmap )
  {
    /* The template just returns the given argument... */
     
       switch ( Bitmap )
       {
      	  case App::ChannelType.None : return null;								
          case App::ChannelType.Smoke : return App::SmokeBitmap;
          case App::ChannelType.HeatB : return App::HeatBSensorBitmap;
          case App::ChannelType.HeatA1R : return App::HeatA1RBitmap;
          case App::ChannelType.CO : return App::COBitmap;
          case App::ChannelType.PIR : return App::PIRBitmap;
          case App::ChannelType.Sounder : return App::SounderBitmap;
          case App::ChannelType.Beacon : return App::BeaconBitmap;
          case App::ChannelType.FireCallpoint : return App::FireAlarmBitmap;
          case App::ChannelType.Status_indicator_led : return null;			
          case App::ChannelType.VisualIndicator : return App::VIBitmap;
          case App::ChannelType.SounderVisualIndicatorCombined : return App::SounderVIBitmap;	
          case App::ChannelType.MedicalCallpoint : return App::GreenCallpointBitmap;
          case App::ChannelType.EvacCallpoint : return App::evacuate;
          case App::ChannelType.OutputRouting : return App::FireRouting;

          case App::ChannelType.PanelAlarmInput : return App::input_alarm;
          case App::ChannelType.PanelAlarmRelay : return App::output_alarm;
          case App::ChannelType.PanelCallpoint  : return App::input_callpoint;
          case App::ChannelType.PanelFaultInput : return App::input_fault;
          case App::ChannelType.PanelFaultRelay : return App::output_fault;
          case App::ChannelType.PanelFireRelay : return App::output_fire;
          case App::ChannelType.PanelRoutingAck : return App::input_routing_ack;
          case App::ChannelType.PanelRoutingOutput: return App::output_routing;
          case App::ChannelType.PanelSilenceInput: return App::input_silence;
          case App::ChannelType.PanelSoundersRelay: return App::output_sounders;
          case App::ChannelType.PanelFunction1: return App::function;
          case App::ChannelType.PanelFunction2: return App::function;
          case App::ChannelType.PanelEvacuate: return App::EvacuateBitmap;
          case App::ChannelType.WaterLeak: return App::WaterLeakBitmap;


    	    default :
          {
               if ( (int32) Bitmap <=  (int32) App::ChannelType.Input32 &&
                    (int32) Bitmap >=  (int32) App::ChannelType.Input1)
               {
                   
                   return App::GeneralInputBitmap;

               }
               if ( (int32) Bitmap <=  (int32) App::ChannelType.Output16 &&
                    (int32) Bitmap >=  (int32) App::ChannelType.Output1 )
               {
                  
                   return App::GeneralOutputBitmap;
               }
           }
        }
    return null;

  }

  $rect <220,440,420,480>
  method string Unit( arg int32 u )
  {
    /* The template just returns the given argument... */

    if ( u < 512 )
    {
      return "Unit " + string( u );
    }
    else if ( u == 512 )
    {
      return "Panel IO";
    }
    else if ( u == 514 )
    {
       return "Evacuate";
    }
    else if ( u == 513 )
    {
      return "Buttons";
    }
    return "Unit ?";
  }

  $rect <730,130,930,170>
  method int32 LocalPanelIndex()
  {
    /* The template just returns the given argument... */

    var int32 i = -1;

    native( i )
    {
      if ( capp != NULL )
      {
        if ( capp->panel != NULL && capp->site != NULL )
        {
           i = capp->panel - capp->site->panels;
        }
      }
    }

    return i;

  }

  $rect <640,230,810,270>
  method Resources::Bitmap TypeSmallBitmap( arg App::ChannelType Bitmap )
  {
    /* The template just returns the given argument... */
     
       switch ( Bitmap )
       {
      	  case App::ChannelType.None : return null;								
          case App::ChannelType.Smoke : return App::smoke2small;
          case App::ChannelType.HeatB : return App::heatsmall;
          case App::ChannelType.HeatA1R : return App::heatA1Rsmall;
          case App::ChannelType.CO : return App::cosmall;
          case App::ChannelType.PIR : return App::pirsmall;
         
          case App::ChannelType.FireCallpoint : return App::fire_alarmsmall;
       
      
          case App::ChannelType.MedicalCallpoint : return App::greencall2small;
          case App::ChannelType.EvacCallpoint : return App::evacuatesmall;
          case App::ChannelType.OutputRouting : return App::fire_routingsmall;

          case App::ChannelType.PanelAlarmInput : return App::input_alarmsmall;
        
          case App::ChannelType.PanelCallpoint  : return App::input_callpointsmall;
          case App::ChannelType.PanelFaultInput : return App::input_faultsmall;
          case App::ChannelType.PanelRoutingAck : return App::input_routing_acksmall;
          
          case App::ChannelType.PanelSilenceInput: return App::input_silencesmall;
          
          case App::ChannelType.PanelFunction1: return App::functionsmall;
          case App::ChannelType.PanelFunction2: return App::functionsmall;
          case App::ChannelType.PanelEvacuate: return App::evacuate40csmall ;



    	    default :
          {
               if ( (int32) Bitmap <=  (int32) App::ChannelType.Input32 &&
                    (int32) Bitmap >=  (int32) App::ChannelType.Input1)
               {
                   
                   return App::general_inputsmall;

               }
              
           }
        }
    return null;

  }

  $rect <40,610,240,650>
  method int32 GetNumFireRouting()
  {
    native
    {

         Command cmd;
      Command0( CMD_GET_NUM_ROUTING, &cmd);
      return cmd.int0;
    }


    return 0;

  }
}

$rect <240,1580,440,1620>
$output false
autoobject App::LibClass Lib;

$rect <860,1210,1060,1250>
$output false
set Options
{
  $rect <20,10,190,50>
  item Latching = 1;

  $rect <20,50,190,90>
  item Disabled = 2;

  $rect <20,90,190,130>
  item Inverted = 4;

  $rect <20,130,190,170>
  item DisabledDay = 8;

  $rect <20,170,190,210>
  item DisabledNight = 16;

  $rect <20,210,190,250>
  item IgnoreDelay = 32;

  $rect <20,250,190,290>
  item Silenceable = 64;

  $rect <20,290,190,330>
  item Coincidence = 128;

  $rect <20,330,190,370>
  item UseGlobalDelays = 256;

  $rect <20,370,190,410>
  item NoNightDelays = 512;
}

$rect <880,1260,1080,1300>
$output false
class RadioUnit
{
  $rect <0,0,200,40>
  $output true
  property int16 zonenum = 0;

  $rect <0,40,200,80>
  $output true
  property int16 unitnum = 0;

  $rect <0,80,200,120>
  $output true
  property uint8 combination = 0;

  $rect <0,120,200,160>
  $output true
  property uint32 starttime = 0;

  $rect <0,160,200,200>
  $output true
  property int16 rssi = 0;

  $rect <0,200,200,240>
  $output true
  property int16 primary = 0;

  $rect <0,240,200,280>
  $output true
  property int16 received = 0;

  $rect <0,280,200,320>
  $output true
  property int16 sent = 0;

  $rect <0,320,200,360>
  $output true
  property App::NCUStage stage = App::NCUStage.Dropped;

  $rect <0,360,200,400>
  $output true
  property int8 battery = 0;

  $rect <10,400,210,440>
  $output true
  property uint8 valid = 0;
}

$rect <660,1250,860,1290>
$output false
class DeviceConfig
{
  $rect <0,0,200,40>
  property int16 zonenum = 1;

  $rect <0,40,200,80>
  property int16 unitnum = 1;

  $rect <0,80,200,120>
  $output true
  property uint8 combination = 12;

  $rect <0,120,200,160>
  $output true
  property uint8 numparams = 0;

  $rect <10,220,210,260>
  $output true
  array App::InputChannel inputs[ 32 ] =
  (
    Default[0] = App::DummyInputChan;
  );

  $rect <10,270,210,310>
  $output true
  array App::OutputChannel outputs[ 32 ] =
  (
    Default[0] = App::DummyOutputChan;
    Default[1] = App::DummyOutputChan1;
  );

  $rect <10,320,210,360>
  $output true
  array App::Parameter params[ 4 ] =
  (
    Default[0] = App::DummyParam;
    Default[1] = App::DummyParam1;
  );

  $rect <260,10,460,50>
  property string location = "Dumy device";

  $rect <0,160,200,200>
  $output true
  property string combiname = "TYPE";

  $rect <260,70,460,110>
  $output true
  property uint8 numinputs = 0;

  $rect <260,120,460,160>
  $output true
  property uint8 numoutputs = 0;

  // true
  $rect <260,170,460,210>
  $output true
  property App::DeviceConfigFlags flags = App::DeviceConfigFlags[];

  $rect <330,280,530,320>
  method bool IsAlarmDevice( arg int32 channum )
  {
    /* The template just returns the given argument... */
    var App::OutputChannel ch = outputs[ channum ];

    if ( ch.type == App::ChannelType.Beacon ||
         ch.type == App::ChannelType.Sounder || 
         ch.type == App::ChannelType.PanelSoundersRelay || 
         ch.type == App::ChannelType.PanelFireRelay || 
         ch.type == App::ChannelType.PanelAlarmRelay || 
         ch.type == App::ChannelType.SounderVisualIndicatorCombined || 
         ch.type == App::ChannelType.VisualIndicator )
    {
      return true;
    }
    return false;

  }
}

$rect <980,1300,1180,1340>
$output false
class InputChannel
{
  $rect <0,0,200,40>
  property uint16 delay = 0;

  $rect <0,40,230,80>
  property App::Options flags = App::Options[];

  $rect <0,80,200,120>
  property App::Action action = App::Action.Fire;

  $rect <0,120,200,160>
  property App::ChannelType type = App::ChannelType.None;
}

$rect <840,1160,980,1200>
$output false
enum Action
{
  $rect <10,10,210,50>
  item Fire = 0;

  $rect <220,10,420,50>
  item FirstAid = 1;

  $rect <240,60,440,100>
  item Evacuation = 2;

  $rect <430,10,630,50>
  item Security = 3;

  $rect <680,110,880,150>
  item General = 4;

  $rect <460,110,660,150>
  item Fault = 5;

  $rect <240,110,440,150>
  item RoutingAck = 6;

  $rect <650,240,850,280>
  item Resound = 8;

  $rect <20,110,220,150>
  item Reset = 9;

  $rect <650,60,850,100>
  item Silence = 10;

  $rect <440,60,640,100>
  item Undefined = 11;
}

$rect <770,1300,970,1340>
$output false
enum ChannelType
{
  $rect <430,10,630,50>
  item None = 0;

  $rect <310,250,510,290>
  item Smoke;

  $rect <780,220,980,260>
  item HeatB;

  $rect <530,220,730,260>
  item CO;

  $rect <60,230,260,270>
  item PIR;

  $rect <80,170,280,210>
  item Sounder;

  $rect <740,160,940,200>
  item Beacon;

  $rect <500,160,700,200>
  item FireCallpoint;

  $rect <280,120,480,160>
  item Status_indicator_led;

  $rect <50,120,250,160>
  item VisualIndicator;

  $rect <290,200,550,240>
  item SounderVisualIndicatorCombined;

  $rect <220,10,420,50>
  item MedicalCallpoint;

  $rect <710,30,910,70>
  item EvacCallpoint;

  $rect <490,90,690,130>
  item OutputRouting;

  $rect <270,400,470,440>
  item Input1 = 14;

  $rect <280,360,480,400>
  item Input32 = 45;

  $rect <40,400,240,440>
  item Output1 = 46;

  $rect <30,360,230,400>
  item Output16 = 61;

  $rect <770,280,970,320>
  item HeatA1R = 62;

  $rect <1120,270,1320,310>
  item WaterLeak = 63;

  $rect <570,320,770,360>
  item PanelRoutingAck = 64;

  $rect <570,360,770,400>
  item PanelCallpoint = 65;

  $rect <570,400,770,440>
  item PanelAlarmInput = 66;

  $rect <570,440,770,480>
  item PanelSilenceInput = 67;

  $rect <570,480,770,520>
  item PanelFaultInput = 68;

  $rect <800,340,1000,380>
  item PanelAlarmRelay = 69;

  $rect <800,380,1000,420>
  item PanelFaultRelay = 70;

  $rect <800,420,1000,460>
  item PanelFireRelay = 71;

  $rect <800,460,1000,500>
  item PanelRoutingOutput = 72;

  $rect <800,500,1000,540>
  item PanelSoundersRelay = 73;

  $rect <50,480,250,520>
  item PanelFunction1 = 74;

  $rect <280,480,480,520>
  item PanelFunction2 = 75;

  $rect <60,520,260,560>
  item PanelEvacuate = 76;
}

$rect <980,1340,1180,1380>
$output false
class OutputChannel
{
  $rect <0,0,200,40>
  property uint16 delay1 = 0;

  $rect <230,0,430,40>
  property uint16 delay2 = 0;

  $rect <0,40,230,80>
  property App::Options flags = App::Options[];

  $rect <0,80,200,120>
  property App::ActionBits actions = App::ActionBits[];

  $rect <0,120,200,160>
  property App::ChannelType type = App::ChannelType.None;
}

$rect <1080,1260,1230,1300>
$output false
class Parameter
{
  $rect <0,0,200,40>
  $output true
  property uint8 channel = 0;

  $rect <0,50,200,90>
  $output true
  property string name = "";

  $rect <0,100,200,140>
  $output true
  property int16 value = 0;

  $rect <0,150,200,190>
  $output true
  property App::ParamCode code = App::ParamCode.Unused;

  $rect <230,200,430,240>
  $output true
  property int16 max = 0;

  $rect <10,200,210,240>
  $output true
  property int16 min = 0;
}

$rect <610,1160,810,1200>
$output false
enum ParamCode
{
  $rect <10,60,210,100>
  item Unused = 0;

  $rect <10,10,210,50>
  item Volume = 1;

  $rect <240,10,440,50>
  item Toggle = 2;
}

$rect <900,620,1060,660>
$output false
class OutputParams : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,510,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorizontalSlider
  {
    preset Bounds = <117,80,317,130>;
    preset Enabled = true;
    preset MaxValue = 3;
    preset MinValue = 0;
    preset CurrentValue = 2;
    preset Appearance = WidgetSet::HorizontalSlider_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <60,10,240,65>;
    preset Checked = true;
    preset OnSwitchOn = FlashSlotOn;
    preset OnSwitchOff = FlashSlotOff;
    preset Icon = null;
    preset LabelOn = "0.5Hz";
    preset LabelOff = "1Hz";
    preset Label = "Flash Rate";
    preset Appearance = App::NotmalToggleButton;
  }

  $rect <20,20,160,60>
  object Views::Text VolumeText
  {
    preset Bounds = <20,91,103,115>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Volume";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text SecondsText
  {
    preset Bounds = <249,20,357,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "1 Second";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <805,10,975,50>
  slot FlashSlotOff
  {
    sender; /* the method is called from the sender object */

    SecondsText.String = "2 Seconds";


  }

  $rect <810,60,980,100>
  slot FlashSlotOn
  {
    sender; /* the method is called from the sender object */

    SecondsText.String = "1 Second";




  }

  $rect <580,130,780,170>
  method int32 Method( arg int32 aArg1 )
  {
      /*
    if ( (flags & 1) == 1 )
    { 
      p.ToggleButton.Enabled = true;
      p.SecondsText.Color = #FFFFFFFF;
    }
    else
    {
      p.ToggleButton.Enabled = false;
      p.SecondsText.Color = #999999FF;
    }

    if ((flags & 2) == 2 )
    {
      p.HorizontalSlider.Enabled = true;
      p.VolumeText.Color = #FFFFFFFF;
    }
    else
    {
      p.HorizontalSlider.Enabled = false;
      p.VolumeText.Color = #999999FF;
    }

    //p.Writable.TextEditor.Text.String = location;
    p.Writable.TextEditor.String = location;

    p.HorizontalSlider.CurrentValue = vol;
    p.ToggleButton.Checked = frate == 0;

    if ( icount == 0 )
    {
      p.InputChanButton.Enabled = false;
    }
    else
    {
      p.InputChanButton.Enabled = true;
    }

    if ( ocount == 0 )
    {
      p.OutputChanButton.Enabled = false;
    }
    else
    {
      p.OutputChanButton.Enabled = true;
    }
    */
  }
}

$rect <770,710,910,750>
$output false
class ParamSlider : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,70>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <80,350,860,670>;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <10,16,212,46>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzBarSlider
  {
    preset Bounds = <221,10,538,52>;
    preset OnChange = null;
    preset OnEnd = null;
    preset StepSize = 1;
    preset MaxValue = 14;
    preset CurrentValue = 0;
    preset Appearance = App::NormalHorizontalSlider;
  }

  $rect <30,90,230,130>
  property App::Parameter param = null;
}

$rect <600,710,750,750>
$output false
class ParamToggle : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,60>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <80,350,860,670>;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <220,10,345,55>;
    preset OnSwitchOn = Slot;
    preset OnSwitchOff = Slot;
    preset LabelOn = "";
    preset LabelOff = "";
    preset Label = "Off";
    preset Appearance = WidgetSet::Switch_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <10,16,212,46>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <30,90,230,130>
  property App::Parameter param = null;

  $rect <340,110,540,150>
  slot Slot
  {
    sender; /* the method is called from the sender object */

    if ( ToggleButton.Checked )  ToggleButton.Label = "On";
    else  ToggleButton.Label = "Off";
  }
}

$rect <720,750,900,790>
$output false
class ParamSpecific : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,40>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <80,350,860,670>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <9,1,299,36>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Channel parameters";
    preset Font = Flat::FontM;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <542,20>;
    preset Point1 = <222,20>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <11,46,213,76>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }
}

$rect <470,1260,610,1300>
$output false
class Device
{
  $rect <30,90,270,130>
  $output true
  array App::ChannelFlags flags[ 32 ];

  $rect <20,40,220,80>
  property App::DeviceSetting settings = App::DeviceSetting[];

  $rect <60,150,260,190>
  array uint8 menuSelection[ 32 ];

  $rect <50,220,260,260>
  method bool IsDisableExpanded( arg int32 zonegroup )
  {
    if ( zonegroup == -1 )
    {
      return settings.contains( App::DeviceSetting[ DisableFireExpanded ] );
    }
    else if ( zonegroup == 0 )
    {
      return settings.contains( App::DeviceSetting[ DisableRoutingExpanded ] );       
    }
    else if  ( zonegroup >= 0 )
    {
      return settings.contains( App::DeviceSetting[ DisableExpanded ] );       
    }
    return false;

  }

  $rect <20,300,220,340>
  array uint8 val[ 4 ];
}

$rect <470,1060,670,1100>
$output false
set ChannelFlags
{
  $rect <10,10,210,50>
  item Asserted = 1;

  $rect <220,10,420,50>
  item Silenced = 2;

  $rect <430,10,630,50>
  item Latched = 4;

  $rect <240,70,440,110>
  item InputRuledDisabled = 8;

  $rect <660,70,860,110>
  item InputRuledOnTest = 16;

  $rect <850,10,1050,50>
  item InputOnTest = 32;

  $rect <20,70,220,110>
  item InFault = 64;

  $rect <450,70,650,110>
  item InputActiveOnTest = 128;

  $rect <640,10,840,50>
  item InputActive = 256;

  $rect <640,10,840,50>
  item InputNoticedOnTest = 512;

  $rect <640,10,840,50>
  item InputNotFound = 1024;

  $rect <470,190,670,230>
  item OutputDelayed = 2048;

  $rect <680,190,880,230>
  item OutputSkipped = 4096;

  $rect <30,260,230,300>
  item OutputRuledDisabled = 8192;

  $rect <250,190,450,230>
  item OutputOnTest = 16384;

  $rect <30,190,230,230>
  item OutputAsserted = 32768;
}

$rect <660,1110,860,1150>
$output false
autoobject App::DeviceConfig DummyConfig
{
  preset zonenum = 1;
  preset unitnum = 1;
  preset combination = 10;
  preset numparams = 2;
  preset location = "Devcice Location";
  preset numinputs = 1;
  preset numoutputs = 2;
}

$rect <250,1460,450,1500>
$output false
class Zone;

$rect <260,1420,460,1460>
$output false
set ZoneFlags
{
  $rect <220,10,420,50>
  item InFire = 1;

  $rect <680,100,880,140>
  item Silenced = 2;

  $rect <930,100,1130,140>
  item ModifyExpanded = 4;

  $rect <10,10,210,50>
  item OnTest = 8;

  $rect <680,10,880,50>
  item Disabled = 16;

  $rect <910,10,1110,50>
  item TestExpanded = 32;

  $rect <250,110,450,150>
  item DisableExpanded = 64;

  $rect <30,110,230,150>
  item FireExpanded = 128;
}

$rect <370,1320,520,1360>
$output false
set DeviceSetting
{
  $rect <10,10,210,50>
  item DisableFireExpanded = 1;

  $rect <220,10,420,50>
  item DisableExpanded = 2;

  $rect <430,10,630,50>
  item OnTest = 4;

  $rect <680,10,880,50>
  item TestExpanded = 8;

  $rect <10,60,240,100>
  item DisableRoutingExpanded = 16;

  $rect <320,70,550,110>
  item RuledOnTest = 32;

  $rect <600,70,830,110>
  item RuledDisabled = 64;
}

$rect <1260,1090,1440,1130>
$output false
resource Resources::Bitmap FireRouting
{
  attr bitmapfile FileName = .\Images\fire_routing.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1450,1080,1630,1120>
$output false
resource Resources::Bitmap GeneralOutputBitmap
{
  attr bitmapfile FileName = .\Images\general_output.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1450,1120,1630,1160>
$output false
resource Resources::Bitmap GeneralInputBitmap
{
  attr bitmapfile FileName = .\Images\general_input.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1260,1130,1440,1170>
$output false
resource Resources::Bitmap SounderBitmap
{
  attr bitmapfile FileName = .\Images\sounder1.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1090,1110,1250,1150>
$output false
resource Resources::Bitmap SounderVIBitmap
{
  attr bitmapfile FileName = .\Images\svi.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1130,1070,1260,1110>
$output false
resource Resources::Bitmap VIBitmap
{
  attr bitmapfile FileName = .\Images\vi_ring.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1110,1150,1270,1190>
$output false
resource Resources::Bitmap BeaconBitmap
{
  attr bitmapfile FileName = .\Images\sounder_beacon1.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1110,1010,1240,1050>
$output false
resource Resources::Bitmap COBitmap
{
  attr bitmapfile FileName = .\Images\co.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1710,790,1910,830>
$output false
resource Resources::Bitmap evacuate
{
  attr bitmapfile FileName = .\Images\evacuate.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1620,1090,1780,1130>
$output false
resource Resources::Bitmap SilencedBitmap
{
  attr bitmapfile FileName = .\Images\silenced.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <770,1340,970,1380>
$output false
enum RadioStatus
{
  $rect <220,10,420,50>
  item NotFound = 0;

  $rect <230,90,430,130>
  item Found = 1;

  $rect <20,30,220,70>
  item Additional = 2;

  $rect <20,150,220,190>
  item Different = 3;

  $rect <250,180,450,220>
  item NCU = 4;
}

$rect <460,1140,600,1180>
$output false
class Alert
{
  $rect <0,0,200,40>
  property string description = 0;

  $rect <0,50,200,90>
  property uint8 zonenum = 0;

  $rect <0,100,200,140>
  property int16 unitnum = 0;

  $rect <0,150,200,190>
  property App::AlertFlags flags = App::AlertFlags[];

  $rect <5,200,145,240>
  property string time = 0;

  $rect <220,50,420,90>
  property App::ChannelType chanimg = App::ChannelType.None;

  $rect <230,110,430,150>
  property uint8 action = 0;

  $rect <210,180,410,220>
  property uint8 panelnum = 0;
}

$rect <460,1210,620,1250>
$output false
set AlertFlags
{
  $rect <20,0,150,40>
  item Silenced = 1;

  $rect <20,80,150,120>
  item NetDevice = 16;

  $rect <20,120,150,160>
  item Device = 32;

  $rect <20,40,150,80>
  item NetCAE = 64;

  $rect <20,160,150,200>
  item CAE = 128;
}

$rect <750,960,950,1000>
$output false
enum NCUStage
{
  $rect <10,10,210,50>
  item Unknnown = 0;

  $rect <10,60,210,100>
  item Meshing = 1;

  $rect <10,110,210,150>
  item Activating = 2;

  $rect <10,220,210,260>
  item Dropped = 10;
}

$rect <1020,930,1220,970>
$output false
class MeshButton : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,270,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var App::MeshTree mt = (App::MeshTree) Owner;

    if ( mt != null )
    {
        if ( numItems == 0 )
        {
            RoundBox1.Text.String = inactive;
        }
        else if ( numItems == mt.totalItems )
        {
            RoundBox1.Text.String = done + " " + string( numItems ) + "/" +  string(mt.totalItems);
        }
        else
        {
            RoundBox1.Text.String = active + " " + string( numItems ) + "/" +  string(mt.totalItems);
        }
    }

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <310,50,510,90>
  property int16 numItems = -1;

  $rect <300,100,500,140>
  onset numItems
  {
     

    // Remember the property's new value.
    pure numItems = value;


    InvalidateViewState();


    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <550,0,750,40>
  property string inactive = "";

  $rect <560,50,760,90>
  property string active = "";

  $rect <560,120,760,160>
  property string done = "";

  $rect <20,20,160,60>
  object App::RoundBox RoundBox1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,270,40>;
    preset Radius1 = 8;
    preset LineColour = #4C4C4C83;
    preset FillColour = #AAD1FF87;
  }
}

$rect <650,1000,850,1040>
$output false
class MeshStatus
{
  $rect <0,40,200,80>
  property int16 active = 0;

  $rect <0,80,200,120>
  property int16 meshed = 0;

  $rect <0,130,200,170>
  property int16 total = 0;

  $rect <0,180,200,220>
  property int16 extra = 0;
}

$rect <850,1000,1050,1040>
$output false
class MeshStage
{
  $rect <10,180,210,220>
  property int16 wantedstage = 0;

  $rect <10,240,210,280>
  property int16 currentstage = 0;
}

$rect <860,1110,1010,1150>
$output false
autoobject App::Parameter DummyParam
{
  preset name = "Volume";
  preset value = 20;
  preset code = App::ParamCode.Volume;
  preset min = 100;
}

$rect <690,1050,890,1090>
$output false
autoobject App::InputChannel DummyInputChan
{
  preset flags = App::Options[Coincidence];
  preset type = App::ChannelType.Smoke;
}

$rect <890,1050,1090,1090>
$output false
autoobject App::OutputChannel DummyOutputChan
{
  preset flags = App::Options[Coincidence];
  preset actions = App::ActionBits[Evacuation, Fire, FirstAid];
  preset type = App::ChannelType.SounderVisualIndicatorCombined;
}

$rect <990,1160,1100,1200>
$output false
enum Profile
{
  $rect <10,10,210,50>
  item Fire = 0;

  $rect <220,10,420,50>
  item FirstAid = 1;

  $rect <240,60,440,100>
  item Evacuation = 2;

  $rect <430,10,630,50>
  item Security = 3;

  $rect <680,110,880,150>
  item General = 4;

  $rect <460,110,660,150>
  item Fault = 5;

  $rect <240,110,440,150>
  item RoutingAck = 6;

  $rect <20,110,220,150>
  item TestTone = 7;

  $rect <650,60,850,100>
  item Silent = 8;
}

$rect <920,1080,1090,1120>
$output false
autoobject App::Parameter DummyParam1
{
  preset name = "Switch";
  preset value = 1;
  preset code = App::ParamCode.Toggle;
  preset max = 1;
  preset min = 0;
}

$rect <1220,1040,1420,1080>
$output false
resource Resources::Bitmap HeatA1RBitmap
{
  attr bitmapfile FileName = .\Images\heatA1R.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1450,230,1650,270>
$output false
resource Resources::Bitmap CauseEffect2
{
  attr bitmapfile FileName = .\Images\CauseEffect2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1580,1140,1780,1180>
$output false
resource Resources::Bitmap zone3
{
  attr bitmapfile FileName = .\Images\zone3.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <0,0,160,40>
$output false
class Fire : Core::Group
{
  $rect <220,405,420,445>
  inherited property Bounds = <0,0,795,365>;

  $rect <-10,455,190,495>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,400,210,440>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <980,40,1120,80>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    // TO DO: Write your code here ... 

      
      var bool found = false;

      // nasty hack

      native( found )
      {
        if ( !strncmp( (char*)0x90D00004, "BMP=", 4 ) )
        {
          found = 1;
        }
      }

      if ( found )
      {
         LogoImage.Bitmap = App::LogoBitmap;
      }

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <440,370,680,410>
  slot OnLoadItem
  {
     
    var int32       itemNo   = ListViewer.Item;
    var App::FireContainer view = (App::FireContainer) ListViewer.VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( view == null )
      return;


    var App::ZoneAlert za = null;


     
    var int32 zonenum = 0;
    var int32 row = 0;

    var int32 numzonealerts = numZonesInFire; 
     

    while ( numzonealerts > 0 && itemNo >= 0 )
    {
        za = App::Lib.GetZoneAlert( zonenum );
        var App::ZoneFlags zf;
        
        if ( za.zone != 0 )
        {
          zf = App::Lib.GetPanelZoneFlags( za.zone, za.panel);
        }
        else 
        {
          zf = App::ZoneFlags[];
        }

        if ( row == itemNo )
        {
          if ( za.zone != 0 )
          {
            view.FireZone.Enabled = true;
            view.FireZone.Visible = true;
            view.FireChannel.Enabled = false;
            view.FireChannel.Visible = false;

            view.FireZone.Bounds.origin.y = 5;

            view.FireZone.panel = za.panel;
            view.FireZone.zone =  za.zone;
            
            view.FireZone.AttrText.String = "{lay65,105,*}{col}" + App::Lib.Order(zonenum + 1) + "{col}Zone " +
                 string(za.zone)+"{col}" + App::Lib.GetPanelName( za.panel );
          
            view.FireZone.Silenced.Visible = zf.contains( App::ZoneFlags[ Silenced ] );

            if ( zf.contains( App::ZoneFlags[ FireExpanded ] ) )
            {
                view.FireZone.ExpandImage.Bitmap = App::CollapseBitmap;
            }
            else
            {
                view.FireZone.ExpandImage.Bitmap = App::ExpandBitmap;  
            }      
          }
          else
          {
              view.FireChannel.Visible = false;
              view.FireChannel.Enabled = false;   
              view.FireZone.Visible = false;
              view.FireZone.Enabled = false;         
          }
          view.FireZone.InvalidateViewState();
          view.InvalidateViewState();
          return;
        }
        else
        {
            row = row + 1;
        }
         
        if ( row == itemNo )
        {
            if ( za.zone != 0 )
            {
                view.FireZone.Enabled = true;
                view.FireZone.Visible = true;
                view.FireChannel.Enabled = false;
                view.FireChannel.Visible = false;

                view.FireZone.panel = za.panel;
                view.FireZone.zone =  za.zone;

                view.FireZone.Bounds.origin.y = -20;

                view.FireZone.AttrText.String = "{lay65,105,*}{col}" + App::Lib.Order(zonenum + 1) + "{col}Zone " +
                    string(za.zone)+"{col}" + App::Lib.GetPanelName( za.panel );
          
        
                view.FireZone.Silenced.Visible = zf.contains( App::ZoneFlags[ Silenced ] );

                if ( zf.contains( App::ZoneFlags[ FireExpanded ] ) )
                {
                    view.FireZone.ExpandImage.Bitmap = App::CollapseBitmap;
                }
                else
                {
                    view.FireZone.ExpandImage.Bitmap = App::ExpandBitmap;  
                }          
                    
            }
            else
            {
                view.FireChannel.Visible = false;
                view.FireChannel.Enabled = false;   
                view.FireZone.Visible = false;
                view.FireZone.Enabled = false;   
                view.Visible = false;      
            }
            view.FireZone.InvalidateViewState();
            view.InvalidateViewState();
            return;
        } 
        else
        {
            row = row + 1;
        }
          
        if ( zf.contains( App::ZoneFlags[ FireExpanded ] ) )
        {
            var App::Alert alert = null;
            var int32 n = 0;

            do
            {
                alert = App::Lib.GetAlertNumInZone( App::ActionBits[ Fire ], n, za.zone, za.panel );   

                if ( alert == null )
                {
                  view.FireZone.Visible = false;
                  view.FireZone.Enabled = false;   
                  view.FireChannel.Visible = false;
                  view.FireChannel.Enabled = false;      
                  view.InvalidateViewState(); 
                  return;
                }

                n = n + 1;

                if ( !alert.flags.isempty ) 
                {      
                    if ( row == itemNo )
                    {               
                        view.FireZone.Enabled = false;
                        view.FireZone.Visible = false;
                        view.FireChannel.Enabled = true;
                        view.FireChannel.Visible = true;

                      

                        var string s = "{lay70,*,135}{col}";
                          
                        view.FireChannel.TimeText.String = alert.time;
                        
                        if ( alert.flags.contains( App::AlertFlags[ CAE ] ) )
                        {
                            view.FireChannel.TypeImage.Bitmap = App::CauseEffect2;
                            view.FireChannel.SmallChannelImage.Bitmap = App::ChannelType.None;
                            s = s + "Rule " + string( alert.unitnum ) + "{col}" + alert.description + "{col}{parr}Cause And Effect";
                        }
                        else if ( alert.flags.contains( App::AlertFlags[ Device ] ) )
                        {
                            view.FireChannel.TypeImage.Bitmap = null;
                            view.FireChannel.SmallChannelImage.Bitmap = alert.chanimg;
                            s = s + App::Lib.Unit( alert.unitnum ) + "{col}" + alert.description + "{col}{parr}" + App::Lib.TypeName( alert.chanimg );   
                        }
                        else if ( alert.flags.contains( App::AlertFlags[ NetDevice ] ) )
                        {
                            view.FireChannel.TypeImage.Bitmap = null;
                            view.FireChannel.SmallChannelImage.Bitmap = alert.chanimg;
                            s = s + App::Lib.Unit( alert.unitnum ) + "{col}" + alert.description + "{col}{parr}" + App::Lib.TypeName( alert.chanimg );   
                        }
                        else if ( alert.flags.contains( App::AlertFlags[ NetCAE ] ) )
                        {
                            view.FireChannel.TypeImage.Bitmap = App::CauseEffect2;
                            view.FireChannel.SmallChannelImage.Bitmap = App::ChannelType.None;
                            s = s + "Rule " + string( alert.unitnum ) + "{col}" + alert.description + "{col}{parr}Cause And Effect";
                        }
                        else 
                        {
                           view.FireChannel.Visible = false;
                            view.InvalidateViewState(); 
                           return;
                        }
                        view.FireChannel.AttrText.String = s;

                        view.FireChannel.SilenceImage.Visible = alert.flags.contains( App::AlertFlags[ Silenced ] );

                        view.FireChannel.InvalidateViewState();
                        view.InvalidateViewState();
                        return;
                    }
                    else 
                    {
                        row = row + 1;
                    }       
                }
                
            } while ( !alert.flags.isempty );
        }

        if ( zonenum == 0 ) 
        {
            zonenum = numzonealerts - 1;
            if ( zonenum == 0 )
            {
                view.FireZone.Visible = false;
                view.FireZone.Enabled = false;   
                view.FireChannel.Visible = false;
                view.FireChannel.Enabled = false;      
                view.InvalidateViewState(); 
                return;
            }
        }
        else if ( zonenum == numzonealerts - 1 )
        {
            zonenum = 1;
        }
        else 
        {
            zonenum = zonenum + 1;
            if ( zonenum == numzonealerts - 1 )
            {
                view.FireZone.Visible = false;
                view.FireZone.Enabled = false;   
                view.FireChannel.Visible = false;
                view.FireChannel.Enabled = false;      
                view.InvalidateViewState(); 
              return;
            }
        }
        numzonealerts = numzonealerts - 1;
    };

      view.FireZone.Visible = false;
      view.FireZone.Enabled = false;   
      view.FireChannel.Visible = false;
      view.FireChannel.Enabled = false;  
       
     // view.FireChannel.InvalidateViewState();
     // view.FireZone.InvalidateViewState();
      view.InvalidateViewState();



      /*
    }
          


    var int16 itemNo   = VerticalList.Item;

    var App::AlarmRowItem row = (App::AlarmRowItem)VerticalList.View;

    if ( row != null )
    {
      var App::Alert alert;

      var int32 numAlarms = 0;

      native( numAlarms )
      {
        Command cmd;
        Command0( CMD_GET_NUM_FIRES, &cmd );
        numAlarms = cmd.int0;
      }

      if ( numAlarms == 0 )
      {
         row.Visible = false;
         return;
      }

      if ( itemNo == 0 )
      {
          row.Flashing = true;
          row.OrderPosition = numAlarms;
          alert = App::Lib.GetAlertNum( App::ActionBits[ Fire ], numAlarms - 1 );
      }
      else
      {  
         row.Flashing = false;
         row.OrderPos.Visible = true;
         row.OrderPosition = itemNo;
         alert = App::Lib.GetAlertNum( App::ActionBits[ Fire ], itemNo - 1 ); 
      }


      if ( alert.flags.contains( App::AlertFlags[ Silenced ] ) )
      {
         row.Image1.Visible = true;
      }
      else
      {
         row.Image1.Visible = false;
      }

      if ( alert.flags.contains( App::AlertFlags[ CAE ] ) )
      {
         row.ZoneText.String = "Rule " + string( alert.unitnum ) + "  Zone " + string( alert.zonenum );
      }
      else if ( alert.flags.contains( App::AlertFlags[ Device ] ) )
      {
         row.ZoneText.String = "Zone " + string( alert.zonenum ) + "  Unit " + string( alert.unitnum );
      }
      else if ( alert.flags.contains( App::AlertFlags[ Network ] ) ) 
      {
         row.ZoneText.String =  "Panel " + string( alert.unitnum ) + "  Zone " + string( alert.zonenum );
      }
      else
      {
        row.Visible = false;
        row.Enabled = false;
        return;
      }

     
      if ( alert.chanimg == -2 ) row.Image.Bitmap = App::zone3;
      else if ( alert.chanimg == -1 ) row.Image.Bitmap = App::CauseEffect2;
      else
      {   
        var App::ChannelType itype = (App::ChannelType) alert.chanimg;

        row.Image.Bitmap = App::Lib.TypeBitmap( itype );
      }

      row.Text.String = alert.description;
      row.TimeText.String = alert.time; 
      row.Visible = true;
    }
      

    var int32 n = itemNo % 4;

    switch ( n )
    {
        case 0 :{ view.FireChannel.Visible = false;
                 view.FireChannel.Enabled = false;
                 view.FireZone.Visible = true;
                 view.FireZone.Enabled = true;
                 view.FireZone.Bounds.origin.y = 5;}

        case 1 : {view.FireChannel.Visible = false;
                 view.FireChannel.Enabled = false;
                 view.FireZone.Visible = true;
                 view.FireZone.Enabled = true;
                 view.FireZone.Bounds.origin.y = -20; }
                 
       case 2 :  {view.FireChannel.Visible = true;
                 view.FireChannel.Enabled = true;
                 view.FireZone.Visible = false;
                 view.FireZone.Enabled = false;
                 view.FireChannel.Bounds.origin.y = 0;   }
        case 3 :  {view.FireChannel.Visible = true;
                 view.FireChannel.Enabled = true;
                 view.FireZone.Visible = false;
                 view.FireZone.Enabled = false;
                 view.FireChannel.Bounds.origin.y = 0; }
    }          */

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ResoundAlarmsButton
  {
    preset Bounds = <615,130,795,185>;
    preset Enabled = false;
    preset OnRelease = null;
    preset OnActivate = ResoundSlot;
    preset Label = "Re-sound Alarms";
    preset Appearance = App::NormalPushButton;
  }

  $rect <800,120,940,160>
  slot ResoundSlot
  {
                                         
    if ( ((App::Application) GetRoot()).LevelAccess.AccessLevel >= 2 )
    {
     var App::Action a = App::Action.Resound;

      native (a)
      {
         event( EVENT_RESOUND_BUTTON );
         Command1( CMD_NETWORK, a );
      }

      signal ListViewer.onRefreshAll;
    }
    else
    {
       ((App::Application) GetRoot()).LowLevel( 2 );
    }
     
  }

  $rect <685,360,885,400>
  method int32 SetListSize()
  {
    /* The template just returns the given argument... */

    var int32 z;
    var int32 p;
    var int32 items = 0;
     

    numZonesInFire = 0;

    for( p = 0; p < 5; p = p + 1 )
    {
        for( z = 1; z <= 96; z = z + 1 )
        {
            var int32 alerts = App::Lib.GetNumAlertsInZone( z, p );

            if ( alerts > 0 ) 
            {
                var App::ZoneFlags zf = App::Lib.GetPanelZoneFlags( z, p );

                numZonesInFire = numZonesInFire + 1;
                items = items + 2;

                if ( zf.contains( App::ZoneFlags[ FireExpanded ] ) )
                {
                    items = items + alerts;
                }
            }
        }
    }

    ListViewer.NoOfItems = items;
     
    var int32 nf = numZonesInFire;

    native( nf )
    {
      Command1( CMD_SET_NUM_FIRES, nf );
    }   

    return numZonesInFire;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ConfirmFireButton
  {
    preset Bounds = <615,0,795,55>;
    preset Enabled = false;
    preset OnRelease = null;
    preset OnActivate = ConfirmSlot;
    preset Label = "Confirm Fire";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton AcknowledgeFireButton
  {
    preset Bounds = <615,65,795,120>;
    preset Enabled = false;
    preset OnRelease = null;
    preset OnActivate = AckSlot;
    preset IconFrame = -1;
    preset Icon = null;
    preset Label = "Acknowledge Fire";
    preset Appearance = App::NormalPushButton;
  }

  $rect <810,0,950,40>
  slot ConfirmSlot
  {
    sender; /* the method is called from the sender object */

    native
    {
      Command1( CMD_NETWORK, ACTION_SHIFT_CONFIRM_FIRE );
      event( EVENT_CONFIRM_FIRE_BUTTON );
    }
  }

  $rect <845,65,975,105>
  slot AckSlot
  {
    sender; /* the method is called from the sender object */

    native
    {
      Command1( CMD_NETWORK, ACTION_SHIFT_ACKNOWLEDGE_FIRE );
      event( EVENT_ACKNOWLEDGE_FIRE_BUTTON );
    }

  }

  $rect <20,20,160,60>
  object Views::Image LogoImage
  {
    preset Bounds = <5,10,540,340>;
    preset AutoSize = true;
    preset Bitmap = App::goodbyeelise;
  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <0,0,615,365>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::FireContainer;
    preset ItemHeight = 25;
    preset NoOfItems = 20;
    preset onRefreshAll = OnRefreshAll;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <440,410,680,450>
  slot OnRefreshAll
  {
     
    var int32       itemNo   = ListViewer.Item;
    var App::FireContainer view = (App::FireContainer) ListViewer.VerticalList.first;

     
    var App::ZoneAlert za = null;

     
    var int32 zonenum = 0;
    var int32 row = 0;


    var App::ZoneFlags zf = App::ZoneFlags[];

    var int32 numzonealerts = numZonesInFire;
    var int32  alertcount = numZonesInFire;
     

    while ( view != null )
    {
       if ( itemNo >= 0 && alertcount > 0 )
       {
           za = App::Lib.GetZoneAlert( zonenum );

           if ( za.zone != 0 )
           {
              zf = App::Lib.GetPanelZoneFlags( za.zone, za.panel);
           }
           else
           {
              zf = App::ZoneFlags[];
           }

           if ( row == itemNo )
           {
               if ( za.zone != 0 )
               {
                  view.Visible = true;
                  view.FireZone.Enabled = true;
                  view.FireZone.Visible = true;
                  view.FireChannel.Enabled = false;
                  view.FireChannel.Visible = false;

                  view.FireZone.Bounds.origin.y = 5;

                  view.FireZone.panel = za.panel;
                  view.FireZone.zone =  za.zone;
            
                  view.FireZone.AttrText.String = "{lay65,105,*}{col}" + App::Lib.Order(zonenum + 1) + "{col}Zone " +
                       string(za.zone)+"{col}" + App::Lib.GetPanelName( za.panel );
          
                  view.FireZone.Silenced.Visible = zf.contains( App::ZoneFlags[ Silenced ] );

                  if ( zf.contains( App::ZoneFlags[ FireExpanded ] ) )
                  {
                      view.FireZone.ExpandImage.Bitmap = App::CollapseBitmap;
                  }
                  else
                  {
                      view.FireZone.ExpandImage.Bitmap = App::ExpandBitmap;  
                  }      
              }
              else
              {
                  view.Visible = false;
              }
              view.FireZone.InvalidateViewState();
              view.InvalidateViewState();         
              
              view = (App::FireContainer) view.next;
              if ( view == null ) return;
          }
          else
          {
              row = row + 1;
          }

          if ( row == itemNo )
          {
              if ( za.zone != 0 )
              {
                  view.Visible = true;
                  view.FireZone.Enabled = true;
                  view.FireZone.Visible = true;
                  view.FireChannel.Enabled = false;
                  view.FireChannel.Visible = false;

                  view.FireZone.panel = za.panel;
                  view.FireZone.zone =  za.zone;

                  view.FireZone.Bounds.origin.y = -20;

                  view.FireZone.AttrText.String = "{lay65,105,*}{col}" + App::Lib.Order(zonenum + 1) + "{col}Zone " +
                      string(za.zone)+"{col}" + App::Lib.GetPanelName( za.panel );
      

                  view.FireZone.Silenced.Visible = zf.contains( App::ZoneFlags[ Silenced ] );

                  if ( zf.contains( App::ZoneFlags[ FireExpanded ] ) )
                  {
                      view.FireZone.ExpandImage.Bitmap = App::CollapseBitmap;
                  }
                  else
                  {
                      view.FireZone.ExpandImage.Bitmap = App::ExpandBitmap;  
                  }          
              }
              else
              {      
                  view.Visible = false;        
              }
              view.FireZone.InvalidateViewState();
              view.InvalidateViewState();
             
              view = (App::FireContainer) view.next;

              if ( view == null ) return;
          } 
          else
          {
              row = row + 1;
          }

          if ( zf.contains( App::ZoneFlags[ FireExpanded ] ) )
          {
              var App::Alert alert = null;
              var int32 n = 0;

              do
              {
                  alert = App::Lib.GetAlertNumInZone( App::ActionBits[ Fire ], n, za.zone, za.panel );   

                  n = n + 1;

                  if ( alert == null )
                  {
                      if ( row == itemNo )
                      { 
                          view.Visible = false;
                          view.InvalidateViewState();
                      }
                      else
                      
                      {
                          row = row + 1;
                      }  
                  }

                  else if ( !alert.flags.isempty ) 
                  {            
                      if ( row == itemNo )
                      {  
                          view.Visible = true;  
                          view.FireZone.Enabled = false;
                          view.FireZone.Visible = false;
                          view.FireChannel.Enabled = true;
                          view.FireChannel.Visible = true;

                          var string s = "{lay70,*,135}{col}";
                  
                          view.FireChannel.TimeText.String = alert.time;
                
                          if ( alert.flags.contains( App::AlertFlags[ CAE ] ) )
                          {
                              view.FireChannel.TypeImage.Bitmap = App::CauseEffect2;
                              view.FireChannel.SmallChannelImage.Bitmap = App::ChannelType.None;
                              s = s + "Rule " + string( alert.unitnum ) + "{col}" + alert.description + "{col}{parr}Cause And Effect";
                          }
                          else if ( alert.flags.contains( App::AlertFlags[ Device ] ) )
                          {
                              view.FireChannel.TypeImage.Bitmap = null;
                              view.FireChannel.SmallChannelImage.Bitmap = alert.chanimg;
                              s = s + App::Lib.Unit( alert.unitnum ) + "{col}" + alert.description + "{col}{parr}" + App::Lib.TypeName( alert.chanimg );   
                          }
                          else if ( alert.flags.contains( App::AlertFlags[ NetDevice ] ) )
                          {
                              view.FireChannel.TypeImage.Bitmap = null;
                              view.FireChannel.SmallChannelImage.Bitmap = alert.chanimg;
                              s = s + App::Lib.Unit( alert.unitnum ) + "{col}" + alert.description + "{col}{parr}" + App::Lib.TypeName( alert.chanimg );   
                          }
                          else if ( alert.flags.contains( App::AlertFlags[ NetCAE ] ) )
                          {
                              view.FireChannel.TypeImage.Bitmap = App::CauseEffect2;
                              view.FireChannel.SmallChannelImage.Bitmap = App::ChannelType.None;
                              s = s + "Rule " + string( alert.unitnum ) + "{col}" + alert.description + "{col}{parr}Cause And Effect";
                          }
                          else
                          {
                               view.FireChannel.Visible = false;
                           }

                          view.FireChannel.AttrText.String = s;

                          view.FireChannel.SilenceImage.Visible = alert.flags.contains( App::AlertFlags[ Silenced ] );

                          view.FireChannel.InvalidateViewState();
                          view.InvalidateViewState();

                          view = (App::FireContainer) view.next;

                          if ( view == null ) return;
                      }
                      else
                      {
                          row = row + 1;
                      }  
                  }   
            
              } while ( !alert.flags.isempty );
          }
          
          if ( zonenum == 0 ) 
          {
              zonenum = numzonealerts - 1;
          }
          else if ( zonenum == numzonealerts - 1 )
          {
              zonenum = 1;
          }
          else 
          {
              zonenum = zonenum + 1; 
          }

          alertcount = alertcount - 1;
      }
      else
      {
          view.Visible = false;

          view.InvalidateViewState();
          view = (App::FireContainer) view.next;
          itemNo = itemNo + 1;
      }  
    }


      /*
    }
          


    var int16 itemNo   = VerticalList.Item;

    var App::AlarmRowItem row = (App::AlarmRowItem)VerticalList.View;

    if ( row != null )
    {
      var App::Alert alert;

      var int32 numAlarms = 0;

      native( numAlarms )
      {
        Command cmd;
        Command0( CMD_GET_NUM_FIRES, &cmd );
        numAlarms = cmd.int0;
      }

      if ( numAlarms == 0 )
      {
         row.Visible = false;
         return;
      }

      if ( itemNo == 0 )
      {
          row.Flashing = true;
          row.OrderPosition = numAlarms;
          alert = App::Lib.GetAlertNum( App::ActionBits[ Fire ], numAlarms - 1 );
      }
      else
      {  
         row.Flashing = false;
         row.OrderPos.Visible = true;
         row.OrderPosition = itemNo;
         alert = App::Lib.GetAlertNum( App::ActionBits[ Fire ], itemNo - 1 ); 
      }


      if ( alert.flags.contains( App::AlertFlags[ Silenced ] ) )
      {
         row.Image1.Visible = true;
      }
      else
      {
         row.Image1.Visible = false;
      }

      if ( alert.flags.contains( App::AlertFlags[ CAE ] ) )
      {
         row.ZoneText.String = "Rule " + string( alert.unitnum ) + "  Zone " + string( alert.zonenum );
      }
      else if ( alert.flags.contains( App::AlertFlags[ Device ] ) )
      {
         row.ZoneText.String = "Zone " + string( alert.zonenum ) + "  Unit " + string( alert.unitnum );
      }
      else if ( alert.flags.contains( App::AlertFlags[ Network ] ) ) 
      {
         row.ZoneText.String =  "Panel " + string( alert.unitnum ) + "  Zone " + string( alert.zonenum );
      }
      else
      {
        row.Visible = false;
        row.Enabled = false;
        return;
      }

     
      if ( alert.chanimg == -2 ) row.Image.Bitmap = App::zone3;
      else if ( alert.chanimg == -1 ) row.Image.Bitmap = App::CauseEffect2;
      else
      {   
        var App::ChannelType itype = (App::ChannelType) alert.chanimg;

        row.Image.Bitmap = App::Lib.TypeBitmap( itype );
      }

      row.Text.String = alert.description;
      row.TimeText.String = alert.time; 
      row.Visible = true;
    }
      

    var int32 n = itemNo % 4;

    switch ( n )
    {
        case 0 :{ view.FireChannel.Visible = false;
                 view.FireChannel.Enabled = false;
                 view.FireZone.Visible = true;
                 view.FireZone.Enabled = true;
                 view.FireZone.Bounds.origin.y = 5;}

        case 1 : {view.FireChannel.Visible = false;
                 view.FireChannel.Enabled = false;
                 view.FireZone.Visible = true;
                 view.FireZone.Enabled = true;
                 view.FireZone.Bounds.origin.y = -20; }
                 
       case 2 :  {view.FireChannel.Visible = true;
                 view.FireChannel.Enabled = true;
                 view.FireZone.Visible = false;
                 view.FireZone.Enabled = false;
                 view.FireChannel.Bounds.origin.y = 0;   }
        case 3 :  {view.FireChannel.Visible = true;
                 view.FireChannel.Enabled = true;
                 view.FireZone.Visible = false;
                 view.FireZone.Enabled = false;
                 view.FireChannel.Bounds.origin.y = 0; }
    }          */

  }

  $rect <20,20,160,60>
  object Views::Image NotOperationalBitmap
  {
    preset Bounds = <152,27,402,247>;
    preset Bitmap = App::hazard;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text NotOperationalText
  {
    preset Bounds = <111,270,450,309>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Not operational - Check Faults";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #000000FF;
    preset Visible = false;
  }

  $rect <850,395,1100,435>
  object Core::SystemEventHandler NewBitmapLogoEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = App::Devices.NewBitmapLogoEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <845,305,1045,345>
  slot onEvent
  {
    var bool found = false;

      // nasty hack

      native( found )
      {
        if ( !strncmp( (char*)0x90D00004, "BMP=", 4 ) )
        {
          found = 1;
        }
      }

      if ( found )
      {
         LogoImage.Bitmap = App::LogoBitmap;
         App::LogoBitmap.Reload();
      }
      else
      {
        LogoImage.Bitmap = App::goodbyeelise;
        App::LogoBitmap.Reload();
      }
     
       



  }

  $rect <840,180,1085,220>
  object Core::SystemEventHandler ResoundStateEventHandler
  {
    preset OnEvent = onResoundStateEvent;
    preset Event = App::Devices.ResoudStateEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <820,150,1025,190>
  slot onResoundStateEvent
  {
    ResoundAlarmsButton.Enabled = ( ResoundStateEventHandler.Context != null );




  }

  $rect <595,485,795,525>
  slot Slot
  {
    sender; /* the method is called from the sender object */
  }

  $rect <810,240,950,280>
  slot ResetFire
  {
    var App::Application ap = (App::Application) GetRoot();

    if ( ap.LevelAccess.AccessLevel >= 2 )
    {
        native
        {
          Command1( CMD_RESET_FIRE_STATE, 1 );
        }
        
    }
    else

    {
      ap.LowLevel(  2);
    }

  }

  $rect <200,485,400,525>
  var int32 numZonesInFire = 0;
}

$rect <160,0,340,40>
$output false
class FireZone : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <15,340,205,380>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 
    super( aState );

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <235,175,960,420>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <4,0,550,45>;
    preset Color = #DBDBDBFF;
  }

  $rect <240,105,440,145>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */

    var App::ZoneFlags zf = App::Lib.GetPanelZoneFlags( zone, panel );

     
    if ( !zf.contains( App::ZoneFlags[ FireExpanded ] ) )
    {                                                      
        zf = zf + App::ZoneFlags[ FireExpanded ];  
    }
    else
    {
        zf = zf - App::ZoneFlags[ FireExpanded ];
    } 

    App::Lib.SetPanelZoneFlags( zone, panel, zf );


    ((App::Fire)Owner.Owner.Owner.Owner).SetListSize();




  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <50,0>;
    preset Point2 = <50,45>;
    preset Point1 = <0,45>;
    preset OnPress = ToggleExpand;
  }

  $rect <20,20,160,60>
  object Views::Image Silenced
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <495,0,550,45>;
    preset Bitmap = App::SilencedBitmap;
  }

  $rect <540,90,740,130>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font1 = OldResources::FontVerdana20;
    preset Font0 = Resources::FontMedium;
    preset Bitmap2 = App::ExpandBitmap;
    preset Bitmap1 = App::CollapseBitmap;
    preset Bitmap0 = App::SilencedBitmap;
  }

  $rect <20,20,160,60>
  object Views::AttrText AttrText
  {
    preset Bounds = <50,0,500,45>;
    preset String = "{lay65,105,*}{col}200th{col}Zone 100{col}Panel 1";
    preset AttrSet = App::AttrSetFireZone;
  }

  $rect <20,20,160,60>
  object Views::Image ExpandImage
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <6,5,46,40>;
    preset Bitmap = App::CollapseBitmap;
  }

  $rect <10,90,210,130>
  property int8 zone = 0;

  $rect <5,135,205,175>
  property int8 panel = 0;
}

$rect <350,0,530,40>
$output false
class FireChannel : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,545,25>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

     
     

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,550,25>;
    preset Color = #DBDBDBFF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <499,0,539,25>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "12:22";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::SmallChannelImage SmallChannelImage
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <445,0,470,24>;
  }

  $rect <20,20,160,60>
  object Views::AttrText AttrText
  {
    preset Bounds = <20,0,442,25>;
    preset String = "{lay75,225,145}{col}Unit 888{col}Lower Kitchen{col}{parr}Routing-Ack Input";
    preset AttrSet = App::AttrSetFireChannel;
  }

  $rect <20,20,160,60>
  object Views::Image SilenceImage
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <472,0,497,25>;
    preset Alignment = Views::ImageAlignment[AlignHorzRight, AlignVertCenter];
    preset Bitmap = App::silenced_small;
  }

  $rect <20,20,160,60>
  object Views::Image TypeImage
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <445,0,470,25>;
    preset Bitmap = Resources::DefaultBitmap;
  }
}

$rect <540,0,720,40>
$output false
class FireContainer : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,25>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object App::FireZone FireZone
  {
    preset Bounds = <0,5,550,50>;
  }

  $rect <20,20,160,60>
  object App::FireChannel FireChannel
  {
    preset Bounds = <0,0,550,25>;
  }
}

$rect <730,0,930,40>
$output false
class ZoneAlert
{
  $rect <0,0,200,40>
  property int32 zone = 0;

  $rect <10,60,210,100>
  property int32 panel = 0;
}

$rect <0,1050,170,1090>
$output false
class ButtonState
{
  $rect <0,0,120,40>
  property bool on = false;
}

$rect <1280,1170,1480,1210>
$output false
resource Resources::Bitmap ConfirmFireBitmapA
{
  attr bitmapfile FileName = .\Images\confirm40d.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1420,1170,1620,1210>
$output false
resource Resources::Bitmap ConfirmFireBitmapB
{
  attr bitmapfile FileName = .\Images\confirm40c.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <0,1690,200,1730>
$output false
autoobject Resources::ExternBitmap LogoBitmap
{
  preset Name = "Logo";
}

$rect <1630,1180,1830,1220>
$output false
resource Resources::Bitmap BlankButton
{
  attr bitmapfile FileName = .\Images\blank40.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1750,1150,1950,1190>
$output false
resource Resources::Bitmap AcknowledgeButton
{
  attr bitmapfile FileName = .\Images\acknowledge40d.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1510,1420,1710,1460>
$output false
resource Resources::Bitmap battery1
{
  attr bitmapfile FileName = .\Images\battery1.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1510,1460,1710,1500>
$output false
resource Resources::Bitmap battery2
{
  attr bitmapfile FileName = .\Images\battery2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1510,1500,1710,1540>
$output false
resource Resources::Bitmap battery3
{
  attr bitmapfile FileName = .\Images\battery3.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1520,1380,1720,1420>
$output false
resource Resources::Bitmap battery0
{
  attr bitmapfile FileName = .\Images\battery0.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <0,1760,200,1800>
$output false
class ChannelImage : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,36,36>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    Image.Bitmap = TypeBitmap( );


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,36,36>;
    preset Bitmap = App::GeneralInputBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <3,10,21,26>;
    preset String = "33";
    preset Font = Resources::FontSmall;
    preset Color = #000000FF;
  }

  $rect <17,55,217,95>
  property App::ChannelType Bitmap = App::ChannelType.Input1;

  $rect <17,95,217,135>
  onset Bitmap
  {
    // The value doesn't change - nothing to do.
    if ( pure Bitmap == value )
      return;

    // Remember the property's new value.
    pure Bitmap = value;


    InvalidateViewState( );

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <36,157,236,197>
  method Resources::Bitmap TypeBitmap()
  {
    /* The template just returns the given argument... */
    Text.String = "";

      
               if ( (int32) Bitmap <=  (int32) App::ChannelType.Input32 &&
                    (int32) Bitmap >=  (int32) App::ChannelType.Input1)
               {
                   Text.String = string( (int32) Bitmap - (int32) App::ChannelType.Input1 + 1 );
                  
               }
               if ( (int32) Bitmap <=  (int32) App::ChannelType.Output16 &&
                    (int32) Bitmap >=  (int32) App::ChannelType.Output1 )
               {
                   Text.String = string( (int32) Bitmap - (int32) App::ChannelType.Output1 + 1 );
                  
               }
       
    return App::Lib.TypeBitmap( Bitmap );


  }
}

$rect <210,1760,410,1800>
$output false
class SmallChannelImage : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,25,24>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    Image.Bitmap = TypeBitmap( );


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <17,55,217,95>
  property App::ChannelType Bitmap = App::ChannelType.Input32;

  $rect <17,95,217,135>
  onset Bitmap
  {
    // The value doesn't change - nothing to do.
    if ( pure Bitmap == value )
      return;

    // Remember the property's new value.
    pure Bitmap = value;


    InvalidateViewState( );

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <36,157,236,197>
  method Resources::Bitmap TypeBitmap()
  {
    /* The template just returns the given argument... */
    Text.String = "";

      
               if ( (int32) Bitmap <=  (int32) App::ChannelType.Input32 &&
                    (int32) Bitmap >=  (int32) App::ChannelType.Input1)
               {
                   Text.String = string( (int32) Bitmap - (int32) App::ChannelType.Input1 + 1 );
                    

               }
               if ( (int32) Bitmap <=  (int32) App::ChannelType.Output16 &&
                    (int32) Bitmap >=  (int32) App::ChannelType.Output1 )
               {
                   Text.String = string( (int32) Bitmap - (int32) App::ChannelType.Output1 + 1 );
                    
               }
        
    return App::Lib.TypeSmallBitmap( Bitmap );


  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <2,6,15,18>;
    preset String = "33";
    preset Font = Resources::DefaultFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,25,25>;
    preset Bitmap = Resources::DefaultBitmap;
  }
}

$rect <1060,380,1210,420>
$output false
class DayTimesPopup : App::Popup
{
  $rect <760,0,900,40>
  inherited property Bounds = <0,0,750,480>;

  $rect <820,380,960,420>
  inherited method Init()
  {
    VerticalList.InvalidateItems( 0, 6 );

    postsignal AccessChange;



  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CECECEFF;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <20,40,710,380>;
    preset Enabled = true;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 50;
    preset NoOfItems = 7;
    preset ItemClass = App::DayTimeRow;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <780,80,980,120>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
     
    var App::DayTimeRow r = (App::DayTimeRow) VerticalList.View; 

    var int32 n = VerticalList.Item;

    if ( r == null )
         return;

    var int32 sh = n;
    var int32 sm = n;
    var int32 eh = n;
    var int32 em = n;

    native( sh, sm, eh, em, n )
    {
        Command cmd;

        cmd.int0 = n;
        Command0( CMD_GET_DAY_TIME, &cmd );
        sh = cmd.int0;
        sm = cmd.int1;
        eh = cmd.int2;
        em = cmd.int3;
    }


    if ( r != null )
    {
      r.Start.Hour = sh;
      r.Start.Minute = sm;
      r.End.Hour = eh;
      r.End.Minute = em;

      var string s;

      switch ( n )
      {
        case 0 : s = Resources::Monday;
        case 1 : s = Resources::Tuesday;
        case 2 : s = Resources::Wednesday;
        case 3 : s = Resources::Thursday;
        case 4 : s = Resources::Friday;
        case 5 : s = Resources::Saturday;
        case 6 : s = Resources::Sunday;
      }
      r.Text.String = s;
    }


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <200,390,350,440>;
    preset OnRelease = null;
    preset OnActivate = OKSlot;
    preset Label = "OK";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <400,390,550,440>;
    preset OnRelease = null;
    preset OnActivate = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <170,500,370,540>
  slot OKSlot
  {
    sender; /* the method is called from the sender object */


    var App::Application app = (App::Application)GetRoot();

    if ( app != null )
    {
      
      if ( app.LevelAccess.AccessLevel >= 3 )
      {

        var App::DayTimeRow r = (App::DayTimeRow) VerticalList.first;
        var int32 i = 0;

        while ( r != null && i < 7 )
        {
          var int32 sh = r.Start.Hour;
          var int32 sm = r.Start.Minute;
          var int32 eh = r.End.Hour;
          var int32 em = r.End.Minute;

          native( sh, sm, eh, em, i )
          {
              Command cmd;

              cmd.int0  = i;
              cmd.short2 = sh;
              cmd.short3 = sm;
              cmd.short4 = eh;
              cmd.short5 = em;

              Command0( CMD_SET_DAY_TIME, &cmd );
          }
          i = i + 1;
          r = (App::DayTimeRow) r.next;
        }
      }
    }
     
    this.Hide();


  }

  $rect <430,500,630,540>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

    this.Hide();

  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <520,10,630,39>;
    preset String = "Daytime End";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <200,10,330,39>;
    preset String = "Daytime Start";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <20,40>;
    preset Point3 = <710,40>;
    preset Point2 = <710,380>;
    preset Point1 = <20,380>;
    preset OnPress = LowLevel;
    preset RetargetDelay = 10000;
    preset MaxStrikeCount = 100;
    preset Enabled = true;
  }

  $rect <790,140,990,180>
  slot LowLevel
  {
    sender; /* the method is called from the sender object */

    var App::Application app = (App::Application) GetRoot();

    if ( app != null )
    {
      if ( app.LevelAccess.AccessLevel < 3 )
      {
        app.LowLevel( 3 );
      }
      else
      {
        SimpleTouchHandler.Enabled = false;
      }
    }


  }

  $rect <770,470,1010,500>
  object Core::SystemEventHandler SiteChangeEventHandler1
  {
    preset OnEvent = CancelSlot;
    preset Event = App::Devices.SiteChangedEvent;
  }

  $rect <780,320,1010,350>
  object Core::SystemEventHandler AccessChangeEventHandler2
  {
    preset OnEvent = AccessChange;
    preset Event = App::Devices.AccessModeChangeEvent;
  }

  $rect <810,280,1010,320>
  slot AccessChange
  {
    sender; /* the method is called from the sender object */


    var App::Application app = (App::Application) GetRoot();

    if ( app != null )
    {
      if ( app.LevelAccess.AccessLevel < 3 )
      {
     
        SimpleTouchHandler.Enabled = true;
      }
      else
      {
         SimpleTouchHandler.Enabled = false;
      }
    }


  }

  $rect <750,200,950,240>
  slot Slot
  {
    sender; /* the method is called from the sender object */


    var App::Application app = (App::Application) GetRoot();

    if ( app != null )
    {
      if ( app.LevelAccess.AccessLevel < 3 )
      {
     
        SimpleTouchHandler.Enabled = true;
      }
    }


  }
}

// This is a GUI component.
$rect <1030,310,1230,350>
$output false
class TimePicker1 : Templates::PickerControl
{
  $rect <250,400,450,440>
  inherited property Bounds = <0,0,270,40>;

  $rect <480,280,680,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the time picker widget.
    //
    // isEnabled  --> the time picker can react to user inputs.
    // isSelected --> the time picker can receive keyboard events.
    // isSliding  --> the user interacts with the time picker.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isSliding  = TouchHandlerHour.Sliding   || 
                          TouchHandlerMinute.Sliding;

    /*

      TO DO:

      Depending on your time picker design, you have surely added some new 
      views  to your time picker. In the below code you should update the
      properties of these views. For example, when your picker has an image
      which you want to show only while the user is changing the time, than
      following can be done:

        theImage.Visible = isSliding;

      Depending on the state of the time picker, you can alternate any property 
      of your views. You can change their visibility, colors, opacity, bitmaps
      shown in image views, fonts used to render text, the position and the
      size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the picker
      (e.g. 'isSliding') with its preceding state (e.g. variable 'sliding').

      Assuming you have already added to your time picker component a new
      effect member, named it 'slidingEffect' and configured it to animate
      e.g. the opacity of an image within the time picker. Then following is
      sufficient to trigger the animation:

        if ( isSliding && !sliding )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isSliding && sliding )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( isSliding )
      BorderCurrent.Color = #C1C1C1FF;

    else
      BorderCurrent.Color = #E1E1E1FF;

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // sliding <<-->> not sliding transition.
    enabled  = isEnabled;
    selected = isSelected;
    sliding  = isSliding;
  }

  // To do:
  // 
  // - Adjust the visible size of your picker (the thick blue border). This will \
  // be the picker's default size.
  // - Remove the 'Background', 'Border', 'BorderCurrent', 'Separator1', 'Separator2', \
  // 'ShineAtTop' and 'ShineAtBottom' members if you want other views to be shown \
  // instead these in your picker.
  // - According to your desired picker design add and configure new views (e.g. \
  // text views as captions for Hour, Minute, etc).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the picker's current state.
  // - You can also add and configure animation effects to your picker. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your picker.
  // - Similarly you can arrange the 3 lists 'ListHour', 'ListMinute' and 'ListSecond' \
  // and the corresponding touch handlers 'TouchHandlerHour', TouchHandlerMinute' \
  // and 'TouchHandlerSecond'. Note, the touch handler should always cover the area \
  // of the corresponding list.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the picker itself is resized.
  // - If you want other fonts, colors, etc. to be displayed in the 3 lists, adapt \
  // the implementation of the corresponding slot methods 'OnLoadHourItem', 'OnLoadMinuteItem' \
  // and 'OnLoadSecondItem'.
  // - If you want the items to be displayed with other height, adapt the property \
  // 'ItemHeight' of the 3 'ListHour', 'ListMinute' and 'ListSecond'. Similarly adapt \
  // the property 'SnapNext' of the corresponding touch handlers 'TouchHandlerHour', \
  // TouchHandlerMinute' and 'TouchHandlerSecond'.
  // - From the Gallery folder 'Chora' add properties to your picker. One property \
  // for every picker specific setting (e.g. 'Caption', 'Icon', 'Color', 'Font', \
  // ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Caption' should update the text view in your picker where \
  // some caption is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note4
  {
    attr Bounds = <10,460,1020,900>;
  }

  // State Management
  note group Note3
  {
    attr Bounds = <470,240,690,450>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <240,240,460,370>;
  }

  // List Management
  note group Note1
  {
    attr Bounds = <10,240,230,410>;
  }

  // This variable stores the current state of the time picker.
  $rect <480,400,680,440>
  var bool sliding;

  // This variable stores the current state of the time picker.
  $rect <480,360,680,400>
  var bool selected;

  // This variable stores the current state of the time picker.
  $rect <480,320,680,360>
  var bool enabled;

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has finished the slide animation. \
  // Thereupon the owner of the time picker is notified, that the time has been changed.
  $rect <250,320,450,360>
  slot onEndSlide
  {
    // The user has finished the interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();

    // Notify the owner of the time picker, that the user has selected another time.
    // Do this however only after the last list has finished the slide animation.
    if ( !TouchHandlerHour.Sliding && !TouchHandlerMinute.Sliding )
      postsignal OnChange;

  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has begun the slide animation.
  $rect <250,280,450,320>
  slot onStartSlide
  {
    // The user has begun an interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();
  }

  // This method is called by 'ListMinute' vertical list every time the list loads \
  // or updates an item.
  $rect <20,320,220,360>
  slot OnLoadMinuteItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListMinute.Item;
    var Views::Text itemView = (Views::Text)ListMinute.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your time picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListMinute.Bounds.w, ListMinute.ItemHeight );
  }

  // This method is called by 'ListHour' vertical list every time the list loads \
  // or updates an item.
  $rect <20,280,220,320>
  slot OnLoadHourItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListHour.Item;
    var Views::Text itemView = (Views::Text)ListHour.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your time picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListHour.Bounds.w, ListHour.ItemHeight );
  }

  $rect <580,85,780,125>
  onget Minute
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListMinute.ScrollOffset / ListMinute.ItemHeight )  ) % 60;
  }

  $rect <580,45,780,85>
  onset Minute
  {
    // Limit the assigned value to the valid range 0 .. 59
    if ( value < 0  ) value = 0;
    if ( value > 59 ) value = 59;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListMinute.ScrollOffset = ( value ) * -ListMinute.ItemHeight;

  }

  $rect <380,85,580,125>
  onget Hour
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListHour.ScrollOffset / ListHour.ItemHeight ) ) % 24;
  }

  $rect <380,45,580,85>
  onset Hour
  {
    // Limit the assigned value to the valid range 0 .. 23
    if ( value < 0  ) value = 0;
    if ( value > 23 ) value = 23;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListHour.ScrollOffset = ( value ) * -ListHour.ItemHeight;

    signal OnChange;

  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <90,5,180,35>;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerMinute
  {
    preset Bounds = <135,5,180,35>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerHour
  {
    preset Bounds = <90,5,135,36>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset SlideHorz = false;
    preset ResetDelay = 100;
    preset Friction = 0.05;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListMinute
  {
    preset Bounds = <141,5,180,36>;
    preset OnLoadItem = OnLoadMinuteItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerMinute;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListHour
  {
    preset Bounds = <92,5,130,36>;
    preset OnLoadItem = OnLoadHourItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerHour;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 24;
  }

  $rect <20,20,160,60>
  object Views::Text Separator1
  {
    preset Bounds = <124,2,147,34>;
    preset String = ":";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #838083FF;
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user select another time. Thereupon the method's logic will be \
  // executed. In the associated slot method you can evaluate the time picker properties \
  // @Hour, @Minute and @Second.
  $rect <380,175,580,215>
  property slot OnChange = null;

  // The property 'Minute' stores the number of minutes after the hour. The value \
  // is valid in range 0 .. 59.
  $rect <580,5,780,45>
  property int32 Minute = 0;

  // The property 'Hour' stores the number of hours since midnight. The value is \
  // valid in range 0 .. 23.
  $rect <380,5,580,45>
  property int32 Hour = 0;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <180,0,225,40>;
    preset OnRelease = ReleaseSlot;
    preset OnPress = PressSlot;
    preset OnActivate = MinuteUp;
    preset IconFrame = 0;
    preset Icon = Resources::NavigationIconsSmall;
    preset Label = "";
    preset Appearance = App::SmallPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <225,0,270,40>;
    preset OnRelease = ReleaseSlot;
    preset OnPress = PressSlot;
    preset OnActivate = MinuteDown;
    preset IconFrame = 1;
    preset Icon = Resources::NavigationIconsSmall;
    preset Label = "";
    preset Appearance = App::SmallPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <0,0,45,40>;
    preset OnRelease = ReleaseSlot;
    preset OnPress = PressSlot;
    preset OnActivate = HourUp;
    preset IconFrame = 0;
    preset Icon = Resources::NavigationIconsSmall;
    preset Label = "";
    preset Appearance = App::SmallPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <45,0,90,40>;
    preset OnRelease = ReleaseSlot;
    preset OnPress = PressSlot;
    preset OnActivate = HourDown;
    preset IconFrame = 1;
    preset Icon = Resources::NavigationIconsSmall;
    preset Label = "";
    preset Appearance = App::SmallPushButton;
  }

  $rect <-2,93,198,133>
  slot HourUp
  {
    sender; /* the method is called from the sender object */

    var int32 h = Hour;

    if ( h == 23 ) Hour = 0; else Hour = h + 1;



  }

  $rect <20,20,160,60>
  object Views::Border BorderCurrent
  {
    preset Bounds = <90,5,180,37>;
    preset Width = 3;
    preset Color = #A3A3A3FF;
    preset Visible = true;
  }

  $rect <-8,138,192,178>
  slot HourDown
  {
    sender; /* the method is called from the sender object */

    var int32 h = Hour;

    if ( h == 0 ) Hour = 23; else Hour = h - 1;


  }

  $rect <190,110,390,150>
  slot MinuteUp
  {
    sender; /* the method is called from the sender object */

    var int32 m = Minute;

    if ( m == 59 ) Minute = 0; else Minute = m + 1;


  }

  $rect <185,155,385,195>
  slot MinuteDown
  {
    sender; /* the method is called from the sender object */

    var int32 m = Minute;

    if ( m == 0 ) Minute = 59; else Minute = m - 1;


  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <92,7,178,13>;
    preset ColorBL = #FFFFFF00;
    preset ColorBR = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <92,27,178,35>;
    preset ColorBL = #A4A4A4FF;
    preset ColorBR = #A4A4A4FF;
    preset ColorTR = #FFFFFF00;
    preset ColorTL = #FFFFFF00;
  }

  $rect <-5,46,120,86>
  slot PressSlot
  {
    sender; /* the method is called from the sender object */

     
    Timer.Enabled = true;

    Pressed = (WidgetSet::PushButton) sender;


  }

  $rect <115,50,246,90>
  slot ReleaseSlot
  {
    sender; /* the method is called from the sender object */

    Timer.Enabled = false;
    Pressed = null;

  }

  $rect <609,136,809,176>
  object Core::Timer Timer
  {
    preset OnTrigger = Tick;
    preset Period = 350;
  }

  $rect <613,182,813,222>
  slot Tick
  {
    sender; /* the method is called from the sender object */


    if ( Pressed == PushButton2 ) signal HourUp;
    if ( Pressed == PushButton3 ) signal HourDown;
    if ( Pressed == PushButton  ) signal MinuteUp;
    if ( Pressed == PushButton1 ) signal MinuteDown;
  }

  $rect <245,59,367,99>
  property WidgetSet::PushButton Pressed = null;

  $rect <1020,260,1220,300>
  method void SetHour( arg int32 hour )
  {
    // Limit the assigned value to the valid range 0 .. 23
    if ( hour < 0  ) hour = 0;
    if ( hour > 23 ) hour = 23;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListHour.ScrollOffset = ( hour ) * -ListHour.ItemHeight;



  }
}

$rect <1060,270,1260,310>
$output false
class DayTimeRow : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,690,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object App::TimePicker1 Start
  {
    preset Bounds = <110,0,380,40>;
    preset OnChange = StartChanged;
  }

  $rect <20,20,160,60>
  object App::TimePicker1 End
  {
    preset Bounds = <420,0,690,40>;
    preset OnChange = EndChanged;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,110,40>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Start";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <350,120,550,160>
  slot StartChanged
  {
    sender; /* the method is called from the sender object */



    if ( Start.Hour >= End.Hour ) Start.SetHour( End.Hour - 1);



  }

  $rect <610,120,810,160>
  slot EndChanged
  {
    sender; /* the method is called from the sender object */


    if ( Start.Hour >= End.Hour ) End.SetHour( Start.Hour + 1);



  }

  $rect <1170,140,1370,180>
  var int32 startHour = 0;

  $rect <1170,190,1370,230>
  var int32 endHour = 0;

  $rect <1190,240,1390,280>
  var int32 startMinute = 0;

  $rect <1190,290,1390,330>
  var int32 endMinute = 0;
}

$rect <860,380,1060,420>
$output false
class ToggleItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,80,30>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <0,0,80,30>;
    preset Label = "";
    preset Appearance = App::SmallCheckBox;
  }
}

$rect <1000,1390,1200,1430>
$output false
set SiteSetting
{
  $rect <20,90,220,130>
  item ResoundNewZone = 1;

  $rect <-10,250,190,290>
  item DisableOutputDelays = 2;

  $rect <360,130,560,170>
  item DisableFireRouting = 4;

  $rect <360,170,560,210>
  item DisableFireAlarms = 8;

  $rect <10,130,210,170>
  item IgnoreSecurityAtNight = 16;

  $rect <0,180,200,220>
  item IgnoreSecurityInDay = 32;

  $rect <0,310,200,350>
  item OverrideOutputDelays = 64;
}

$rect <1000,1520,1200,1560>
$output false
set DeviceConfigFlags
{
  $rect <10,10,210,50>
  item Disabled = 1;
}

$rect <1990,1070,2190,1110>
$output false
resource Resources::Bitmap input_alarm
{
  attr bitmapfile FileName = .\Images\input_alarm.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2190,1070,2390,1110>
$output false
resource Resources::Bitmap input_callpoint
{
  attr bitmapfile FileName = .\Images\input_callpoint.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1990,1110,2190,1150>
$output false
resource Resources::Bitmap input_fault
{
  attr bitmapfile FileName = .\Images\input_fault.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2190,1110,2390,1150>
$output false
resource Resources::Bitmap input_routing_ack
{
  attr bitmapfile FileName = .\Images\input_routing_ack.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1990,1150,2190,1190>
$output false
resource Resources::Bitmap input_silence
{
  attr bitmapfile FileName = .\Images\input_silence.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2190,1150,2390,1190>
$output false
resource Resources::Bitmap output_alarm
{
  attr bitmapfile FileName = .\Images\output_alarm.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1990,1190,2190,1230>
$output false
resource Resources::Bitmap output_fault
{
  attr bitmapfile FileName = .\Images\output_fault.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2190,1190,2390,1230>
$output false
resource Resources::Bitmap output_fire
{
  attr bitmapfile FileName = .\Images\output_fire.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1990,1230,2190,1270>
$output false
resource Resources::Bitmap output_routing
{
  attr bitmapfile FileName = .\Images\output_routing.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2190,1230,2390,1270>
$output false
resource Resources::Bitmap output_sounders
{
  attr bitmapfile FileName = .\Images\output_sounders.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <440,1390,660,1430>
$output false
autoobject WidgetSet::PushButtonConfig FocusedPushButton
{
  preset LabelColorActive = #FFFFFFFF;
  preset LabelColorDisabled = #565656FF;
  preset LabelFont = OldResources::FontVerdana20;
  preset FaceFrameActive = 3;
  preset FaceFrameFocused = 2;
  preset FaceFrameDisabled = 0;
  preset FaceFrameDefault = 2;
  preset FaceActive = WidgetSet::PushButtonMedium;
  preset FaceFocused = WidgetSet::PushButtonMedium;
  preset FaceDisabled = WidgetSet::PushButtonMedium;
  preset FaceDefault = WidgetSet::PushButtonMedium;
}

$rect <520,970,640,1010>
$output false
class Boolean
{
  $rect <50,30,180,70>
  property bool State = false;
}

$rect <1980,710,2180,750>
$output false
class MeshVector : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,330,25>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    //Frame1.Color = colour;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Image Frame1
  {
    preset Bounds = <10,0,330,25>;
    preset Color = #FFFFFFFF;
    preset ScrollOffset = <0,0>;
    preset FrameNumber = 0;
    preset Bitmap = App::meshunit_fill;
  }

  $rect <20,20,160,60>
  object Views::Image Frame
  {
    preset Bounds = <0,0,330,25>;
    preset ScrollOffset = <0,0>;
    preset Bitmap = App::meshunit_outline_thin;
  }
}

$rect <2080,920,2280,960>
$output false
class Mess : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,300,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,260,200>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset NoOfItems = 30;
    preset ItemClass = Views::Rectangle;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <320,60,540,110>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Views::Rectangle itemView = (Views::Rectangle)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    //itemView.String = "Item #" + string( itemNo );
    //itemView.Font   = Resources::FontMedium;
    itemView.Color.blue= itemNo * 20;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.x1 = itemNo * 20;
    itemView.Bounds.x2 = (itemNo * 20 ) + 200;
    itemView.Bounds.h =  VerticalList.ItemHeight;
      


  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Bounds = <260,0,300,200>;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,260,200>;
  }
}

$rect <930,0,1130,40>
autoobject Graphics::AttrSet AttrSetFireZone
{
  preset Font1 = OldResources::FontVerdana20;
  preset Font0 = Resources::FontMedium;
  preset Bitmap2 = App::ExpandBitmap;
  preset Bitmap1 = App::CollapseBitmap;
  preset Bitmap0 = App::SilencedBitmap;
}

$rect <1950,470,2150,510>
$output false
class ListViewer : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,600,350>;

  $rect <10,450,210,490>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    VerticalList.Bounds.x2 = VerticalScrollbar.Bounds.x1;



    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,400,210,440>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    if ( VerticalScrollbar.ContentArea <= VerticalScrollbar.ViewArea )
    {
       VerticalList.ScrollOffset = 0;
       VerticalScrollbar.Position = 0;
        VerticalScrollbar.ContentArea = VerticalScrollbar.ViewArea;
    }

    if ( VerticalList.ScrollOffset >  VerticalScrollbar.ContentArea - VerticalScrollbar.ViewArea )
    {
       VerticalList.ScrollOffset = VerticalScrollbar.ContentArea - VerticalScrollbar.ViewArea ;
    }
     


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <555,0,595,350>;
    preset OnScroll = BarScrollSlot;
    preset Position = 0;
    preset ViewArea = 350;
    preset ContentArea = 350;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <640,140,840,180>
  slot BarScrollSlot
  {
    sender; /* the method is called from the sender object */

        
    VerticalList.ScrollOffset = (-VerticalScrollbar.Position) % VerticalList.ItemHeight;

    SlideTouchHandler.Offset.y = - VerticalScrollbar.Position; 

    Item = -SlideTouchHandler.Offset.y / VerticalList.ItemHeight;

    if ( Item != StartRow )
    {
       if ( onScrollRefresh == null )
       {
         signal onRefreshAll;
       }
       else
       {
         signal onScrollRefresh;
       }
    }
     
    postsignal onScroll;

    StartRow = Item;


  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,350>;
    preset MaxOffset = <0,0>;
    preset MinOffset = <0,-1000>;
    preset OnSlide = SlideScrollSlot;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,350>;
    preset OnLoadItem = LoadItem;
    preset SlideHandler = null;
    preset ItemHeight = 30;
    preset NoOfItems = 0;
    preset ItemClass = null;
  }

  $rect <630,90,830,130>
  slot SlideScrollSlot
  {
    sender; /* the method is called from the sender object */


    VerticalScrollbar.Position = -SlideTouchHandler.Offset.y;

    Item = -SlideTouchHandler.Offset.y / VerticalList.ItemHeight; 

    VerticalList.ScrollOffset =  -(-SlideTouchHandler.Offset.y % VerticalList.ItemHeight);


    if ( Item != StartRow ) 
    {
       Item = (-SlideTouchHandler.Offset.y / VerticalList.ItemHeight);

       if ( onScrollRefresh == null )
       {
         signal onRefreshAll;
       }
       else
       {
         signal onScrollRefresh;
       }
    }
     
    postsignal onScroll;

    StartRow = Item;
                                              



  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <650,290,810,330>
  slot LoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    Item = VerticalList.Item + (-SlideTouchHandler.Offset.y / VerticalList.ItemHeight);

    signal OnLoadItem;


     

  }

  $rect <620,220,820,260>
  property int32 StartRow = 0;

  $rect <270,270,420,310>
  property slot OnLoadItem = null;

  $rect <350,365,550,405>
  property int32 Item = 0;

  $rect <600,350,800,390>
  property class ItemClass = null;

  $rect <600,390,800,430>
  onset ItemClass
  {
    // The value doesn't change - nothing to do.
    if ( pure ItemClass == value )
      return;

    // Remember the property's new value.
    pure ItemClass = value;

    VerticalList.ItemClass = pure ItemClass;


    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <280,420,480,460>
  property int32 ItemHeight = 0;

  $rect <270,465,470,505>
  onset ItemHeight
  {
    // The value doesn't change - nothing to do.
    if ( pure ItemHeight == value )
      return;

    // Remember the property's new value.
    pure ItemHeight = value;

    VerticalList.ItemHeight = pure ItemHeight;
    VerticalList.Bounds.h = Bounds.h;

    VerticalList.NoOfItems = ( VerticalList.Bounds.h + (VerticalList.ItemHeight - 1 ) ) / VerticalList.ItemHeight + 1;

    VerticalScrollbar.ContentArea =  pure NoOfItems * pure ItemHeight;
    SlideTouchHandler.MinOffset.y = -VerticalScrollbar.ContentArea;


    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <755,430,955,470>
  property int32 NoOfItems = 0;

  $rect <755,470,955,510>
  onset NoOfItems
  {
     

    // Remember the property's new value.
    pure NoOfItems = value;
    var int32 n = value;

    //   ///////VerticalList.NoOfItems = this.Bounds.h /  ItemHeight;
                           
    if ( n < VerticalList.NoOfItems - 1 )
    {
      n = VerticalList.NoOfItems - 1;    
    }
                       
    VerticalScrollbar.ViewArea = this.Bounds.h;
                                                                       
    VerticalScrollbar.ContentArea =  n * pure ItemHeight;


    SlideTouchHandler.MinOffset.y = - ( VerticalScrollbar.ContentArea - VerticalScrollbar.ViewArea );

    if ( SlideTouchHandler.Offset.y < SlideTouchHandler.MinOffset.y )
    {
        SlideTouchHandler.Offset.y = SlideTouchHandler.MinOffset.y;
        signal SlideScrollSlot;
    }

    if ( VerticalScrollbar.Position >  VerticalScrollbar.ContentArea - VerticalScrollbar.ViewArea )
    {
        VerticalScrollbar.Position = VerticalScrollbar.ContentArea - VerticalScrollbar.ViewArea;
        signal BarScrollSlot;
    }

     
    Item = (VerticalScrollbar.Position / VerticalList.ItemHeight);

    signal onRefreshAll;



    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <620,0,820,40>
  property int32 ScrollOffset = 0;

  $rect <620,40,820,80>
  onset ScrollOffset
  {
     

    // Remember the property's new value.
    pure ScrollOffset = value;

    VerticalScrollbar.Position = value;
    SlideTouchHandler.Offset.y = - value;

    Item = -SlideTouchHandler.Offset.y / VerticalList.ItemHeight; 

    VerticalList.ScrollOffset = -(value % VerticalList.ItemHeight);



    if ( Item != StartRow ) 
    {
       signal onRefreshAll;
       StartRow = Item;
    }
     


                     
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <890,0,1010,40>
  property slot onScroll = null;

  $rect <890,40,1030,80>
  property slot onRefreshAll = null;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <550,0>;
    preset Point3 = <600,0>;
    preset Point2 = <600,350>;
    preset Point1 = <550,350>;
    preset OnPress = PageScroll;
    preset RetargetOffset = 3;
    preset RetargetCondition = Core::RetargetReason[LongPress, WipeDown, WipeLeft, WipeRight, WipeUp];
  }

  $rect <900,140,1030,180>
  slot PageScroll
  {
    sender; /* the method is called from the sender object */

    if ( VerticalScrollbar.ContentArea != 0 )
    {
      var int32 handleheight = VerticalScrollbar.ViewArea * VerticalScrollbar.ViewArea / VerticalScrollbar.ContentArea;
      var int32 handlepos = VerticalScrollbar.Position * VerticalScrollbar.ViewArea / VerticalScrollbar.ContentArea;

      if ( SimpleTouchHandler.HittingPos.y < handlepos )
      {
           VerticalScrollbar.Position = VerticalScrollbar.Position - VerticalScrollbar.ViewArea;
           signal BarScrollSlot;
      }

      else if ( SimpleTouchHandler.HittingPos.y > handlepos + handleheight )
      {
           VerticalScrollbar.Position = VerticalScrollbar.Position + VerticalScrollbar.ViewArea;
           signal BarScrollSlot;
      }
    }     

     
  }

  $rect <940,260,1130,300>
  property slot onScrollRefresh = null;
}

$rect <1060,0,1260,40>
autoobject Graphics::AttrSet AttrSetFireChannel
{
  preset Font0 = App::FontVerdanaProCondSemiBold18;
  preset Bitmap0 = null;
}

$rect <290,40,420,80>
$output false
class DisablementsTabButton : App::TabButton
{
  $rect <20,70,160,110>
  inherited property Bounds = <0,0,130,45>;

  $rect <20,20,160,60>
  inherited object Image
  {
    preset Bounds = <0,0,35,45>;
  }

  $rect <20,20,160,60>
  inherited object Text2
  {
    preset Bounds = <38,20,78,45>;
  }

  $rect <20,20,160,60>
  inherited object Text1
  {
    preset Bounds = <33,3,128,23>;
    preset String = "Disablments";
  }

  $rect <20,20,160,60>
  object Views::Image routing
  {
    preset Bounds = <75,22,104,41>;
    preset Bitmap = App::lorry;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image fire
  {
    preset Bounds = <106,21,127,43>;
    preset Bitmap = App::outputs_off;
    preset Visible = false;
  }
}

$rect <1880,320,2080,360>
$output false
resource Resources::Bitmap littlefire
{
  attr bitmapfile FileName = .\Images\littlefire.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1880,280,2080,320>
$output false
resource Resources::Bitmap lorry
{
  attr bitmapfile FileName = .\Images\lorry.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1560,790,1680,830>
$output false
resource Resources::Bitmap hook
{
  attr bitmapfile FileName = .\Images\hook.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <540,440,720,480>
$output false
class GSMPopup : App::Popup
{
  $rect <20,405,160,445>
  inherited property Bounds = <0,0,480,345>;

  $rect <460,0,600,40>
  inherited property Focus = Writable;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #B1B1B1FF;
  }

  $rect <520,390,660,430>
  inherited method Show()
  {
    super( rootObject);


    var int32 mcc = 240;
    var int32 mnc = 345;
    var int32 pin = 1234;


    native( mcc, mnc, pin )
    {
      Command cmd;
      Command0( CMD_GET_GSM_SETTINGS, &cmd );

      mcc = cmd.int0;
      mnc = cmd.int1;
      pin = cmd.int2;
    }

    Writable.TextEditor.String = string( mcc );
    Writable1.TextEditor.String = string( mnc );
    Writable2.TextEditor.String = string( pin );

    Writable.ObtainFocus();


    // TO DO: Write your code here ... 
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <38,39,90,63>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "MCC";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <298,250,418,300>;
    preset OnRelease = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <295,355,435,395>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

    this.Hide();


  }

  $rect <20,20,160,60>
  object App::Writable Writable
  {
    preset Bounds = <100,30,200,70>;
    preset Property = null;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <39,106,92,135>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "MNC";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::Writable Writable1
  {
    preset Bounds = <100,100,200,140>;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <40,176,93,205>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "PIN";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::Writable Writable2
  {
    preset Bounds = <101,173,201,213>;
  }

  $rect <480,310,720,350>
  object WidgetSet::PushButtonConfig IconButton
  {
    preset IconTintActive = #92BFFFFF;
    preset FaceTintActive = #93C5FFFF;
    preset FaceFrameActive = 1;
    preset FaceFrameFocused = 0;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 2;
    preset FaceActive = OldResources::ButtonDarkGray;
    preset FaceDefault = OldResources::ButtonDarkGray;
  }

  $rect <20,20,160,60>
  object App::MattsNumKeyboard MattsNumKeyboard
  {
    preset Bounds = <243,28,425,220>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <48,250,168,300>;
    preset OnRelease = OKSlot;
    preset Label = "OK";
    preset Appearance = App::NormalPushButton;
  }

  $rect <15,350,155,390>
  slot OKSlot
  {
    sender; /* the method is called from the sender object */


    var int32 mcc =  Writable.TextEditor.Text.String.parse_int32( -1 );
    var int32 mnc =  Writable1.TextEditor.Text.String.parse_int32( -1 );
    var int32 pin =  Writable2.TextEditor.Text.String.parse_int32( -1 );


    native( mcc, mnc, pin )
    {
      Command3( CMD_SET_GSM_SETTINGS, mcc, mnc, pin );
    }


    this.Hide();


  }
}

$rect <660,450,860,490>
$output false
class Component : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,300,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }
}

$rect <1000,170,1200,210>
$output false
class MattsNumKeyboard : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,125,167>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <300,50,500,90>
  slot PressSlot
  {
    sender; /* the method is called from the sender object */


    var App::KeyLetter k = (App::KeyLetter) this.first;

    while ( k != null )
    {
        if ( k.Bounds == Touch.HittingPos )
        {
            k.Pressed = true;
            k.InvalidateViewState();
        }
        k = (App::KeyLetter) k.next;
    }

    var App::DelKey dk = (App::DelKey) this.last;

    if ( dk.Bounds == Touch.HittingPos )
    {
       dk.Pressed = true;
    }

            



  }

  $rect <305,130,505,170>
  slot ReleaseSlot
  {
    sender; /* the method is called from the sender object */


    var App::KeyLetter k = (App::KeyLetter) this.first;

    while ( k != null )
    {
        if ( k.Bounds == Touch.HittingPos )
        {
            k.Pressed = false;
            k.InvalidateViewState();
        }
        k = (App::KeyLetter) k.next;
    }

    var App::DelKey dk = (App::DelKey) this.last;

    if ( dk.Bounds == Touch.HittingPos )
    {
       dk.Pressed = false;
    }

            



  }

  $rect <20,20,160,60>
  object App::KeyLetter Key
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,40,40>;
    preset KeyChar = '7';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <42,0,82,40>;
    preset KeyChar = '8';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <84,0,124,40>;
    preset KeyChar = '9';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key10
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,42,40,82>;
    preset KeyChar = '4';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key11
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <42,42,82,82>;
    preset KeyChar = '5';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key12
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <84,42,124,82>;
    preset KeyChar = '6';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key14
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,126,60,166>;
    preset KeyChar = '0';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key20
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,84,40,124>;
    preset KeyChar = '1';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key21
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <42,84,82,124>;
    preset KeyChar = '2';
  }

  $rect <20,20,160,60>
  object App::KeyLetter Key22
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <84,84,124,124>;
    preset KeyChar = '3';
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Touch
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <125,0>;
    preset Point2 = <125,165>;
    preset Point1 = <0,165>;
    preset OnRelease = ReleaseSlot;
    preset OnPress = PressSlot;
  }

  $rect <20,20,160,60>
  object App::DelKey DelKey
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <63,126,123,166>;
    preset Word = "Del";
  }
}

$rect <810,230,950,270>
$output false
class DelKey : App::Key
{
  $rect <20,250,160,290>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ...

    super( aState);
     


    Text.String = Word;
  }

  $rect <250,290,390,330>
  inherited onset Pressed
  {
    // TO DO: Write your code here ... 

    if ( value == true )
    {
        GetRoot().DriveKeyboardHitting( Core::KeyCode.Backspace, '\0', true );
        GetRoot().DriveKeyboardHitting( Core::KeyCode.Backspace, '\0', false );   
    }





    pure Pressed = value;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,300,200>;
    preset String = "Del";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <340,30,540,70>
  property string Word = "?";
}

$rect <1250,1380,1490,1420>
$output false
resource Resources::Font FontMediumBold
{
  attr fontname FontName = Roboto Medium;
  attr fontheight Height = 24;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xBB,0x4A9,2264,2265,2126,0x3A9;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
}

$rect <1270,190,1440,230>
$output false
resource Resources::Bitmap hazard
{
  attr bitmapfile FileName = .\Images\hazard.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1280,150,1480,190>
$output false
resource Resources::Bitmap hazardstripe
{
  attr bitmapfile FileName = .\Images\hazardstripe.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <400,140,570,180>
$output false
class ConfirmTimerPopup : App::Popup
{
  $rect <660,40,800,80>
  inherited property Bounds = <0,0,630,340>;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #3755AFFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <30,60,580,140>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
  }

  $rect <0,360,200,400>
  slot Proceed
  {
    sender; /* the method is called from the sender object */

    signal meth;

    Timer.Enabled = true;

    Hide();


  }

  $rect <400,370,600,410>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <0,410,200,450>
  method void ShowThen( arg Core::Root rootObject, arg slot method )
  {
    // Create a new instance of some alert panel component.
    mask = new Views::Rectangle;
    touch = new Core::SimpleTouchHandler;
    root = rootObject;

    meth = method;

    HorizontalValueBar.CurrentValue = 0;
    Timer.Enabled = false;

    touch.Point1 = <0,0>;
    touch.Point2 = <0,480>;
    touch.Point3 = <800,480>;
    touch.Point4 = <800,0>;

    rootObject.Add( touch, 0 );


    mask.Color = #00000030;
    mask.Bounds = <0,0,800,480>;

    rootObject.Add( mask, 0 );

    var point m = point( (800 - this.Bounds.size.x) / 2, (480 - this.Bounds.size.y) / 2);

        
    this.Bounds.point1 = m;
    this.Bounds.point2 = <800,480> - m;


    rootObject.Add( this, 0 );

    return;

  }

  $rect <270,420,470,460>
  var slot meth = null;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <30,190,180,240>;
    preset OnRelease = Proceed;
    preset Label = "OK";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <425,190,575,240>;
    preset OnRelease = Cancel;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <30,260,570,300>;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <510,510,710,550>
  object Core::Timer Timer
  {
    preset OnTrigger = Tick;
    preset Period = 300;
  }

  $rect <680,450,880,490>
  slot Tick
  {
    sender; /* the method is called from the sender object */

     HorizontalValueBar.CurrentValue = 100 - ((100 - HorizontalValueBar.CurrentValue)  * 19 / 20);

  }
}

$rect <100,140,250,180>
$output false
class OnTestWarning : Core::Group
{
  $rect <225,480,425,520>
  inherited property Bounds = <0,0,520,190>;

  $rect <0,460,200,500>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <380,290,580,330>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <60,190,210,230>
  inherited method Init()
  {
    // TO DO: Write your code here ... 


  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <490,10,520,160>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight];
    preset Bounds = <490,160,520,190>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, ResizeHorz];
    preset Bounds = <10,160,490,190>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,10,490,160>;
    preset Color = #7F3731FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <490,0,520,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle5
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <0,160,10,190>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle6
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <10,0,490,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle7
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,0,10,10>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle8
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <0,10,10,160>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <5,410,205,450>
  method void Show( arg Core::Root rootObject )
  {
    /* The template just returns the given argument... */

    // Obtain access to the root object.
    //var Core::Root rootObject = GetRoot();

    // Create a new instance of some alert panel component.
    mask = new Views::Rectangle;
    touch = new Core::SimpleTouchHandler;
    root = rootObject;

    touch.Point1 = <0,0>;
    touch.Point2 = <0,480>;
    touch.Point3 = <800,480>;
    touch.Point4 = <800,0>;

    rootObject.Add( touch, 0 );


    mask.Color = #00000020;
    mask.Bounds = <0,0,800,480>;

    rootObject.Add( mask, 0 );

    var point m = point( (800 - this.Bounds.size.x) / 2, (480 - this.Bounds.size.y) / 2);

        
    this.Bounds.point1 = m;
    this.Bounds.point2 = <800,480> - m;


    rootObject.Add( this, 0 );


    return;
  }

  $rect <30,270,230,310>
  var Views::Rectangle mask = null;

  $rect <30,230,230,270>
  var Core::SimpleTouchHandler touch = null;

  $rect <30,310,230,350>
  var Core::Root root = null;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,40,470,130>;
    preset WrapText = true;
    preset String = "";
    preset Font = Resources::FontMedium;
  }

  $rect <310,220,510,260>
  object Core::Timer Timer
  {
    preset OnTrigger = Hide;
    preset Period = 1200;
  }

  $rect <340,340,540,380>
  slot Hide
  {
    /* The template just returns the given argument... */

    // Obtain access to the root object.
    //var Core::Root rootObject = GetRoot();

    // Create a new instance of some alert panel component.
    root.Remove( mask );
    root.Remove( touch );
    root.Remove( this );
    Timer.Enabled = false;

    return;

  }
}

$rect <1940,380,2140,420>
$output false
resource Resources::Bitmap outline3
{
  attr bitmapfile FileName = .\Images\outline3.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <200,430,380,470>
$output false
class NewNumberPopup : App::Popup
{
  $rect <680,20,820,60>
  inherited property Bounds = <0,0,720,420>;

  $rect <700,80,840,120>
  inherited property Focus = Writable;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CDCDCDFF;
  }

  $rect <20,20,160,60>
  object App::MattsKeyboard MattsKeyboard
  {
    preset Bounds = <20,170,600,370>;
  }

  $rect <20,20,160,60>
  object App::Writable Writable
  {
    preset Bounds = <120,30,610,80>;
  }

  $rect <20,20,160,60>
  object App::Writable Writable1
  {
    preset Bounds = <120,100,610,150>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,110,130,140>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Number";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <30,40,130,70>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Name";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <535,257,675,307>;
    preset OnActivate = OK;
    preset Label = "OK";
    preset Appearance = App::NormalPushButton;
  }

  $rect <410,450,610,490>
  slot OK
  {
    sender; /* the method is called from the sender object */


    var string name =  Writable.TextEditor.String;
    var string num  = Writable1.TextEditor.String;



    native( name, num )
    {
       char _name[ 40];
       char _num[ 16];

       EwStringToAnsi( name, _name, 40, '-' );
       EwStringToAnsi( num, _num, 16, '-' );

       Command2( CMD_NEW_SMS_NUMBER, (int)_name, (int)_num );
    }


    var App::TextPopup p = (App::TextPopup) Parent;

    if ( p != null )
    {
      postsignal p.Refresh;
    }

    Hide();


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <534,330,674,380>;
    preset OnActivate = Cancel;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <660,450,810,490>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    Hide();


  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <120,100>;
    preset Point3 = <610,100>;
    preset Point2 = <610,150>;
    preset Point1 = <120,150>;
    preset OnPress = NumberSlot;
  }

  $rect <770,180,970,220>
  slot NumberSlot
  {
    sender; /* the method is called from the sender object */


    var App::MattsKeyboard kbd = MattsKeyboard;
        
    kbd.Keyboard.Visible = false;
    kbd.Numboard.Visible = true;
    kbd.Keyboard.Enabled = false;
    kbd.Numboard.Enabled = true;


    Writable1.ObtainFocus();

  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler1
  {
    preset Point4 = <120,30>;
    preset Point3 = <610,30>;
    preset Point2 = <610,80>;
    preset Point1 = <120,80>;
    preset OnPress = NameSlot;
  }

  $rect <780,130,980,170>
  slot NameSlot
  {
    sender; /* the method is called from the sender object */


    var App::MattsKeyboard kbd = MattsKeyboard;
        
    kbd.Keyboard.Visible = true;
    kbd.Numboard.Visible = false;
    kbd.Keyboard.Enabled = true;
    kbd.Numboard.Enabled = false;


    Writable.ObtainFocus();

  }
}

$rect <560,580,710,620>
$output false
class AddDevicePopup : App::Popup
{
  $rect <750,140,890,180>
  inherited property Bounds = <0,0,729,480>;

  $rect <755,325,895,365>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    SetupMenus();

     this.onHide = CancelRBUComs;


  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #D9D9D9FF;
  }

  $rect <1195,160,1395,200>
  slot GetMenuItem
  {
    var App::DropDownMenu menu = (App::DropDownMenu) sender;

    var int32 i; 

    var int32 n = 0;

    for( i = 1; i < 256; i = i + 1 )
    {
        if ( i < 64 || i > 67 )
        {
          var string name = App::Lib.GetCombiName( i );

          if ( name != "" )
          {
              if ( n == menu.itemIndex )
              {
                 menu.itemName = string(i)+ "-" + name;
                 menu.itemValue = i;
                 return;
              }
              else                                                        
              {
                n = n + 1;
              }
          }
        }
    }

     
     
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <488,142,592,242>;
    preset ScrollOffset = <0,-5>;
    preset Bitmap = App::usbsmall;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <233,166,438,260>;
    preset RowDistance = 30;
    preset WrapText = true;
    preset String = "Connect device to the panels USB host port";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <83,142,195,228>;
    preset Bitmap = App::jackplugsm;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <74,229,184,289>;
    preset WrapText = true;
    preset String = "To Device";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <480,232,590,292>;
    preset WrapText = true;
    preset String = "To Panel";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <769,240,969,280>
  method void SetupMenus()
  {
     

      DropDownMenu.VerticalList.SelectedItem = 0;

      DropDownMenu.MenuSelectionText.String = "<Choose type";

      DropDownMenu1.VerticalList.SelectedItem = 0;

      DropDownMenu1.MenuSelectionText.String = "<Zone>";

      DropDownMenu1.numItems = App::Lib.NumZones();

    // count types

    var int32 i;
    var int32 n = 0;

    for( i = 1; i < 64; i = i + 1 )
    {
        var string name = App::Lib.GetCombiName( i );

        if ( name != "" )
        {
           n = n + 1;
        }
    }
    for( i = 68; i < 256; i = i + 1 )
    {
        var string name = App::Lib.GetCombiName( i );

        if ( name != "" )
        {
           n = n + 1;
        }
    }

    DropDownMenu.numItems = n;

  }

  $rect <740,80,910,120>
  slot FillMenu
  {
    var App::DropDownMenu menu = (App::DropDownMenu) sender; /* the method is called from the sender object */

     
      menu.itemName = "Zone " + string( menu.itemIndex + 1 );
     


  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <51,324,640,365>;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <508,383,658,433>;
    preset OnActivate = Cancel;
    preset Label = "Close";
    preset Appearance = App::NormalPushButton;
  }

  $rect <0,515,150,555>
  slot Setup
  {
    sender; /* the method is called from the sender object */


     
    {
        var App::ModifyPopup p = new App::ModifyPopup;
     
        p.WriteButton.Label = "OK";

        var Core::Root r = GetRoot();

        p.device = App::Lib.GetConfig( NewUnitNum );
         
        if ( p.device != null )
        {
          postsignal p.SetFocus;

          p.Show( r );  
        }
    }

  }

  $rect <420,525,620,565>
  slot Cancel
  {
    sender; /* the method is called from the sender object */


    Hide();



  }

  $rect <769,400,969,440>
  object Core::SystemEventHandler SystemEventHandler10
  {
    preset OnEvent = onEvent;
    preset Event = App::Devices.RBUDetectedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler1' \
  // receives an event.
  $rect <969,400,1169,440>
  slot onEvent
  {
    var App::PtrClass p = (App::PtrClass) SystemEventHandler10.Context;

    if ( p.ptr == -1 )
    {
       Unit.String = "No space";
    }
    else
    {
       Unit.String = App::Lib.Unit( p.ptr );
       
      DropDownMenu.Enabled = true;
      DropDownMenu1.Enabled = true;
       PushButton3.Enabled = true;
    }



    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler1.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <680,515,880,555>
  object Core::SystemEventHandler SystemEventHandler3
  {
    preset OnEvent = onEvent1;
    preset Event = App::Devices.RBUProgressEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler3' \
  // receives an event.
  $rect <880,515,1080,555>
  slot onEvent1
  {
    var App::RBUProgress p = (App::RBUProgress)  SystemEventHandler3.Context;


    if ( p.progress > 0 )
    {
        HorizontalValueBar.CurrentValue = p.progress;
        if ( p.progress == 100 )
        {
            Text5.Color = #000000FF;
            Text5.String = p.errmsg;
            PushButton1.Label = "OK";
        } 
    }
    else
    {
        Text5.Color = #EE0000FF;
        Text5.String = p.errmsg;
    }

  }

  $rect <20,20,160,60>
  object Views::Text Text5
  {
    preset Bounds = <22,91,648,122>;
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #FF0000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <227,382,467,432>;
    preset Enabled = false;
    preset OnActivate = Program;
    preset Label = "Write settings to Device";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <40,382,190,432>;
    preset Enabled = false;
    preset OnActivate = Setup;
    preset Label = "Modify";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <62,286,622,326>;
    preset RowDistance = 30;
    preset WrapText = true;
    preset String = "NOTE: Site should be backed up following any modification.";
    preset Font = Resources::FontMedium;
    preset Color = #F10300FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <499,144>;
    preset Point1 = <189,144>;
    preset Width = 7;
    preset Color = #2B2B2BFF;
  }

  $rect <20,20,160,60>
  object App::DropDownMenu DropDownMenu1
  {
    preset Bounds = <251,25,407,480>;
    preset Enabled = false;
    preset Visible = true;
    preset onSelection = null;
    preset GetItemCallback = FillMenu;
  }

  $rect <20,20,160,60>
  object App::DropDownMenu DropDownMenu
  {
    preset Bounds = <20,26,230,80>;
    preset Enabled = false;
    preset onSelection = SelectSlot;
    preset itemName = "ng";
    preset GetItemCallback = GetMenuItem;
    preset itemIndex = 1;
    preset numItems = 42;
  }

  $rect <925,190,1125,230>
  slot SelectSlot
  {
    sender; /* the method is called from the sender object */

     

    var int32 i; 

      var int32 n = 0;

      for( i = 1; i < 256; i = i + 1 )
      {
          if ( i < 64 || i > 67 )
          {
            var string name = App::Lib.GetCombiName( i );

            if ( name != "" )
            {
                if ( n == DropDownMenu.VerticalList.SelectedItem )
                {
                   typeCode = i;
                   return;
                }
                else                                                        
                {
                  n = n + 1;
                }
            }
          }
      }
  }

  $rect <990,40,1190,80>
  property int32 NewUnitNum = 0;

  $rect <195,510,395,550>
  slot Program
  {
    sender; /* the method is called from the sender object */

    native
    {
      Command1( CMD_PROGRAM_RBU, 0 );
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <540,26,684,76>;
    preset Enabled = false;
    preset OnActivate = CreateSlot;
    preset Label = "Create";
    preset Appearance = App::NormalPushButton;
  }

  $rect <740,10,870,50>
  slot CreateSlot
  {
    sender; /* the method is called from the sender object */


     
     
    Text5.String = "";


                        
    var int32 type = typeCode;
    var int32 zone = DropDownMenu1.VerticalList.SelectedItem + 1;

    var int32 result = 1;

    var int32 unit_num;
    var int32 err = -1;


    native( type, zone, result, unit_num, err )
    {
      Command cmd;

      cmd.int0 = zone;
      cmd.int1 = type;

      result = Command0( CMD_SETUP_RBU, &cmd );

      if ( result == CMD_ERR_WRITE_FAIL )
      {
        err = 1;
      }
      else if ( result == CMD_ERR_ALREADY_EXISTS )
      {
        err = 2;
      }
      else if ( result == CMD_ERR_DEVICE_BUSY )
      {
        err = 3;
      }
      else if ( result == CMD_OK )
      {
        err = 0;
      }
      else 
      {
        err = -1;
      }

      unit_num = cmd.int3;
    }


    if ( err == 2 )
    {
        Text5.Color = #0000EEFF;
         Text5.String = "Unit already exists";

        PushButton4.Enabled = false;
        PushButton2.Enabled = false;  
    }

    else if ( err != 0 )
    {
         Text5.Color = #EE0000FF;
         Text5.String = "Unable to write new device.";

        PushButton4.Enabled = false;
        PushButton2.Enabled = false;  
    }
    else
    {
       Text.String = "Device Unit " + string(unit_num) + " Added";

       NewUnitNum = unit_num;
              
       PushButton2.Enabled = true;
       PushButton4.Enabled = true; 
       PushButton3.Enabled = false;     
    }
     
  }

  $rect <980,270,1180,310>
  object Core::SystemEventHandler SystemEventHandler4
  {
    preset OnEvent = onEvent2;
    preset Event = App::Devices.NewZoneAndCombi;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler4' \
  // receives an event.
  $rect <1020,310,1220,350>
  slot onEvent2
  {
     
       var App::ZoneAndCombi context = (App::ZoneAndCombi) SystemEventHandler4.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
          Text.String = "- Connected -";

          if ( context.Zone > 0 )
          {
             DropDownMenu1.SetIndex( context.Zone - 1 );
          }

          if ( context.Combination != 0 )
          {

            var string devname = App::Lib.GetCombiName( context.Combination );

            if ( devname == "" )
            {
                Text5.String = "No instance of this type. Plesase use Cygnus Config";
                PushButton3.Enabled = false;
                return;
            }
     
            var int32 i; 

            var int32 n = 0;

            for( i = 1; i < 256; i = i + 1 )
            {
                if ( i < 64 || i > 67 )
                {
                  var string name = App::Lib.GetCombiName( i );

                  if ( name != "" )
                  {
                      if ( i == context.Combination )
                      {
                         DropDownMenu.SetIndex( n);
                         return;
                      }
                      else                                                        
                      {
                        n = n + 1;
                      }
                  }
                }
            }

          }
          
       }


  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Bounds = <424,30,519,72>;
    preset Color = #EDEDEDFF;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <423,29,520,73>;
    preset Width = 2;
    preset ColorL = #1C1C1CFF;
    preset ColorR = #BFBFBFFF;
    preset ColorB = #BFBFBFFF;
    preset ColorT = #1C1C1CFF;
  }

  $rect <20,20,160,60>
  object Views::Text Unit
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <432,38,511,64>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Unit 500";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <70,580,270,620>
  slot CancelRBUComs
  {
    sender; /* the method is called from the sender object */


    native
    {
      Command1( CMD_DETECT_RBU, -1 );
    }
       
  }

  $rect <1490,330,1690,370>
  object Core::SystemEventHandler SystemEventHandler5
  {
    preset OnEvent = onEvent3;
    preset Event = App::Devices.SiteChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler4' \
  // receives an event.
  $rect <1510,380,1710,420>
  slot onEvent3
  {
     

    SetupMenus();


  }

  $rect <1160,540,1360,580>
  var int32 typeCode = 0;

  $reorder GetMenuItem 2
  $reorder Image 2
  $reorder Text 2
  $reorder Image1 2
  $reorder Text1 2
  $reorder Text2 2
  $reorder SetupMenus 2
  $reorder FillMenu 2
  $reorder HorizontalValueBar 2
  $reorder PushButton1 2
  $reorder Setup 2
  $reorder Cancel 2
}

$rect <1730,1020,1930,1060>
$output false
resource Resources::Bitmap usbsmall
{
  attr bitmapfile FileName = .\Images\usbsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1840,900,2040,940>
$output false
resource Resources::Bitmap jackplug
{
  attr bitmapfile FileName = .\Images\jackplug.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1860,860,2060,900>
$output false
resource Resources::Bitmap jackplugsm
{
  attr bitmapfile FileName = .\Images\jackplugsm.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <160,1010,360,1050>
$output false
class RBUProgress
{
  $rect <0,0,160,40>
  property int32 progress = 0;

  $rect <0,50,160,90>
  property string errmsg = "";
}

$rect <0,1300,130,1340>
$output false
class PtrClass
{
  $rect <0,0,120,40>
  property int32 ptr = 0;
}

$rect <230,1880,430,1920>
$output false
class DelayUnitItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,550,40>;
    preset Color = #DDDDDDFF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object App::ChannelImage ChannelImage
  {
    preset Bounds = <20,2,56,38>;
    preset Bitmap = App::ChannelType.MedicalCallpoint;
  }

  $rect <20,20,160,60>
  object App::DoubleValueBar DoubleValueBar
  {
    preset Bounds = <348,10,548,30>;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <60,20,172,41>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Sounder";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <645,100,845,140>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */

    var App::ZoneFlags zf = App::Lib.GetPanelZoneFlags( zone, panel );

     
    if ( !zf.contains( App::ZoneFlags[ FireExpanded ] ) )
    {                                                      
        zf = zf + App::ZoneFlags[ FireExpanded ];  
    }
    else
    {
        zf = zf - App::ZoneFlags[ FireExpanded ];
    } 

    App::Lib.SetPanelZoneFlags( zone, panel, zf );


    ((App::Fire)Owner.Owner.Owner.Owner).SetListSize();




  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <60,0,160,21>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "UNIT 555";
    preset Font = App::FontVerdanaProSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::TripleSwitch TripleSwitch
  {
    preset Bounds = <155,5,335,35>;
  }

  $reorder Rectangle 1
}

$rect <830,1870,1030,1910>
$output false
class DoubleValueBar : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,560,30>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,560,30>;
    preset Color = #7A7A7AFF;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <1,1,559,29>;
    preset Color = #4B4B4BFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,2,302,28>;
    preset Color = #B1CEFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <300,2,440,28>;
    preset Color = #4E69DCFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <418,2,558,28>;
    preset Color = #DDDDDDFF;
  }
}

$rect <20,1990,220,2030>
$output false
class DelayRow : Core::Root
{
  $rect <670,20,870,60>
  inherited property Bounds = <0,0,640,480>;

  // To do:
  // 
  // - Adjust the visible size of your application (the thick blue border). It should \
  // correspond to the size of your target display.
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <10,510,790,740>;
  }
}

$rect <420,1880,620,1920>
$output false
class DelayZoneItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,0,550,40>;
    preset Color = #DDDDDDFF;
  }

  $rect <645,100,845,140>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */

    var App::ZoneFlags zf = App::Lib.GetPanelZoneFlags( zone, panel );

     
    if ( !zf.contains( App::ZoneFlags[ FireExpanded ] ) )
    {                                                      
        zf = zf + App::ZoneFlags[ FireExpanded ];  
    }
    else
    {
        zf = zf - App::ZoneFlags[ FireExpanded ];
    } 

    App::Lib.SetPanelZoneFlags( zone, panel, zf );


    ((App::Fire)Owner.Owner.Owner.Owner).SetListSize();




  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <50,0>;
    preset Point2 = <50,45>;
    preset Point1 = <0,45>;
    preset OnPress = ToggleExpand;
  }

  $rect <20,20,160,60>
  object Views::Image ExpandImage
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <6,5,46,40>;
    preset Bitmap = App::CollapseBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <49,0,99,20>;
    preset String = "ZONE";
    preset Font = App::FontVerdanaProSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <115,0,235,39>;
    preset Label = "Override";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object App::DoubleValueBar DoubleValueBar
  {
    preset Bounds = <348,10,548,30>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <250,5,340,35>;
    preset Label = "Edit";
    preset Appearance = App::SmallPushButton;
  }
}

$rect <630,1870,830,1910>
$output false
class DelayGlobalItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,0,550,40>;
    preset Color = #DDDDDDFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <131,-387,186,-362>;
    preset String = "Local";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <194,-387,249,-362>;
    preset String = "Zonal";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <645,100,845,140>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */

    var App::ZoneFlags zf = App::Lib.GetPanelZoneFlags( zone, panel );

     
    if ( !zf.contains( App::ZoneFlags[ FireExpanded ] ) )
    {                                                      
        zf = zf + App::ZoneFlags[ FireExpanded ];  
    }
    else
    {
        zf = zf - App::ZoneFlags[ FireExpanded ];
    } 

    App::Lib.SetPanelZoneFlags( zone, panel, zf );


    ((App::Fire)Owner.Owner.Owner.Owner).SetListSize();




  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <50,0,170,40>;
    preset Label = "Overide";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object App::DoubleValueBar DoubleValueBar
  {
    preset Bounds = <348,10,548,30>;
  }
}

$rect <-260,520,-160,560>
$output false
class Delays__ : Core::Group
{
  $rect <0,550,200,590>
  inherited property Bounds = <0,0,780,350>;

  $rect <0,410,200,450>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );


  }

  $rect <10,470,210,510>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*
      var int32 numZones = 32;

       native( numZones )
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }
       VerticalList.NoOfItems = numZones;
       VerticalList.InvalidateItems( 0, numZones );

      VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;
      VertScrollbar.ViewArea = VerticalList.Bounds.h;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <790,380,930,420>
  inherited method Init()
  {
    InitSite();

  }

  $rect <250,380,390,420>
  inherited property AlphaBlended = true;

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <490,360,630,400>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    var Core::VerticalList vlist = ListViewer.VerticalList;

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;

     
    var App::ZoneToggle item = (App::ZoneToggle) vlist.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    if ( itemNo < 0 )
    {
       item.Visible = false;
       item.InvalidateViewState();
       return;
    }

    item.Visible = true;

    //var Application::ModifyZoneItem currentZone = null;

    var uint8 curZone = 1;


       var int32 i = 0;
       var int32 numZones = 2;

       native( numZones ) 
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }
       
       
       while ( numZones > 0 )
       {
          var int32 numdevs = 4;
           
          native( numdevs, curZone )
          {  
             numdevs = get_num_devs_in_zone( curZone );
          }

          if ( numdevs > 0 )
          {
            
            numZones = numZones - 1;

            if ( itemNo == i )
            {
              item.ZoneNum = curZone;
              item.isDevice = false;
              item.isZone = true;
               
              item.InvalidateViewState();
              return;
            }
            else
            {
               i = i + 1;
            }

            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );

            if ( zf.contains( App::ZoneFlags[ ModifyExpanded ] ) )
            {                    
              if ( itemNo < numdevs + i )
              {
                var int32 dev = itemNo - i;
                var string location = "????";
                var uint16 unitno = dev + 1;
                var uint8 zoneno = curZone;

                var App::DeviceConfig dc = App::Lib.GetConfigNumInZone( curZone, dev );

                 
                
                item.isDevice = true;
                item.isZone = false;
                item.UnitNum = dc.unitnum;
                item.ZoneNum = dc.zonenum;
                item.DescriptionText.String = dc.location;       

                item.InvalidateViewState(); 
                 

                return;
              }
              else
              {
                 i = i + numdevs;
              }
           }
         }
         curZone = curZone + 1;
       }

     
        item.Visible = false;
        item.InvalidateViewState(); 

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <610,0,780,50>;
    preset Enabled = false;
    preset Label = "Edit Panel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <610,60,780,110>;
    preset Enabled = false;
    preset Label = "Add Device";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <0,0,600,350>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::ZoneToggle;
    preset ItemHeight = 50;
    preset onRefreshAll = RefreshAll;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <480,420,620,460>
  slot RefreshAll
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */
                                                                 

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;

     
    var App::ZoneToggle item = (App::ZoneToggle) ListViewer.VerticalList.first;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    while ( itemNo < 0 )
    {
       item.Visible = false;
       item.InvalidateViewState();

       item = (App::ZoneToggle) item.next; 
       if ( item == null ) return;

       itemNo = itemNo + 1;
    }


    //var Application::ModifyZoneItem currentZone = null;

    var uint8 curZone = 1;


    var int32 i = 0;
    var int32 numZones = 2;

    native( numZones ) 
    {
      Command cmd;
      Command0( CMD_GET_NUM_ZONES, &cmd );
      numZones = cmd.int0;
    }


    while ( numZones > 0 )
    {
        var int32 numdevs = 4;
     
        native( numdevs, curZone )
        {  
           numdevs = get_num_devs_in_zone( curZone );
        }

        if ( numdevs > 0 )
        {
            numZones = numZones - 1;

            if ( itemNo == i )
            {
                item.Visible = true;

                item.ZoneNum = curZone;
                item.isDevice = false;
                item.isZone = true;

                item.InvalidateViewState();
                item = (App::ZoneToggle) item.next; 
                if ( item == null ) return;

            }
            else
            {
                i = i + 1;
            }

            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );

            if ( zf.contains( App::ZoneFlags[ ModifyExpanded ] ) )
            {                    
                if ( itemNo < numdevs + i )
                {
                    var int32 dev = 0;

                    while ( dev < numdevs )
                    {
                        if ( i == itemNo )
                        {
                            var string location = "????";
                            var uint16 unitno = dev + 1;
                            var uint8 zoneno = curZone;

                            var App::DeviceConfig dc = App::Lib.GetConfigNumInZone( curZone, dev );
                            
                            
              
                            item.Visible = true;
                            item.isDevice = true;
                            item.isZone = false;
                            item.UnitNum = dc.unitnum;
                            item.ZoneNum = dc.zonenum;
                            item.DescriptionText.String = dc.location;
                            
                            item.InvalidateViewState(); 
                            
                            item = (App::ZoneToggle) item.next; 
                            if ( item == null ) return;
                        }
                        else
                        {
                            i = i + 1;
                        }
                        dev = dev + 1;
                    }
                }
                else
                {
                    i = i + numdevs;
                }
            }     
        }
        curZone = curZone + 1;
    }

    while ( item != null )
    { 
        item.Visible = false;
        item.InvalidateViewState();
        item = (App::ZoneToggle) item.next; 
    }
         

  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,555,350>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2C2C2CFF;
  }

  $rect <840,100,1040,140>
  object Core::SystemEventHandler SiteChangedEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = App::Devices.SiteChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <830,140,1030,180>
  slot onEvent
  {
    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */

    InitSite();

  }

  $rect <840,240,970,280>
  method void InitSite()
  {
    // TO DO: Write your code here ...
     var int32 numZones = 2;

       native( numZones )
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }

     ListViewer.NoOfItems = numZones ;
      

  }

  $rect <840,10,1100,50>
  object Core::SystemEventHandler MeshListChangeEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = App::Devices.MeshListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <840,40,1040,80>
  slot onEvent1
  {
        signal ListViewer.onRefreshAll;
  }
}

$rect <30,1860,210,1900>
$output false
class Delays : Core::Group
{
  $rect <0,550,200,590>
  inherited property Bounds = <0,0,600,350>;

  $rect <0,500,200,540>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <210,420,360,460>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    signal onEvent1;

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <490,360,630,400>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */
               

    var Core::VerticalList vlist = ListViewer.VerticalList;

     

    // Get the number of the item to load. The list component takes care of the
    var int32       itemNo   = ListViewer.Item;

     
    var App::TestItem item = (App::TestItem) vlist.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;


    native
    {
       if ( Command1( CMD_CHECK_TREE, 0 ) ) return;
    }

    if ( itemNo < 0 )
    {
       item.Visible = false;
       item.InvalidateViewState();
       return;
    }


    var uint8 curZone = 1;


    var int32 i = 0;
    var int32 numZones = App::Lib.NumZonesWithDevices();


    while ( numZones > 0 )
    {
        var int32 numdevs = App::Lib.NumDevsInZone( curZone ); 
         
        if ( numdevs > 0 )
        {
            numZones = numZones - 1;

            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );

            if ( itemNo == i )
            {
              item.TestZoneItem.ZoneNum = curZone;
              item.TestZoneItem.Visible = true;
              item.TestZoneItem.Enabled = true;

              item.TestUnitItem.Visible = false;
              item.TestUnitItem.Enabled = false;

              item.TestChannelItem.Visible = false;
              item.TestChannelItem.Enabled = false;

              item.TestZoneItem.ToggleButton.Checked = zf.contains( App::ZoneFlags[ OnTest] );    
              item.TestZoneItem.PushButton.Enabled = !item.TestZoneItem.ToggleButton.Checked;

              if ( zf.contains( App::ZoneFlags[ TestExpanded ] ) )
              { 
                  item.TestZoneItem.ExpandImage.Bitmap = App::CollapseBitmap;
              }
              else
              {
                  item.TestZoneItem.ExpandImage.Bitmap = App::ExpandBitmap;
              }
        
              item.TestZoneItem.InvalidateViewState();
              return;
            }
            else
            {
               i = i + 1;
            }

     
            if ( zf.contains( App::ZoneFlags[ TestExpanded ] ) )    // if zone expanded
            {                             
               var int32 dev = 0;

               while ( dev < numdevs )
               {
                  var int16 unitno = App::Lib.GetDevInZone( curZone, dev );
                    
                  var App::Device device = App::Lib.GetDevice( unitno );
                  var App::DeviceConfig config = App::Lib.GetConfig( unitno ); 

                  if ( config == null ) return;

                  if ( i == itemNo )   
                  { 
                      item.TestUnitItem.Visible = true;

                      if ( device.settings.contains( App::DeviceSetting[ TestExpanded ] ) )
                      {
                          item.TestUnitItem.Image1.Bitmap = App::CollapseBitmap; 
                      }
                      else
                      {
                          item.TestUnitItem.Image1.Bitmap = App::ExpandBitmap; 
                      }

                      if ( device == null )
                      {
                          item.TestUnitItem.Enabled = false;
                      }
                      else
                      {
                          item.TestUnitItem.Enabled = true;

                          if ( zf.contains( App::ZoneFlags[ OnTest] ) )
                          { 
                              item.TestUnitItem.UnitCheckBox.Enabled = false;
                              item.TestUnitItem.UnitCheckBox.Checked = true;
                          }
                          else
                          {
                              item.TestUnitItem.UnitCheckBox.Enabled = true;
                              item.TestUnitItem.UnitCheckBox.Checked = device.settings.contains( App::DeviceSetting[ OnTest] );
                          }
                      }

                      item.TestZoneItem.Visible = false;
                      item.TestZoneItem.Enabled = false;

                      item.TestChannelItem.Visible = false;
                      item.TestChannelItem.Enabled = false;

                      
                      item.TestUnitItem.UnitNum = unitno;
                      item.TestUnitItem.ZoneNum = curZone;


                      item.TestUnitItem.DescriptionText.String = config.location;             

                      item.TestUnitItem.InvalidateViewState(); 

                      return;
                   }
                   else
                   {
                      i = i + 1;
                   }

                   if ( device != null )
                   if ( device.settings.contains( App::DeviceSetting[ TestExpanded ] ) )   
                   {
                     var int32 chan = 0;

                     for ( chan = 0 ; chan < config.numinputs; chan = chan + 1 )
                     {                      
                        if ( i == itemNo )
                        {
                          item.TestUnitItem.Visible = false;
                          item.TestUnitItem.Enabled = false;

                          item.TestZoneItem.Visible = false;
                          item.TestZoneItem.Enabled = false;

                          item.TestChannelItem.Visible = true;
                          item.TestChannelItem.Enabled = true;


                          item.TestChannelItem.ChanNum = chan;
                          item.TestChannelItem.UnitNum = unitno;
                          item.TestChannelItem.ZoneNum = curZone;

                          item.TestChannelItem.HorizontalLedValueBar.Enabled = true;
                          item.TestChannelItem.HorizontalLedValueBar.Visible = true;

                          if ( device.flags[ chan].contains( App::ChannelFlags[ InputActiveOnTest ] ) )
                          {
                            item.TestChannelItem.HorizontalLedValueBar.CurrentValue = 100;
                          }
                          else
                          {
                            item.TestChannelItem.HorizontalLedValueBar.CurrentValue = 0;
                          }

                          item.TestChannelItem.ToggleButton.Enabled = false;
                          item.TestChannelItem.ToggleButton.Visible = false;
                          item.TestChannelItem.CheckBox.Visible = true;
                          item.TestChannelItem.CheckBox.Enabled = true;

                          item.TestChannelItem.SmallDropDownMenu.Visible = false;
                          item.TestChannelItem.SmallDropDownMenu.Enabled = false;

                          item.TestChannelItem.ChannelName.String = App::Lib.TypeName( config.inputs[ chan ].type );

                           
                          if ( zf.contains( App::ZoneFlags[ OnTest] ) || device.settings.contains( App::DeviceSetting[ OnTest] ) )
                          { 
                              item.TestChannelItem.CheckBox.Enabled = false;
                              item.TestChannelItem.CheckBox.Checked = true;
                          }
                          else
                          {
                              item.TestChannelItem.CheckBox.Enabled = true;    
                              item.TestChannelItem.CheckBox.Checked = device.flags[ chan ].contains( App::ChannelFlags[ InputOnTest] );
                          }
                      
                          if ( config.inputs[ chan ] != null ) 
                          {                    
                             item.TestChannelItem.ChannelImage.Bitmap = config.inputs[ chan ].type;
                          }

                          item.TestChannelItem.InvalidateViewState();
                         
                          return;
                        }
                        else
                        {
                           i = i + 1;
                        }
                      }
                              
                      
                      for( chan = 0; chan < config.numoutputs; chan = chan + 1 )
                      {
                         if ( i == itemNo )
                         {
                            item.TestUnitItem.Visible = false;
                            item.TestUnitItem.Enabled = false;

                            item.TestZoneItem.Visible = false;
                            item.TestZoneItem.Enabled = false;    

                            item.TestChannelItem.Visible = true;
                            item.TestChannelItem.Enabled = true;

                            item.TestChannelItem.ChanNum = chan;
                            item.TestChannelItem.UnitNum = unitno;
                            item.TestChannelItem.ZoneNum = curZone;

                            item.TestChannelItem.HorizontalLedValueBar.Visible = false;
                            item.TestChannelItem.HorizontalLedValueBar.Enabled = false;

                            item.TestChannelItem.ToggleButton.Enabled = true;
                            item.TestChannelItem.ToggleButton.Visible = true;

                            item.TestChannelItem.CheckBox.Visible = false;
                            item.TestChannelItem.CheckBox.Enabled = false;

                            item.TestChannelItem.SmallDropDownMenu.Visible = true;
                            item.TestChannelItem.SmallDropDownMenu.Enabled = true;


                            var int32 menu = (int32) device.menuSelection[ chan ];

                            item.TestChannelItem.SmallDropDownMenu.selIndex = menu;
                            item.TestChannelItem.DefaultAction = (App::Profile) menu;
                            item.TestChannelItem.SmallDropDownMenu.Text.String = App::Lib.ProfileName( (App::Profile) menu );  

                            item.TestChannelItem.ChannelName.String = App::Lib.TypeName( config.outputs[ chan].type ); 

                               
                            if ( device.flags[ chan ].contains( App::ChannelFlags[ OutputOnTest ] ) )
                            { 
                                item.TestChannelItem.ToggleButton.Checked = true;
                            }
                            else
                            {
                                item.TestChannelItem.ToggleButton.Checked = false;  
                            }             
                      
                            if ( config.outputs[ chan ] != null ) 
                            {                         
                               item.TestChannelItem.ChannelImage.Bitmap = config.outputs[ chan ].type;  
                            }

                            item.TestChannelItem.InvalidateViewState( );
                            return;
                         }
                         else
                         {
                            i = i + 1;
                         }
                      }         

                     
                  }
                  dev = dev + 1;
              }
           }
         }
         curZone = curZone + 1;
       }


        // EEK shouldnt be here
        item.TestUnitItem.Visible = false;
        item.TestZoneItem.Visible = false;
        item.TestChannelItem.Visible = false;
       
     
     

  }

  $rect <910,340,1140,380>
  object Core::SystemEventHandler SiteLoadedEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = App::Devices.SiteChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <890,410,1040,450>
  slot onEvent1
  {
    var int32 numZones = App::Lib.NumZonesWithDevices();


    var int32 i = 0;
     
     

    ListViewer.NoOfItems = numZones ;
     
     
          
  }

  $rect <620,0,820,40>
  property uint16 unitnum = 0;

  $rect <620,40,820,80>
  property uint16 zonenum = 0;

  $rect <620,100,820,140>
  property slot ZoneSelect = null;

  $rect <620,140,820,180>
  property slot ZoneDeSelect = null;

  $rect <620,180,820,220>
  property slot DeviceDeSelect = null;

  $rect <620,220,820,260>
  property slot DeviceSelect = null;

  $rect <940,0,1140,40>
  object Core::SystemEventHandler OnTestChangeEventHandler
  {
    preset OnEvent = TestChange;
    preset Event = App::Devices.OnTestChangeEvent;
  }

  $rect <390,490,590,530>
  slot CountOnTest
  {
    sender; /* the method is called from the sender object */


    /*

    var int32 i;
    var int32 unitCount = 0;


    var Core::VerticalList lst = (Core::VerticalList) Owner.Owner;

    var int32 zone;

     var int32 numZones = 2;

       native( numZones )
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }


    for( zone = 0; zone < numZones; zone = zone + 1 )
    {   
        unitCount = unitCount + UpdateZone( zone, false );    
    }

     */
    var App::Application app = (App::Application) Owner.Owner;

    if ( app != null )
    {
       postsignal app.OnTest.Refresh;
    } 

  }

  $rect <880,190,1080,230>
  method void j()
  {
    var Core::View view = GetRoot( ).last; 

    while ( view != null )
    {
      var App::SmallDropDownMenuList list = (App::SmallDropDownMenuList) view;

      if ( list != null ) 
      {
        GetRoot().Remove( view );
        return;
       }
      view = view.prev;
    }

  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::TestItem;
    preset ItemHeight = 50;
    preset onScroll = RemoveMenu;
    preset onRefreshAll = RefreshAll;
  }

  $rect <850,250,1050,290>
  slot RemoveMenu
  {
    var Core::View view = GetRoot( ).last; 

    if ( MenuHandle != null && MenuHandle.Owner == GetRoot() )
    {
        GetRoot().Remove( MenuHandle );
        MenuHandle.Owner = null;          
        MenuHandle = null;
    }

  }

  $rect <680,340,880,380>
  property App::SmallDropDownMenuList MenuHandle = null;

  $rect <20,20,160,60>
  object Views::Bevel Bevel1
  {
    preset Bounds = <0,0,554,350>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2C2C2CFF;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <500,410,640,450>
  slot RefreshAll
  {
       

    var Core::VerticalList vlist = ListViewer.VerticalList;

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo = ListViewer.Item;

     
    var App::TestItem item = (App::TestItem) vlist.first;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;


    native
    {
       if ( Command1( CMD_CHECK_TREE, 0 ) ) return;
    }

    while ( itemNo < 0 )
    {
       item.Visible = false;
       item.InvalidateViewState( );

       item = (App::TestItem) item.next;
       if ( item == null ) return;
       itemNo = itemNo + 1;
    }



    var uint8 curZone = 1;


    var int32 i = 0;
    var int32 numZones = App::Lib.NumZonesWithDevices();


    while ( numZones > 0 )
    {
        var int32 numdevs = App::Lib.NumDevsInZone( curZone ); 
         
        if ( numdevs > 0 )
        {
            numZones = numZones - 1;

            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );

            if ( itemNo == i )
            {
              item.Visible = true;
              item.TestZoneItem.ZoneNum = curZone;
              item.TestZoneItem.Visible = true;
              item.TestZoneItem.Enabled = true;

              item.TestUnitItem.Visible = false;
              item.TestUnitItem.Enabled = false;

              item.TestChannelItem.Visible = false;
              item.TestChannelItem.Enabled = false;
              item.TestChannelItem.ToggleButton.Enabled = false;


              item.TestZoneItem.ToggleButton.Checked = zf.contains( App::ZoneFlags[ OnTest] );    
              item.TestZoneItem.PushButton.Enabled = !item.TestZoneItem.ToggleButton.Checked;

              if (  zf.contains( App::ZoneFlags[ TestExpanded ] ) )
              { 
                  item.TestZoneItem.ExpandImage.Bitmap = App::CollapseBitmap;
              }
              else
              {
                  item.TestZoneItem.ExpandImage.Bitmap = App::ExpandBitmap;
              }
        
              item.TestZoneItem.InvalidateViewState();

              item = (App::TestItem) item.next;

              if ( item == null ) return;
            }
            else
            {
               i = i + 1;
            }

     
            if ( zf.contains( App::ZoneFlags[ TestExpanded ] ) )    // if zone expanded
            {                             
                var int32 dev = 0;

                while ( dev < numdevs )
                {
                  var int16 unitno = App::Lib.GetDevInZone( curZone, dev );
               
                  var App::Device device = App::Lib.GetDevice( unitno );

                  var App::DeviceConfig config = App::Lib.GetConfig( unitno ); 

                  if ( config != null )
                  {  
                      if ( i == itemNo )   
                      { 
                          item.Visible = true;
                          item.TestUnitItem.Visible = true;

                          if ( device.settings.contains( App::DeviceSetting[ TestExpanded ] ) )
                          {
                              item.TestUnitItem.Image1.Bitmap = App::CollapseBitmap; 
                          }
                          else
                          {
                              item.TestUnitItem.Image1.Bitmap = App::ExpandBitmap; 
                          }

                          if ( device == null )
                          {
                              item.TestUnitItem.Enabled = false;
                          }
                          else
                          {
                              item.TestUnitItem.Enabled = true;

                              if ( zf.contains( App::ZoneFlags[ OnTest] ) )
                              { 
                                  item.TestUnitItem.UnitCheckBox.Enabled = false;
                                  item.TestUnitItem.UnitCheckBox.Checked = true;
                              }
                              else
                              {
                                  item.TestUnitItem.UnitCheckBox.Enabled = true;
                                  item.TestUnitItem.UnitCheckBox.Checked = device.settings.contains( App::DeviceSetting[ OnTest] );
                              }
                          }

                          
                          item.TestZoneItem.Visible = false;
                          item.TestZoneItem.Enabled = false;

                          item.TestChannelItem.Visible = false;
                          item.TestChannelItem.Enabled = false;

                          item.TestChannelItem.ToggleButton.Enabled = false;


                      
                          item.TestUnitItem.UnitNum = unitno;
                          item.TestUnitItem.ZoneNum = curZone;


                          item.TestUnitItem.DescriptionText.String = config.location;             

                          item.TestUnitItem.InvalidateViewState(); 

                          item = (App::TestItem) item.next;

                          if ( item == null ) return;
                       }
                       else
                       {
                          i = i + 1;
                       }

                       if ( device != null )
                       if ( device.settings.contains( App::DeviceSetting[ TestExpanded ] ) )   
                       {
                           var int32 chan = 0;

                           for ( chan = 0 ; chan < config.numinputs; chan = chan + 1 )
                           {                      
                              if ( i == itemNo )
                              {
                                  item.Visible = true;
                                  item.TestUnitItem.Visible = false;
                                  item.TestUnitItem.Enabled = false;

                                  item.TestZoneItem.Visible = false;
                                  item.TestZoneItem.Enabled = false;

                                  item.TestChannelItem.Visible = true;
                                  item.TestChannelItem.Enabled = true;


                                  item.TestChannelItem.ChanNum = chan;
                                  item.TestChannelItem.UnitNum = unitno;
                                  item.TestChannelItem.ZoneNum = curZone;

                                  item.TestChannelItem.HorizontalLedValueBar.Enabled = true;
                                  item.TestChannelItem.HorizontalLedValueBar.Visible = true;

                                  if ( device.flags[ chan].contains( App::ChannelFlags[ InputActiveOnTest ] ) )
                                  {
                                    item.TestChannelItem.HorizontalLedValueBar.CurrentValue = 100;
                                  }
                                  else
                                  {
                                    item.TestChannelItem.HorizontalLedValueBar.CurrentValue = 0;
                                  }

                                  item.TestChannelItem.ToggleButton.Enabled = false;
                                  item.TestChannelItem.ToggleButton.Visible = false;
                                  item.TestChannelItem.CheckBox.Visible = true;
                                  item.TestChannelItem.CheckBox.Enabled = true;

                                  item.TestChannelItem.SmallDropDownMenu.Visible = false;
                                  item.TestChannelItem.SmallDropDownMenu.Enabled = false;

                                  
                                  item.TestChannelItem.ChannelName.String = App::Lib.TypeName( config.inputs[ chan ].type );

                           
                                  if ( zf.contains( App::ZoneFlags[ OnTest] ) || device.settings.contains( App::DeviceSetting[ OnTest] ) )
                                  { 
                                      item.TestChannelItem.CheckBox.Enabled = false;
                                      item.TestChannelItem.CheckBox.Checked = true;
                                  }
                                  else
                                  {
                                      item.TestChannelItem.CheckBox.Enabled = true;    
                                      item.TestChannelItem.CheckBox.Checked = device.flags[ chan ].contains( App::ChannelFlags[ InputOnTest] );
                                  }
                      
                                  if ( config.inputs[ chan ] != null ) 
                                  {                    
                                     item.TestChannelItem.ChannelImage.Bitmap = config.inputs[ chan ].type;
                                  }

                                  item.TestChannelItem.InvalidateViewState();
                         
                                  item = (App::TestItem) item.next;

                                  if ( item == null ) return;
                              }
                              else
                              {
                                 i = i + 1;
                              }
                          }
                              
                 
                        
                          for( chan = 0; chan < config.numoutputs; chan = chan + 1 )
                          {
                             if ( i == itemNo )
                             {
                                item.Visible = true;
                                item.TestUnitItem.Visible = false;
                                item.TestUnitItem.Enabled = false;

                                item.TestZoneItem.Visible = false;
                                item.TestZoneItem.Enabled = false;    

                                item.TestChannelItem.Visible = true;
                                item.TestChannelItem.Enabled = true;

                                item.TestChannelItem.ChanNum = chan;
                                item.TestChannelItem.UnitNum = unitno;
                                item.TestChannelItem.ZoneNum = curZone;

                                item.TestChannelItem.HorizontalLedValueBar.Visible = false;
                                item.TestChannelItem.HorizontalLedValueBar.Enabled = false;

                                item.TestChannelItem.ToggleButton.Enabled = true;
                                item.TestChannelItem.ToggleButton.Visible = true;

                                item.TestChannelItem.CheckBox.Visible = false;
                                item.TestChannelItem.CheckBox.Enabled = false;

                                item.TestChannelItem.SmallDropDownMenu.Visible = true;
                                item.TestChannelItem.SmallDropDownMenu.Enabled = true;

                                item.TestChannelItem.SmallDropDownMenu.selIndex = device.menuSelection[ chan];
                                item.TestChannelItem.SmallDropDownMenu.Text.String = App::Lib.ProfileName( (App::Profile) item.TestChannelItem.SmallDropDownMenu.selIndex );
     
                                item.TestChannelItem.DefaultAction = (App::Profile) item.TestChannelItem.SmallDropDownMenu.selIndex;
                               
                                item.TestChannelItem.ChannelName.String = App::Lib.TypeName( config.outputs[ chan].type ); 

                               
                                if ( device.flags[ chan ].contains( App::ChannelFlags[ OutputOnTest ] ) )
                                { 
                                    item.TestChannelItem.ToggleButton.Checked = true;
                                }
                                else
                                {
                                    item.TestChannelItem.ToggleButton.Checked = false;  
                                }             
                      
                                if ( config.outputs[ chan ] != null ) 
                                {                         
                                   item.TestChannelItem.ChannelImage.Bitmap = config.outputs[ chan ].type;  
                                }

                                item.TestChannelItem.InvalidateViewState( );

                                item = (App::TestItem) item.next;

                                if ( item == null ) return;
                             }
                             else
                             {
                                i = i + 1;
                             }
                          }         
                      }
                     
                  }
                  dev = dev + 1;
              }
           }
        }
        curZone = curZone + 1;   
    }

    while ( item != null )
    {
       item.Visible = false;
       item.InvalidateViewState( );

       item = (App::TestItem) item.next;
     
    }

        
  }

  $rect <910,80,1170,120>
  object Core::SystemEventHandler MeshListChangeEventHandler
  {
    preset OnEvent = GetLength;
    preset Event = App::Devices.MeshListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <950,40,1150,80>
  slot TestChange
  {
    signal ListViewer.onRefreshAll;




    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <990,120,1130,160>
  slot GetLength
  {
       


    var uint8 curZone = 1;


    var int32 count = 0;
    var int32 numZones = App::Lib.NumZonesWithDevices();


    while ( numZones > 0 )
    {
        var int32 numdevs = App::Lib.NumDevsInZone( curZone ); 
         
        if ( numdevs > 0 )
        {
            numZones = numZones - 1;

            count = count + 1;

            var App::ZoneFlags zf = App::Lib.GetZoneFlags( curZone );

     
            if ( zf.contains( App::ZoneFlags[ TestExpanded ] ) )    // if zone expanded
            {                             
                var int32 dev = 0;

                count = count + numdevs;

                while ( dev < numdevs )
                {
                  var int16 unitno = App::Lib.GetDevInZone( curZone, dev );
               
                  var App::Device device = App::Lib.GetDevice( unitno );

                  var App::DeviceConfig config = App::Lib.GetConfig( unitno ); 

                  if ( config != null )
                  {  
                       if ( device != null )
                       if ( device.settings.contains( App::DeviceSetting[ TestExpanded ] ) )   
                       {
                           var int32 chan = 0;
                           count = count + config.numinputs + config.numoutputs;      
                      }                 
                  }
                  dev = dev + 1;
              }
           }
        }
        curZone = curZone + 1;   
    }
     
    ListViewer.NoOfItems = count;
        
  }

  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
}

$rect <60,2090,260,2130>
$output false
class TripleSwitch : Core::Group
{
  $rect <40,145,240,185>
  inherited property Bounds = <0,0,180,30>;

  $rect <340,115,540,155>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <340,45,540,85>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    if ( Selection^ == Text4.String )
    {
        Rectangle1.Bounds.origin.x = 0;
    }
    else if ( Selection^ == Text5.String )
    {
        Rectangle1.Bounds.origin.x = 60;
    }
    else  
    {
        Rectangle1.Bounds.origin.x = 120;
    }

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,0,60,30>;
    preset Color = #B8B8B8FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,180,30>;
    preset Color = #B8B8B8FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text6
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <125,5,175,25>;
    preset String = "Global";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text5
  {
    preset Bounds = <65,5,115,25>;
    preset String = "Zonal";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Bounds = <5,5,55,25>;
    preset String = "Local";
    preset Font = Flat::FontS;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Touch
  {
    preset Point4 = <0,0>;
    preset Point3 = <180,0>;
    preset Point2 = <180,30>;
    preset Point1 = <0,30>;
    preset OnPress = TouchSlot;
  }

  $rect <0,45,200,85>
  slot TouchSlot
  {
    sender; /* the method is called from the sender object */

    var int32 x = Touch.CurrentPos.x - Bounds.x1;

    if ( x < 60 )
    {
       Selection = ^Text4.String;
       Text4.Color = #FFFFFFFF;
       Text5.Color = #000000FF;
       Text6.Color = #000000FF;
    }
    else if (x < 120 )
    {
      Selection = ^Text5.String;
       Text4.Color = #000000FF;
       Text5.Color = #FFFFFFFF;
       Text6.Color = #000000FF;
    }
    else
    {
       Selection = ^Text6.String;
       Text4.Color = #000000FF;
       Text5.Color = #000000FF;
       Text6.Color = #FFFFFFFF;
    }


    InvalidateViewState();




  }

  $rect <45,85,245,125>
  property ^string Selection = ^Text4.String;
}

$rect <410,1940,610,1980>
$output false
class Delay : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object App::DelayUnitItem DelayUnitItem
  {
    preset Bounds = <0,0,550,40>;
  }

  $rect <20,20,160,60>
  object App::DelayZoneItem DelayZoneItem
  {
    preset Bounds = <0,0,550,40>;
  }

  $rect <20,20,160,60>
  object App::DelayGlobalItem DelayGlobalItem
  {
    preset Bounds = <0,0,550,40>;
  }
}

$rect <450,2050,650,2090>
$output false
class DelayPage : Core::Group
{
  $rect <40,290,240,330>
  inherited property Bounds = <0,0,520,280>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <350,330,1130,650>;
  }
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'check box'.
$rect <500,1670,710,1710>
$output false
autoobject WidgetSet::ToggleButtonConfig LargeDisableCheckBox
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDisabled = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDisabled = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 45;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #A8ABABAA;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #A8ABABAA;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 40;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToLeft];
  preset FaceOnTintDisabled = #94949499;
  preset FaceOnFrameActive = 0;
  preset FaceOnFrameFocused = 0;
  preset FaceOnFrameDisabled = 2;
  preset FaceOnFrameDefault = 2;
  preset FaceOnActive = App::DisableCheckboxBitmap;
  preset FaceOnFocused = App::DisableCheckboxBitmap;
  preset FaceOnDisabled = App::DisableCheckboxBitmap;
  preset FaceOnDefault = App::DisableCheckboxBitmap;
  preset FaceOffTintDefault = #94949493;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 1;
  preset FaceOffFrameDefault = 1;
  preset FaceOffActive = App::DisableCheckboxBitmap;
  preset FaceOffFocused = App::DisableCheckboxBitmap;
  preset FaceOffDisabled = App::DisableCheckboxBitmap;
  preset FaceOffDefault = App::DisableCheckboxBitmap;
  preset WidgetMinSize = <39,39>;
}

$rect <670,1730,890,1770>
$output false
resource Resources::Bitmap DisableCheckboxBitmap
{
  attr bitmapfile FileName = .\Images\DisableCheckbox.png;
  attr alphafile AlphaName;
  attr framesize FrameSize = <36,36>;
  attr framedelay FrameDelay;
}

$rect <670,1770,920,1810>
$output false
resource Resources::Bitmap DisableCheckboxSmallBitmap
{
  attr bitmapfile FileName = .\Images\DisableCheckboxSmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize = <20,20>;
  attr framedelay FrameDelay;
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'check box'.
$rect <770,1650,980,1690>
$output false
autoobject WidgetSet::ToggleButtonConfig DisableSmallCheckBox
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDisabled = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDisabled = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 0;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #85858587;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #85858587;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 40;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
  preset FaceLayout = Core::Layout[];
  preset FaceOnTintDisabled = #85858587;
  preset FaceOnFrameActive = 0;
  preset FaceOnFrameFocused = 0;
  preset FaceOnFrameDisabled = 2;
  preset FaceOnFrameDefault = 2;
  preset FaceOnActive = App::DisableCheckboxSmallBitmap;
  preset FaceOnFocused = App::DisableCheckboxSmallBitmap;
  preset FaceOnDisabled = App::DisableCheckboxSmallBitmap;
  preset FaceOnDefault = App::DisableCheckboxSmallBitmap;
  preset FaceOffTintDisabled = #85858587;
  preset FaceOffTintDefault = #94949493;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 1;
  preset FaceOffFrameDefault = 1;
  preset FaceOffActive = App::DisableCheckboxSmallBitmap;
  preset FaceOffFocused = App::DisableCheckboxSmallBitmap;
  preset FaceOffDisabled = App::DisableCheckboxSmallBitmap;
  preset FaceOffDefault = App::DisableCheckboxSmallBitmap;
  preset WidgetMinSize = <30,30>;
}

$rect <130,1330,330,1370>
$output false
enum RadioStage
{
  $rect <10,10,210,50>
  item Idle = 0;

  $rect <220,10,420,50>
  item Synced = 1;

  $rect <430,10,630,50>
  item Formed = 2;

  $rect <640,10,840,50>
  item Active = 3;

  $rect <870,10,1070,50>
  item Dropped = 3;
}

$rect <950,410,1150,450>
$output false
class ThreeWaySwitch : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,75,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,75,45>;
    preset FrameNumber = 2;
    preset Bitmap = App::SwitchMedium2;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <75,0>;
    preset Point2 = <75,45>;
    preset Point1 = <0,45>;
    preset OnRelease = null;
    preset OnPress = Tap;
  }

  $rect <80,0,195,40>
  slot Tap
  {
    sender; /* the method is called from the sender object */

    switch( Image.FrameNumber )
    {
      case 2: Image.FrameNumber = 6;
      case 6: Image.FrameNumber = 3;
      case 3: Image.FrameNumber = 2;
      default: Image.FrameNumber = 2;
    }

    signal onChange;

  }

  $rect <15,50,215,90>
  property slot onChange = null;
}

$rect <880,120,990,160>
$output false
class KeypadChangePopup : App::Popup
{
  $rect <870,380,1010,420>
  inherited property Bounds = <0,0,480,440>;

  $rect <160,420,300,460>
  inherited method Init()
  {
    // TO DO: Write your code here ... 
     
    AcceptTimer.Enabled = false;
     



    Writable.TextEditor.Text.String = "";
    Writable1.TextEditor.Text.String = "";

    passkey1 = "";
    passkey2 = "";

    passkey = ^passkey1;

    Writable.TextEditor.ObtainFocus();

    editor = Writable.TextEditor;







  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CBCBCBFF;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey
  {
    preset Bounds = <290,100,350,150>;
    preset NumProperty = "5";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey1
  {
    preset Bounds = <360,40,420,90>;
    preset NumProperty = "9";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey2
  {
    preset Bounds = <220,40,280,90>;
    preset NumProperty = "7";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey3
  {
    preset Bounds = <220,100,280,150>;
    preset NumProperty = "4";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey4
  {
    preset Bounds = <290,40,350,90>;
    preset NumProperty = "8";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey5
  {
    preset Bounds = <360,100,420,150>;
    preset NumProperty = "6";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey6
  {
    preset Bounds = <220,160,280,210>;
    preset NumProperty = "1";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey7
  {
    preset Bounds = <290,160,350,210>;
    preset NumProperty = "2";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey8
  {
    preset Bounds = <360,160,420,210>;
    preset NumProperty = "3";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey9
  {
    preset Bounds = <220,220,280,270>;
    preset NumProperty = "0";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::KeypadKey KeypadKey10
  {
    preset Bounds = <290,220,420,270>;
    preset NumProperty = "Del";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object App::Writable Writable
  {
    preset Bounds = <33,59,133,99>;
    preset Focus = null;
    preset MaxLength = 4;
    preset onPress = PressTop;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <33,20,163,54>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Enter new PIN";
    preset Font = Resources::FontMedium;
    preset Color = #020202FF;
  }

  $rect <510,220,710,260>
  slot Press
  {
    sender; /* the method is called from the sender object */

    var App::KeypadKey key = (App::KeypadKey) sender;

    if ( key.NumProperty.length == 1 )
    {
        if (passkey^.length < 4 )
        {
            passkey^ = (passkey^) + key.NumProperty[0];
            Update();
        }
      
        if (passkey1.length == 4 && editor == Writable.TextEditor )
        {
           Writable1.Visible = true;
           Text1.Visible = true;
           Writable1.TextEditor.ObtainFocus();
           passkey = ^passkey2;
           editor = Writable1.TextEditor;
           Writable1.Enabled = true;
        }
    }

    if ( key.NumProperty == "Del" )
    {
      if ( passkey^.length > 0 )
      {
        passkey^ = passkey^.left( passkey^.length - 1 );
        Update();
       }
    }



  }

  $rect <0,449,200,489>
  slot Proceeed
  {
    sender; /* the method is called from the sender object */

    var App::Application ap = (App::Application) GetRoot();

    if ( passkey1.length != 4 ) 
    {
       deny2.Visible = true;
           DenyTimer.Enabled = true;
              DenyTimer.restart( 0, 2000);
       return;
    }
    if ( passkey1 != passkey2 )
    {
       deny3.Visible = true;
       DenyTimer.Enabled = true;
              DenyTimer.restart( 0, 2000);
    }
    else
    {
      var int32 userindex = ap.LevelAccess.UserIndex;
      
      if ( userindex != -1 )
      { 
          var int32 level;
        
          var int32 key = passkey1.parse_int32( -1 );
       
          var bool ok = false;

          native( key, userindex )
          {
              if ( Command2( CMD_SET_PASSKEY, key, userindex ) == CMD_OK )
              {
                  ok = 1;
              }
          } 
          if ( ok )
          {   
              accept2.Visible = true;
              AcceptTimer.Enabled = true;
              AcceptTimer.restart( 0, 800 );
              return;
          }  
       } 
        deny4.Visible = true;
    }


  }

  $rect <280,422,480,462>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <510,20,710,60>
  property string EngLevel = "1234";

  $rect <510,70,710,110>
  property string SupLevel = "0000";

  $rect <550,150,750,190>
  object Core::Timer AcceptTimer
  {
    preset OnTrigger = AcceptSlot;
    preset Period = 1000;
  }

  $rect <540,290,740,330>
  slot AcceptSlot
  {
    sender; /* the method is called from the sender object */

    AcceptTimer.Enabled = false;  
    Hide();



  }

  $rect <750,60,950,100>
  object Core::Timer StarTimer
  {
    preset OnTrigger = StarSlot;
  }

  $rect <780,100,980,140>
  slot StarSlot
  {
    sender; /* the method is called from the sender object */

     
    StarTimer.Enabled = false;



    var int32 n;
    var string s = "";

    for( n = 0; n < passkey^.length; n=n+1 )
    {
        s = s + "*";
    }

    if ( passkey == ^passkey2 ) Writable.TextEditor.String = "****";

    editor.String = s;

  }

  $rect <810,154,1010,194>
  property string passkey1 = 0;

  $rect <840,260,1040,300>
  method void Update()
  {
             var int32 n;
             if ( StarTimer.Enabled ) StarTimer.Enabled = false;

            
           
             editor.String = "";
          
             for( n = 0; n < passkey^.length; n=n+1)
             {
                if ( n ==  passkey^.length-1 || !getting )
                {
                   editor.String = editor.String + passkey^[n];
                }
                else
                {
                    editor.String = editor.String + '*';
                }
              }
              
             StarTimer.Enabled = true;
             StarTimer.restart( 0, 1000 );

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <290,346,430,396>;
    preset OnRelease = Cancel;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <30,346,170,396>;
    preset OnRelease = Proceeed;
    preset Label = "OK";
    preset Appearance = App::NormalPushButton;
  }

  $rect <830,-10,1030,30>
  property bool getting = true;

  $rect <20,20,160,60>
  object Views::Text deny2
  {
    preset Bounds = <33,100,203,130>;
    preset String = "4 digits required";
    preset Font = Flat::FontM;
    preset Color = #3651AAFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text accept2
  {
    preset Bounds = <33,296,213,326>;
    preset String = "Passkey changed";
    preset Font = Flat::FontM;
    preset Color = #3651AAFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object App::Writable Writable1
  {
    preset Bounds = <34,180,134,220>;
    preset Focus = null;
    preset Enabled = false;
    preset Visible = false;
    preset MaxLength = 4;
    preset onPress = PressBot;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <34,144,164,178>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Confirm PIN";
    preset Font = Resources::FontMedium;
    preset Color = #020202FF;
    preset Visible = false;
  }

  $rect <700,290,900,330>
  property App::TextEditor editor = null;

  $rect <700,330,900,370>
  onset editor
  {
    // The value doesn't change - nothing to do.
    if ( pure editor == value )
      return;

    // Remember the property's new value.
    pure editor = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <700,370,900,410>
  onget editor
  {
    return pure editor;
  }

  $rect <20,20,160,60>
  object Views::Text deny3
  {
    preset Bounds = <34,222,203,280>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzJustified, AlignHorzLeft, AlignVertCenter];
    preset String = "Confirmation mismatch";
    preset Font = Flat::FontM;
    preset Color = #3651AAFF;
    preset Visible = false;
  }

  $rect <810,190,1010,230>
  property string passkey2 = 0;

  $rect <670,440,870,480>
  property ^string passkey = ^passkey1;

  $rect <530,120,730,160>
  object Core::Timer DenyTimer
  {
    preset OnTrigger = DenySlot;
    preset Period = 1000;
  }

  $rect <590,200,790,240>
  slot DenySlot
  {
    sender; /* the method is called from the sender object */

     deny3.Visible = false;
     deny2.Visible = false;

     



  }

  $rect <490,350,600,390>
  slot PressTop
  {
    sender; /* the method is called from the sender object */

    passkey = ^passkey1;
    editor = Writable.TextEditor;
    editor.ObtainFocus();

  }

  $rect <500,389,669,430>
  slot PressBot
  {
    sender; /* the method is called from the sender object */

     

    passkey = ^passkey2;
    editor = Writable1.TextEditor;
    editor.ObtainFocus();


  }

  $rect <20,20,160,60>
  object Views::Text deny4
  {
    preset Bounds = <34,222,203,280>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzJustified, AlignHorzLeft, AlignVertCenter];
    preset String = "Unable to set new PIN";
    preset Font = Flat::FontM;
    preset Color = #3651AAFF;
    preset Visible = false;
  }

  $reorder KeypadKey 3
  $reorder KeypadKey1 3
  $reorder KeypadKey2 3
  $reorder KeypadKey3 3
  $reorder KeypadKey4 3
  $reorder KeypadKey5 3
  $reorder KeypadKey6 3
  $reorder KeypadKey7 3
  $reorder KeypadKey8 3
  $reorder KeypadKey9 3
  $reorder KeypadKey10 3
  $reorder Writable 3
  $reorder Text 3
  $reorder Press 3
  $reorder Proceeed 3
  $reorder Cancel 3
  $reorder EngLevel 3
  $reorder SupLevel 3
  $reorder AcceptTimer 3
  $reorder AcceptSlot 3
  $reorder StarTimer 3
  $reorder StarSlot 3
  $reorder passkey1 3
  $reorder Update 3
  $reorder PushButton 3
  $reorder PushButton1 3
}

$rect <480,1020,680,1060>
$output false
class ZoneAndCombi
{
  $rect <80,50,280,90>
  property uint8 Zone = 0;

  $rect <80,110,280,150>
  property uint8 Combination = 0;
}

$rect <1100,860,1250,900>
$output false
class MeshLogPopup : App::Popup
{
  $rect <880,10,1020,50>
  inherited property Bounds = <0,0,800,470>;

  $rect <629,520,769,560>
  inherited method Init()
  {
    signal ChckOnOff;


    if ( ( ListViewer.NoOfItems * ListViewer.ItemHeight ) >  ListViewer.Bounds.h )
    {
      ListViewer.ScrollOffset = ListViewer.NoOfItems * ListViewer.ItemHeight - ListViewer.Bounds.h;
    } 


  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CBCBCBFF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,360,770,440>;
    preset Color = #C6C6C6FF;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <870,200,1070,240>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;
    var App::LogItem i= (App::LogItem)ListViewer.VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( i == null )
      return;

     if ( itemNo <0 || itemNo >= ListViewer.NoOfItems) 
     {
      i.Visible = false;
      return;
     }

     i.Visible = true;

    var int32 t = -1;
    var int32 filter = GetFilter();
    var string msg = "---------------------------------------------------------------------------------------------------";

      
      native( t, itemNo, filter, msg )
        {
          char buff[ 128 ];
          Command cmd;
      
          cmd.int0 = itemNo;
          cmd.int1 = filter;
          cmd.int2 = (int) buff;
      
          if ( Command0( CMD_GET_MESH_LOG_LINE, &cmd ) == CMD_OK )
          {
        
            t = cmd.int3;

            msg = EwNewStringAnsi( buff );
          }
       
        }

        switch (t )
        {
           case 4 :   i.Image.Bitmap = App::log_broadcast;
           case 1 :   i.Image.Bitmap = App::log_status;
           case 5 :   i.Image.Bitmap = App::LogMisc;
           case 6 :   i.Image.Bitmap = App::LogFaults;
           case 0 :   i.Image.Bitmap = App::log_link;
           case 3 :   i.Image.Bitmap = App::LogFire;
           case 2 :   i.Image.Bitmap = App::log_drop;
           case 7 :   i.Image.Bitmap = App::LogSettings;
           default :    i.Image.Bitmap = null;
        }

        switch (t )
        {
           case 4 :   i.TypeText.String = "Broadcast";
           case 1 :   i.TypeText.String = "Status";
           case 5 :   i.TypeText.String = "Misc";
           case 6 :   i.TypeText.String = "Fault";
           case 0 :   i.TypeText.String = "Link";
           case 3 :   i.TypeText.String = "Alarm";
           case 2 :   i.TypeText.String = "Drop";
           case 7 :   i.TypeText.String = "Settings";
           default:  i.TypeText.String = ""; 
        }

     

    i.DescripText.String = msg;

    i.Bounds.x2 = ListViewer.VerticalList.Bounds.x2;                                                                                                        
  }

  $rect <900,270,1100,310>
  slot Close
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <599,376,749,426>;
    preset OnRelease = Close;
    preset Label = "Close";
    preset Appearance = App::NormalPushButton;
  }

  $rect <840,500,960,540>
  method int32 GetFilter()
  {
    /* The template just returns the given argument... */

    var int32 filter = 0;

    if ( Sync.Checked )   filter = filter | 1;
    if ( Faults.Checked )   filter = filter | 64;
    if ( Broadcast.Checked )   filter = filter | 16;
    if ( Fire.Checked )     filter = filter | 8;
    if ( Misc.Checked )     filter = filter | 32;
    if ( Mesh.Checked )   filter = filter | 4;
    if ( Settings.Checked ) filter = filter | 128;
    if ( Status.Checked )  filter = filter | 2;

    return filter;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Sync
  {
    preset Bounds = <20,360,160,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Link";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Faults
  {
    preset Bounds = <180,360,297,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Faults";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Broadcast
  {
    preset Bounds = <320,360,450,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Broadcast";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Fire
  {
    preset Bounds = <20,400,160,440>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Fire/Alarm";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Settings
  {
    preset Bounds = <470,360,587,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Settings";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Mesh
  {
    preset Bounds = <180,400,310,440>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Drop";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Status
  {
    preset Bounds = <320,400,437,440>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Status";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Misc
  {
    preset Bounds = <471,400,588,440>;
    preset Enabled = true;
    preset Visible = true;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Misc.";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <880,320,1080,360>
  object Core::SystemEventHandler LogEventHandler
  {
    preset OnEvent = null;
    preset Enabled = false;
    preset Event = App::Devices.LogListChangeEvent;
  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <20,20,750,345>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::LogItem;
    preset ItemHeight = 25;
    preset NoOfItems = 10;
    preset onRefreshAll = RefreshAll;
    preset onScrollRefresh = ScrollRefresh;
  }

  $rect <860,160,1060,200>
  slot ScrollRefresh
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;


    var int32 filter = GetFilter();

    // if span up / scroll down
    if ( ListViewer.StartRow < itemNo )
    {  
      var App::LogItem i = (App::LogItem)ListViewer.VerticalList.first;
      var App::LogItem j = i;

      var int32 diff = itemNo - ListViewer.StartRow;
      var int32 n = 0;

      while ( j != null && n < diff )
      {
         j = (App::LogItem) j.next;
         n = n + 1;
      }

      while ( i != null && j != null )
      { 
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          i.Image.Bitmap = j.Image.Bitmap;
          i.DescripText.String = j.DescripText.String;
          i.TypeText.String = j.TypeText.String;
          i.Visible = true;
        }
        else
        {
          i.Visible = false;
        }
        i.InvalidateViewState();
        itemNo = itemNo + 1;
        j = (App::LogItem) j.next;
        i = (App::LogItem) i.next; 
      }
      while ( i != null )
      {
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          var int32 t = -1;

          var string msg = "---";

          i.Visible = true;

          native( t, itemNo, filter, msg )
          {
            char buff[ 129 ];
            Command cmd;
      
            cmd.int0 = itemNo;
            cmd.int1 = filter;
            cmd.int2 = (int) buff;
      
            if ( Command0( CMD_GET_MESH_LOG_LINE, &cmd ) == CMD_OK )
            {
        
              t = cmd.int3;

              msg = EwNewStringAnsi( buff );
            }
        
          }  

         
        switch (t )
        {
           case 4 :   i.Image.Bitmap = App::log_broadcast;
           case 1 :   i.Image.Bitmap = App::log_status;
           case 5 :   i.Image.Bitmap = App::LogMisc;
           case 6 :   i.Image.Bitmap = App::LogFaults;
           case 0 :   i.Image.Bitmap = App::log_link;
           case 3 :   i.Image.Bitmap = App::LogFire;
           case 2 :   i.Image.Bitmap = App::log_drop;
           case 7 :   i.Image.Bitmap = App::LogSettings;
           default :    i.Image.Bitmap = null;
        }

        switch (t )
        {
           case 4 :   i.TypeText.String = "Broadcast";
           case 1 :   i.TypeText.String = "Status";
           case 5 :   i.TypeText.String = "Misc";
           case 6 :   i.TypeText.String = "Fault";
           case 0 :   i.TypeText.String = "Link";
           case 3 :   i.TypeText.String = "Alarm";
           case 2 :   i.TypeText.String = "Drop";
           case 7 :   i.TypeText.String = "Settings";
           default:  i.TypeText.String = ""; 
         }
        
          i.DescripText.String = msg;
        
        }
        else
        {
        
           i.Visible = false;
        }
        itemNo = itemNo + 1;
        i.InvalidateViewState();
        i = (App::LogItem) i.next;
      }
    }
    else  // scroll up / pan down
    {
      var App::LogItem i = (App::LogItem) ListViewer.VerticalList.last;
      var App::LogItem j = i;

      var int32 diff = ListViewer.StartRow - itemNo;
      var int32 n = 0;

      while ( j != null && n < diff )
      {
         j = (App::LogItem) j.prev;
         n = n + 1;
      }

      itemNo = itemNo + 12;

      while ( i != null && j != null )
      { 
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          i.Image.Bitmap = j.Image.Bitmap;
          i.DescripText.String = j.DescripText.String;
          i.TypeText.String = j.TypeText.String;
          i.Visible = true;
        }
        else
        {
          i.Visible = false;
        }
        i.InvalidateViewState();
        itemNo = itemNo - 1;
        j = (App::LogItem) j.prev;
        i = (App::LogItem) i.prev; 
      }
      while ( i != null )
      {
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          var int32 t = -1;

          var string msg = "---";

          i.Visible = true;

          native( t, itemNo, filter, msg )
          {
            char buff[ 129 ];
            Command cmd;
      
            cmd.int0 = itemNo;
            cmd.int1 = filter;
            cmd.int2 = (int) buff;
      
            if ( Command0( CMD_GET_MESH_LOG_LINE, &cmd ) == CMD_OK )
            {
        
              t = cmd.int3;

              msg = EwNewStringAnsi( buff );
            }
        
          }  
          switch (t )
        {
           case 4 :   i.Image.Bitmap = App::log_broadcast;
           case 1 :   i.Image.Bitmap = App::log_status;
           case 5 :   i.Image.Bitmap = App::LogMisc;
           case 6 :   i.Image.Bitmap = App::LogFaults;
           case 0 :   i.Image.Bitmap = App::log_link;
           case 3 :   i.Image.Bitmap = App::LogFire;
           case 2 :   i.Image.Bitmap = App::log_drop;
           case 7 :   i.Image.Bitmap = App::LogSettings;
           default :    i.Image.Bitmap = null;
        }

        switch (t )
        {
           case 4 :   i.TypeText.String = "Broadcast";
           case 1 :   i.TypeText.String = "Status";
           case 5 :   i.TypeText.String = "Misc";
           case 6 :   i.TypeText.String = "Fault";
           case 0 :   i.TypeText.String = "Link";
           case 3 :   i.TypeText.String = "Alarm";
           case 2 :   i.TypeText.String = "Drop";
           case 7 :   i.TypeText.String = "Settings";
           default:  i.TypeText.String = ""; 
         }
        
          i.DescripText.String = msg;
        
        }
        else
        {   
           i.Visible = false;
        }
        itemNo = itemNo - 1;
        i.InvalidateViewState();
        i = (App::LogItem) i.prev;
      }                     
    }

  }

  $rect <0,510,130,550>
  slot ChckOnOff
  {
    sender; /* the method is called from the sender object */

     

    var int32 n = GetFilter( );

    native( n )
    {
        Command cmd;
        cmd.int0 = n;

        Command0( CMD_GET_MESH_LOG_LENGTH, &cmd );

        n = cmd.int0;
    }

    ListViewer.NoOfItems = n;


  }

  $rect <870,120,1070,160>
  slot RefreshAll
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;
    var App::LogItem i= (App::LogItem)ListViewer.VerticalList.first;

    var int32 filter = GetFilter();
    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    while ( i != null )
    { 
      if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
      {
        i.Visible = true;
        var int32 t = -1;

        var string msg = "---";


        native( t, itemNo, filter, msg )
        {
          char buff[ 129 ];
          Command cmd;
      
          cmd.int0 = itemNo;
          cmd.int1 = filter;
          cmd.int2 = (int) buff;
      
          if ( Command0( CMD_GET_MESH_LOG_LINE, &cmd ) == CMD_OK )
          {
        
            t = cmd.int3;

            msg = EwNewStringAnsi( buff );
          }
        
        }  

        switch (t )
        {
           case 4 :   i.Image.Bitmap = App::log_broadcast;
           case 1 :   i.Image.Bitmap = App::log_status;
           case 5 :   i.Image.Bitmap = App::LogMisc;
           case 6 :   i.Image.Bitmap = App::LogFaults;
           case 0 :   i.Image.Bitmap = App::log_link;
           case 3 :   i.Image.Bitmap = App::LogFire;
           case 2 :   i.Image.Bitmap = App::log_drop;
           case 7 :   i.Image.Bitmap = App::LogSettings;
           default :    i.Image.Bitmap = null;
        }

        switch (t )
        {
           case 4 :   i.TypeText.String = "Broadcast";
           case 1 :   i.TypeText.String = "Status";
           case 5 :   i.TypeText.String = "Misc";
           case 6 :   i.TypeText.String = "Fault";
           case 0 :   i.TypeText.String = "Link";
           case 3 :   i.TypeText.String = "Alarm";
           case 2 :   i.TypeText.String = "Drop";
           case 7 :   i.TypeText.String = "Settings";
           default:  i.TypeText.String = ""; 
        }
        

        i.DescripText.String = msg;
        
      }
      else
      {
        
         i.Visible = false;
      }
      itemNo = itemNo + 1;
       i.InvalidateViewState();
       i = (App::LogItem) i.next;
    }
                         
  }

  $reorder Rectangle9 3
  $reorder OnLoadItem 3
  $reorder Close 3
  $reorder PushButton 1
  $reorder GetFilter 1
  $reorder Sync 1
  $reorder Faults 1
  $reorder Broadcast 1
  $reorder Fire 1
  $reorder Settings 1
  $reorder Mesh 1
  $reorder Status 1
  $reorder Misc 1
}

$rect <1880,550,2080,590>
$output false
resource Resources::Bitmap log_broadcast
{
  attr bitmapfile FileName = .\Images\log_broadcast.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1880,590,2080,630>
$output false
resource Resources::Bitmap log_link
{
  attr bitmapfile FileName = .\Images\log_link.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1880,630,2080,670>
$output false
resource Resources::Bitmap log_status
{
  attr bitmapfile FileName = .\Images\log_status.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1870,500,2070,540>
$output false
resource Resources::Bitmap SwitchMedium2
{
  attr bitmapfile FileName = .\Images\Widgets\SwitchMedium2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize = <69,39>;
  attr framedelay FrameDelay;
}

$rect <1849,420,2049,460>
$output false
resource Resources::Bitmap log_drop
{
  attr bitmapfile FileName = .\Images\log_drop.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1320,550,1520,590>
$output false
resource Resources::Bitmap cygnusblue2
{
  attr bitmapfile FileName = .\Images\cygnusblue2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1740,220,1940,260>
$output false
resource Resources::Bitmap function
{
  attr bitmapfile FileName = .\Images\function.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <40,830,240,870>
$output false
class CountView : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,195,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    Text.String = prefix + " " + string(count) + "/" + string(total);


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,2,190,19>;
    preset String = "Detected 0/0";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,70,220,110>
  property string prefix = "";

  $rect <20,110,220,150>
  onset prefix
  {
    // The value doesn't change - nothing to do.
    if ( pure prefix == value )
      return;

    // Remember the property's new value.
    pure prefix = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <280,0,480,40>
  property int32 count = 0;

  $rect <280,40,480,80>
  onset count
  {
    // The value doesn't change - nothing to do.
    if ( pure count == value )
      return;

    // Remember the property's new value.
    pure count = value;

    HorizontalValueBar1.CurrentValue = value;

    InvalidateViewState( );

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <510,0,710,40>
  property int32 total = 0;

  $rect <510,40,710,80>
  onset total
  {
    // The value doesn't change - nothing to do.
    if ( pure total == value )
      return;

    // Remember the property's new value.
    pure total = value;

    HorizontalValueBar1.MaxValue = value;

    InvalidateViewState( );


    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, ResizeHorz];
    preset Bounds = <0,20,195,40>;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Small;
  }

  $rect <355,130,555,170>
  object Core::Timer Timer
  {
    preset OnTrigger = Slot;
    preset Period = 125;
    preset Enabled = false;
  }

  $rect <550,130,750,170>
  slot Slot
  {
    sender; /* the method is called from the sender object */


    HorizontalValueBar1.Opacity =  HorizontalValueBar1.Opacity + dy;

    if ( HorizontalValueBar1.Opacity >= 255 )
    {
        
       dy = -16;
    }

    if ( HorizontalValueBar1.Opacity <= 32 )
    {
       
       dy = 16;
    }
  }

  $rect <820,20,1020,60>
  property int32 dy = 16;
}

$rect <20,80,170,120>
$output false
class AlarmPopup : App::Popup
{
  $rect <30,320,170,360>
  inherited property Bounds = <0,0,355,250>;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #E1E1E1FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <30,25,80,75>;
    preset Bitmap = App::FireAlarmBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <30,90,80,140>;
    preset Bitmap = App::GreenCallpointBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <30,155,80,205>;
    preset Bitmap = App::evacuate;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirePushButton
  {
    preset Bounds = <120,25,290,75>;
    preset OnActivate = OutsideTap;
    preset Label = "Fire";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstAidButton
  {
    preset Bounds = <120,90,290,140>;
    preset OnActivate = OutsideTap;
    preset Label = "First Aid";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton EvacuateButton
  {
    preset Bounds = <120,155,290,205>;
    preset OnActivate = OutsideTap;
    preset Label = "Evacuate";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <375,95,575,135>
  slot Slot
  {
    if (sender == FirePushButton )
    {
       native
       {
         Command1( CMD_RAISE_ALARM, ACTION_SHIFT_FIRE );
       }
    }
    else if ( sender == FirstAidButton )
    {
     native
       {
         Command1( CMD_RAISE_ALARM, ACTION_SHIFT_FIRST_AID );
       }
    }
    else if ( sender == EvacuateButton )
    {
     native
       {
         Command1( CMD_RAISE_ALARM, ACTION_SHIFT_EVACUATION );
       }
     }    
  }
}

$rect <930,480,1080,520>
$output false
class MeshLogPopup2 : App::Popup
{
  $rect <880,10,1020,50>
  inherited property Bounds = <0,0,800,470>;

  $rect <540,510,680,550>
  inherited method Init()
  {
    signal ChckOnOff;


    if ( ( ListViewer.NoOfItems * ListViewer.ItemHeight ) >  ListViewer.Bounds.h )
    {
      ListViewer.ScrollOffset = ListViewer.NoOfItems * ListViewer.ItemHeight - ListViewer.Bounds.h;
    } 


  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #CBCBCBFF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,360,770,440>;
    preset Color = #C6C6C6FF;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <870,200,1070,240>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;
    var App::LogItem i= (App::LogItem)ListViewer.VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( i == null )
      return;

     if ( itemNo <0 || itemNo >= ListViewer.NoOfItems) 
     {
      i.Visible = false;
      return;
     }

     i.Visible = true;

    var int32 t = -1;
    var int32 filter = GetFilter();
    var string msg = "---";


     
      
      native( t, itemNo, filter, msg )
        {
          char buff[ 128 ];
          Command cmd;
      
          cmd.int0 = itemNo;
          cmd.int1 = filter;
          cmd.int2 = (int) buff;
      
          if ( Command0( CMD_GET_MESH_LOG_LINE, &cmd ) == CMD_OK )
          {
        
            t = cmd.int3;

            msg = EwNewStringAnsi( buff );
          }
       
        }

      

        switch (t )
        {
          case 4 :   i.Image.Bitmap = App::log_broadcast;
           case 1 :   i.Image.Bitmap = App::log_status;
           case 5 :   i.Image.Bitmap = App::LogMisc;
           case 6 :   i.Image.Bitmap = App::LogFaults;
           case 0 :   i.Image.Bitmap = App::log_link;
           case 3 :   i.Image.Bitmap = App::LogFire;
           case 2 :   i.Image.Bitmap = App::log_drop;
           case 7 :   i.Image.Bitmap = App::LogSettings;
           default :    i.Image.Bitmap = null;
        }

        switch (t )
        {
           case 4 :   i.TypeText.String = "Broadcast";
           case 1 :   i.TypeText.String = "Status";
           case 5 :   i.TypeText.String = "Misc";
           case 6 :   i.TypeText.String = "Fault";
           case 0 :   i.TypeText.String = "Link";
           case 3 :   i.TypeText.String = "Alarm";
           case 2 :   i.TypeText.String = "Drop";
           case 7 :   i.TypeText.String = "Settings";
           default:  i.TypeText.String = ""; 
        }

     

    i.DescripText.String = msg;

                                                                                                              
  }

  $rect <900,270,1100,310>
  slot Close
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <599,376,749,426>;
    preset OnRelease = Close;
    preset Label = "Close";
    preset Appearance = App::NormalPushButton;
  }

  $rect <840,500,960,540>
  method int32 GetFilter()
  {
    /* The template just returns the given argument... */

    var int32 filter = 0;

    if ( Sync.Checked )   filter = filter | 1;
    if ( Faults.Checked )   filter = filter | 64;
    if ( Broadcast.Checked )   filter = filter | 16;
    if ( Fire.Checked )     filter = filter | 8;
    if ( Misc.Checked )     filter = filter | 32;
    if ( Mesh.Checked )   filter = filter | 4;
    if ( Settings.Checked ) filter = filter | 128;
    if ( Status.Checked )  filter = filter | 2;

    return filter;
  }

  $rect <880,320,1080,360>
  object Core::SystemEventHandler LogEventHandler
  {
    preset OnEvent = null;
    preset Event = App::Devices.LogListChangeEvent;
  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <20,20,750,345>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::LogItem;
    preset ItemHeight = 25;
    preset NoOfItems = 10;
    preset onRefreshAll = RefreshAll;
    preset onScrollRefresh = ScrollRefresh;
  }

  $rect <860,160,1060,200>
  slot ScrollRefresh
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;


    var int32 filter = GetFilter();

    // if span up / scroll down
    if ( ListViewer.StartRow < itemNo )
    {  
      var App::LogItem i = (App::LogItem)ListViewer.VerticalList.first;
      var App::LogItem j = i;

      var int32 diff = itemNo - ListViewer.StartRow;
      var int32 n = 0;

      while ( j != null && n < diff )
      {
         j = (App::LogItem) j.next;
         n = n + 1;
      }

      while ( i != null && j != null )
      { 
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          i.Image.Bitmap = j.Image.Bitmap;
          i.DescripText.String = j.DescripText.String;
          i.TypeText.String = j.TypeText.String;
          i.Visible = true;
        }
        else
        {
          i.Visible = false;
        }
        i.InvalidateViewState();
        itemNo = itemNo + 1;
        j = (App::LogItem) j.next;
        i = (App::LogItem) i.next; 
      }
      while ( i != null )
      {
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          var int32 t = -1;

          var string msg = "---";

          i.Visible = true;

          native( t, itemNo, filter, msg )
          {
            char buff[ 129 ];
            Command cmd;
      
            cmd.int0 = itemNo;
            cmd.int1 = filter;
            cmd.int2 = (int) buff;
      
            if ( Command0( CMD_GET_MESH_LOG_LINE, &cmd ) == CMD_OK )
            {
        
              t = cmd.int3;

              msg = EwNewStringAnsi( buff );
            }
        
          }  

          switch (t )
          {  
          case 4 :   i.Image.Bitmap = App::log_broadcast;
           case 1 :   i.Image.Bitmap = App::log_status;
           case 5 :   i.Image.Bitmap = App::LogMisc;
           case 6 :   i.Image.Bitmap = App::LogFaults;
           case 0 :   i.Image.Bitmap = App::log_link;
           case 3 :   i.Image.Bitmap = App::LogFire;
           case 2 :   i.Image.Bitmap = App::log_drop;
           case 7 :   i.Image.Bitmap = App::LogSettings;
           default :    i.Image.Bitmap = null;
        }

        switch (t )
        {
           case 4 :   i.TypeText.String = "Broadcast";
           case 1 :   i.TypeText.String = "Status";
           case 5 :   i.TypeText.String = "Misc";
           case 6 :   i.TypeText.String = "Fault";
           case 0 :   i.TypeText.String = "Link";
           case 3 :   i.TypeText.String = "Alarm";
           case 2 :   i.TypeText.String = "Drop";
           case 7 :   i.TypeText.String = "Settings";
             default:  i.TypeText.String = ""; 
          }
        
          i.DescripText.String = msg;
        
        }
        else
        {
        
           i.Visible = false;
        }
        itemNo = itemNo + 1;
        i.InvalidateViewState();
        i = (App::LogItem) i.next;
      }
    }
    else  // scroll up / pan down
    {
      var App::LogItem i = (App::LogItem) ListViewer.VerticalList.last;
      var App::LogItem j = i;

      var int32 diff = ListViewer.StartRow - itemNo;
      var int32 n = 0;

      while ( j != null && n < diff )
      {
         j = (App::LogItem) j.prev;
         n = n + 1;
      }

      itemNo = itemNo + 12;

      while ( i != null && j != null )
      { 
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          i.Image.Bitmap = j.Image.Bitmap;
          i.DescripText.String = j.DescripText.String;
          i.TypeText.String = j.TypeText.String;
          i.Visible = true;
        }
        else
        {
          i.Visible = false;
        }
        i.InvalidateViewState();
        itemNo = itemNo - 1;
        j = (App::LogItem) j.prev;
        i = (App::LogItem) i.prev; 
      }
      while ( i != null )
      {
        if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
        {
          var int32 t = -1;

          var string msg = "---";

          i.Visible = true;

          native( t, itemNo, filter, msg )
          {
            char buff[ 129 ];
            Command cmd;
      
            cmd.int0 = itemNo;
            cmd.int1 = filter;
            cmd.int2 = (int) buff;
      
            if ( Command0( CMD_GET_MESH_LOG_LINE, &cmd ) == CMD_OK )
            {
        
              t = cmd.int3;

              msg = EwNewStringAnsi( buff );
            }
        
          }  

          switch (t )
          {  
           case 4 :   i.Image.Bitmap = App::log_broadcast;
           case 1 :   i.Image.Bitmap = App::log_status;
           case 5 :   i.Image.Bitmap = App::LogMisc;
           case 6 :   i.Image.Bitmap = App::LogFaults;
           case 0 :   i.Image.Bitmap = App::log_link;
           case 3 :   i.Image.Bitmap = App::LogFire;
           case 2 :   i.Image.Bitmap = App::log_drop;
           case 7 :   i.Image.Bitmap = App::LogSettings;
           default :    i.Image.Bitmap = null;
        }

        switch (t )
        {
           case 4 :   i.TypeText.String = "Broadcast";
           case 1 :   i.TypeText.String = "Status";
           case 5 :   i.TypeText.String = "Misc";
           case 6 :   i.TypeText.String = "Fault";
           case 0 :   i.TypeText.String = "Link";
           case 3 :   i.TypeText.String = "Alarm";
           case 2 :   i.TypeText.String = "Drop";
           case 7 :   i.TypeText.String = "Settings";
             default:  i.TypeText.String = ""; 
          }
        
          i.DescripText.String = msg;
        
        }
        else
        {   
           i.Visible = false;
        }
        itemNo = itemNo - 1;
        i.InvalidateViewState();
        i = (App::LogItem) i.prev;
      }                     
    }

  }

  $rect <0,510,130,550>
  slot ChckOnOff
  {
    sender; /* the method is called from the sender object */

     

    var int32 n = GetFilter( );

    native( n )
    {
        Command cmd;
        cmd.int0 = n;

        Command0( CMD_GET_MESH_LOG_LENGTH, &cmd );

        n = cmd.int0;
    }

    ListViewer.NoOfItems = n;


  }

  $rect <870,120,1070,160>
  slot RefreshAll
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListViewer.Item;
    var App::LogItem i= (App::LogItem)ListViewer.VerticalList.first;

    var int32 filter = GetFilter();
    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    while ( i != null )
    { 
      if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
      {
        i.Visible = true;
        var int32 t = -1;

        var string msg = "---";


        native( t, itemNo, filter, msg )
        {
          char buff[ 129 ];
          Command cmd;
      
          cmd.int0 = itemNo;
          cmd.int1 = filter;
          cmd.int2 = (int) buff;
      
          if ( Command0( CMD_GET_MESH_LOG_LINE, &cmd ) == CMD_OK )
          {
        
            t = cmd.int3;

            msg = EwNewStringAnsi( buff );
          }
        
        }  

        switch (t )
        {  
           case 4 :   i.Image.Bitmap = App::log_broadcast;
           case 1 :   i.Image.Bitmap = App::log_status;
           case 5 :   i.Image.Bitmap = App::LogMisc;
           case 6 :   i.Image.Bitmap = App::LogFaults;
           case 0 :   i.Image.Bitmap = App::log_link;
           case 3 :   i.Image.Bitmap = App::LogFire;
           case 2 :   i.Image.Bitmap = App::log_drop;
           case 7 :   i.Image.Bitmap = App::LogSettings;
           default :    i.Image.Bitmap = null;
        }

        switch (t )
        {
           case 4 :   i.TypeText.String = "Broadcast";
           case 1 :   i.TypeText.String = "Status";
           case 5 :   i.TypeText.String = "Misc";
           case 6 :   i.TypeText.String = "Fault";
           case 0 :   i.TypeText.String = "Link";
           case 3 :   i.TypeText.String = "Alarm";
           case 2 :   i.TypeText.String = "Drop";
           case 7 :   i.TypeText.String = "Settings";
           default:  i.TypeText.String = ""; 
        }
        

        i.DescripText.String = msg;
        
      }
      else
      {
        
         i.Visible = false;
      }
      itemNo = itemNo + 1;
       i.InvalidateViewState();
       i = (App::LogItem) i.next;
    }
                         
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Sync
  {
    preset Bounds = <20,360,160,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Link";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Faults
  {
    preset Bounds = <180,360,297,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Faults";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Broadcast
  {
    preset Bounds = <320,360,450,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Broadcast";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Fire
  {
    preset Bounds = <20,400,160,440>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Fire/Alarm";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Settings
  {
    preset Bounds = <470,360,587,400>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Settings";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Mesh
  {
    preset Bounds = <180,400,310,440>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Drop";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Status
  {
    preset Bounds = <320,400,437,440>;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Status";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Misc
  {
    preset Bounds = <471,400,588,440>;
    preset Enabled = true;
    preset Visible = true;
    preset Checked = true;
    preset OnSwitchOn = ChckOnOff;
    preset OnSwitchOff = ChckOnOff;
    preset Label = "Misc.";
    preset Appearance = App::SmallCheckBoxCaption;
  }

  $reorder Rectangle9 3
  $reorder OnLoadItem 3
  $reorder Close 3
  $reorder PushButton 1
  $reorder GetFilter 1
}

$rect <1260,-9,1410,31>
$output false
class UserButton : Core::Group
{
  $rect <0,260,200,300>
  inherited property Bounds = <0,0,80,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

      Path1.InitSubPath( 0, 4 + 20  );
    //  Path1.Translate( 1,1 )    ;
      Path1.Begin( 0, pure Radius, 0 );
      Path1.AddArc( 0, Bounds.w-2 - pure Radius , pure Radius, pure Radius, pure Radius, -90, 0, 5 );
      Path1.AddArc( 0, Bounds.w-2 - pure Radius , Bounds.h-3 - pure Radius, pure Radius, pure Radius, 0, 90, 5 );
      Path1.AddArc( 0, pure Radius , Bounds.h-3 - pure Radius, pure Radius, pure Radius, 90, 180, 5 );
      Path1.AddArc( 0, pure Radius , pure Radius, pure Radius, pure Radius, 180, 270, 5 );
      Path1.Close( 0 );
      return;


    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var App::Application app = (App::Application) GetRoot( ) ;

    if ( app != null )
    {
      if ( Elevation > ((App::Application)GetRoot() ).LevelAccess.AccessLevel )
      {
          Greyed.Visible = true;
      }
      else
      {
          Greyed.Visible = false;
      }
    }

    Text.String = string( ButtonIndex + 1 );


    var int32 i = ButtonIndex;
    var string s = "";

    native( i, s )
    {
      Command cmd;
      
      cmd.int0 = i;
      Command0( CMD_GET_USER_BUTTON_ACTION, &cmd );

      s = EwNewStringAnsi( (char*) cmd.int1 ); 
    }

    AttrText.String = s;



    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <665,125,805,165>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    // Assume the worst case of a ring composed of two ellipsis thus
    // two sub-paths.

      Path1.InitSubPath( 0, 4 + 20  );
      Path1.Translate( 1,1 )    ;
      Path1.Begin( 0, pure Radius, 0 );
      Path1.AddArc( 0, Bounds.w-2 - pure Radius , pure Radius, pure Radius, pure Radius, -90, 0, 5 );
      Path1.AddArc( 0, Bounds.w-2 - pure Radius , Bounds.h-3 - pure Radius, pure Radius, pure Radius, 0, 90, 5 );
      Path1.AddArc( 0, pure Radius , Bounds.h-3 - pure Radius, pure Radius, pure Radius, 90, 180, 5 );
      Path1.AddArc( 0, pure Radius , pure Radius, pure Radius, pure Radius, 180, 270, 5 );
      Path1.Close( 0 );
      return;

  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,80,45>;
    preset Color = #E2E2E2FF;
    preset Quality = false;
    preset Path = Path1;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::AttrText AttrText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <3,20,78,45>;
    preset WrapWidth = 0;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Routing Ack";
    preset AttrSet = App::AttrSetFireChannel;
  }

  $rect <20,20,160,60>
  object Views::StrokePath StrokePath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,80,45>;
    preset Color = #646464FF;
    preset Quality = true;
    preset JoinPoints = Graphics::PathJoin.Round;
    preset Width = 2;
    preset Path = Path1;
  }

  $rect <310,160,510,200>
  object Graphics::Path Path1;

  $rect <790,0,990,40>
  property int32 Radius = 5;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <80,0>;
    preset Point2 = <80,45>;
    preset Point1 = <0,45>;
    preset OnRelease = Release;
    preset OnPress = Touch;
  }

  $rect <205,10,370,40>
  property slot ActionPress = null;

  $rect <265,95,395,135>
  slot Touch
  {
    sender; /* the method is called from the sender object */




    if ( ((App::Application)GetRoot()).LevelAccess.AccessLevel >= Elevation )
    {
      postsignal ActionPress;
    }
    else
    {
       ((App::Application)GetRoot()).LowLevel( Elevation );
    }




  }

  $rect <410,100,540,140>
  slot Release
  {
    sender; /* the method is called from the sender object */




    if ( ((App::Application)GetRoot()).LevelAccess.AccessLevel >= Elevation )
    {
      postsignal ActionRelease;
    }



  }

  $rect <0,190,130,230>
  property int8 Elevation = 1;

  $rect <210,50,370,90>
  property slot ActionRelease = null;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <1,1,79,19>;
    preset Bitmap = App::lillybutton;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Greyed
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,80,45>;
    preset Color = #ECECEC96;
  }

  $rect <5,110,205,150>
  property int32 ButtonIndex = 0;

  $rect <450,40,650,80>
  object Core::SystemEventHandler SystemEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = App::Devices.SiteChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <440,0,640,40>
  slot onEvent
  {
     
    InvalidateViewState( );



  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <49,1,69,21>;
    preset String = "2";
    preset Font = App::FontMediumBold;
  }
}

$rect <1309,100,1509,140>
$output false
resource Resources::Bitmap lillybutton
{
  attr bitmapfile FileName = .\Images\lillybutton.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <340,529,540,569>
$output false
class PanelNetStat : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,190,140>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,140,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel One";
    preset Font = Flat::FontM;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <1,40,98,70>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Packets rx";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <100,40,187,67>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "99999999";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <0,70,97,100>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Packets rx";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }
}

$rect <149,529,329,569>
$output false
class PanelNetworking : Core::Group
{
  $rect <30,400,230,440>
  inherited property Bounds = <0,0,790,350>;

  $rect <20,490,220,530>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <20,450,220,490>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <820,50,1020,90>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = HorizontalList.Item;
    var Views::Image itemView = (Views::Image)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.Bitmap      = Resources::SymbolIconsLarge;
    itemView.FrameNumber = ( itemNo % itemView.Bitmap.NoOfFrames );

    switch ( itemNo % 4 )
    {
      case 1  : itemView.Color = #0000FFFF;
      case 2  : itemView.Color = #FF0000FF;
      case 3  : itemView.Color = #00FF00FF;
      default : itemView.Color = #FFFF00FF;
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,0,600,120>;
    preset OnLoadItem = OnLoadItem1;
    preset ItemWidth = 120;
    preset NoOfItems = 5;
    preset ItemClass = App::PanelNetStat;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <180,250,380,290>
  slot OnLoadItem1
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = HorizontalList.Item;
    var Views::Image itemView = (Views::Image)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.Bitmap      = Resources::SymbolIconsLarge;
    itemView.FrameNumber = ( itemNo % itemView.Bitmap.NoOfFrames );

    switch ( itemNo % 4 )
    {
      case 1  : itemView.Color = #0000FFFF;
      case 2  : itemView.Color = #FF0000FF;
      case 3  : itemView.Color = #00FF00FF;
      default : itemView.Color = #FFFF00FF;
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }
}

$rect <1130,170,1330,210>
$output false
resource Resources::Bitmap goodbyeelise
{
  attr bitmapfile FileName = .\Images\54_CygnusFavicon.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <860,409,1010,449>
$output false
class RadioSetup : App::Popup
{
  $rect <690,40,830,80>
  inherited property Bounds = <0,0,530,420>;

  $rect <20,430,250,480>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 

    var int32 id = 0;
    var string encrypt = "";
    var bool acu = false;

    native( id, encrypt, acu )
    {
        Command cmd;

        Command0( CMD_GET_RADIO_SETTINGS, &cmd );

        if ( cmd.int1 != 0 )
        {
          id = cmd.int0;
          encrypt = EwNewStringAnsi( (char*) cmd.int1 );
          acu = cmd.int2;
        }
    }

    var int32 c;    

    for( c = 0; c < encrypt.length; c = c + 1 )
    {
        if ( encrypt[ c] == '-' ) encrypt = encrypt.remove( c, 1 );
    }

    Text3.String = encrypt.upper;
    Text2.String = string( id );

    PushButton2.Enabled = acu;

    if ( acu ) 
    {
      AddLine( "ACUMESH CONNECTED.." );
    }
    else
    {
      AddLine( "PLEASE CONNECT THE RADIO" );
      AddLine( "USING THE USB CABLE." );
    }

     
  }

  $rect <70,480,210,520>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    DropDownMenu.MenuSelectionText.String = "9600";
    DropDownMenu.VerticalList.SelectedItem = 0;

  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #D1D1D1FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle10
  {
    preset Bounds = <130,100,270,140>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle11
  {
    preset Bounds = <120,160,420,200>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <130,100,270,140>;
    preset Width = 2;
    preset ColorL = #2B2B2BFF;
    preset ColorR = #AAAAAAFF;
    preset ColorB = #AAAAAAFF;
    preset ColorT = #2B2B2BFF;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel1
  {
    preset Bounds = <120,160,420,200>;
    preset Width = 2;
    preset ColorL = #2B2B2BFF;
    preset ColorR = #AAAAAAFF;
    preset ColorB = #AAAAAAFF;
    preset ColorT = #2B2B2BFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <22,159,126,198>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Encryption";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <22,99,136,138>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Network ID";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <428,156,488,202>;
    preset Checked = true;
    preset OnSwitchOn = Encrpt;
    preset OnSwitchOff = Encrpt;
    preset Label = "";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <307,99,357,139>;
    preset OnActivate = Up;
    preset IconFrame = 0;
    preset Icon = Resources::NavigationIconsSmall;
    preset Label = "";
    preset Appearance = App::SmallPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <364,99,414,139>;
    preset OnActivate = Down;
    preset IconFrame = 1;
    preset Icon = Resources::NavigationIconsSmall;
    preset Label = "";
    preset Appearance = App::SmallPushButton;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <138,108,262,132>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "12345";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <130,170,410,190>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "ABCDEF0123456789ABCDEF0123456789";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <305,240,478,290>;
    preset OnActivate = Configure;
    preset Label = "Configure Radio";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Bounds = <26,235,275,375>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <31,240,270,369>;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 16;
    preset NoOfItems = 8;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <750,170,950,210>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Views::Text itemView = (Views::Text)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = " ";//Item #" + string( itemNo );
    itemView.Font   = App::TerminalFont;
    itemView.Color  = #00FF00FF;
    itemView.Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );

     
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <306,325,476,373>;
    preset OnActivate = Close;
    preset Label = "Close";
    preset Appearance = App::NormalPushButton;
  }

  $rect <530,10,640,50>
  slot Up
  {
    sender; /* the method is called from the sender object */

    var int32 x =  Text2.String.parse_int32( 0 );

    if ( x < 32767 )
      x = x + 1;

    Text2.String = string( x );


  }

  $rect <590,30,700,70>
  slot Down
  {
    sender; /* the method is called from the sender object */

     
    var int32 x =  Text2.String.parse_int32( 0 );

    if ( x > 0 )
      x = x - 1;

    Text2.String = string( x );

  }

  $rect <600,90,800,130>
  slot Encrpt
  {
    sender; /* the method is called from the sender object */

     
    if ( ToggleButton.Checked )
    {
    //  Frame1.FrameNumber = 2;
      Text3.Color = #000000FF;
      Bevel1.ColorB =#AAAAAAFF;
      Bevel1.ColorL =#2B2B2BFF;
      Bevel1.ColorR =#AAAAAAFF;
      Bevel1.ColorT =#2B2B2BFF;
       

    }
    else 
    {
       Text3.Color = #AAAAAAFF;
     Bevel1.ColorB =#BBBBBBFF;
      Bevel1.ColorL =#BBBBBBFF;
      Bevel1.ColorR =#BBBBBBFF;
      Bevel1.ColorT =#BBBBBBFF;
    }

     
      


  }

  $rect <540,170,730,210>
  slot Configure
  {
    sender; /* the method is called from the sender object */

    var int32 id = Text2.String.parse_int32( 0 ) ;
     
    var bool aes = ToggleButton.Checked;
     
    var int32 i;

    var int32 baud = DropDownMenu.MenuSelectionText.String.parse_int32( 9600 );

    var string key = Text3.String;

    native( id, key, aes, baud )
    {   
        char dest[ 34 ];
       EwStringToAnsi( key, dest, 34, '0' );

       if ( Command4( CMD_SET_RADIO_SETTINGS, id, (int) dest, aes, baud ) == CMD_OK )
       {
          // AddLine( "SUCCESS!" );
       }
    }

  }

  $rect <720,260,920,300>
  method void AddLine( arg string s )
  {
    var Views::Text tv = (Views::Text) VerticalList.first;

    if ( tv != null )
    while (  tv.next != null )
    {
      var Views::Text nxt = ( Views::Text) tv.next;

      tv.String = nxt.String;

      tv = nxt;
    }

    tv.String = s;
     
  }

  $rect <550,270,650,310>
  slot Close
  {
    sender; /* the method is called from the sender object */

    native
    {
      Command1( CMD_EXIT_RADIO_SETTINGS, 0 ); 
    }

    Hide();


  }

  $rect <590,400,790,440>
  object Core::SystemEventHandler AcumeshEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = App::Devices.AcumeshEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler1' \
  // receives an event.
  $rect <800,400,920,440>
  slot onEvent
  {
    var App::Progress p = (App::Progress)  AcumeshEventHandler.Context;

     
    switch( p.amount )
    { 
      case 1 : 
      {
           PushButton2.Enabled = true;
           AddLine( "ACUMESH CONNECTED.." );
      }
      case  0:
      {
           PushButton2.Enabled = false;
           AddLine( "ACUMESH DISCONNECTED.." );
      }

      case 2 : 
      {
           AddLine( "SETTING BAUD.." );
      }

      case -2 :
      {
           PushButton2.Enabled = false;
           AddLine( "BAUD FAIL.." );
      }
      case 3 : 
      {
           AddLine( "STARTING.." );
      }
      case 4 : 
      {
           AddLine( "SETTING ID.." );
      }
      case 5 : 
      {
           AddLine( "SETTING ENCRYPTION KEY.." );
      }
      case 6 : 
      {
           AddLine( "SWITCHING ENCRYPTION.." );
      }
      case 7 : 
      {
           AddLine( "SETTING DATA RATE.." );
      }
      case 8 : 
      {
           AddLine( "SUCCESS. FINSHED." );
      }
      case -3 : 
      {
           AddLine( "..." );
      }
    }

  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Bounds = <24,28,71,61>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Baud";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::DropDownMenu DropDownMenu
  {
    preset Bounds = <84,20,290,268>;
    preset onSelection = Select;
    preset GetItemCallback = GetItems;
    preset numItems = 5;
  }

  $rect <490,470,690,510>
  slot GetItems
  {
    sender; /* the method is called from the sender object */



    switch( DropDownMenu.itemIndex )
    {
        case 0: DropDownMenu.itemName = "9600";
        case 1: DropDownMenu.itemName = "19200";
        case 2: DropDownMenu.itemName = "38400";
        case 3: DropDownMenu.itemName = "57600";
        case 4: DropDownMenu.itemName = "115200";
    }
  }

  $rect <850,90,950,130>
  slot Select
  {
    sender; /* the method is called from the sender object */

    native
    {
      Command1( CMD_CHANGE_RADIO_SETTINGS, 0 ); 
    }

     
  }

  $reorder Owner 1
  $reorder viewShape 1
  $reorder viewState 1
  $reorder layoutContext 1
  $reorder initLayoutContext 1
  $reorder OnSetLayout 1
  $reorder GetRoot 1
  $reorder Draw 1
  $reorder HandleEvent 1
  $reorder CursorHitTest 1
  $reorder ArrangeView 1
  $reorder MoveView 1
  $reorder GetExtent 1
  $reorder ChangeViewState 1
  $reorder Layout 1
  $reorder OnSetBounds 1
  $reorder Bounds 1
  $reorder first 1
  $reorder last 1
  $reorder keyHandlers 1
  $reorder buffer 1
  $reorder dialogStack 1
  $reorder fadersQueue 1
  $reorder pendingFader 1
  $reorder processKeyHandlers 1
  $reorder updateBufferSlot 1
  $reorder drawContent 1
  $reorder recalculateLayout 1
  $reorder updateComponent 1
  $reorder OnSetFocus 1
  $reorder OnGetBuffered 1
  $reorder OnSetBuffered 1
  $reorder OnGetEnabled 1
  $reorder OnSetEnabled 1
  $reorder OnSetOpacity 1
  $reorder OnGetEmbedded 1
  $reorder OnSetEmbedded 1
  $reorder OnGetAlphaBlended 1
  $reorder OnSetAlphaBlended 1
  $reorder OnGetVisible 1
  $reorder OnSetVisible 1
  $reorder FindActiveDialogByClass 1
  $reorder FindDialogByClass 1
  $reorder FindCurrentDialog 1
  $reorder IsCurrentDialog 1
  $reorder IsActiveDialog 1
  $reorder IsDialog 1
  $reorder GetIndexOfDialog 1
  $reorder GetDialogAtIndex 1
  $reorder CountDialogs 1
  $reorder SwitchToDialog 1
  $reorder DismissDialog 1
  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder Init 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Focus 2
  $reorder Buffered 2
  $reorder Enabled 2
  $reorder Opacity 2
  $reorder Embedded 2
  $reorder AlphaBlended 2
  $reorder Visible 2
  $reorder Bounds1 2
  $reorder Add 1
  $reorder Rectangle 2
  $reorder Rectangle1 2
  $reorder Rectangle2 2
  $reorder Rectangle4 2
  $reorder Rectangle5 2
  $reorder Rectangle6 2
  $reorder Rectangle7 2
  $reorder Rectangle8 2
  $reorder InsideTouchHandler 1
  $reorder Show 2
  $reorder mask 2
  $reorder touch 2
  $reorder root 2
  $reorder Hide 2
  $reorder Parent 2
  $reorder SystemEventHandler 2
  $reorder FireHide 2
  $reorder SystemEventHandler2 2
  $reorder EventHide 2
  $reorder Dead 2
  $reorder onHide 2
  $reorder Background 1
  $reorder Rectangle10 3
  $reorder Rectangle11 3
  $reorder Bevel 3
  $reorder OutsideTap 1
  $reorder Bevel1 2
  $reorder Text 2
  $reorder Text1 2
  $reorder ToggleButton 2
  $reorder PushButton 2
  $reorder PushButton1 2
  $reorder Text2 2
  $reorder Text3 2
  $reorder PushButton2 2
  $reorder Rectangle9 2
  $reorder VerticalList 2
  $reorder OnLoadItem 2
  $reorder PushButton3 2
  $reorder Up 2
  $reorder Down 2
  $reorder Encrpt 2
  $reorder Configure 2
  $reorder CatchBackgroundTap 1
  $reorder AddLine 1
  $reorder Close 1
  $reorder AcumeshEventHandler 1
  $reorder onEvent 1
  $reorder Text4 1
  $reorder DropDownMenu 1
  $reorder GetItems 1
  $reorder Select 1
}

$rect <0,650,200,690>
$output false
resource Resources::Font TerminalFont
{
  attr fontname FontName = Lucida Console;
  attr fontheight Height = 16;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x60;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <1289,69,1489,109>
$output false
resource Resources::Bitmap outputs_off
{
  attr bitmapfile FileName = .\Images\outputs_off.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1089,420,1199,460>
$output false
class AcuMesh
{
  $rect <0,0,200,40>
  property string response = "";
}

$rect <10,1540,190,1580>
$output false
class UpdateDevicePopup : App::Popup
{
  $rect <0,250,140,290>
  inherited property Bounds = <0,0,430,230>;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #AEAEAEFF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <38,80,368,125>;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <38,43,218,68>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Updating Device...";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <148,149,260,190>;
    preset OnRelease = CancelSlot;
    preset Label = "Close";
    preset Appearance = App::NormalPushButton;
  }

  $rect <170,250,310,290>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

        
    ProgressHandler.Enabled = false;    
        

    Hide();


  }

  $rect <530,70,730,110>
  object Core::SystemEventHandler ProgressHandler
  {
    preset OnEvent = ProgressEvent;
    preset Event = App::Devices.UpdateDeviceEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <510,220,710,260>
  slot ProgressEvent
  {
    if ( !this.Dead )
    {
     
    var App::Progress p = (App::Progress) ProgressHandler.Context;

    if ( PushButton.Label != "Failed" )
    {

      if ( p.amount == -1  )
      {
       PushButton.Label = "Failed";
       HorizontalValueBar.CurrentValue = 0;
     
      }
      else  if ( p.amount == 100 )
      {
       PushButton.Label = "Success";  
       HorizontalValueBar.CurrentValue = 100; 
      }
      else
      {
         HorizontalValueBar.CurrentValue = p.amount;
      }
    }

     
    }


    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <160,360,360,400>
  slot SetConfigTrue
  {
     
    var App::ModifyPopup p = (App::ModifyPopup) sender;
     
                        
    App::Lib.SetConfig( p.device.unitnum, true, p.device );
     
  }

  $rect <130,420,330,460>
  slot SetConfigFalse
  {
    var App::ModifyPopup p = (App::ModifyPopup) sender;
     
    App::Lib.SetConfig( p.device.unitnum, false, p.device );
      
  }
}

$rect <890,1050,1090,1090>
$output false
autoobject App::OutputChannel DummyOutputChan1
{
  preset flags = App::Options[Coincidence];
  preset actions = App::ActionBits[Evacuation, Fire, FirstAid];
  preset type = App::ChannelType.Beacon;
}

$rect <1340,0,1540,40>
$output false
resource Resources::Bitmap ontest
{
  attr bitmapfile FileName = .\Images\ontest.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <840,449,990,489>
$output false
class AppSupportPopup : App::Popup
{
  $rect <30,480,170,520>
  inherited property Bounds = <0,0,700,460>;

  $rect <770,300,910,340>
  inherited method Init()
  {
    // TO DO: Write your code here ... 



    postsignal SetFocus;

  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #D4D4D4FF;
  }

  $rect <20,20,160,60>
  object App::MattsKeyboard MattsKeyboard
  {
    preset Bounds = <21,206,611,414>;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <28,35,122,63>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Site Key";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <535,293,655,342>;
    preset OnActivate = OK;
    preset Label = "Set";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <533,364,653,415>;
    preset OnActivate = Cancel;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <740,180,940,220>
  slot SetFocus
  {
    sender; /* the method is called from the sender object */


    KeyWritable.TextEditor1.ObtainFocus();


    var string k="";
    var string a="";
    var string p="";

    native( a, k, p )
    {
      Command cmd;

      Command0( CMD_GET_APP_SETUP, &cmd );

      k = EwNewStringAnsi( (char*) cmd.int0 );
      p = EwNewStringAnsi( (char*) cmd.int1 );
      a = EwNewStringAnsi( (char*) cmd.int2 );
    }

    KeyWritable.TextEditor1.String = k;
    APN.TextEditor1.String = a;
    PWD.TextEditor1.String = p;


     $if (!$prototyper)

    MattsKeyboard.Keyboard.KeybBmp2.Pressed = true;
    MattsKeyboard.Keyboard.KeybBmp2.Pressed = false;

    $endif


  }

  $rect <610,470,810,510>
  slot Cancel
  {
    sender; /* the method is called from the sender object */


    this.Hide();



  }

  $rect <730,380,930,420>
  slot OK
  {
    sender; /* the method is called from the sender object */


    var string key = KeyWritable.TextEditor1.String;
    var string apn = APN.TextEditor1.String;
    var string pwd = PWD.TextEditor1.String;


    if ( key.length != 11 )
    {
      var App::AccesssPopup ll = new App::AccesssPopup;
     
       ll.Text.String = "Site key should be 11 characters in length.";
       ll.Show( GetRoot() );
       return;
    }

    if ( apn.length > 40 )
    {
      var App::AccesssPopup ll = new App::AccesssPopup;
     
       ll.Text.String = "APN should have a maximum of 40 characters in length.";
       ll.Show( GetRoot() );
       return;
    }
    if ( pwd.length > 40 )
    {
      var App::AccesssPopup ll = new App::AccesssPopup;
     
       ll.Text.String = "Password should have a maximum of 40 characters in length.";
       ll.Show( GetRoot() );
       return;
    }

    native( key, apn, pwd )
    {
      char k[ 17];
      char a[ 41];
      char p[ 41];

      EwStringToAnsi( key, k, 17, '_' );
      EwStringToAnsi( apn, a, 41, '_' );
      EwStringToAnsi( pwd, p, 41, '_' );


      Command3( CMD_SETUP_APP, (int) k, (int) p, (int) a );
    }


    this.Hide();



  }

  $rect <20,20,160,60>
  object App::Writable1 KeyWritable
  {
    preset Bounds = <160,-1,610,69>;
    preset MaxLength = 32;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <26,89,153,120>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "APN / WiFi";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::Writable1 APN
  {
    preset Bounds = <160,55,610,125>;
    preset MaxLength = 40;
  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Bounds = <26,147,153,178>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Password";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::Writable1 PWD
  {
    preset Bounds = <159,112,609,182>;
    preset MaxLength = 40;
  }
}

// This component implements an editor.
$rect <1100,1709,1300,1749>
$output false
class TextEditor1 : Templates::TextEditor
{
  $rect <670,620,870,660>
  inherited property Bounds = <0,0,160,65>;

  $rect <680,280,880,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited version of the method
    super( aState );

    // Activate the caret blinking if the editor component has the input focus
    if ( aState.contains( Core::ViewState[ Focused ]))
      blinkEffect.Enabled = true;

    // ... otherwise hide the caret
    else
    {
      blinkEffect.Enabled = false;
      Caret.Visible       = false;
    }
  }

  // To do:
  // 
  // - Adjust the visible size of the text editor (the thick blue border). This will \
  // be the editor's default size.
  // - Resize and arrange the member 'Text' so it covers the area where you intend \
  // to display the text. This is usually the entire area.
  // - Adjust the position and the size of the 'SimpleTouchHandler' and 'SlideTouchHandler', \
  // so they cover the 'Text' view.
  // - If your design it expects, add and configure more views in the component, \
  // e.g. views to display background, borders, etc.
  // - The editor implements several handler to process keyboard inputs. See the \
  // annotation 'Keyboard events'. Feel free to add more handler for other key events \
  // or remove the handler you don't need in your version.
  // - The editor displays a magnifying glass when the user touches and holds the \
  // finger for a while (see the method 'onHoldTouch'). If you don't want it, remove \
  // the contents within the annotation 'Magnifying glass' and the slot method 'onHoldTouch'.
  // - The editor reacts to touch interactions. See the annotation 'Touch screen \
  // events'. If your device is not touch driven, you can remove the both handlers \
  // 'SimpleTouchHandler', 'SlideTouchHandler' and the methods from the annotation \
  // 'Touch screen events'.
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the editor's current state (e.g. focused editor \
  // may appear with other colors, etc.)
  // - The editor is implemented with various properties allowing the configuration \
  // of the text (e.g. 'Font', 'Color', ...). If your version of the editor doesn't \
  // need such configuration, remove the properties and the associated OnSet methods.
  // - If you need other properties to configure the editor, add from the Gallery \
  // folder 'Chora' new properties. One property for every new setting (e.g. 'BorderWidth', \
  // etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'BorderWidth' should update the eventually used 'Border' \
  // view, etc.).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note6
  {
    attr Bounds = <10,690,990,1150>;
  }

  // Magnifying glass
  note group Note5
  {
    attr Bounds = <440,500,660,670>;
  }

  // Caret
  note group Note4
  {
    attr Bounds = <10,500,430,670>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <670,240,890,330>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <440,240,660,450>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <10,240,430,490>;
  }

  // This internal variable refers to a temporary Views::Image object used to show \
  // the background for the augmented text content around the caret. This view appears \
  // during the user is moving this caret by touching the caret with the finger.
  $rect <450,620,650,660>
  var Views::Rectangle magnifyingBack = null;

  // This internal variable refers to a temporary Views::WarpGroup object used to \
  // show the augmented text content around the caret. This view appears during the \
  // user is moving this caret by touching the caret with the finger.
  $rect <450,580,650,620>
  var Views::WarpGroup magnifyingView = null;

  // This flag is set if it is evtl. necessary to scroll the editor content in order \
  // to ensure that the caret is still visible.
  $rect <220,620,420,660>
  var bool autoScroll;

  // This internal variable stores the current caret index. This is the position \
  // within Text.String property where the user can input text or delete signs.
  $rect <20,620,220,660>
  var int32 caretIndex = 0;

  // This slot method is called after the caret has been adjusted. Its job is to \
  // adjust too the position of the magnifying glass view where the augmented text \
  // content around the caret is shown.
  $rect <450,540,650,580>
  slot updateMagnifyingView
  {
    // There is actually no magnifying glass displayed. Nothing to do.
    if ( magnifyingView == null )
      return;

    var rect  srcArea = magnifyingView.SourceArea;
    var rect  extent  = magnifyingView.GetExtent();
    var rect  bounds  = Bounds;
    var point caret   = Caret.Point1;

    // Calculate the start position of the area to show in the magnifying
    // view. Preferably the caret should appear in the center of this area.
    var int32 srcX = caret.x - ( srcArea.w / 2 );

    // However, the part of magnifying glass displaying the caret should 
    // remain arranged horizontally within the editor area.
    if ( srcX < 0 )
      srcX = 0;

    if (( srcX + srcArea.w ) > bounds.w )
      srcX = bounds.w - srcArea.w;

    // The resulting start position of the area to augment
    magnifyingView.SourceArea.origin = point( srcX, caret.y );

    // Now calculate the position for the magnifyingView. Preferably the
    // the view should be arranged so it shows the augmented caret 
    // exactly above the origin caret
    var int32 dstX = ( bounds.x1 + caret.x ) - ( caret.x - srcX ) * 2;

    // From the new magnifyingView position and its current position calculate
    // an offset.
    var point ofs = point( dstX - extent.x1, bounds.y1 + caret.y - extent.y2 );

    // Move the magnifyingView and its background by the just calculated offset
    magnifyingView.MoveView( ofs, false );
    magnifyingBack.MoveView( ofs, false );
  }

  // This slot method is called after a short delay when the user has moved the caret \
  // or modified the text. Its job is to ensure that the caret is still visible. \
  // If necessary, the editor content is scrolled.
  $rect <220,540,420,580>
  slot updateScrollOffset
  {
    // Get the visible area of the text view
    var rect  bounds = Text.Bounds;
    var int32 ofsX   = 0;
    var int32 ofsY   = 0;

    // Calculate an offset to scroll the text content if the caret lies
    // outside the visible area
    if ( Caret.Point1.x < bounds.x1 ) ofsX = bounds.x1 - Caret.Point1.x;
    if ( Caret.Point1.x > bounds.x2 ) ofsX = bounds.x2 - Caret.Point1.x;
    if ( Caret.Point1.y < bounds.y1 ) ofsY = bounds.y1 - Caret.Point1.y;
    if ( Caret.Point2.y > bounds.y2 ) ofsY = bounds.y2 - Caret.Point2.y;

    // Should the cont be scrolled?
    if (( ofsX != 0 ) || ( ofsY != 0 ))
      Text.ScrollOffset = Text.ScrollOffset + point( ofsX, ofsY );

    // The following code takes care of the automatic adjustment of the
    // text scroll position if after modifying the text, its area is small
    // enough to be completely visible.
    ofsX = Text.ScrollOffset.x;
    ofsY = Text.ScrollOffset.y;

    // Get the current text area of the 
    var point size = Text.GetContentArea().size;

    // Does the area fit completely within the text editor?
    if ( size.x <= Text.Bounds.w ) ofsX = 0;
    if ( size.y <= Text.Bounds.h ) ofsY = 0;

    // If possible arrange the text so it fits within the text editor.
    Text.ScrollOffset = point( ofsX, ofsY );
  }

  // This slot method is attached to the Text view. Each time the Text view has rearranged \
  // the text, this method is called. Its job is to adjust the caret to the evtl. \
  // new position.
  $rect <20,540,220,580>
  slot updateCaret
  {
    // Without the font we don't know the height of the caret
    if ( Font == null )
      return;

    // Get the pixel position of the sign right to the caret
    var point rowCol = Text.StringIndex2RowCol( caretIndex );
    var point pos    = Text.RowCol2Position( rowCol );

    // Arrange the caret at the just determined position. The height of 
    // the caret corresponds to the height of a text row drawn with the
    // font
    Caret.Point1 = pos - point( 0, Font.Ascent  );
    Caret.Point2 = pos + point( 0, Font.Descent );

    // Restart the blink effect -> this ensures that the user can see the
    // caret while it is moved or the text is modified
    if ( blinkEffect.Enabled )
    {
      blinkEffect.Enabled = false;
      blinkEffect.Enabled = true;
    }

    // Should adjust the scroll position so that the caret remains in the visible
    // area? Finally clear the 'autoScroll' flag again.
    if ( autoScroll )
    {
      postsignal updateScrollOffset;
      autoScroll = false;
    }

    // If there is a magnifying glass view visible -> arrange it also to the
    // current caret position.
    if ( magnifyingView != null )
      postsignal updateMagnifyingView;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to hide the magnifying glass view again.
  $rect <450,400,650,440>
  slot onReleaseTouch
  {
    // Hide the views used temporarily to show the augmented editor content
    if ( magnifyingView != null )
    {
      Owner.Remove( magnifyingView );
      Owner.Remove( magnifyingBack );
      magnifyingView = null;
      magnifyingBack = null;

      // Free the temporary used off-screen memory
      Buffered = false;
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to move the caret accordingly to the user's finger movement.
  $rect <450,360,650,400>
  slot onDragTouch
  {
    // Does the user currently drag the caret?
    if ( magnifyingView != null )
    {
      // From the touched screen position estimate the corresponding position
      // within the text string.
      var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
      var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

      // Does the caret position change? Force the editor to update the
      // position of the blinking caret
      if ( newCaretIndex != caretIndex )
      {
        caretIndex = newCaretIndex;
        postsignal updateCaret;

        // Ensure the caret is still visible later in the updateText slot method
        autoScroll = true;
      }
    }


    // No, then redirect the touch interaction to the slide touch handler when the
    // user moved the finger a little bit. In this manner the user can scroll the text.
    else
    {
      var point ofs   = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;
      var int32 limit = GetRoot().CursorDragLimit;

      // Start the slide mode if the user has dragged the finger a little bit
      if (( ofs.x < -limit ) || ( ofs.x > limit ) ||
          ( ofs.y < -limit ) || ( ofs.y > limit ))
        GetRoot().DeflectCursor( SlideTouchHandler, <0,0>);
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to activate the caret movement mode if the user has pressed the finger on the \
  // screen for a while. The method also shows a small magnifying glass where the \
  // text around the caret is shown. This should help the user to navigate the caret \
  // with the finger.
  $rect <450,320,650,360>
  slot onHoldTouch
  {
    // When the user presses the finger within the text editor area,
    // the editor enters the caret dragging mode. In this mode the
    // user can move the caret with the finger. For convenience the
    // area below the finger is displayed in a kind of magnifying glass.
    // Does enter the mode?
    if (( SimpleTouchHandler.HoldPeriod >= 300 ) && ( magnifyingView == null ))
    {
      // Calculate the size of the area to augment
      var int32 height = Caret.Point2.y - Caret.Point1.y;
      var int32 width  = height * 3;

      // Limit to the available size of the editor component
      if ( height > Bounds.h ) height = Bounds.h;
      if ( width  > Bounds.w ) width  = Bounds.w;

      // The editor component should store its content in an off-screen bitmap
      // in order to be able to to show it augmented in an overlay 'magnifyingView'
      Buffered = true;

      // Create a temporary view to show the augmented content and to show the
      // 'magnifying glass' background
      magnifyingView = new Views::WarpGroup;
      magnifyingBack = new Views::Rectangle;

      // Prepare a magnifyingView to show an augmented content of the edited text
      // row. The content is augmented by the factor x 2
      magnifyingView.Group       = this;
      magnifyingView.Quality     = true;
      magnifyingView.Opacity     = 200;
      magnifyingView.SourceArea  = rect( 0, 0, width, height );
      magnifyingView.Point2.x    = width  * 2;
      magnifyingView.Point3.x    = width  * 2;
      magnifyingView.Point3.y    = height * 2;
      magnifyingView.Point4.y    = height * 2;

      // Also prepare the magnifying glass background view. It is a semitransparent
      // rectangle.
      magnifyingBack.Bounds.size   = point( width * 2, height * 2 ) + <20,20>;
      magnifyingBack.Bounds.origin = <-10,-10>;
      magnifyingBack.Color         = #EEEEEECC;

      // Make the just created views visible on the screen
      Owner.Add( magnifyingBack, 0 );
      Owner.Add( magnifyingView, 0 );

      // Arrange the 'magnifying glass' views at the correct position
      postsignal updateMagnifyingView;
    }

    // Even if the user is not moving the cursor (finger) continue the scrolling when
    // the user holds the finger near an edge of the text editor.
    if ( magnifyingView != null )
      signal onDragTouch;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to obtain the focused state for the editor so the user can interact with the \
  // editor content and to place the caret at the touched position.
  $rect <450,280,650,320>
  slot onPressTouch
  {
    // With the first touch focus the text editor
    if ( !HasViewState( Core::ViewState[ Focused ]))
      ObtainFocus();

    // Estimate the position within the text string corresponding to the
    // position touched on the screen.
    var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the text editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex || caretIndex == 0 )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // move the caret up/down/left or right in the editor text.
  $rect <220,440,420,480>
  slot onCursorKey
  {
    // No font specified to show the text -> no navigation
    // possible
    if ( Font == null )
      return;

    // Knowing the position of the caret within the string, get the
    // corresponding row/column position in the displayed text.
    var point rc = Text.StringIndex2RowCol( caretIndex );

    // Has the user moved the caret to the left? Get the new resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Left )
    {
      // Navigate to the previous column
      rc.x = rc.x - 1;

      // Skip to the end of the preceding row?
      if ( rc.x < 0 )
      {
        rc.y = rc.y - 1;
        rc.x = Text.GetRowString( rc.y ).length;
      }
    }

    // Has the user moved the caret to the right? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Right )
    {
      // Navigate to the next column
      rc.x = rc.x + 1;

      // Skip to the begin of the next row?
      if ( rc.x == Text.GetRowString( rc.y ).length )
      {
        rc.y = rc.y + 1;
        rc.x = 0;
      }
    }

    // Has the user moved the caret one row up? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Up )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just above
      rc = Text.Position2RowCol( pos - point( 0, rowHeight ));
    }

    // Has the user moved the caret one row down? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Down )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just below
      rc = Text.Position2RowCol( pos + point( 0, rowHeight ));
    }

    // From the just determined new row/column position get the corresponding
    // position within the text string
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign preceding the current caret position and to move the caret accordingly.
  $rect <220,400,420,440>
  slot onBackspaceKey
  {
    // No signs preceding the caret -> Nothing to delete
    if ( caretIndex == 0 )
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex - 1 ];
    var int32 count = 1;

    // Is this a space sign? Usually space signs are eliminated by the
    // text view unless we use the non-breakable space sign \xA0. However,
    // to perform the text wrap, a silent break sign '^' is placed behind
    // the space sign. Consider the both signs '\xA0^' as a unit
    if (( caretIndex > 1 ) && ( ch == '^' ) && 
        ( Text.String[ caretIndex - 2 ] == '\xA0' ))
      count = 2;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    else if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      count = 2;

    // Remove the affected text portion and adjust the caret position
    Text.String = Text.String.remove( caretIndex - count, count );
    caretIndex  = caretIndex - count;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign at the current caret position.
  $rect <220,360,420,400>
  slot onDeleteKey
  {
    // No signs following the caret -> Nothing to delete
    if ( caretIndex >= ( Text.String.length - 1 ))
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if ( ch == '%' )
      count = 2;

    // Is this a space sign? Usually space signs are eliminated by the
    // text view unless we use the non-breakable space sign \xA0. However,
    // to perform the text wrap, a silent break sign '^' is placed behind
    // the space sign. Consider the both signs '\xA0^' as a unit
    else if ( ch == '\xA0' )
      count = 2;

    // Remove the affected text fragment
    Text.String = Text.String.remove( caretIndex, count );

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the <new line> sign and to move the caret \
  // to the next row.
  $rect <220,320,420,360>
  slot onNewlineKey
  {
    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( '\n', caretIndex );
    caretIndex  = caretIndex + 1;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the sign which has been input by the user \
  // and to move the caret to the next column.
  $rect <220,280,420,320>
  slot onCharacterKey
  {
    var char   ch  = CharacterKeyHandler.CharCode;
    var string str = ch;

    // Precede all special control signs with the '%' escape sign. Otherwise
    // the user can't input nor see them
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '\xAD' ) || ( ch == '%' ))
      str = "%" + ch;

    // To avoid the elimination of space signs at the end of a wrapped row
    // use the non-breakable space signs mit the additional 'silent' break
    // sign to perform the wrapping
    else if ( ch == ' ' )
      str = "\xA0^";

    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( str, caretIndex );
    caretIndex  = caretIndex + str.length;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  $rect <390,180,590,220>
  onset WrapText
  {
    // The value doesn't change - nothing to do.
    if ( pure WrapText == value )
      return;

    // Remember the new value ...
    pure WrapText = value;
    Text.WrapText = value;

    // If the text is warp automatically in rows, there is no need to
    // scroll the text horizontally.
    SlideTouchHandler.SlideHorz = !value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <190,180,390,220>
  onset Alignment
  {
    // The value doesn't change - nothing to do.
    if ( pure Alignment == value )
      return;

    // The justified mode is not supported by the editor.
    if ( value.contains( Views::TextAlignment[ AlignHorzJustified ]))
      value = value - Views::TextAlignment[ AlignHorzJustified ]
                    + Views::TextAlignment[ AlignHorzLeft ];

    // Remember the new value ...
    pure Alignment = value;
    Text.Alignment = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <590,90,790,130>
  onget String
  {
    // Get the current text view content
    var string str = Text.String;

    // In the following steps remove any special text view control signs
    // which are usually used to control the text flow. The resulting string
    // should contain the 'pure' text only.
    var int32  inx = str.find( '\xA0', 0 );

    // Internally the text editor works with the sign sequence '\xA0^' as
    // the space ' ' sign. This is because the text view tends to eliminate
    // regular space signs at the end of a text row.
    // Convert all '\xA0^' sign sequences to a regular space ' '
    while ( inx >= 0 )
    {
      if ( str[ inx + 1 ] == '^' )
      {
        str = str.remove( inx, 1 );
        str[ inx ] = ' ';
      }

      inx = str.find( '\xA0', inx + 1 );
    }

    inx = str.find( '%', 0 );

    // The special control/escape signs are not visible until there is a
    // '%' sign in front of them. Remove all superfluous '%' signs
    while ( inx >= 0 )
    {
      str = str.remove( inx, 1 );
      inx = str.find( '%', inx + 1 );
    }

    // Finally remove the <new line> sign at the end of text which was used
    // as workaround for a text flow parser issue
    return str.left( str.length - 1 );
  }

  $rect <590,50,790,90>
  onset String
  {
    // The value doesn't change - nothing to do.
    if ( pure String == value )
      return;

    // Remember the new string ...
    pure String = value;

    // In the following steps disarm in the assigned Unicode string the special
    // control and escape signs, which usually control the text flow in a  text
    // view. Without this conversion step, signs like '%' couldn't be seen in
    // the editor.
    var string str = value;
    var int32  inx = str.find( '%', 0 );

    // The special '%' escape sign is not visible until there is other
    // '%' sign in front of it. Convert all '%' signs into '%%' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '%', inx + 2 );
    }

    inx = str.find( '^', 0 );

    // The special '^' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '^' signs into '%^' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '^', inx + 2 );
    }

    inx = str.find( '~', 0 );

    // The special '~' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '~' signs into '%~' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '~', inx + 2 );
    }

    inx = str.find( '\xAD', 0 );

    // The special '\xAD' hyphen sign is not visible until there is a '%'
    // sign in front of it. Convert all '\xAD' hyphen signs into '%\xAD'
    // sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '\xAD', inx + 2 );
    }

    inx = str.find( ' ', 0 );

    // The text view tends to eliminate space signs at the end of a text row.
    // To avoid it, the editor will work internally with the non-breakable
    // space \xA0 sign. To perform the line wrap, an additional '^' silent
    // break control sign is placed behind the non-breakable space.
    // Convert all ' ' space signs to '\xA0^' sequence
    while ( inx >= 0 )
    {
      str[ inx ] = '\xA0';
      str = str.insert( "^", inx + 1 );
      inx = str.find( ' ', inx + 2 );
    }

    // Ensure that the caret still refers to a sign within the string
    if ( caretIndex > str.length )
      caretIndex = str.length;

    // Now show the new string in the editor's text view. The additional
    // <new line> is a workaround for a flow text parser issue
    Text.String = str + "\n";

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <390,50,590,90>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Store the new Color
    pure Color  = value;
    Text.Color  = value;
    Caret.Color = value;
  }

  $rect <190,50,390,90>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Store the new font...
    pure Font = value;
    Text.Font = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  // This bool change effect is used to blink the caret.
  $rect <20,580,220,620>
  object Effects::BoolEffect blinkEffect
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Caret.Visible;
    preset CycleDuration = 500;
    preset InterCycleDelay = 500;
  }

  // This key handler reacts to user inputs if the user has pressed the 'up', 'down', \
  // 'left' or 'right' key. In this case the associated onCursorKey method is called.
  $rect <20,440,220,480>
  object Core::KeyPressHandler CursorKeyHandler
  {
    preset OnPress = onCursorKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onCursorKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'backspace' \
  // key. In this case the associated onBackspaceKey method is called.
  $rect <20,400,220,440>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = onBackspaceKey;
    preset Filter = Core::KeyCode.Backspace;
    preset OnHold = onBackspaceKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'delete' \
  // key. In this case the associated onDeleteKey method is called.
  $rect <20,360,220,400>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = onDeleteKey;
    preset Filter = Core::KeyCode.Delete;
    preset OnHold = onDeleteKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'enter' key. \
  // In this case the associated onNewlineKey method is called.
  $rect <20,320,220,360>
  object Core::KeyPressHandler NewlineKeyHandler
  {
    preset OnPress = onNewlineKey;
    preset Filter = Core::KeyCode.Enter;
    preset OnHold = onNewlineKey;
  }

  // This key handler reacts to user inputs if the user has pressed a key corresponding \
  // to character/digit. In this case the associated onCharacterKey method is called.
  $rect <20,280,220,320>
  object Core::KeyPressHandler CharacterKeyHandler
  {
    preset OnPress = onCharacterKey;
    preset Filter = Core::KeyCode.CharacterKeys;
    preset OnHold = onCharacterKey;
  }

  // This slide gesture handler is used to scroll the text content.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,30,160,65>;
    preset SlideHorz = false;
    preset Friction = 0.05;
  }

  // This generic touch handler is used to move the caret.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,65>;
    preset Point3 = <160,65>;
    preset Point2 = <160,30>;
    preset Point1 = <0,30>;
    preset OnDrag = onDragTouch;
    preset OnHold = onHoldTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset MaxStrikeCount = 3;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <5,30,160,65>;
    preset OnUpdate = updateCaret;
    preset SlideHandler = SlideTouchHandler;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text\n";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Caret
  {
    preset Point2 = <4,59>;
    preset Point1 = <4,35>;
    preset Width2 = 2;
    preset Width1 = 2;
    preset Color = #000000FF;
    preset Visible = false;
  }

  // The property 'OnChange' can refer to a slot method, which should be invoked \
  // by the text editor when the user modifies the text.
  $rect <590,140,790,180>
  property slot OnChange = null;

  // The property 'WrapText' determines whether long text rows should be wrapped \
  // automatically.
  $rect <390,140,590,180>
  property bool WrapText = true;

  // The property 'Alignment' determines how the editor should display the text rows \
  // if their size differ from the size of the editor. 
  // In this manner the rows can be aligned horizontally. The entire text block can \
  // be aligned vertically.
  $rect <190,140,390,180>
  property Views::TextAlignment Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];

  // The property 'String' stores the text of the editor.
  $rect <590,10,790,50>
  property string String = "Text";

  // The property 'Color' controls the color of the text.
  $rect <390,10,590,50>
  property color Color = #000000FF;

  // The property 'Font' refers to the font object used to display the text. The \
  // text is determined by the property @String.
  $rect <190,10,390,50>
  property Resources::Font Font = Resources::FontMedium;
}

$rect <390,440,540,480>
$output false
class Writable1 : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,150,70>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <260,60,400,100>
  inherited method Init()
  {
    // TO DO: Write your code here ... 



  }

  $rect <200,0,340,40>
  inherited property Focus = TextEditor1;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,30,150,70>;
    preset Width = 2;
    preset ColorL = #333333FF;
    preset ColorR = #C9C9C9FF;
    preset ColorB = #CCCCCCFF;
    preset ColorT = #333333FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <3,32,147,68>;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object App::TextEditor1 TextEditor1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <5,0,150,70>;
    preset OnChange;
    preset WrapText = false;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  }

  $rect <470,50,670,90>
  property int32 MaxLength = 0;
}

$rect <860,580,1060,620>
$output false
set EN54Set
{
  $rect <10,10,210,50>
  item SilenceInput;

  $rect <220,10,420,50>
  item NoSkipCallpoint;

  $rect <430,10,630,50>
  item InputDelays;
}

$rect <2549,829,2749,869>
$output false
resource Resources::Bitmap cosmall
{
  attr bitmapfile FileName = .\Images\cosmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2749,829,2949,869>
$output false
resource Resources::Bitmap evacuate40csmall
{
  attr bitmapfile FileName = .\Images\evacuate40csmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2549,869,2749,909>
$output false
resource Resources::Bitmap evacuatesmall
{
  attr bitmapfile FileName = .\Images\evacuatesmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2749,869,2949,909>
$output false
resource Resources::Bitmap fire_alarmsmall
{
  attr bitmapfile FileName = .\Images\fire_alarmsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2549,909,2749,949>
$output false
resource Resources::Bitmap fire_routingsmall
{
  attr bitmapfile FileName = .\Images\fire_routingsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2749,909,2949,949>
$output false
resource Resources::Bitmap functionsmall
{
  attr bitmapfile FileName = .\Images\functionsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2549,949,2749,989>
$output false
resource Resources::Bitmap general_inputsmall
{
  attr bitmapfile FileName = .\Images\general_inputsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2749,949,2949,989>
$output false
resource Resources::Bitmap general_outputsmall
{
  attr bitmapfile FileName = .\Images\general_outputsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2549,989,2749,1029>
$output false
resource Resources::Bitmap greencall2small
{
  attr bitmapfile FileName = .\Images\greencall2small.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2749,989,2949,1029>
$output false
resource Resources::Bitmap heatA1Rsmall
{
  attr bitmapfile FileName = .\Images\heatA1Rsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2549,1029,2749,1069>
$output false
resource Resources::Bitmap heatsmall
{
  attr bitmapfile FileName = .\Images\heatsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2749,1029,2949,1069>
$output false
resource Resources::Bitmap input_alarmsmall
{
  attr bitmapfile FileName = .\Images\input_alarmsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2549,1069,2749,1109>
$output false
resource Resources::Bitmap input_callpointsmall
{
  attr bitmapfile FileName = .\Images\input_callpointsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2749,1069,2949,1109>
$output false
resource Resources::Bitmap input_faultsmall
{
  attr bitmapfile FileName = .\Images\input_faultsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2549,1109,2749,1149>
$output false
resource Resources::Bitmap input_routing_acksmall
{
  attr bitmapfile FileName = .\Images\input_routing_acksmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2749,1109,2949,1149>
$output false
resource Resources::Bitmap input_silencesmall
{
  attr bitmapfile FileName = .\Images\input_silencesmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2549,1149,2749,1189>
$output false
resource Resources::Bitmap pirsmall
{
  attr bitmapfile FileName = .\Images\pirsmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2749,1149,2949,1189>
$output false
resource Resources::Bitmap silenced_small
{
  attr bitmapfile FileName = .\Images\silenced_small.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2549,1189,2749,1229>
$output false
resource Resources::Bitmap smoke2small
{
  attr bitmapfile FileName = .\Images\smoke2small.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2189,660,2389,700>
$output false
resource Resources::Bitmap meshunit_fill
{
  attr bitmapfile FileName;
  attr alphafile AlphaName = .\Images\meshunit_fill.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2189,700,2389,740>
$output false
resource Resources::Bitmap meshunit_outline
{
  attr bitmapfile FileName = .\Images\meshunit_outline.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2189,740,2389,780>
$output false
resource Resources::Bitmap meshunit_outline_thin
{
  attr bitmapfile FileName = .\Images\meshunit_outline_thin.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <0,2170,200,2210>
$output false
class UnitNumber
{
  $rect <0,0,200,40>
  property int16 num = 0;
}

$rect <289,469,439,509>
$output false
class LogChoice : App::Popup
{
  $rect <520,50,660,90>
  inherited property Bounds = <0,0,290,300>;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Color = #D2D2D2FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <40,30,230,80>;
    preset OnActivate = MainSlot;
    preset Label = "Main Log";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <40,100,230,150>;
    preset OnActivate = MeshSlot;
    preset Label = "Mesh Log";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <60,200,210,250>;
    preset OnActivate = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <320,10,520,50>
  slot MainSlot
  {
    sender; /* the method is called from the sender object */

    var App::Popup pop = new App::LogPopup;

    pop.Show( GetRoot() );

    Hide();

  }

  $rect <320,100,520,140>
  slot MeshSlot
  {
    sender; /* the method is called from the sender object */

    var App::Popup pop = new App::MeshLogPopup2;

    pop.Show( GetRoot() );

    Hide();

  }

  $rect <320,200,520,240>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

    Hide();

  }
}

$rect <789,849,939,889>
$output false
class AdditionalPopup : App::Popup
{
  $rect <800,185,940,225>
  inherited property Bounds = <0,0,680,385>;

  $rect <40,395,180,435>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 

     

    var int32 numItems = 8;

    native (numItems)
    {
       Command cmd;

       Command0( CMD_GET_NUM_EXTRA_RADIO_UNITS, &cmd );

       numItems = cmd.int0;
    }

     
    ListViewer.NoOfItems =  numItems;

     
  }

  $rect <730,405,870,445>
  inherited method Init()
  {
    // TO DO: Write your code here ... 
     

    var int32 numItems = 8;

    native (numItems)
    {
       Command cmd;

       Command0( CMD_GET_NUM_EXTRA_RADIO_UNITS, &cmd );

       numItems = cmd.int0;
    }

     
    ListViewer.NoOfItems =  numItems;


  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <10,10,650,355>;
    preset Color = #EDEDEDFF;
  }

  $rect <20,20,160,60>
  object App::ListViewer ListViewer
  {
    preset Bounds = <20,20,480,340>;
    preset OnLoadItem = OnLoadItem;
    preset ItemClass = App::AdditionalUnit;
    preset ItemHeight = 40;
    preset NoOfItems = 20;
    preset onRefreshAll = OnRefreshAll1;
  }

  $rect <505,400,705,440>
  slot OnLoadItem
  {
    sender; /* the method is called from the sender object */



    var int32       itemNo   = ListViewer.Item;
    var App::AdditionalUnit view = (App::AdditionalUnit) ListViewer.VerticalList.View;


    var int32 ri = 0;

      
       if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
       {
           var int32 intptr = 0;

            view.Visible = true;

           native (  itemNo, intptr )
           {
              Command cmd;

              cmd.int0 = itemNo;
              Command0( CMD_GET_EXTRA_RADIO_NUM, &cmd );

              intptr = cmd.int1;
           }

           var App::RadioUnit ru = App::Lib.GetRadioFromPtr( intptr );

           if ( ru != null )
           {
              view.Index = itemNo;

              view.UnitCheckBox.Checked =  (( ru.valid & 32 ) == 32);
              view.DescriptionText.String = App::Lib.GetCombiName( ru.combination );

               if ( ru.zonenum < 1 )  ru.zonenum = 1;

              view.ZoneSpinner.VerticalList1.ScrollOffset = ( ru.zonenum - 1 ) * view.ZoneSpinner.VerticalList1.ItemHeight;

                
               view.Bounds.size = point( ListViewer.VerticalList.Bounds.w, ListViewer.VerticalList.ItemHeight );
          }     
             //view.Bounds.w = 440;
      }
      else
      {
          view.Visible = false;
       
       }  
        view.InvalidateViewState();
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButtonCancel
  {
    preset Bounds = <485,285,635,335>;
    preset OnActivate = Cancel;
    preset Label = "Cancel";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButtonOK
  {
    preset Bounds = <485,220,635,270>;
    preset OnActivate = AddDevices;
    preset Label = "Add Devices";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButtonOK1
  {
    preset Bounds = <485,80,635,130>;
    preset OnActivate = SelectAll;
    preset Label = "Deselect All";
    preset Appearance = App::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButtonOK2
  {
    preset Bounds = <485,20,635,70>;
    preset OnActivate = SelectAll;
    preset Label = "Select All";
    preset Appearance = App::NormalPushButton;
  }

  $rect <750,225,950,265>
  slot OnRefreshAll1
  {
    sender; /* the method is called from the sender object */


    var int32       itemNo   = ListViewer.Item;
    var App::AdditionalUnit view = (App::AdditionalUnit) ListViewer.VerticalList.first;


    var int32 ri = 0;

     

    while ( view != null )
    {
       if ( itemNo >= 0 && itemNo < ListViewer.NoOfItems )
       {
           var int32 intptr = 0;

           native (  itemNo, intptr )
           {
              Command cmd;

              cmd.int0 = itemNo;
              Command0( CMD_GET_EXTRA_RADIO_NUM, &cmd );

              intptr = cmd.int1;
           }

           var App::RadioUnit ru = App::Lib.GetRadioFromPtr( intptr );

           if ( ru != null )
           {
                view.Visible = true;
              view.Index = itemNo;

              view.UnitCheckBox.Checked =  (( ru.valid & 32 ) == 32);
              view.DescriptionText.String = App::Lib.GetCombiName( ru.combination );

               if ( ru.zonenum < 1 )  ru.zonenum = 1;

              view.ZoneSpinner.VerticalList1.ScrollOffset = ( ru.zonenum - 1 ) * view.ZoneSpinner.VerticalList1.ItemHeight;


               view.Bounds.size = point( ListViewer.VerticalList.Bounds.w, ListViewer.VerticalList.ItemHeight );
             
              view = (App::AdditionalUnit) view.next;
              if ( view == null ) return;
          }     
      }
      else
      {
          view.Visible = false;

          view.InvalidateViewState();
          view = (App::AdditionalUnit) view.next;
          
       }  
      itemNo = itemNo + 1;
    }

  }

  $rect <690,15,890,55>
  slot SelectAll
  {
    sender; /* the method is called from the sender object */
     
    var int32       itemNo   = 0;
     
    var bool select = ( sender == PushButtonOK2 ); 

    var int32 numItems = 8;

    native (numItems, select )
    {
       Command cmd;

       Command0( CMD_GET_NUM_EXTRA_RADIO_UNITS, &cmd );

       numItems = cmd.int0;
     
        for (  cmd.int0 = 0; cmd.int0 < numItems; cmd.int0++ )
        {
       
          Command0( CMD_GET_EXTRA_RADIO_NUM, &cmd );

          RadioUnit* r = (RadioUnit*)   cmd.int1;

           if ( r != NULL )
           {
               if ( select )
               { 
                  r->valid |= 32;
                }
                else
                {
                  r->valid &= ~32;
                } 
                         
            }     
        }
    }
      
     InvalidateViewState( );


  }

  $rect <270,400,470,440>
  slot AddDevices
  {
    sender; /* the method is called from the sender object */

     native  
     {
        
        Command1( CMD_ADD_ADDITIONAL, 1);
          
     }

  }

  $rect <260,465,460,505>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    Hide( );


  }

  $rect <735,95,935,135>
  object Core::SystemEventHandler SystemEventHandler3
  {
    preset OnEvent = onEvent;
    preset Event = App::Devices.MeshListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler3' \
  // receives an event.
  $rect <720,130,920,170>
  slot onEvent
  {
    InvalidateViewState( );

  }
}

$rect <940,830,1140,870>
$output false
class AdditionalUnit : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,420,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <150,4,388,35>;
    preset ColorBL = #000000FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #000000FF;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton UnitCheckBox
  {
    preset Bounds = <0,0,50,40>;
    preset Enabled = true;
    preset OnSwitchOn = ToggleSlot;
    preset OnSwitchOff = ToggleSlot;
    preset Label = "";
    preset Appearance = App::NormalCheckBox;
  }

  $rect <50,165,250,205>
  slot ToggleSlot
  {
    sender; /* the method is called from the sender object */

                           
    var int32 itemNo = Index;
    var bool checked = UnitCheckBox.Checked;

    native (  itemNo, checked )
    {
      Command cmd;

      cmd.int0 = itemNo;
      Command0( CMD_GET_EXTRA_RADIO_NUM, &cmd );

     

      RadioUnit* rad = (RadioUnit*) cmd.int1;

      if ( rad != NULL )
      {
        if ( checked )
        {
            rad->valid |= 32;
        }
        else
        {
             rad->valid &= 223;
         }
      }
    }
     
  }

  $rect <20,20,160,60>
  object App::ZoneSpinner ZoneSpinner
  {
    preset Bounds = <88,3,144,36>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <49,10,86,30>;
    preset String = "Zone";
    preset Font = App::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <82,78,250,120>
  property int32 Index = 0;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop];
    preset Bounds = <340,4,419,36>;
    preset OnActivate = LocateSlot;
    preset Label = "Locate";
    preset Appearance = App::SmallPushButton;
  }

  $rect <252,124,452,164>
  slot LocateSlot
  {
    sender; /* the method is called from the sender object */

                         
    var int32 itemNo = Index;


    native (  itemNo)
    {
      Command cmd;

      cmd.int0 = itemNo;
      Command0( CMD_FLASH_EXTRA_RADIO_NUM, &cmd );
     
    }
     
  }
}

$rect <629,889,829,929>
$output false
class ZoneSpinner : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,90,32>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  // This method is called by 'VerticalList1' every time the list loads or updates \
  // an item.
  $rect <412,110,578,154>
  slot OnLoadItem1
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList1.Item;
    var Views::Text itemView = (Views::Text)VerticalList1.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo + 1 );
    itemView.Font   = App::FontMediumBold;
    itemView.Color  = #000000FF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList1.Bounds.w, VerticalList1.ItemHeight );
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <3,3,87,29>;
    preset Color = #DDDDDDFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,3,88,9>;
    preset ColorBL = #FFFFFF00;
    preset ColorBR = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,22,88,30>;
    preset ColorBL = #888888FF;
    preset ColorBR = #959595FF;
    preset ColorTR = #FFFFFF00;
    preset ColorTL = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <4,3,86,30>;
    preset OnLoadItem = OnLoadItem1;
    preset SlideHandler = SlideTouchHandler;
    preset NoOfItems = 96;
  }

  $rect <20,20,160,60>
  object Views::Border BorderCurrent
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,90,32>;
    preset Width = 3;
    preset Color = #A3A3A3FF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,90,32>;
    preset OnEnd = SlideEnd;
    preset Friction = 0.1;
  }

  $rect <142,88,296,128>
  slot SlideEnd
  {
    sender; /* the method is called from the sender object */



    VerticalList1.ScrollOffset = ( ( VerticalList1.ScrollOffset - (  VerticalList1.ItemHeight/2 ) ) / VerticalList1.ItemHeight ) * VerticalList1.ItemHeight;

    VerticalList1.SelectedItem =  -VerticalList1.ScrollOffset / VerticalList1.ItemHeight;

     
    var int32 itemNo = 0;
    var int32 zone =  VerticalList1.SelectedItem + 1;

    var App::AdditionalUnit u = (App::AdditionalUnit) Owner;

    if ( u == null ) return;

    itemNo = u.Index;

    native (  itemNo, zone )
    {
      Command cmd;

      cmd.int0 = itemNo;
      Command0( CMD_GET_EXTRA_RADIO_NUM, &cmd );

      RadioUnit* rad = (RadioUnit*) cmd.int1;

      if ( rad != NULL )
      {
        rad->zone= zone;
       
      }
    }
     

  }
}

$rect <2280,310,2480,350>
$output false
resource Resources::Bitmap Bmp_1bar
{
  attr bitmapfile FileName;
  attr alphafile AlphaName = .\Images\1bar.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2280,350,2480,390>
$output false
resource Resources::Bitmap Bmp_2bar
{
  attr bitmapfile FileName;
  attr alphafile AlphaName = .\Images\2bar.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2280,390,2480,430>
$output false
resource Resources::Bitmap Bmp_3bar
{
  attr bitmapfile FileName;
  attr alphafile AlphaName = .\Images\3bar.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <2280,430,2480,470>
$output false
resource Resources::Bitmap Bmp_4bar
{
  attr bitmapfile FileName;
  attr alphafile AlphaName = .\Images\4bar.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <20,860,170,900>
$output false
class MeshTreeReference : Core::Group
{
  $rect <540,465,680,505>
  inherited property Bounds = <0,0,695,365>;

  $rect <25,595,165,635>
  inherited onset Visible
  {
    // TO DO: Write your code here ... 

    super( value );


    if ( Visible )
    {
      ListViewer.NoOfItems = ActiveCountView.total + extra + 2;       // + ncu and gap row
     
      InvalidateViewState();
    }
  }

  $rect <-15,420,125,460>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    MeshUnit4.Extention.String = "X";
    MeshUnit4.Extention.Visible = true;
                                       MeshUnit4.Extention.Color = #00000000;

  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <-25,-50,740,410>;
  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit
  {
    preset Bounds = <35,52,345,77>;
    preset Opacity = 127;
    preset Status = App::RadioStatus.Found;
    preset RSSI = 2;
    preset Stage = App::NCUStage.Activating;
  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit1
  {
    preset Bounds = <35,22,345,47>;
    preset Status = App::RadioStatus.NCU;
    preset Stage = App::NCUStage.Activating;
  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit2
  {
    preset Bounds = <35,114,345,139>;
    preset Opacity = 127;
    preset Status = App::RadioStatus.Found;
    preset RSSI = -118;
    preset Stage = App::NCUStage.Activating;
  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit3
  {
    preset Bounds = <35,83,345,108>;
    preset Opacity = 127;
    preset Status = App::RadioStatus.Found;
    preset RSSI = -110;
    preset Stage = App::NCUStage.Activating;
  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit4
  {
    preset Bounds = <35,268,345,293>;
    preset Opacity = 127;
    preset Status = App::RadioStatus.NotFound;
    preset RSSI = -118;
    preset Stage = App::NCUStage.Unknnown;
    preset flags = 32;
  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit5
  {
    preset Bounds = <35,145,345,170>;
    preset Opacity = 127;
    preset Status = App::RadioStatus.Found;
    preset RSSI = -118;
    preset Stage = App::NCUStage.Meshing;
  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit6
  {
    preset Bounds = <35,237,345,262>;
    preset Opacity = 127;
    preset Status = App::RadioStatus.Found;
    preset RSSI = -118;
    preset Stage = App::NCUStage.Dropped;
  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit7
  {
    preset Bounds = <35,175,345,200>;
    preset Opacity = 127;
    preset Status = App::RadioStatus.Found;
    preset RSSI = -118;
    preset Stage = App::NCUStage.Activating;
    preset flags = 2;
  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit8
  {
    preset Bounds = <35,206,345,231>;
    preset Opacity = 127;
    preset Status = App::RadioStatus.Found;
    preset RSSI = -118;
    preset Stage = App::NCUStage.Activating;
    preset flags = 16;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <360,20,460,50>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel / NCU";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <360,50,535,80>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Active Excellent signal";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <360,110,520,141>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Active Bad Signal";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <360,80,550,110>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Active Weak Signal";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Bounds = <360,141,460,171>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Meshing";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text5
  {
    preset Bounds = <360,172,540,204>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Device In Fault";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text6
  {
    preset Bounds = <360,203,555,236>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Device With Warning";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text7
  {
    preset Bounds = <360,235,589,263>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Device Dropped";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text8
  {
    preset Bounds = <361,265,530,294>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Device Not Found";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text9
  {
    preset Bounds = <279,266,379,296>;
    preset String = "x";
    preset Font = Resources::FontLarge;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit9
  {
    preset Bounds = <24,299,334,324>;
    preset Opacity = 127;
    preset Status = App::RadioStatus.Found;
    preset RSSI = -118;
    preset Stage = App::NCUStage.Meshing;
  }

  $rect <20,20,160,60>
  object Views::Text Text10
  {
    preset Bounds = <278,295,378,325>;
    preset String = "+";
    preset Font = Resources::FontLarge;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text11
  {
    preset Bounds = <360,295,615,325>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Additional Device (not in site)";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object App::MeshUnit MeshUnit10
  {
    preset Bounds = <26,329,336,354>;
    preset Opacity = 127;
    preset Status = App::RadioStatus.Found;
    preset RSSI = -118;
    preset Stage = App::NCUStage.Meshing;
  }

  $rect <20,20,160,60>
  object Views::Text Text12
  {
    preset Bounds = <280,325,380,355>;
    preset String = "?";
    preset Font = Resources::FontLarge;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text13
  {
    preset Bounds = <360,324,615,354>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Different Device Type";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }
}

$rect <2280,269,2480,309>
$output false
resource Resources::Bitmap Bmp_0bar
{
  attr bitmapfile FileName;
  attr alphafile AlphaName = .\Images\0bar.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1830,680,2030,720>
$output false
resource Resources::Bitmap WaterLeakBitmap
{
  attr bitmapfile FileName = .\Images\waterleak.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <330,200,530,240>
$output false
class FaultListChange
{
  $rect <300,110,500,150>
  property bool jump = false;
}
