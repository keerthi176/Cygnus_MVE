$version 6.60

$rect <140,0,240,40>
inline Inline1
{
  #include "stm32f7xx_hal_rtc.h"

  #include "MM_Command2.h"
  #include "MM_CUtils.h"

  #include "CO_Site.h"
  #include "CO_RBU.h"
  #include "MM_Device.h" 

  #include <stdio.h>
  #include <string.h>

}

$rect <480,600,680,640>
$output false
class DynamicAreaHead : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,595,55>;

  $rect <50,200,250,240>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,170,210,210>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


    CheckBox.CaptionText.String = stringstart + string( ZoneNum );


    if ( Expanded )
    {
         Image.Bitmap = Application::CollapseBitmap;

         //VerticalList.Visible = true;
    }
    else
    {
         Image.Bitmap = Application::ExpandBitmap;

        // VerticalList.Visible = false;
    }



    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <10,20,40,50>;
    preset Bitmap = Application::ExpandBitmap;
  }

  $rect <20,20,160,60>
  object XFlat::CheckBox CheckBox
  {
    preset Bounds = <61,10,360,55>;
    preset Enabled = true;
    preset OnChange = GreyAll;
    preset Caption = "Zone 1";
    preset Outlet = ^ZoneEnabled;
  }

  $rect <670,10,870,50>
  property bool Expanded = false;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,15>;
    preset Point3 = <50,15>;
    preset Point2 = <50,60>;
    preset Point1 = <0,60>;
    preset OnPress = ToggleHandler;
  }

  $rect <410,130,610,170>
  slot ToggleHandler
  {
    sender; /* the method is called from the sender object */

    Expanded = !Expanded;


    var Core::VerticalList lst = (Core::VerticalList) this.next;

    if ( lst != null )
    {
        lst.Visible = Expanded; 
    }

    InvalidateViewState();

  }

  $rect <770,230,970,270>
  property bool ZoneEnabled = false;

  $rect <770,270,970,310>
  onset ZoneEnabled
  {
    // The value doesn't change - nothing to do.
    if ( pure ZoneEnabled == value )
      return;

    // Remember the property's new value.
    pure ZoneEnabled = value;


    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <770,310,970,350>
  onget ZoneEnabled
  {
    return pure ZoneEnabled;
  }

  $rect <950,100,1150,140>
  property int32 ZoneNum = 0;

  $rect <400,220,600,260>
  property slot DisableAll = null;

  $rect <400,280,600,320>
  slot DisChange
  {
    sender; /* the method is called from the sender object */

    signal DisableAll;

  }

  $rect <0,85,200,125>
  property string stringstart = "";

  $rect <10,320,210,360>
  slot ClearAll
  {
    sender ; /* the method is called from the sender object */


            var Core::VerticalList vl = (Core::VerticalList) this.next;

            if ( vl != null )
            {
                 var Application::DeviceItem di = (Application::DeviceItem) vl.first;

                 while ( di != null )
                 {
                    if (di.FlatCheckBox0.Enabled) di.FlatCheckBox0.Checked = false;
                    di = (Application::DeviceItem) di.next;
                 }
             }



  }

  $rect <230,320,430,360>
  slot GreyAll
  {
    sender; /* the method is called from the sender object */


            var Core::VerticalList vl = (Core::VerticalList) this.next;

            if ( vl != null )
            {
                 var Application::DeviceItem di = (Application::DeviceItem) vl.first;

                 while ( di != null )
                 {
                    di.FlatCheckBox0.Enabled = !this.CheckBox.Checked;
                 //   di.FlatCheckBox0.Checked = this.CheckBox.Checked;
                    di = (Application::DeviceItem) di.next;
                 }
             }



  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <438,8,583,48>;
    preset OnRelease = ClearAll;
    preset Label = "Clear All";
    preset Appearance = Application::NormalPushButton;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Image 6
  $reorder CheckBox 6
  $reorder Expanded 6
  $reorder SimpleTouchHandler 6
  $reorder ToggleHandler 6
  $reorder Enabled 5
}

$rect <1240,590,1440,630>
$output false
resource Resources::Bitmap Circle55Bitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\circle55.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,230,1440,270>
$output false
resource Resources::Bitmap UpBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\up.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <970,0,1100,40>
$output false
class PushButton : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,50,50>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) ;

    Image.Bitmap = IconImage;

    if ( isPressed )
    {
        Background.Color = #00EE00FF;
    }                                               
    else
    {
        Background.ColorBR = #444444FF;  
        Background.ColorBL = #FFFFFFFF;  
        Background.ColorTL = #FFFFFFFF;  
        Background.ColorTR = #777777FF;  
          
    }

  }

  // To do:
  // 
  // - Adjust the visible size of your button (the thick blue border). This will \
  // be the button's default size.
  // - Resize the member 'TouchHandler' so it still fills the button's new area.
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your button.
  // - According to your desired button design add and configure new views (e.g. \
  // an image view to show the icon or a text view to show the button caption, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the button's current state.
  // - You can also add and configure animation effects to your button. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your button.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the button itself is resized.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // button to be activated with key other than the 'Enter' key.
  // - Alternatively remove the members 'KeyHandler' and 'onPressKey' if you don't \
  // want any keyboard handling.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your button. One property \
  // for every button specific setting (e.g. 'Caption', 'Icon', 'Color', 'Font', \
  // ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your button where \
  // the icon is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,370,990,750>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
     
    //Background.Color = #00EE00FF;

      postsignal OnActivate;
     
     
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,50,50>;
    preset ColorBL = #CCCCCCFF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,50,50>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #313131FF;
    preset ColorTR = #363636FF;
    preset ColorTL = #FFFFFFFF;
    preset Visible = false;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,50,50>;
    preset ColorBL = #6E6E6EFF;
    preset Bitmap = IconImage;
  }

  $rect <220,80,420,120>
  property Resources::Bitmap IconImage = null;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,50>;
    preset Point3 = <50,50>;
    preset Point2 = <50,0>;
    preset Point1 = <0,0>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }
}

$rect <530,1350,750,1390>
$output false
autoobject WidgetSet::PushButtonConfig NormalPushButton
{
  preset LabelColorActive = #FFFFFFFF;
  preset LabelColorDisabled = #565656FF;
  preset LabelFont = OldResources::FontVerdana20;
  preset FaceFrameActive = 3;
  preset FaceFrameFocused = 2;
  preset FaceFrameDisabled = 0;
  preset FaceFrameDefault = 1;
  preset FaceActive = WidgetSet::PushButtonMedium;
  preset FaceFocused = WidgetSet::PushButtonMedium;
  preset FaceDisabled = WidgetSet::PushButtonMedium;
  preset FaceDefault = WidgetSet::PushButtonMedium;
}

$rect <1440,590,1640,630>
$output false
resource Resources::Bitmap FireBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\fire3.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

// This is the root component of the entire GUI application.
$rect <0,0,140,40>
$output false
class Application : Core::Root
{
  $rect <830,0,1030,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <1030,5,1180,45>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

      TestPop = new Application::TestPopup;
      DisablePop = new Application::DisablePopup;

  }

  // To do:
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <5,740,785,940>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,50,800,480>;
    preset ColorBL = #383838FF;
    preset ColorBR = #666666FF;
    preset ColorTR = #202020FF;
    preset ColorTL = #212121FF;
    preset Color = #FFFFFFFF;
    preset AlphaBlended = true;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Seperator
  {
    preset Bounds = <0,45,800,50>;
    preset ColorBL = #78AAFFFF;
    preset ColorBR = #2B3844FF;
    preset ColorTR = #2B3844FF;
    preset ColorTL = #78AAFFFF;
    preset Color = #8BB8E8FF;
  }

  $rect <20,20,160,60>
  object Views::Text TimeDateText
  {
    preset Bounds = <622,455,796,472>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertBottom];
    preset String = "$time";
    preset Font = Application::FontVerdana16;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Application::TabButton AlarmsTabButton
  {
    preset Bounds = <0,0,133,45>;
    preset OnActivate = AlarmsEnter;
    preset Text = "{fnt2}{clr1}Fires";
    preset Icon = Application::Fire4Bitmap;
    preset pressed = true;
    preset Selected = ^SelectedTab;
    preset OnDeactivate = AlarmsExit;
    preset NumberOf = 0;
  }

  $rect <20,20,160,60>
  object Application::Button EvacuateButton
  {
    preset Bounds = <130,425,250,470>;
    preset Icon = Application::EvacuateBitmap;
    preset ButtonText = "{parc}Evacuate";
    preset Action = Evacuate;
  }

  $rect <20,20,160,60>
  object Application::Button MuteButton
  {
    preset Bounds = <5,425,125,470>;
    preset Icon = Application::MuteBitmap;
    preset ButtonText = "{fnt0}{parc}Mute Buzzer";
    preset Action = Mute;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <612,350,792,410>;
    preset AutoSize = true;
    preset Bitmap = Application::SiteNetBitmap;
  }

  $rect <15,496,215,536>
  slot AlarmsEnter
  {
    sender; /* the method is called from the sender object */

    Alarms.Visible = true;
    Alarms.Enabled = true;
    //Alarms.SlideTouchHandler.Enabled = true;


  }

  $rect <20,20,160,60>
  object Application::TabButton FaultsTabButton
  {
    preset Bounds = <133,0,266,45>;
    preset OnActivate = FaultsEnter;
    preset Text = "{fnt2}{clr1}Faults";
    preset Icon = Application::FaultBitmap;
    preset Selected = ^SelectedTab;
    preset OnDeactivate = FaultsExit;
    preset NumberOf = 0;
  }

  $rect <20,20,160,60>
  object Application::TabButton DisablementsTabButton
  {
    preset Bounds = <400,0,533,45>;
    preset OnActivate = DisablementsEnter;
    preset Text = "{fnt1}{clr1} Disablements";
    preset Icon = Application::DisableBitmap;
    preset Selected = ^SelectedTab;
    preset OnDeactivate = DisablementsExit;
    preset NumberOf = 0;
  }

  $rect <20,20,160,60>
  object Application::TabButton OnTestTabButton
  {
    preset Bounds = <533,0,666,45>;
    preset OnActivate = OnTestEnter;
    preset Text = "{fnt2}{clr1}On Test";
    preset Icon = Application::OnTestBitmap;
    preset Selected = ^SelectedTab;
    preset OnDeactivate = OnTestExit;
    preset NumberOf = 0;
  }

  $rect <20,20,160,60>
  object Application::TabButton EventsTabButton
  {
    preset Bounds = <266,0,400,45>;
    preset OnActivate = EventsEnter;
    preset Text = "{fnt3}{clr1}Other Events";
    preset Icon = Application::AlertBitmap;
    preset Selected = ^SelectedTab;
    preset OnDeactivate = EventsExit;
    preset NumberOf = 0;
  }

  $rect <835,40,1035,80>
  property string SelectedTab = "{fnt2}{clr1}Fires";

  $rect <20,20,160,60>
  object Application::Button ResetButton
  {
    preset Bounds = <380,425,500,470>;
    preset Icon = Application::ResetBitmap;
    preset ButtonText = "{parc}Reset";
    preset Action = Reset;
  }

  $rect <20,20,160,60>
  object Application::Button ViewLogButton
  {
    preset Bounds = <505,425,625,470>;
    preset Enabled = true;
    preset Icon = Application::ViewLogBitmap;
    preset ButtonText = "{parc}Silence/ {fnt3}Acknowledge";
    preset Action = Silence;
  }

  $rect <20,20,160,60>
  object Application::Button LogOnButton
  {
    preset Bounds = <255,425,375,470>;
    preset Icon = Application::KeyBitmap;
    preset ButtonText = "{parc}Log On";
    preset Action = LogOn;
  }

  $rect <425,495,625,535>
  slot DisablementsEnter
  {
    sender; /* the method is called from the sender object */



    Disablements.Visible = true;
    Disablements.Enabled = true;




  }

  $rect <415,540,615,580>
  slot DisablementsExit
  {
    sender; /* the method is called from the sender object */ 


    Disablements.Visible = false;
    Disablements.Enabled = false;
  }

  $rect <213,496,413,536>
  slot EventsEnter
  {
    sender; /* the method is called from the sender object */




    DeviceList.Visible = true;
    DeviceList.Enabled = true;


    //Events.SlideTouchHandler.Enabled = true;


  }

  $rect <200,540,400,580>
  slot EventsExit
  {
    sender; /* the method is called from the sender object */

    DeviceList.Visible = false;
    DeviceList.Enabled = false;

    //Events.SlideTouchHandler.Enabled = false;



  }

  $rect <6,543,206,583>
  slot AlarmsExit
  {
    sender; /* the method is called from the sender object */

    Alarms.Visible = false;
    Alarms.Enabled = false;

    //Alarms.SlideTouchHandler.Enabled = false;



  }

  $rect <20,20,160,60>
  object Application::Events DeviceList
  {
    preset Bounds = <10,60,800,420>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::Alarms Alarms
  {
    preset Bounds = <10,60,790,410>;
    preset Enabled = true;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Application::CauseAndEffects CauseAndEffects
  {
    preset Bounds = <10,60,800,410>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <835,120,1035,160>
  slot PageSelection
  {
    sender; /* the method is called from the sender object */


    var Application::MenuItem i = (Application::MenuItem) sender;

    if ( i.Text1.String == "Enable/Disable" )
    {
        EnableDisable.Enabled = true;
        EnableDisable.Visible = true;
    }
    else if ( SelectedTab == "Cause And Effects" )
    {
         CauseAndEffects.Enabled = true;
         CauseAndEffects.Visible = true;
    }
    else if ( SelectedTab == "Test" )
    {
         Test.Enabled = true;
         Test.Visible = true;
    }
    else if ( SelectedTab == "Settings" )
    {
         Settings.Visible = true;
         Settings.Enabled = true;
    }
    else if ( SelectedTab == "Configure" )
    {
         MeshTree.Enabled = true;
         MeshTree.Visible = true;
    }
    else if ( SelectedTab == "System" )
    {
       SystemPage.Enabled = true;
       SystemPage.Visible = true;
       SystemPage.Timer.Enabled = true;
    }
    else if ( SelectedTab == "Modify" )
    {
       Modify.Enabled = true;
       Modify.Visible = true;
    }

  }

  $rect <835,160,1035,200>
  method void PageDeselection()
  {
    var object v = first;

    while ( v != last )
    {
        var class tc = (Application::TabButton) classof v;

        if ( tc != null )
        {
            var Application::TabButton tb = (Application::TabButton) v;
            if ( tb.Text1.String == SelectedTab )
            {            
                tb.pressed = false;
                postsignal tb.OnDeactivate;
                return;
            }
        }

        v = ((Core::View)v).next;
    }
       
    TabButtonPull.Text2.String = "";
    TabButtonPull.Background.Color = #93C2FFFF;
     

    if ( SelectedTab == "Enable/Disable" )
    {
        EnableDisable.Visible = false;
        EnableDisable.Enabled = false;
    }
    else if ( SelectedTab == "Settings" )
    {
         Settings.Visible = false;
         Settings.Enabled = false;
     }
    else if ( SelectedTab == "Cause And Effects" )
    {
         CauseAndEffects.Enabled = false;
         CauseAndEffects.Visible = false;
    }
    else if ( SelectedTab == "Test" )
    {
         Test.Enabled = false;
         Test.Visible = false;
    }
    else if ( SelectedTab == "Configure" )
    {
         MeshTree.Enabled = false;
         MeshTree.Visible = false;
    }
    else if ( SelectedTab == "System" )
    {
       SystemPage.Visible = false;
       SystemPage.Enabled = false;
       SystemPage.Enabled = false;
       SystemPage.Timer.Enabled = false;
    }
    else if ( SelectedTab == "Modify" )
    {
       Modify.Enabled = false;
       Modify.Visible = false;
    }
    return ;
  }

  $rect <20,20,160,60>
  object Application::Test Test
  {
    preset Bounds = <10,60,790,410>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::Settings Settings
  {
    preset Bounds = <10,60,790,410>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::SystemPage SystemPage
  {
    preset Bounds = <10,60,795,410>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::Modify Modify
  {
    preset Bounds = <10,60,790,410>;
    preset Enabled = false;
    preset AlphaBlended = true;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::Faults Faults
  {
    preset Bounds = <5,55,795,405>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <623,495,823,535>
  slot FaultsEnter
  {
    sender; /* the method is called from the sender object */

    Faults.Visible = true;
    Faults.Enabled = true;


    //Events.SlideTouchHandler.Enabled = true;


  }

  $rect <610,539,810,579>
  slot FaultsExit
  {
    sender; /* the method is called from the sender object */

    Faults.Visible = false;
    Faults.Enabled = false;

    //Events.SlideTouchHandler.Enabled = false;



  }

  $rect <828,495,1028,535>
  slot OnTestEnter
  {
    sender; /* the method is called from the sender object */

    OnTest.Visible = true;
    OnTest.Enabled = true;


    //Events.SlideTouchHandler.Enabled = true;


  }

  $rect <20,20,160,60>
  object Application::LevelAccess LevelAccess
  {
    preset Bounds = <662,431,797,446>;
  }

  $rect <815,539,1015,579>
  slot OnTestExit
  {
    sender; /* the method is called from the sender object */

    OnTest.Visible = false;
    OnTest.Enabled = false;

    //Events.SlideTouchHandler.Enabled = false;



  }

  $rect <489,589,609,629>
  slot Mute
  {
    native 
    {
       Command cmd;

       Command0( CMD_MUTE_BUZZER, &cmd );
    }




  }

  $rect <830,295,1030,335>
  var Core::Time TheTime = null;

  $rect <810,360,1010,400>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font3 = OldResources::FontVerdana20;
    preset Font2 = OldResources::FontVerdana18;
    preset Font1 = Application::FontVerdana16;
    preset Font0 = Application::FontVerdana14;
    preset Color1 = #FFFFFFFF;
  }

  $rect <810,400,1010,440>
  object Core::Timer Timer
  {
    preset OnTrigger = Tick;
    preset Enabled = true;
  }

  $rect <815,440,1015,480>
  slot Tick
  {
    sender; /* the method is called from the sender object */

    //if ( Time == null )
    {

      var Core::Time Time = new Core::Time;
       
                 
     
      Time = Time.CurrentTime;

       TimeDateText.String = Time.Format( "%H:%M.%S %a %#d" );

       var string pf;

       if ( Time.Day > 3 && Time.Day < 21 )
       {
       pf = "th";
       }
       else switch ( Time.Day % 10 )
       {
          case 1 : pf = "st";
          case 2 : pf = "nd";
          case 3 : pf = "rd";
          default : pf = "th";
       }
        
       TimeDateText.String = TimeDateText.String + pf + Time.Format( " %b" );


     }
  }

  $rect <2,590,131,630>
  slot Evacuate
  {
    if ( LevelAccess.Level > 1 )
    {
      var Application::ConfirmPopup popup = new Application::ConfirmPopup;

      popup.Text1.String = "Sound alarms for evacuation?";

      popup.ShowThen( GetRoot(), Evacuate1 );
    }
    else
    {
       LowLevel();
    }
        
  }

  $rect <129,589,238,629>
  slot LogOn
  {
    var Application::KeypadPopup popup = new Application::KeypadPopup;

    if ( LogOnButton.ButtonText == "{parc}Log On" )
    {
      popup.Show( GetRoot() );
      popup.Writable.ObtainFocus();
    }
    else
    {
      LevelAccess.Level = 1;
    }





  }

  $rect <240,589,360,629>
  slot Reset
  {
    var Application::ConfirmPopup popup = new Application::ConfirmPopup;

    popup.Text1.String = "Reset System?";

    popup.ShowThen( GetRoot(), Reset1 );



  }

  $rect <369,589,489,629>
  method void LowLevel()
  {
    var Application::AccesssPopup ll = new Application::AccesssPopup;

    ll.Text.String = "Logon required";

    ll.Show( GetRoot() );

  }

  $rect <830,215,1030,255>
  property Application::Popup TestPop = null;

  $rect <830,255,1030,295>
  property Application::Popup DisablePop = null;

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1090,210,1220,250>
  slot onFireEvent
  {
    var uint16 fires;



    native ( fires )
    {
      Command cmd;

      Command0( CMD_GET_NUM_FIRES, &cmd );  

      fires = cmd.int0;  
    }


    if ( fires > 0 )
    {
         
        Seperator.ColorBL = #FF0000FF ;
        Seperator.ColorBR = #3C0000FF ;
        Seperator.ColorTL = #FF0000FF ;
        Seperator.ColorTR = #3C0000FF ;

        Alarms.NoActiveAlarmsText.Visible = false;
     }
     else
     {
        Seperator.ColorBL  = #78AAFFFF ;
        Seperator.ColorBR  = #2B3844FF ;
        Seperator.ColorTL  = #78AAFFFF ;
        Seperator.ColorTR  = #2B3844FF ;
                           
        Alarms.NoActiveAlarmsText.Visible = true;
     }


    AlarmsTabButton.NumberOf = fires;
    AlarmsTabButton.InvalidateViewState();

    Alarms.InvalidateViewState();


    Alarms.VerticalList.NoOfItems = fires;
    Alarms.VerticalList.InvalidateItems( 0, fires - 1 );
    Alarms.VertScrollbar.ContentArea = fires * Alarms.VerticalList.ItemHeight;
     

    if (  fires != 0 )
    {
      postsignal AlarmsTabButton.OnPress;
    }






    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <1125,75,1325,115>
  var int32 xpos = 0;

  $rect <1095,175,1295,215>
  object Core::SystemEventHandler FireListChangeEventHandler
  {
    preset OnEvent = onFireEvent;
    preset Event = Application::Devices.FireListChangeEvent;
  }

  $rect <231,630,351,670>
  slot Reset1
  {
    native 
    {
       Command cmd;

       Command0( CMD_RESET_BUTTON, &cmd );
    }

    Alarms.EvacPressed = false;
    Alarms.ResoundAlarmsButton.Enabled = true;



  }

  $rect <-6,630,123,670>
  slot Evacuate1
  {
    Alarms.EvacPressed = true;


    native 
    {
       Command cmd;

       Command0( CMD_EVACUATE_BUTTON, &cmd );
    }



  }

  $rect <614,586,734,626>
  slot Silence
  {
    if ( Alarms.EvacPressed )
    {
       Alarms.ResoundAlarmsButton.Enabled = true;
    }

    native 
    {
       Command cmd;

       Command0( CMD_SILENCE_ACK_BUTTON, &cmd );
    }


  }

  $rect <1080,300,1310,340>
  object Core::SystemEventHandler StartProgressEventHandler
  {
    preset OnEvent = onEvent;
    preset Enabled = true;
    preset Event = Application::Devices.StartProgressEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1080,340,1280,380>
  slot onEvent
  {
    ProgressPopup.HorizontalValueBar.CurrentValue = 0;
    ProgressPopup.Visible = true;
    ProgressPopup.Timer.Enabled = true;




    /*
    var Application::Progress p = (Application::Progress) SystemEventHandler.Context;



    if ( p.amount == -1  )
    {
      ProgressPopup.HorizontalValueBar.CurrentValue = 0;
      ProgressPopup.HorizontalValueBar.Draw( aCanvas, aClip, aOffset, aOpacity, aBlend )
      ActionButton3.CaptionText.String = "OK";
       Text.Visible = true;
       return;
     }

    HorzBar1.CurrentValue = p.amount;
                                   

    if ( p.amount == 100  )
    {
       ActionButton3.CaptionText.String = "OK";
       
       HorzBar1.BarColor = XFlat::ColorXFlatYellow;

        
    }

    */
    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <20,20,160,60>
  object Application::Disablements Disablements
  {
    preset Bounds = <5,60,795,410>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::OnTest OnTest
  {
    preset Bounds = <5,55,795,405>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::Disable EnableDisable
  {
    preset Bounds = <5,55,605,405>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::MeshTree MeshTree
  {
    preset Bounds = <2,55,799,405>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::ProgressPopup ProgressPopup
  {
    preset Bounds = <170,140,600,370>;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::TabButtonPull TabButtonPull
  {
    preset Bounds = <630,0,800,340>;
    preset Text = "Access";
    preset Icon = Application::AccessBitmap;
    preset OnSelectItem = PageSelection;
  }

  $rect <1080,395,1310,435>
  object Core::SystemEventHandler WriteProtectedEventHandler
  {
    preset OnEvent = onEvent1;
    preset Enabled = true;
    preset Event = Application::Devices.WriteProtectedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1080,435,1280,475>
  slot onEvent1
  {
    var Application::AccesssPopup ll = new Application::AccesssPopup;

    ll.Text.String = "Internal Flash is write protected";

    ll.Show( GetRoot() );


  }

  $rect <20,20,160,60>
  object Application::DFUPopup DFUPopup
  {
    preset Bounds = <170,140,600,350>;
    preset Visible = false;
  }

  $rect <1085,495,1285,535>
  object Core::SystemEventHandler DFUEventHandler
  {
    preset OnEvent = onEvent2;
    preset Event = Application::Devices.DFUEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1075,535,1275,575>
  slot onEvent2
  {
    DFUPopup.Visible = true;

    InvalidateViewState( );

    DFUPopup.Text.String = DFUPopup.Text.String + " ";

    InvalidateViewState( );

    DFUPopup.Timer.Enabled = true;




  }
}

$rect <400,0,530,40>
$output false
class TabButton : Core::Group
{
  $rect <0,170,140,210>
  inherited property Layout = Core::Layout[ResizeHorz, ResizeVert];

  $rect <10,230,210,270>
  inherited property Bounds = <0,0,133,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


          Text1.String = Text;
          Image.Bitmap = Icon;

          if ( NumberOf > 0 )
          {
              Text2.String = "(" + string( NumberOf ) + ")";
          }
          else
          {
              Text2.String = "";
          }

          
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <1,1,134,44>;
    preset ColorBL = #ECECECFF;
    preset ColorBR = #ECECECFF;
    preset ColorTR = #ECECECFF;
    preset ColorTL = #ECECECFF;
    preset Color = #ECECECFF;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,133,45>;
    preset Width = 1;
    preset ColorL = #737373FF;
    preset ColorR = #303030FF;
    preset ColorB = #303030FF;
    preset ColorT = #737373FF;
  }

  // This variable stores the current state of the button.
  $rect <10,490,210,530>
  var bool selected = false;

  // This variable stores the current state of the button.
  $rect <10,450,210,490>
  var bool enabled = true;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <133,0>;
    preset Point2 = <133,45>;
    preset Point1 = <0,45>;
    preset OnLeave = null;
    preset OnRelease = null;
    preset OnPress = OnPress;
  }

  $rect <330,0,530,40>
  slot OnPress
  {
    sender; /* the method is called from the sender object */

    Image.Visible = true;
    Timer.Enabled = false;


    if ( Selected^ == Text1.String ) return;

    var Application::Application app = (Application::Application) Owner;

    app.PageDeselection( );

    app.SelectedTab = Text1.String;
    pressed = true;

    postsignal OnActivate;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <540,0,740,40>
  property slot OnActivate = null;

  $rect <94,70,294,110>
  property string Text = "{clr1}Text {fnt0}";

  $rect <20,120,220,160>
  property Resources::Bitmap Icon = null;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToLeft, ResizeVert];
    preset Bounds = <0,0,40,45>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <1050,280,1250,320>
  property bool pressed = false;

  $rect <1050,330,1250,370>
  onset pressed
  {
    // The value doesn't change - nothing to do.
    if ( pure pressed == value )
      return;

    // Remember the property's new value.
    pure pressed = value;

     var color t = Bevel.ColorB;
      Bevel.ColorB = Bevel.ColorT;
      Bevel.ColorT = t;

      t = Bevel.ColorL;
      Bevel.ColorL = Bevel.ColorR;
      Bevel.ColorR = t;

    if ( pressed )
    {
        Background.ColorBL = #BBBBBBFF;
        Background.ColorBR = #CCCCCCFF;
        Background.ColorTL = #DCDCDCFF;
        Background.ColorTR = #DCDCDCFF;

        Text1.Bounds.x1 = Text1.Bounds.x1 + 2;
        Text1.Bounds.y1 = Text1.Bounds.y1 + 2;
        Text2.Bounds.x1 = Text2.Bounds.x1 + 2;
        Text2.Bounds.y1 = Text2.Bounds.y1 + 2;


        Image.Bounds.x1 = Image.Bounds.x1 + 2;
        Image.Bounds.y1 = Image.Bounds.y1 + 2;    
    }

    else
    {
        Background.ColorBL = #ECECECFF;
        Background.ColorBR = #ECECECFF;
        Background.ColorTL = #ECECECFF;
        Background.ColorTR = #ECECECFF;

        Text2.Bounds.x1 = Text2.Bounds.x1 - 2;
        Text2.Bounds.y1 = Text2.Bounds.y1 - 2;

        Text1.Bounds.x1 = Text1.Bounds.x1 - 2;
        Text1.Bounds.y1 = Text1.Bounds.y1 - 2;
        Image.Bounds.x1 = Image.Bounds.x1 - 2;
        Image.Bounds.y1 = Image.Bounds.y1 - 2;   
    }
            

    InvalidateViewState();


    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <520,160,720,200>
  property ^string Selected = null;

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <549,40,749,80>
  property slot OnDeactivate = null;

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <40,20,85,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "(33)";
    preset Font = Application::FontVerdana16;
    preset Color = #0A0637FF;
  }

  $rect <300,70,500,110>
  property uint16 NumberOf = 0;

  $rect <20,20,160,60>
  object Views::AttrText Text1
  {
    preset Bounds = <39,5,132,45>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertTop];
    preset String = "";
    preset AttrSet = AttrSet1;
  }

  $rect <500,590,700,630>
  $output true
  object Graphics::AttrSet AttrSet1
  {
    preset Font3 = Application::FontVerdanaProCondSemiBold18;
    preset Font2 = OldResources::FontVerdana18;
    preset Font1 = Application::FontVerdana14;
    preset Font0 = Application::VerdanaProSemiBold16;
    preset Color1 = #000000FF;
    preset Color0 = #111111FF;
  }

  $rect <810,80,1010,120>
  object Core::Timer Timer
  {
    preset OnTrigger = TimerSlot;
    preset Period = 400;
    preset Enabled = false;
  }

  $rect <810,120,1010,160>
  slot TimerSlot
  {
    sender; /* the method is called from the sender object */

    Image.Visible = !Image.Visible;

     

  }
}

$rect <1240,270,1440,310>
$output false
resource Resources::Bitmap AlarmBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\alarm2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,550,1640,590>
$output false
resource Resources::Bitmap AlertBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\alert2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <230,50,380,90>
$output false
class AlarmRowItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,510,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
     

          var string s = string( OrderPosition );

          if ( OrderPosition > 3 && OrderPosition < 21 ) 
          {
              s = s + "th";
          }
          else switch( OrderPosition % 10 )
          {
            case 1: s = s + "st";
            case 2: s = s + "nd";
            case 3: s = s + "rd";
            default: s = s + "th";
          }

          OrderPos.String = s;


            
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,510,45>;
    preset Color = #E2E2E2FF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <68,20,430,43>;
    preset WrapWidth = Bounds.w;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Textual Description";
    preset Font = Resources::FontMedium;
    preset Color = #161616FF;
  }

  $rect <20,20,160,60>
  object Views::Text OrderPos
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,65,45>;
    preset String = "Text";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #161616FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <70,1,365,19>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 1 Unit 23";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #161616FF;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <340,1,470,19>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "12:33 31/12/18";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #161616FF;
  }

  $rect <230,80,430,120>
  property string DescriptionText = "Textual Description";

  $rect <230,120,430,160>
  onset DescriptionText
  {
    // The value doesn't change - nothing to do.
    if ( pure DescriptionText == value )
      return;

    // Remember the property's new value.
    pure DescriptionText = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <230,160,430,200>
  onget DescriptionText
  {
    return pure DescriptionText;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, ResizeVert];
    preset Bounds = <471,0,509,45>;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset Bitmap = Application::FireBitmap;
  }

  $rect <190,190,390,230>
  object Core::Timer Timer
  {
    preset OnTrigger = Trigger;
    preset Period = 600;
    preset Enabled = true;
  }

  $rect <660,10,790,50>
  slot Trigger
  {
    sender; /* the method is called from the sender object */

    if (Flashing )
    {
      OrderPos.Visible = !OrderPos.Visible;
    }



  }

  $rect <790,10,910,50>
  var bool Flashing = true;

  $rect <710,80,910,120>
  property Application::IconEnum IconType = Application::IconEnum.AlarmActivated;

  $rect <710,120,910,160>
  onset IconType
  {
    // The value doesn't change - nothing to do.
    if ( pure IconType == value )
      return;

    // Remember the property's new value.
    pure IconType = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <0,70,200,110>
  property int32 OrderPosition = 0;

  $rect <0,110,200,150>
  onset OrderPosition
  {
    // The value doesn't change - nothing to do.
    if ( pure OrderPosition == value )
      return;

    // Remember the property's new value.
    pure OrderPosition = value;


    InvalidateViewState();
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <45,90,555,135>;
    preset Color = #D4D4D4FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight];
    preset Bounds = <435,20,467,42>;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset Bitmap = Application::SilencedBitmap;
  }
}

$rect <1240,310,1440,350>
$output false
resource Resources::Bitmap FireAlarmBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\fire_alarm.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <680,0,830,40>
$output false
class Button : Core::Group
{
  $rect <0,260,200,300>
  inherited property Bounds = <0,0,120,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

     
    Image.Bitmap = Icon;


    AttrText.String = ButtonText;



    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <665,125,805,165>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    // Assume the worst case of a ring composed of two ellipsis thus
    // two sub-paths.

      Path1.InitSubPath( 0, 4 + 20  );
      Path1.Translate( 1,1 )    ;
      Path1.Begin( 0, pure Radius, 0 );
      Path1.AddArc( 0, Bounds.w-2 - pure Radius , pure Radius, pure Radius, pure Radius, -90, 0, 5 );
      Path1.AddArc( 0, Bounds.w-2 - pure Radius , Bounds.h-3 - pure Radius, pure Radius, pure Radius, 0, 90, 5 );
      Path1.AddArc( 0, pure Radius , Bounds.h-3 - pure Radius, pure Radius, pure Radius, 90, 180, 5 );
      Path1.AddArc( 0, pure Radius , pure Radius, pure Radius, pure Radius, 180, 270, 5 );
      Path1.Close( 0 );
      return;

  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath
  {
    preset Bounds = <0,0,120,45>;
    preset Color = #E2E2E2FF;
    preset Quality = false;
    preset Path = Path1;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToLeft, ResizeVert];
    preset Bounds = <0,0,40,45>;
    preset Bitmap = null;
  }

  $rect <0,60,200,100>
  property Resources::Bitmap Icon = null;

  $rect <0,110,200,150>
  property string ButtonText = "Button";

  $rect <20,20,160,60>
  object Views::AttrText AttrText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <40,0,120,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text {img0}";
    preset AttrSet = AttrSet;
  }

  $rect <410,30,610,70>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font3 = Steel::FontArial12;
    preset Font2 = Application::FontVerdana14;
    preset Font1 = Application::VerdanaProSemiBold16;
    preset Font0 = Application::FontVerdanaProSemiBold18;
    preset Color2 = #000000FF;
    preset Color1 = #757575FF;
    preset Color0 = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::StrokePath StrokePath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,45>;
    preset Color = #646464FF;
    preset Quality = true;
    preset JoinPoints = Graphics::PathJoin.Round;
    preset Width = 2;
    preset Path = Path1;
  }

  $rect <310,160,510,200>
  object Graphics::Path Path1;

  $rect <790,0,990,40>
  property int32 Radius = 5;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <120,0>;
    preset Point2 = <120,45>;
    preset Point1 = <0,45>;
    preset OnRelease = Release;
    preset OnPress = Touch;
  }

  $rect <205,0,335,40>
  property slot Action = null;

  $rect <265,95,395,135>
  slot Touch
  {
    sender; /* the method is called from the sender object */

    postsignal Action;

    FillPath.Color = #8BB8E8FF;




  }

  $rect <410,100,540,140>
  slot Release
  {
    sender; /* the method is called from the sender object */


    FillPath.Color = #E2E2E2FF;



  }
}

$rect <1240,350,1440,390>
$output false
resource Resources::Bitmap KeyBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\logon40c.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,430,1440,470>
$output false
resource Resources::Bitmap SmokeBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\smoke2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1100,0,1220,40>
$output false
enum IconEnum
{
  $rect <10,10,210,50>
  item TempSensor;

  $rect <220,10,420,50>
  item SmokeSensor;

  $rect <430,10,630,50>
  item AlarmActivated;
}

$rect <1240,390,1440,430>
$output false
resource Resources::Bitmap MuteBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\mute40c.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

// This class implements a 'scrollbar' widget. The widget is intended to show the \
// current position within a large document (e.g. a long list with thousand of items). \
// It is not intended to react to user interactions.
// When using the scrollbar you need to set its property @ContentArea to the size \
// of the entire document and the property @ViewArea to the size of the visible portion \
// of the document. The scrollbar will calculate from these both values the size \
// of the scrollbar thumb. The current scroll position within the document is determined \
// by the property @Position.
// Per default the scrollbar is invisible. It appears when the properties @ContentSize, \
// @ViewSize or @Position are changed. After a short delay the scrollbar disappears \
// again.
$rect <830,0,970,40>
$output false
class VertScrollbar : Templates::VerticalScrollbar
{
  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,70,340>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2F2F2FFF;
    preset AlphaBlended = false;
  }

  $rect <540,230,740,270>
  inherited property Bounds = <0,0,70,340>;

  $rect <320,190,520,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    Thumb.ColorBR =   #D8D8FFFF;
    Thumb.ColorBL =   #5E5E93FF;
    Thumb.ColorTR =   #D8D8FFFF;
    Thumb.ColorTL =   #5E5E93FF;

    Thumb.Bounds.y1 = Rectangle2.Bounds.y1 + ( Position * Rectangle2.Bounds.h / ContentArea );
    Thumb.Bounds.h = Rectangle2.Bounds.h * ViewArea / ContentArea;

  }

  $rect <540,190,740,230>
  inherited property Enabled = false;

  // To do:
  // 
  // - Adjust the visible size of your scrollbar (the thick blue border). This will \
  // be the scrollbar's default size.
  // - Remove the 'Thumb' member if you want other views to be shown instead this \
  // in your scrollbar.
  // - According to your desired scrollbar design add and configure new views (e.g. \
  // a bitmap frame view to show the thumb, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the scrollbar's current state.
  // - You can also add and configure animation effects to your scrollbar. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your scrollbar.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the scrollbar itself is resized.
  // - Configure the property 'Begin' of the 'ActiveTimer' member to determine when \
  // the scrollbar should disappear. The default duration is 500 millisec.
  // - If you don't want the scrollbar to disappear automatically, remove the members \
  // 'ActiveTimer' and 'onActiveTimer'.
  // - From the Gallery folder 'Chora' add properties to your scrollbar. One property \
  // for every scrollbar specific setting (e.g. 'Color', 'Image', etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'ThumbColor' should update the color property of a rectangle \
  // view representing the thumb in your scrollbar).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note3
  {
    attr Bounds = <200,360,1180,700>;
  }

  // State management
  note group Note2
  {
    attr Bounds = <310,150,530,280>;
  }

  // This variable stores the current state of the scrollbar.
  $rect <320,230,520,270>
  var bool active;

  $rect <490,80,690,120>
  onget Position
  {
    // Get the internally stored value of the property 'Position' and the maximum
    // value the position may assume.
    var int32 value = pure Position;
    var int32 range = ContentArea - ViewArea;

    // Limit the value of the property to its max. allowed value.
    if (( range >  0 ) && ( value > range )) value = range;
    if (  range <= 0 )                       value = 0;

    return value;
  }

  $rect <490,40,690,80>
  onset Position
  {
    // Limit to valid range
    if ( value < 0 )
      value = 0;

    // Check if the given value differs from the current value.
    if ( pure Position == value )
      return;

    // Remember the new value.
    pure Position = value;

    if ( pure Position + ViewArea > ContentArea ) pure Position = ContentArea -  ViewArea;


    if ( Outlet != null ) Outlet^ = Position;



    // Finally force the component to update its appearance.
    InvalidateViewState();
  }

  $rect <290,40,490,80>
  onset ViewArea
  {
    // Limit to valid range
    if ( value < 0 )
      value = 0;

    // Check if the given value differs from the current value.
    if ( pure ViewArea == value )
      return;

    // Remember the new value.
    pure ViewArea = value;

    ThumbSize = Rectangle2.Bounds.h * ViewArea / ContentArea;

    // Every time the size of the view area is modified, the scrollbar should
    // appear for a short period automatically. After the period the scrollbar 
    // disappears again. This short period is controlled by the 'ActiveTimer'.
    // Restart the timer now. Do it however only when there is content to scroll:
    // when 'ContentArea' > 'ViewArea'.
    // to hide the scrollbar.


    // Finally force the component to update its appearance.
    InvalidateViewState();
  }

  $rect <90,40,290,80>
  onset ContentArea
  {
    // Limit to valid range
    if ( value < 0 )
      value = 0;

    // Check if the given value differs from the current value.
    if ( pure ContentArea == value )
      return;

    // Remember the new value.
    pure ContentArea = value;

    if ( ContentArea < ViewArea ) ContentArea = ViewArea;
    // Every time the size of the content area is modified, the scrollbar should
    // appear for a short period automatically. After the period the scrollbar 
    // disappears again. This short period is controlled by the 'ActiveTimer'.
    // Restart the timer now. Do it however only when there is content to scroll:
    // when 'ContentArea' > 'ViewArea'.

    // Finally force the component to update its appearance.
    InvalidateViewState();
  }

  // The property 'Position' determines the current scroll position within the entire \
  // content. Generally the value lies in the range 0 .. ( @ContentArea - @ViewArea \
  // ).
  $rect <490,0,690,40>
  property int32 Position = 0;

  // The property 'ViewArea' determines the size of the visible portion of the entire \
  // content. This usually corresponds to the size of the viewport where the user \
  // can see the document (the image, text, etc.). Generally the value ViewArea <= \
  // @ContentArea.
  $rect <290,0,490,40>
  property int32 ViewArea = 160;

  // The property 'ContentArea' determines the size of the entire content to scroll. \
  // This usually corresponds to the size of the document (image, text, etc.) you \
  // want to present to the user. Generally the value ContentArea >= @ViewArea.
  $rect <90,0,290,40>
  property int32 ContentArea = 1000;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,2,68,338>;
    preset Color = #353535FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Thumb
  {
    preset Layout = Core::Layout[ResizeHorz];
    preset Bounds = <2,2,68,70>;
    preset ColorBL = #D8D8FFFF;
    preset ColorBR = #5E5E83FF;
    preset ColorTR = #5E5E83FF;
    preset ColorTL = #D8D8FFFF;
    preset Color = #047601FF;
    preset AlphaBlended = false;
  }

  $rect <830,130,1030,170>
  slot Start
  {
    sender; /* the method is called from the sender object */


    //StartPos = Touch.Offset.y;

  }

  $rect <810,210,1010,250>
  slot Stop
  {
    sender; /* the method is called from the sender object */
  }

  $rect <810,170,1010,210>
  slot Drag
  {
    sender; /* the method is called from the sender object */

    //Position = Position + Touch.Offset.y;

  }

  $rect <830,80,1030,120>
  var int32 StartPos = 0;

  $rect <100,100,300,140>
  slot Bottom
  {
    sender; /* the method is called from the sender object */

    Position = 999999;

    postsignal OnChange;

    InvalidateViewState();

  }

  $rect <100,150,300,190>
  slot Top
  {
    sender; /* the method is called from the sender object */

    Position = 0;

    postsignal OnChange;

    InvalidateViewState();


  }

  $rect <100,250,300,290>
  slot Down
  {
    sender; /* the method is called from the sender object */

    Position = Position + ViewArea;

    signal OnChange;

    InvalidateViewState();

  }

  $rect <100,210,300,250>
  slot Up
  {
    sender; /* the method is called from the sender object */

    Position = Position - ViewArea;

    postsignal OnChange;

    InvalidateViewState();

  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,10,60,60>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #6C6C6CFF;
    preset ColorTR = #6C6C6CFF;
    preset ColorTL = #FFFFFFFF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <10,10>;
    preset Point3 = <60,10>;
    preset Point2 = <60,60>;
    preset Point1 = <10,60>;
    preset OnPress = Top;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,70,60,120>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #6C6C6CFF;
    preset ColorTR = #6C6C6CFF;
    preset ColorTL = #FFFFFFFF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <10,70>;
    preset Point3 = <60,70>;
    preset Point2 = <60,120>;
    preset Point1 = <10,120>;
    preset OnPress = Up;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,280,60,330>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #6C6C6CFF;
    preset ColorTR = #6C6C6CFF;
    preset ColorTL = #FFFFFFFF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <10,280>;
    preset Point3 = <60,280>;
    preset Point2 = <60,330>;
    preset Point1 = <10,330>;
    preset OnPress = Bottom;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,220,60,270>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #6C6C6CFF;
    preset ColorTR = #6C6C6CFF;
    preset ColorTL = #FFFFFFFF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <10,220>;
    preset Point3 = <60,220>;
    preset Point2 = <60,270>;
    preset Point1 = <10,270>;
    preset OnDrag = null;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnHold = null;
    preset OnRelease = null;
    preset OnPress = Down;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,10,60,60>;
    preset Color = #F00000FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,70,60,120>;
    preset Color = #F00000FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Border Border2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,220,60,270>;
    preset Color = #F00000FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Border Border3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,280,60,330>;
    preset Color = #F00000FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,70,60,120>;
    preset Bitmap = Application::UpBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,280,60,330>;
    preset Bitmap = Application::EndBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,10,60,60>;
    preset Bitmap = Application::StartBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image Image3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,220,60,270>;
    preset Bitmap = Application::DownBitmap;
  }

  // The property 'Position' determines the current scroll position within the entire \
  // content. Generally the value lies in the range 0 .. ( @ContentArea - @ViewArea \
  // ).
  $rect <700,0,900,40>
  property int32 ThumbSize = 50;

  $rect <1000,0,1200,40>
  property ^int32 Outlet = null;

  $rect <1000,40,1200,80>
  onset Outlet
  {
    /* check if the new outlet differs from the currently used outlet */
    if ( pure Outlet == value )
      return;

    /* detach from the previous outlet */
    if ( pure Outlet != null )
      detachobserver outletSlot, pure Outlet;

    /* store the new outlet */
    pure Outlet = value;

    /* ... and attach to the new one */
    if ( value != null )
      attachobserver outletSlot, value;

    /* finally, update the current state of the widget by posting a signal to the outlet slot */
    if ( value != null )
      postsignal outletSlot;

  }

  $rect <1050,80,1250,120>
  slot outletSlot
  {
    sender; /* the method is called from the sender object */

    if ( Outlet != null )
      Position = Outlet^;


  }

  $rect <310,300,510,340>
  property slot OnChange = null;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler4
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <10,70>;
    preset Point3 = <60,70>;
    preset Point2 = <60,120>;
    preset Point1 = <10,120>;
    preset OnPress = Up;
  }

  $reorder Bevel 76
}

$rect <1660,590,1860,630>
$output false
resource Resources::Bitmap HelpBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\help.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,630,1440,670>
$output false
resource Resources::Bitmap CygnusBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\Cygnus_Smartnet_crap_blue.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,670,1860,710>
$output false
resource Resources::Bitmap FaultBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\fault.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,270,1860,310>
$output false
resource Resources::Bitmap DisableBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\disablements_new.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,270,1640,310>
$output false
resource Resources::Bitmap OnTestBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\test.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <530,0,680,40>
$output false
class TabButtonPull : Core::Group
{
  $rect <800,110,940,150>
  inherited property Layout = Core::Layout[ResizeHorz, ResizeVert];

  $rect <810,170,1010,210>
  inherited property Bounds = <0,0,170,285>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


          Text1.String = Text;
      //    Image.Bitmap = Icon;

          
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <37,1,169,44>;
    preset ColorBL = #93C2FFFF;
    preset ColorBR = #93C2FFFF;
    preset ColorTR = #93C2FFFF;
    preset ColorTL = #93C2FFFF;
    preset Color = #93C2FFFF;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <36,0,170,45>;
    preset Width = 1;
    preset ColorL = #737373FF;
    preset ColorR = #303030ff;
    preset ColorB = #303030ff;
    preset ColorT = #737373FF;
  }

  // This variable stores the current state of the button.
  $rect <10,490,210,530>
  var bool selected = false;

  // This variable stores the current state of the button.
  $rect <10,450,210,490>
  var bool enabled = true;

  $rect <250,80,450,120>
  slot OnPress
  {
    sender; /* the method is called from the sender object */

       
    if ( !pressed )
    {
      var Application::Application ap = (Application::Application) this.GetRoot();

      if ( ap.LevelAccess.Level > 1 )
      {
     
        pressed = true;

        Menu.Visible = true;
        Menu.Enabled = true;

        outside1 = new Core::SimpleTouchHandler;
        outside2 = new Core::SimpleTouchHandler;

        outside1.Point1 = <0,0>;
        outside1.Point2 = <630,0>;
        outside1.Point3 = <630,325>;
        outside1.Point4 = <0, 325>;

        outside2.Point1 = <0,325>;
        outside2.Point2 = <800,325>;
        outside2.Point3 = <800,480>;
        outside2.Point4 = <0, 480>;

        outside1.OnPress = OutsidePress;
        outside2.OnPress = OutsidePress;

        Owner.Add( outside1, 0 );
        Owner.Add( outside2, 0 );

        InvalidateViewState();
      }
      else
      {
       ((Application::Application) GetRoot()).LowLevel();
       }

    }


  }

  $rect <870,0,1070,40>
  property string Text = "TabButton";

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <44,0,119,25>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Access";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <820,60,1020,100>
  property Resources::Bitmap Icon = null;

  $rect <1020,280,1220,320>
  property bool pressed = false;

  $rect <1020,330,1220,370>
  onset pressed
  {
    // The value doesn't change - nothing to do.
    if ( pure pressed == value )
      return;

    // Remember the property's new value.
    pure pressed = value;

     var color t = Bevel.ColorB;
      Bevel.ColorB = Bevel.ColorT;
      Bevel.ColorT = t;

      t = Bevel.ColorL;
      Bevel.ColorL = Bevel.ColorR;
      Bevel.ColorR = t;

    if ( pressed )
    {

        Text1.Bounds.x1 = Text1.Bounds.x1 + 2;
        Text1.Bounds.y1 = Text1.Bounds.y1 + 2;
        Image.Bounds.x1 = Image.Bounds.x1 + 2;
        Image.Bounds.y1 = Image.Bounds.y1 + 2;    
    }

    else
    {
        Text1.Bounds.x1 = Text1.Bounds.x1 - 2;
        Text1.Bounds.y1 = Text1.Bounds.y1 - 2;
        Image.Bounds.x1 = Image.Bounds.x1 - 2;
        Image.Bounds.y1 = Image.Bounds.y1 - 2;   
    }
            

    InvalidateViewState();


  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <135,0,167,29>;
    preset Bitmap = Application::DropdownBitmap;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <35,0>;
    preset Point3 = <169,0>;
    preset Point2 = <169,45>;
    preset Point1 = <35,45>;
    preset OnLeave = null;
    preset OnRelease = null;
    preset OnPress = OnPress;
  }

  $rect <20,20,160,60>
  object Core::VerticalList Menu
  {
    preset Layout = Core::Layout[AlignToTop, ResizeHorz];
    preset Bounds = <0,45,170,285>;
    preset Enabled = false;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 40;
    preset NoOfItems = 6;
    preset ItemClass = Application::MenuItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <225,125,425,165>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = Menu.Item;
    var Application::MenuItem item = (Application::MenuItem) Menu.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    switch ( itemNo )
    {
        case 0 : item.Text1.String = "Enable/Disable";
        case 1 : item.Text1.String = "Test";

        case 2: item.Text1.String = "System";
        case 3 : item.Text1.String = "Modify";
        case 4 : item.Text1.String = "Configure";
        case 5 : item.Text1.String = "Settings";
    }


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.

    item.Bounds.size = point( Menu.Bounds.w, Menu.ItemHeight );
  }

  $rect <260,175,460,215>
  method void MenuChoice( arg Application::MenuItem choice )
  {
    /* The template just returns the given argument... */
                 
    Owner.Remove( outside1 );
    Owner.Remove( outside2 ); 



    ((Application::Application) Owner).PageDeselection( );

    Text2.String = choice.Text1.String;
    Background.ColorBL = #AAAAAAFF;
    Background.ColorBR = #AAAAAAFF;
    Background.ColorTL = #AAAAAAFF;
    Background.ColorTR = #AAAAAAFF;


    ((Application::Application) Owner).SelectedTab = Text2.String;



    Menu.Visible = false;
    Menu.Enabled = false;

    pressed = false;                  

    postsignal OnSelectItem, choice;

    return;
  }

  $rect <570,10,770,50>
  property slot OnSelectItem = null;

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <42,20,162,46>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Application::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $rect <480,70,680,110>
  slot OutsidePress
  {
    sender; /* the method is called from the sender object */

    Owner.Remove( outside1 );
    Owner.Remove( outside2 ); 




    Menu.Visible = false;
    Menu.Enabled = false;

    pressed = false;    
  }

  $rect <490,120,690,160>
  var Core::SimpleTouchHandler outside1 = null;

  $rect <505,180,705,220>
  var Core::SimpleTouchHandler outside2 = null;
}

$rect <1240,190,1440,230>
$output false
resource Resources::Bitmap XBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\x-mark-32.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,230,1640,270>
$output false
resource Resources::Bitmap AccessBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\access.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,670,1440,710>
$output false
resource Resources::Bitmap DropdownBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\dropdown.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,630,1860,670>
$output false
resource Resources::Bitmap EvacuateBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\evacuate40c.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,710,1640,750>
$output false
resource Resources::Bitmap OnTestBitmap1
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\test.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,550,1440,590>
$output false
resource Resources::Bitmap ResetBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\reset40c.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,630,1640,670>
$output false
resource Resources::Bitmap EndBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\end.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,670,1640,710>
$output false
resource Resources::Bitmap StartBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\start.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,550,1860,590>
$output false
resource Resources::Bitmap DownBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\down.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1300,1210,1500,1250>
$output false
resource Resources::Font FontVerdana16
{
  attr fontname FontName = Verdana;
  attr fontheight Height = 16;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7E;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <1660,470,1860,510>
$output false
resource Resources::Bitmap ExpandBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\expand30.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,510,1860,550>
$output false
resource Resources::Bitmap CollapseBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\collapse30.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <790,140,990,180>
$output false
class CheckBoxRow : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,600,35>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Application::FlatCheckBox FlatCheckBox0
  {
    preset Bounds = <0,0,300,35>;
  }

  $rect <20,20,160,60>
  object Application::FlatCheckBox FlatCheckBox1
  {
    preset Bounds = <300,0,600,35>;
  }
}

$rect <1230,0,1430,40>
$output false
class FlatCheckBox : Flat::CheckBox
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,150,35>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  inherited object TouchHandler
  {
    preset Point4 = <0,35>;
    preset Point3 = <150,35>;
    preset Point2 = <150,0>;
  }

  $rect <20,20,160,60>
  inherited object BoxImage
  {
    preset Bounds = <0,0,40,35>;
  }

  $rect <20,20,160,60>
  inherited object CheckImage
  {
    preset Bounds = <0,0,140,35>;
  }

  $rect <20,20,160,60>
  inherited object CaptionText
  {
    preset Bounds = <35,0,140,35>;
    preset Font = Flat::FontS;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }
}

$rect <250,100,450,140>
$output false
class DeviceItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,520,50>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    UnitNumberText.String = "Disable Unit " + string( UnitNum );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Application::FlatCheckBox FlatCheckBox0
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <-1,0,60,50>;
    preset OnChange = OnChangeSlot;
    preset Caption = "";
  }

  $rect <70,80,270,120>
  property int32 UnitNum = 0;

  $rect <20,20,160,60>
  object Views::Text UnitNumberText
  {
    preset Bounds = <49,2,189,22>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 1 Unit 23";
    preset Font = Application::FontVerdanaProSemiBold18;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <48,17,463,47>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Hallway, Front building 2";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, ResizeVert];
    preset Bounds = <472,5,512,45>;
    preset ScrollOffset = <0,0>;
    preset Bitmap = Application::FireAlarmBitmap;
  }

  $rect <320,80,520,120>
  slot OnChangeSlot
  {
    sender; /* the method is called from the sender object */

    /*

     var Core::VerticalList vl = (Core::VerticalList) this.Owner;

            if ( vl != null )
            {
                 var Application::DeviceItem di = (Application::DeviceItem) vl.first;

                 while ( di != null )
                 {
                    if ( di.FlatCheckBox0.Checked ) return;
                
                    di = (Application::DeviceItem) di.next;
                 }
                 var Application::DynamicAreaHead head = (Application::DynamicAreaHead) vl.prev;

                 if ( head != null ) head.CheckBox.Checked = false;
             }

             */
  }
}

$rect <0,50,150,80>
$output false
class Alarms : Core::Group
{
  $rect <10,370,210,410>
  inherited property Bounds = <0,0,780,350>;

  $rect <0,450,200,490>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;
    VertScrollbar.ViewArea    = VerticalList.Bounds.h;


    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,410,200,450>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var int32 fires = 7;

    native( fires )
    {
      Command cmd;

      Command0( CMD_GET_NUM_FIRES, &cmd );  

      fires = cmd.int0;
    }

     

    if ( fires == 0 )
    {
        NoActiveAlarmsText.Visible = true;
        SlideTouchHandler.Enabled = false;
        VertScrollbar.Visible = false;
        VerticalList.Visible = false;
       
    }
    else
    {
        NoActiveAlarmsText.Visible = false;
        SlideTouchHandler.Enabled = true;
        VertScrollbar.Visible = true;

        VerticalList.NoOfItems = fires;
        VerticalList.InvalidateItems( 0, fires - 1 );

        VerticalList.Visible = true;
         
        ResoundAlarmsButton.Enabled = true;

        
    }





  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,550,350>;
    preset Enabled = true;
    preset Visible = true;
    preset OnUpdate = OnScroll;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset SelectedItem = 1;
    preset ItemHeight = 50;
    preset NoOfItems = 11;
    preset ItemClass = Application::AlarmRowItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <10,550,240,590>
  slot OnLoadItem
  {
    var int16 itemNo   = VerticalList.Item;

    var Application::AlarmRowItem row = (Application::AlarmRowItem)VerticalList.View;


    if ( itemNo == 0 )
    {
        row.Flashing = true;
    }
    else
    {  
       row.Flashing = false;
    }

    var int16 order = itemNo;
    var int16 type = 1 + ( itemNo % 7 );
    var string location = "Unknown";
    var string time = "";
    var int16  zone = 0;
    var int16  yunit = 0;
    var int16 fires = 0;
    var int32 lastchan = 0;
    var int32 lastdev = 0;
     

    native ( order, type, location, zone, yunit, itemNo, fires, time, lastdev, lastchan )
    {
      Command cmd;

      Command0(  CMD_GET_NUM_FIRES, &cmd );  

      fires = cmd.int0;

      if ( fires != 0 )
      {
        if ( itemNo == 0 )
        {
           cmd.int0 = 0;
           Command0( CMD_GET_LAST_DETAILS, &cmd );
           order = fires;
        }
        else
        {
          int n;

          cmd.int0 = lastdev;
          cmd.int1 = lastchan;

          for( n = 0; n < itemNo; n++ )
          { 
            Command0( CMD_GET_FIRE_DETAILS, &cmd );
          }
          order = itemNo;
        }
       
        Device* d = (Device*) cmd.int0;

        location = EwNewStringAnsi( (char*) d->config->location );
        
        time     = EwNewStringAnsi( (char*) cmd.int2 );
        zone  =  d->config->zone;
        yunit =  d->config->unit;
        type =   d->config->input[ cmd.int1 ].type;
       }
    }

    $if ($prototyper)
    if ( itemNo == 0 )
    {
      order = VerticalList.NoOfItems;
    }
     
    $endif

    row.OrderPosition = order;


    row.Image.Bitmap = Application::Lib.TypeBitmap( (Application::ChannelType) type );


    row.Text.String = location;
    row.ZoneText.String = "Zone " + string( zone)+"  Unit " + string( yunit );
    row.TimeText.String = time; 

    row.Bounds.w = VerticalList.Bounds.w;      
  }

  $rect <20,500,200,540>
  slot OnScroll
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -VerticalList.ScrollOffset;



  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <-10,0,550,350>;
    preset SnapLast = <0,40>;
    preset SnapNext = <0,40>;
    preset SlideHorz = false;
    preset Enabled = true;
  }

  $rect <805,40,1005,80>
  slot PressScroll
  {
    sender; /* the method is called from the sender object */

    VerticalList.ScrollOffset = -VertScrollbar.Position;

  }

  $rect <20,20,160,60>
  object Views::Text NoActiveAlarmsText
  {
    preset Bounds = <80,140,690,195>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "No active alarms";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #000000FF;
    preset Visible = false;
  }

  $rect <810,0,1010,40>
  slot ResoundSlot
  {
    native
    {
      Command cmd;

      Command0( CMD_RESOUND_ALARMS, &cmd );
    }


  }

  $rect <820,150,970,200>
  property bool EvacPressed = false;

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <551,0,590,350>;
    preset OnScroll = PressScroll;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ResoundAlarmsButton
  {
    preset Bounds = <600,0,780,50>;
    preset OnRelease = ResoundSlot;
    preset Label = "Resound";
    preset Appearance = Application::NormalPushButton;
  }
}

$rect <0,100,110,140>
$output false
class Events : Core::Group
{
  $rect <10,470,210,510>
  inherited property Bounds = <0,0,790,350>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    VertScrollbar.ViewArea = VerticalList.Bounds.h;
    VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,430,210,470>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <500,450,1280,770>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,550,350>;
    preset AlphaBlended = true;
    preset OnUpdate = ScrollDragSlot;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 50;
    preset NoOfItems = 0;
    preset ItemClass = Application::EventItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,550,350>;
  }

  $rect <810,60,1010,100>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -VerticalList.ScrollOffset;
  }

  $rect <810,100,1010,140>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    VerticalList.ScrollOffset = -VertScrollbar.Position;


  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <550,0,600,350>;
    preset OnScroll = ScrollPressSlot;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <850,250,1050,290>
  slot OnLoadItem
  {
    var int16 itemNo   = VerticalList.Item;

    var Application::EventItem row = (Application::EventItem) VerticalList.View;


    if ( itemNo == 0 )
    {
        row.Flashing = true;
    }
    else
    {  
       row.Flashing = false;
    }

    var int16 order = itemNo + 1;
    var int16 type = 0;
    var string location = "Unknown";
    var string time = "";
    var int16  zone = 0;
    var int16  yunit = 0;
    var int16 fires = 0;

    native ( order, type, location, zone, yunit, itemNo, fires, time )
    {
      Command cmd;

      Command0(  CMD_GET_NUM_OTHER_EVENTS, &cmd );  

      fires = cmd.int0;

      if ( fires != 0 )
      {
        if ( itemNo == 0 )
        {
          cmd.int0 = fires - 1;
        }
        else
        {
          cmd.int0 = itemNo - 1;
        }

        order = cmd.int0 + 1;

        Command0( CMD_GET_OTHER_EVENTS_DETAILS, &cmd );
     
        location = EwNewStringAnsi( (char*) cmd.int0 );
        time = EwNewStringAnsi( (char*) cmd.int3);
        zone  = cmd.short2;
        yunit = cmd.short3;
        type = cmd.short4;
       }
    }

    $if ($prototyper)
    if ( itemNo == 0 )
    {
      order = VerticalList.NoOfItems;
    }
    else
    {
      order = itemNo;
    }
    $endif

    row.OrderPosition = order;

    if ( type == 1 )
    {
      row.Image.Bitmap = Application::GreenCallpointBitmap;
    }
    else if ( type == 4 )
    {
      row.Image.Bitmap = Application::PIRBitmap;
    }
    else if ( type == 3 )
    {
       row.Image.Bitmap = Application::EvacEvent;
    }

    row.Text.String = location;
    row.ZoneText.String = "Zone " + string( zone)+"  Unit " + string( yunit );
    row.TimeText.String = time; 

    row.Bounds.w = VerticalList.Bounds.w;       
  }

  $rect <830,330,1030,370>
  object Core::SystemEventHandler SystemEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = Application::Devices.EventListChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <820,370,1020,410>
  slot onEvent
  {
    var int32 numItems = 8;


     
    native( numItems )
    {
      Command cmd;

      Command0( CMD_GET_NUM_OTHER_EVENTS, &cmd );

      numItems = cmd.int0;
    }  


    VerticalList.NoOfItems = numItems;

    var Application::Application ap = (Application::Application) Owner;

    if ( ap != null )
    {
      ap.EventsTabButton.NumberOf = numItems;
      ap.EventsTabButton.InvalidateViewState();

      if ( ( ap.AlarmsTabButton.NumberOf == 0 || ap.SelectedTab != "{fnt2}{clr1}Fires" ) && ( ap.FaultsTabButton.NumberOf == 0 || ap.SelectedTab != "{fnt2}{clr1}Faults" ) &&
         ( ap.SelectedTab != "{fnt3}{clr1}Other Events" && numItems != 0 )  )
      {
          postsignal ap.EventsTabButton.OnPress;
      
      }
      else if ( numItems > 0 && ap.SelectedTab != "{fnt3}{clr1}Other Events" )
      {
         ap.EventsTabButton.Timer.Enabled = true;
      
       }
       else
       {
         ap.EventsTabButton.Timer.Enabled = false;
         ap.EventsTabButton.Image.Visible = true;
       } 
    }

    VerticalList.InvalidateItems( 0, numItems - 1 );



    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }
}

$rect <1270,1250,1510,1290>
$output false
resource Resources::Font VerdanaProSemiBold16
{
  attr fontname FontName = Verdana Pro SemiBold;
  attr fontheight Height = 16;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7E;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
}

$rect <1650,710,1850,750>
$output false
resource Resources::Bitmap ViewLogBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\silence40c.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,750,1440,790>
$output false
resource Resources::Bitmap HeatSensorBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\heat.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,510,1640,550>
$output false
resource Resources::Bitmap GreenCallpointBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\greencall2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1240,710,1440,750>
$output false
resource Resources::Bitmap PIRBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\pir.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,470,1640,510>
$output false
resource Resources::Bitmap SwitchBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\switch.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <250,0,400,40>
$output false
class ImageCheckbox : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,170,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    Text.String = IconText;
    Image.Bitmap = IconImage;
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object XFlat::CheckBox CheckBox
  {
    preset Bounds = <0,0,160,40>;
    preset Caption = "";
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <42,0,82,40>;
    preset Bitmap = Application::FireAlarmBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <84,0,170,40>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Application::FontVerdana16;
  }

  $rect <0,70,200,110>
  property string IconText = "";

  $rect <-10,110,190,150>
  property Resources::Bitmap IconImage = null;
}

$rect <0,140,200,180>
$output false
class EnableDisable : Core::Group
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <2,0,550,350>;
    preset Color = #353535FF;
  }

  $rect <0,550,200,590>
  inherited property Bounds = <0,0,780,350>;

  $rect <0,410,200,450>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    VertScrollbar.ViewArea = Outline.Bounds.h;

    var int32 size = 0;
    var Core::View   v = (Core::View) first;

    while ( v != null )
    {
        var Core::Group g = (Core::Group) v;
         
        if ( g != null )
        {
            if ( g.Embedded && g.Visible ) 
            {
                size = size + g.Bounds.h;
            }
        }
        v = v.next;
    }

    //Outline.GetViewAtIndex( Outline.CountViews()-1 );

    VertScrollbar.ContentArea = size;


    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,500,200,540>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <810,140,1010,180>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ((Core::VerticalList) sender).Item;
    var Application::DeviceItem item = (Application::DeviceItem) ((Core::VerticalList) sender).View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    // Configure the item view ...
    item.UnitNum = itemNo + 1;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    item.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );

  }

  $rect <810,60,1010,100>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -Outline.ScrollOffset.y;
  }

  $rect <810,100,1010,140>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    Outline.ScrollOffset.y = -VertScrollbar.Position;


  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,550,350>;
    preset OnSlide = ScrollDragSlot;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <2,2,550,350>;
    preset SlideHandler = SlideTouchHandler;
    preset Formation = Core::Formation.TopToBottom;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 1;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead1
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 2;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList1
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead2
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 3;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList2
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead3
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 4;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList3
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead4
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 5;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList4
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead5
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 6;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList5
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead6
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 7;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList6
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead7
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 8;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList7
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead8
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 9;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList8
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead9
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 10;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList9
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead10
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 11;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList10
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead11
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 12;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList11
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead12
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 13;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList12
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead13
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 14;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList13
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead14
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 15;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList14
  {
    preset Bounds = <2,60,548,326>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Application::DynamicAreaHead DynamicAreaHead15
  {
    preset Bounds = <2,0,548,60>;
    preset Embedded = true;
    preset ZoneNum = 16;
    preset stringstart = "Disable Zone ";
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList15
  {
    preset Bounds = <2,60,550,350>;
    preset Embedded = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 45;
    preset NoOfItems = 10;
    preset ItemClass = Application::DeviceItem;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,550,350>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2C2C2CFF;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <550,0,599,350>;
    preset OnScroll = ScrollPressSlot;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $reorder Rectangle 76
}

$rect <1530,1210,1820,1250>
$output false
resource Resources::Font FontVerdanaProCondSemiBold18
{
  attr fontname FontName = Verdana Pro Cond SemiBold;
  attr fontheight Height = 18;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7E;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <990,40,1190,80>
$output false
class MenuItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,170,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <260,40,430,80>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,170,40>;
    preset ColorBL = #414141FF;
    preset ColorBR = #414141FF;
    preset ColorTR = #828282FF;
    preset ColorTL = #828282FF;
    preset Color = #DBDBDBFF;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,170,40>;
    preset Width = 1;
    preset ColorL = #737373FF;
    preset ColorR = #303030FF;
    preset ColorB = #303030FF;
    preset ColorT = #737373FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,170,40>;
    preset String = "Text";
    preset Font = OldResources::FontVerdana18;
    preset Color = #000000FF;
  }

  $rect <240,60,440,100>
  slot Leave
  {
    sender; /* the method is called from the sender object */

    if ( pressed )
    {
        pressed = false;

    var color t = Bevel.ColorB;
    Bevel.ColorB = Bevel.ColorT;
    Bevel.ColorT = t;

    t = Bevel.ColorR;
    Bevel.ColorR = Bevel.ColorL;
    Bevel.ColorL = t;

    Text1.Bounds.x1 = Text1.Bounds.x1 - 2;
    Text1.Bounds.y1 = Text1.Bounds.y1 - 2;


    InvalidateViewState();


    }
  }

  $rect <240,110,440,150>
  slot Press
  {
    sender; /* the method is called from the sender object */

    if ( !pressed )
    {
        pressed = true;

    var color t = Bevel.ColorB;
    Bevel.ColorB = Bevel.ColorT;
    Bevel.ColorT = t;

    t = Bevel.ColorR;
    Bevel.ColorR = Bevel.ColorL;
    Bevel.ColorL = t;

    Text1.Bounds.x1 = Text1.Bounds.x1 + 2;
      Text1.Bounds.y1 = Text1.Bounds.y1 + 2;

                         InvalidateViewState();
                     
    }

  }

  $rect <240,160,440,200>
  slot Release
  {
    sender; /* the method is called from the sender object */


    if ( pressed )
    {
        pressed = false;

    var color t = Bevel.ColorB;
    Bevel.ColorB = Bevel.ColorT;
    Bevel.ColorT = t;

    t = Bevel.ColorR;
    Bevel.ColorR = Bevel.ColorL;
    Bevel.ColorL = t;


    Text1.Bounds.x1 = Text1.Bounds.x1 - 2;
    Text1.Bounds.y1 = Text1.Bounds.y1 - 2;
    }


    ((Application::TabButtonPull) Owner.Owner).MenuChoice( this );

  }

  $rect <470,20,670,60>
  property bool pressed = false;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <170,0>;
    preset Point2 = <170,40>;
    preset Point1 = <0,40>;
    preset OnLeave = Leave;
    preset OnRelease = Release;
    preset OnPress = Press;
  }
}

$rect <1450,170,1580,210>
$output false
class CAEComponent : Core::Group
{
  $rect <590,50,730,90>
  inherited method Draw()
  {
    CAERoot.Render( this.Bounds.point1 + aOffset, aClip, aCanvas );


    //and.RenderFall( <50,50>, <100,100>, aClip, aCanvas );

     //aCanvas.DrawLine( aClip, <50,50>, <100,100>, #FF00FFFF, #FFFF00FF, true );
    //var rect clp;
    //clp = <0,0,800,480>;

    //var rect aDstRect = <100,100,118,118>;
    //var rect aSrcRect = <0,0,36,36>;

    //var rect aDstRect2 = <100,100,160,160>;
    //var rect aSrcRect2 = <0,0,100,100>;


    //var Application::Application app = (Application::Application) Owner;
                  
                     
    //aCanvas.DrawLine( aClip, <100,100>, <200,100>, #FFFFFFFF, #FFFFFFFF, false );
    //aCanvas.ScaleBitmap( aClip, Application::FireAlarmBitmap, 0, aDstRect, aSrcRect, #000000FF,#000000FF,#000000FF,#000000FF, true, true );
    //aCanvas.ScaleBitmap( aClip, Application::ZoneCircleBitmap, 0, aDstRect2, aSrcRect2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FF0000FF, true, true ); 

  }

  $rect <610,120,810,160>
  inherited property Bounds = <0,0,515,280>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );




    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    //Bounds.size = CAERoot.Size();

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <870,70,1010,110>
  inherited method Init()
  {
    // TO DO: Write your code here ... 



    var Application::CAEDevice alarm_dev = new Application::CAEDevice;

    alarm_dev.UnitNum = 3;
    alarm_dev.ZoneNum = 15;
    alarm_dev.type = Application::FireAlarmBitmap;

    var Application::CAEZoneFireAlarm alarms = new Application::CAEZoneFireAlarm;
    var Application::CAEZoneSmokeDetectors smokes = new Application::CAEZoneSmokeDetectors;

    var Application::CAECompare comp = new Application::CAECompare;

    comp.Input = smokes;

     alarms.ZoneNum = 5;
     smokes.ZoneNum = 6;

     var Application::CAEGateAND and = new Application::CAEGateAND;

     and.InputA = alarm_dev;

     and.InputB = comp;

     var Application::CAEGateOR or = new Application::CAEGateOR;

     or.InputA = and;
     or.InputB = and;

    var Application::CAEGateAND and2 = new Application::CAEGateAND;

    var Application::CAEDayNight dn = new Application::CAEDayNight;
    dn.Input = and;

    and2.InputA = dn;
    and2.InputB = or;

    CAERoot = new Application::CAEAction;


    ((Application::CAEAction)CAERoot).Input = and2;


    Bounds.size = CAERoot.Size();


  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <530,360,1310,680>;
  }

  $rect <610,160,810,200>
  property Application::CAEModule CAERoot = null;

  $rect <610,200,810,240>
  onset CAERoot
  {
    // The value doesn't change - nothing to do.
    if ( pure CAERoot == value )
      return;

    // Remember the property's new value.
    pure CAERoot = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }
}

$rect <0,220,160,261>
$output false
class CauseAndEffects : Core::Group
{
  $rect <820,55,1020,95>
  inherited property Bounds = <0,0,792,360>;

  $rect <850,140,1050,180>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );



    this.VertScrollbar.ContentArea = this.CAEComponent.Bounds.h + this.Outline.Space*2 + this.OutputVerticalList.Bounds.h + this.InputVerticalList.Bounds.h;
    this.VertScrollbar.ViewArea = this.Outline.Bounds.h;


    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <855,180,1055,220>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <1060,90,1200,130>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    CAEComponent.Bounds.size = CAEComponent.CAERoot.Size() + <0,10>; 


  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,530,360>;
    preset Color = #353535FF;
    preset Visible = true;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <910,360,1690,680>;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <2,0,530,360>;
    preset SlideHandler = SlideTouchHandler;
    preset Space = 0;
    preset Formation = Core::Formation.TopToBottom;
  }

  $rect <20,20,160,60>
  object Application::CAEComponent CAEComponent
  {
    preset Bounds = <0,0,550,120>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Core::VerticalList InputVerticalList
  {
    preset Bounds = <2,320,530,480>;
    preset Embedded = true;
    preset OnLoadItem = OnLoadInputItem;
    preset ItemHeight = 35;
    preset NoOfItems = 4;
    preset ItemClass = Application::InputItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <830,280,1030,320>
  slot OnLoadInputItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = InputVerticalList.Item;
    var Application::InputItem item = (Application::InputItem) InputVerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item== null )
      return;

    // Configure the item view ...
    item.NumText.String = "In "+string( itemNo+1 );

    if ( itemNo == 1 )
    {
          item.DescriptionText.String = "Count of all smoke detectors";
          item.InputTypeText.String = "Zone Input";
          item.PanelText.String = "Panel 1";
          item.TypeText.String = "Smoke SD01";
          item.UnitText.String = "All units";
          item.ZoneText.String = "Zone 6";
          item.Image.Bitmap = Application::ZoneBitmap; 
    }   
    else if ( itemNo == 2 )
    {
          item.DescriptionText.String = "Evacuate button pressed";
          item.InputTypeText.String = "Panel Input";
          item.PanelText.String = "Panel 2";
          item.TypeText.String = "Function";
          item.UnitText.String = "";
          item.ZoneText.String = "";
          item.Image.Bitmap = Application::PanelBitmap; 
    }
    else if ( itemNo == 3 )
    {
          item.DescriptionText.String = "Launch rockets switch 1";
          item.InputTypeText.String = "General Input";
          item.PanelText.String = "Panel 1";
          item.TypeText.String = "Switch 1";
          item.UnitText.String = "Unit 6";
          item.ZoneText.String = "Zone 4";
          item.Image.Bitmap = Application::PullSwitchBitmap; 
    }   
       

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    item.Bounds.size = point( InputVerticalList.Bounds.w, InputVerticalList.ItemHeight );
  }

  $rect <20,20,160,60>
  object Core::VerticalList OutputVerticalList
  {
    preset Bounds = <2,320,530,470>;
    preset Embedded = true;
    preset OnLoadItem = OnLoadOutputItem;
    preset ItemHeight = 35;
    preset NoOfItems = 4;
    preset ItemClass = Application::OutputItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <850,240,1050,280>
  slot OnLoadOutputItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = OutputVerticalList.Item;
    var Application::OutputItem item = (Application::OutputItem) OutputVerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item== null )
      return;

    // Configure the item view ...
    item.NumText.String = "Out "+string( itemNo+1 );

    if ( itemNo == 1 )
    {
          item.DescriptionText.String = "Beacon Light";
          item.OutputTypeText.String = "Device Output";
          item.PanelText.String = "Panel 1";
          item.TypeText.String = "Beacon BC112";
          item.UnitText.String = "Unit 7";
          item.ZoneText.String = "Zone 4";
          item.Image.Bitmap = Application::RadioBitmap; 
    }   
    else if ( itemNo == 2 )
    {
          item.DescriptionText.String = "Msg: \"This is the message!\"";
          item.OutputTypeText.String = "Panel Output";
          item.PanelText.String = "Panel 2";
          item.TypeText.String = "Disp. Message";
          item.UnitText.String = "";
          item.ZoneText.String = "";
          item.Image.Bitmap = Application::PanelBitmap; 
    }
    else if ( itemNo == 3 )
    {
          item.DescriptionText.String = "Launch rockets relay";
          item.OutputTypeText.String = "General Output";
          item.PanelText.String = "Panel 3";
          item.TypeText.String = "Switch 12";
          item.UnitText.String = "";
          item.ZoneText.String = "Zone 4";
          item.Image.Bitmap = Application::PullSwitchBitmap; 
    }   
       

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    item.Bounds.size = point( OutputVerticalList.Bounds.w, OutputVerticalList.ItemHeight );
  }

  $rect <820,10,1020,50>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -Outline.ScrollOffset.y;
  }

  $rect <810,100,1010,140>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    Outline.ScrollOffset.y = -VertScrollbar.Position;


  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,530,360>;
    preset OnSlide = ScrollDragSlot;
    preset SlideHorz = false;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,530,360>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2C2C2CFF;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <580,0,790,240>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler1;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset ItemHeight = 30;
    preset NoOfItems = 99;
    preset ItemClass = Application::CAEName;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <1040,240,1240,280>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Application::CAEName itemView = (Application::CAEName)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.NumText.String = string( itemNo+1 );
    itemView.NameText.String = "CAE Name";

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <660,370,860,410>
  slot ClickSlot
  {
    // Ignore the case, when the user interaction has been passed over to 
    // the slide touch handler
    if ( SimpleTouchHandler.AutoDeflected )
      return;

    // Get the index of the item at the tapped position
    var int32 itemNo = VerticalList.GetItemAtPosition( SimpleTouchHandler.CurrentPos );

    // If the item is valid ...
    if ( itemNo >= 0 )
    {
      // Select the item in the Vertical List. Thereupon the item appears
      // highlighted
      VerticalList.SelectedItem = itemNo;
    }

  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler1
  {
    preset Bounds = <580,0,790,240>;
    preset SnapNext = <0,30>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <580,0>;
    preset Point3 = <790,0>;
    preset Point2 = <790,240>;
    preset Point1 = <580,240>;
    preset OnRelease = null;
    preset OnPress = ClickSlot;
    preset RetargetCondition = Core::RetargetReason[LongPress, WipeDown, WipeLeft, WipeRight, WipeUp];
  }

  $rect <450,370,650,410>
  slot TopSlot
  {
    sender; /* the method is called from the sender object */

        //   SlideTouchHandler1.Offset = 0;
          VerticalList.ScrollOffset = 0;

  }

  $rect <440,410,640,450>
  slot Up
  {
    sender; /* the method is called from the sender object */

    var int32 page = 8 * VerticalList.ItemHeight; 

    if ( -VerticalList.ScrollOffset > page )    
       VerticalList.ScrollOffset = VerticalList.ScrollOffset + page; 
    else 
       VerticalList.ScrollOffset = 0;

      
  }

  $rect <650,410,850,450>
  slot Down
  {
    sender; /* the method is called from the sender object */

    var int32 page = 8 * VerticalList.ItemHeight; 

    var int32 max = (VerticalList.NoOfItems-8) * VerticalList.ItemHeight; 

    if ( max+VerticalList.ScrollOffset > page )    
       VerticalList.ScrollOffset = VerticalList.ScrollOffset - page; 
    else 
       VerticalList.ScrollOffset = -max;

      
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <530,0,580,360>;
    preset OnScroll = ScrollPressSlot;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <577,248,677,293>;
    preset OnRelease = TopSlot;
    preset Label = "Top";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <679,247,734,292>;
    preset OnRelease = Down;
    preset IconFrame = 13;
    preset Icon = Flat::FlatDemoIcons;
    preset Label = "";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <737,247,792,292>;
    preset OnRelease = Up;
    preset IconFrame = 12;
    preset Icon = Flat::FlatDemoIcons;
    preset Label = "";
    preset Appearance = Application::NormalPushButton;
  }

  $reorder Rectangle 1
}

$rect <1440,350,1640,390>
$output false
resource Resources::Bitmap ActionBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\action.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,310,1640,350>
$output false
resource Resources::Bitmap OrBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\or.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1657,230,1857,270>
$output false
resource Resources::Bitmap AndBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\and.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,390,1640,430>
$output false
resource Resources::Bitmap RelayBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\relay.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1440,430,1640,470>
$output false
resource Resources::Bitmap ZoneCircleBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\circle.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1460,50,1585,90>
$output false
class CAEModule
{
  $rect <40,90,160,130>
  method point Render( arg point position, arg rect aClip, arg Graphics::Canvas aCanvas )
  {
    /* The template just returns the given argument... */



    return point(0,0);

  }

  $rect <30,220,180,260>
  method point RenderHoz( arg point start, arg int32 length, arg rect aClip, arg Graphics::Canvas aCanvas )
  {
    /* The template just returns the given argument... */
    var point dst = start;

    dst.x = dst.x + length;

    aCanvas.DrawLine( aClip, start, dst, #FFFFFFFF, #FFFFFFFF, false );
    start = start + <0,1>;
    dst = dst + <0,1>;
    aCanvas.DrawLine( aClip, start, dst, #FFFFFFFF, #FFFFFFFF, false );

    start.x = start.x + length;

    return start;

  }

  $rect <20,260,170,300>
  method point RenderVert( arg point start, arg int32 length, arg rect aClip, arg Graphics::Canvas aCanvas )
  {
    /* The template just returns the given argument... */
    var point dst = start;

    dst.y = dst.y + length;

    aCanvas.DrawLine( aClip, start, dst, #FFFFFFFF, #FFFFFFFF, false );
    start = start + <1,0>;
    dst = dst + <1,0>;
    aCanvas.DrawLine( aClip, start, dst, #FFFFFFFF, #FFFFFFFF, false );

    start.y = start.y + length;

    return start;


  }

  $rect <40,170,200,210>
  method void RenderConnect( arg point pos1, arg point pos2, arg rect aClip, arg Graphics::Canvas aCanvas )
  {
    /* The template just returns the given argument... */

    var int32 w = (pos2.x - pos1.x);// / 2;
    var int32 h = (pos2.y - pos1.y);

    pos1 = RenderHoz( pos1, w, aClip, aCanvas );
    RenderVert( pos1, h, aClip, aCanvas );

    //RenderHoz( pos1, w, aClip, aCanvas );

    return; 


  }

  $rect <160,90,280,130>
  method point Size()
  {
    /* The template just returns the given argument... */



    return <0,0>;


  }

  $rect <300,90,420,130>
  method point Output( arg point position )
  {
    /* The template just returns the given argument... */


    return position + Size() - point( 0, (Size().y / 2)   );


  }

  $rect <220,250,420,290>
  property int32 gapSize = 10;
}

$rect <1460,10,1585,50>
$output false
class CAEZone : Application::CAEModule
{
  $rect <10,10,160,50>
  inherited method Render()
  {
    return RenderZone( position, aClip, aCanvas, type );

    // TO DO: Write your code here ... 

    /*
    var rect dst = <0,0,0,0>;
    var rect src = <0,0,100,100>;
    var rect dst2 = <0,0,0,0>;
    var rect src2 = <0,0,36,36>;

    dst.point1 = position;
    dst.point2 = position + <100,100>;

    dst2.point1 = position;
    dst2.point2 = position + <18,18>;


    aCanvas.ScaleBitmap( aClip, Application::ZoneCircleBitmap, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true );
    aCanvas.ScaleBitmap( aClip, Application::FireAlarmBitmap, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 + (100 - 18);
    dst2.x2 = dst2.x2 + (100 - 18);
    aCanvas.ScaleBitmap( aClip, Application::FireAlarmBitmap, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.y1 = dst2.y1 + (100 - 18);
    dst2.y2 = dst2.y2 + (100 - 18);
    aCanvas.ScaleBitmap( aClip, Application::FireAlarmBitmap, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 - (100 - 18);
    dst2.x2 = dst2.x2 - (100 - 18);
    aCanvas.ScaleBitmap( aClip, Application::FireAlarmBitmap, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 

    aCanvas.DrawText( aClip, OldResources::FontVerdana18, "Zone", 0, 6, dst, <-30,-30>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );
    aCanvas.DrawText( aClip, OldResources::FontVerdana18, string(ZoneNum), 0, 6, dst, <-45,-50>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );


    //aCanvas.DrawText( aClip, aFont, aString, aOffset, aCount, aDstRect, aSrcPos, aMinWidth, aColorTL, aColorTR, aColorBR, aColorBL, aBlend );


    return Output( position );
    */
  }

  $rect <380,40,520,80>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    return Application::Circle55Bitmap.FrameSize;

  }

  $rect <20,90,220,130>
  property int32 ZoneNum = 0;

  $rect <40,200,190,240>
  method point RenderZone( arg point position, arg rect aClip, arg Graphics::Canvas aCanvas, arg Resources::Bitmap type )
  {
    // TO DO: Write your code here ... 

    var Resources::Bitmap ctype = Application::Circle55Bitmap;

    var rect dst = rect( position, position + ctype.FrameSize );
    var rect dst2 = rect( position,  position + <18,18> );

    var rect src = rect( <0,0>, ctype.FrameSize );

    var rect src2 = <0,0,36,36>;



    aCanvas.ScaleBitmap( aClip, ctype, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 + (ctype.FrameSize.x - 18);
    dst2.x2 = dst2.x2 + (ctype.FrameSize.x - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.y1 = dst2.y1 + (ctype.FrameSize.y - 18);
    dst2.y2 = dst2.y2 + (ctype.FrameSize.y - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 - (ctype.FrameSize.x - 18);
    dst2.x2 = dst2.x2 - (ctype.FrameSize.x - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 

    aCanvas.DrawText( aClip, Application::FontVerdana16, "Zone", 0, 5, dst, <-14,-27>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );
    aCanvas.DrawText( aClip, Application::FontVerdana16, string(ZoneNum), 0, 3, dst, <-20,-40>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );



    return Output( position );
  }

  $rect <220,110,420,150>
  property Resources::Bitmap type = Resources::DefaultBitmap;
}

$rect <1650,90,1820,130>
$output false
class CAEZoneFireAlarm : Application::CAEZone
{
  $rect <10,10,160,50>
  inherited method Render()
  {
    // TO DO: Write your code here ... 


    return RenderZone( position, aClip, aCanvas, Application::FireAlarmBitmap );

  }

  $rect <30,80,170,120>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    return Application::Circle55Bitmap.FrameSize;


  }
}

$rect <1720,10,1845,50>
$output false
class CAEGate : Application::CAEModule
{
  $rect <350,30,490,70>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    var point a = InputA.Size();
    var point b = InputB.Size();

    var int32 maxx = a.x;

    if ( b.x > maxx ) maxx = b.x;

    return point( maxx + 100 + gapSize, a.y + gapSize + b.y );    


  }

  $rect <40,30,240,70>
  method point RenderGate( arg point position, arg rect aClip, arg Graphics::Canvas aCanvas, arg Resources::Bitmap aBitmap )
  {
    if ( InputA != null && InputB != null )
    {
        var point aOut = InputA.Render( position, aClip, aCanvas );

        var point bOut = InputB.Render( position + point( 0, InputA.Size().y + gapSize ), aClip, aCanvas );

       // var point size = Size();

        var point out = Output( position );    // off by one - eek

        RenderConnect( aOut, out - <100,+14>, aClip, aCanvas );
        RenderConnect( bOut, out - <100,-10>, aClip, aCanvas );
       

        var rect aDstRect = rect( out - <100,30>, out + <0, 30> );

        aCanvas.ScaleBitmap( aClip, aBitmap, 0, aDstRect, <0,0,100,60>, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );

        return out - point( 0,1);
    }

    return <0,0>;

        /*

    var rect dst = <0,0,0,0>;
    var rect src = <0,0,100,100>;
    var rect dst2 = <0,0,0,0>;
    var rect src2 = <0,0,36,36>;

    dst.point1 = position;
    dst.point2 = position + <100,60>;

    dst2.point1 = position;
    dst2.point2 = position + <18,18>;


    aCanvas.ScaleBitmap( aClip, Application::ZoneCircleBitmap, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true );
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 + (100 - 18);
    dst2.x2 = dst2.x2 + (100 - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.y1 = dst2.y1 + (100 - 18);
    dst2.y2 = dst2.y2 + (100 - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 
    dst2.x1 = dst2.x1 - (100 - 18);
    dst2.x2 = dst2.x2 - (100 - 18);
    aCanvas.ScaleBitmap( aClip, type, 0, dst2, src2, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, true ); 

    aCanvas.DrawText( aClip, OldResources::FontVerdana18, "Zone", 0, 6, dst, <-30,-30>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );
    aCanvas.DrawText( aClip, OldResources::FontVerdana18, string(ZoneNum), 0, 6, dst, <-45,-50>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );


    var Application::Dimension dim = new Application::Dimension;

    dim.output = position  + <100,50>;
    dim.size = dst;

    return dim;
    */
  }

  $rect <40,120,240,160>
  property Application::CAEModule InputB = null;

  $rect <40,80,240,120>
  property Application::CAEModule InputA = null;
}

$rect <1580,10,1720,50>
$output false
class CAEGateOR : Application::CAEGate
{
  $rect <190,70,340,110>
  inherited method Render()
  {
    // TO DO: Write your code here ... 
    var point outpos = RenderGate( position, aClip, aCanvas, Application::OrBitmap );


    var rect dst = rect( outpos - <100, 30>, outpos + <0,30> );
    aCanvas.DrawText( aClip, OldResources::FontVerdana18, "OR", 0, 5, dst, <-28,-34>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );

    return outpos;
  }
}

$rect <1580,50,1730,90>
$output false
class CAEGateAND : Application::CAEGate
{
  $rect <10,10,160,50>
  inherited method Render()
  {
    // TO DO: Write your code here ... 


    var point outpos = RenderGate( position, aClip, aCanvas, Application::AndBitmap );


    var rect dst = rect( outpos - <100, 30>, outpos + <0,30> );
    aCanvas.DrawText( aClip, OldResources::FontVerdana18, "AND", 0, 5, dst, <-28,-34>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );

    return outpos;
  }
}

$rect <1460,90,1655,130>
$output false
class CAEZoneSmokeDetectors : Application::CAEZone
{
  $rect <20,80,170,120>
  inherited method Render()
  {
    // TO DO: Write your code here ... 


    return RenderZone( position, aClip, aCanvas, Application::SmokeBitmap );

  }

  $rect <190,10,340,50>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    return Application::Circle55Bitmap.FrameSize;


  }
}

$rect <1600,130,1740,170>
$output false
class CAEDevice : Application::CAEModule
{
  $rect <80,100,230,140>
  inherited method Render()
  {
    // TO DO: Write your code here ... 

    var rect dst = rect( position + <54,0>, position + <90,36> );


    var rect src = <0,0,36, 36>;



    aCanvas.ScaleBitmap( aClip, type, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
     
    dst.point1 = dst.point1 - <54,0>;
    aCanvas.DrawText( aClip, Application::FontVerdana16, "Unit " + string(UnitNum), 0, 6, dst, <0,-13>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );
    aCanvas.DrawText( aClip, Application::FontVerdana14, "Zone " + string(ZoneNum), 0, 7, dst, <0,-27>, 0, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true );

    //return position + point( 116, 18 );

    //aCanvas.DrawText( aClip, aFont, aString, aOffset, aCount, aDstRect, aSrcPos, aMinWidth, aColorTL, aColorTR, aColorBR, aColorBL, aBlend );


    return Output( position );
  }

  $rect <200,10,350,50>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    return point(90, 36 );
  }

  $rect <230,100,430,140>
  property Resources::Bitmap type = Resources::DefaultBitmap;

  $rect <220,210,420,250>
  property int32 UnitNum = 0;

  $rect <220,170,420,210>
  property int32 ZoneNum = 0;
}

$rect <1510,1250,1710,1290>
$output false
resource Resources::Font FontVerdana14
{
  attr fontname FontName = Verdana;
  attr fontheight Height = 14;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7E;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <1730,50,1850,90>
$output false
class CAEAction : Application::CAEModule
{
  $rect <10,10,160,50>
  inherited method Render()
  {
    // TO DO: Write your code here ... 

    var point sz = Application::ActionBitmap.FrameSize;
    var point outpos = Input.Render( position, aClip, aCanvas );

    var rect dst = rect( outpos - point(0,sz.y/2), outpos + point(sz.x,(sz.y+1)/2) );
    var rect src = rect( point(0,0), sz );

    aCanvas.ScaleBitmap( aClip, Application::ActionBitmap, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
     
    return <0,0>;

  }

  $rect <210,10,350,50>
  inherited method Size()
  {
    // TO DO: Write your code here ... 

    var point sz = Application::ActionBitmap.FrameSize;

    var point ssz = Input.Size();

    var int32 my = 0;

    if ( sz.y > ssz.y ) my = sz.y - ssz.y;   

    return Input.Size() + point( sz.x, my );
  }

  $rect <0,80,200,120>
  property Application::CAEModule Input = null;
}

$rect <1580,170,1780,210>
$output false
class CAEInput : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,510,30>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,40,30>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "1";
    preset Font = OldResources::FontVerdana18;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <50,0,130,30>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "1";
    preset Font = Application::VerdanaProSemiBold16;
  }
}

$rect <610,300,740,340>
$output false
class InputItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,35>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,35>;
    preset Width = 1;
    preset ColorL = #212121FF;
    preset ColorR = #C9C9C9FF;
    preset ColorB = #D4D4D4FF;
    preset ColorT = #232323FF;
  }

  $rect <20,20,160,60>
  object Views::Text NumText
  {
    preset Bounds = <0,5,50,30>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "1";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Text PanelText
  {
    preset Bounds = <58,0,124,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel 1";
    preset Font = Application::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <57,13,518,33>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Hallway, Front building 2";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, ResizeVert];
    preset Bounds = <514,0,549,35>;
    preset Bitmap = Application::RadioBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text InputTypeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <387,0,507,15>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Device Input";
    preset Font = Application::FontVerdana16;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <129,0,194,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 15";
    preset Font = Application::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text UnitText
  {
    preset Bounds = <209,0,279,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Unit 23";
    preset Font = Application::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text TypeText
  {
    preset Bounds = <289,0,384,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Smoke SD01";
    preset Font = Application::VerdanaProSemiBold16;
  }
}

$rect <1660,430,1860,470>
$output false
resource Resources::Bitmap RadioBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\radio.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,310,1860,350>
$output false
resource Resources::Bitmap ZoneBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\zone2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1660,390,1860,430>
$output false
resource Resources::Bitmap PanelBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\panel.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <740,300,880,340>
$output false
class OutputItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,35>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,35>;
    preset Width = 1;
    preset ColorL = #212121FF;
    preset ColorR = #C9C9C9FF;
    preset ColorB = #D4D4D4FF;
    preset ColorT = #232323FF;
  }

  $rect <20,20,160,60>
  object Views::Text NumText
  {
    preset Bounds = <1,5,51,30>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "1";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  object Views::Text PanelText
  {
    preset Bounds = <59,0,125,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel 1";
    preset Font = Application::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <58,13,519,33>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Fire Alarm";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, ResizeVert];
    preset Bounds = <514,0,549,35>;
    preset Bitmap = Application::ZoneBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text OutputTypeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <387,0,507,15>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Zone Output";
    preset Font = Application::FontVerdana16;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <130,0,195,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "All Zones";
    preset Font = Application::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text UnitText
  {
    preset Bounds = <210,0,280,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "All Units";
    preset Font = Application::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text TypeText
  {
    preset Bounds = <290,0,414,15>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Sounder 1";
    preset Font = Application::VerdanaProSemiBold16;
  }
}

$rect <1660,350,1860,390>
$output false
resource Resources::Bitmap PullSwitchBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\pullswitch.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1460,130,1600,170>
$output false
class CAECompare : Application::CAEModule
{
  $rect <10,10,160,50>
  inherited method Render()
  {
    var point sz = <50,30>;
    var point outpos = Input.Render( position, aClip, aCanvas ) + <10,0>;

    var rect dst = rect( outpos - point(0,sz.y/2), outpos + point(sz.x,(sz.y+1)/2) );

    RenderHoz( dst.point1, dst.w, aClip, aCanvas );
    RenderVert( dst.point1, dst.h, aClip, aCanvas );
    RenderHoz( dst.point2, -dst.w, aClip, aCanvas );
    RenderVert( dst.point2, -dst.h, aClip, aCanvas );
    RenderHoz( outpos, -10, aClip, aCanvas );

    aCanvas.DrawText( aClip, Application::FontVerdana16, ">"+string(minimum-1), 0, 5, dst, <-15,-20>, 30, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true);

    return Output( position );
  }

  $rect <290,0,440,40>
  inherited method Size()
  {
    // TO DO: Write your code here ... 


    var point sz = <60,30>;

    var point ssz = Input.Size();

    var int32 my = 0;

    if ( sz.y > ssz.y ) my = sz.y - ssz.y;   

    return Input.Size() + point( sz.x, my );

  }

  $rect <220,70,470,120>
  property Application::CAEModule Input = null;

  $rect <140,180,340,220>
  property int32 minimum = 2;
}

$rect <0,260,150,300>
$output false
class Test : Core::Group
{
  $rect <0,550,200,590>
  inherited property Bounds = <0,0,780,350>;

  $rect <0,410,200,450>
  inherited method UpdateLayout()
  {
    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,500,200,540>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <790,5,990,45>
  slot TestDisplay
  {
    // Obtain access to the root object.
    var Core::Root rootObject = GetRoot();

    var Application::Popup pop = new Application::DisplayPopup;

    pop.Show( rootObject );

  }

  $rect <790,50,990,90>
  slot TestLED
  {
    // Obtain access to the root object.
    var Core::Root rootObject = GetRoot();

    var Application::Popup pop = new Application::LEDPopup;

    pop.Show( rootObject );

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <620,0,780,50>;
    preset OnRelease = TestDisplay;
    preset Label = "Test Display";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <620,61,780,111>;
    preset OnRelease = TestLED;
    preset Label = "Test LEDs";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <210,420,360,460>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

     
  }

  $rect <20,20,160,60>
  object Application::TreeView TreeView
  {
    preset Bounds = <0,0,600,350>;
  }

  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder TestDisplay 1
  $reorder TestLED 1
  $reorder PushButton 1
  $reorder PushButton1 1
}

$rect <1740,130,1880,170>
$output false
class CAEDayNight : Application::CAEModule
{
  $rect <200,50,350,90>
  inherited method Render()
  {
    // TO DO: Write your code here ... 

    var point sz = XFlat::ButtonNight.FrameSize;


    var rect src = rect( <0,0>, sz );


    var point outpos = position;

    var rect dst = rect( outpos, outpos + sz);

    //RenderHoz( dst.point1, dst.w, aClip, aCanvas );
    //RenderVert( dst.point1, dst.h, aClip, aCanvas );
    //RenderHoz( dst.point2, -dst.w, aClip, aCanvas );
    //RenderVert( dst.point2, -dst.h, aClip, aCanvas );
    //RenderHoz( outpos, -11, aClip, aCanvas );

    //aCanvas.DrawText( aClip, Application::FontVerdana16, ">"+string(minimum-1), 0, 5, dst, <-15,-20>, 30, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true);

    if ( NightTime )
    {
        aCanvas.ScaleBitmap( aClip, XFlat::ButtonNight, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
    }
    else
    {
        aCanvas.ScaleBitmap( aClip, XFlat::ButtonDay, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
    }




    return Output( position );


  }

  $rect <200,10,350,50>
  inherited method Size()
  {
      

    return XFlat::ButtonNight.FrameSize;






  }

  $rect <280,110,480,150>
  property bool NightTime = true;

  $rect <160,180,360,220>
  property Application::CAEModule Input = null;
}

$rect <1850,10,1990,50>
$output false
class CAEInOut : Application::CAEModule
{
  $rect <200,50,350,90>
  inherited method Render()
  {
    // TO DO: Write your code here ... 

    var point sz = XFlat::ButtonNight.FrameSize;


    var rect src = rect( <0,0>, sz );


    var point outpos = Input.Render( position, aClip, aCanvas ) + <10,0>;

    var rect dst = rect( outpos - point(0,sz.y/2), outpos + point(sz.x,(sz.y+1)/2) );

    //RenderHoz( dst.point1, dst.w, aClip, aCanvas );
    //RenderVert( dst.point1, dst.h, aClip, aCanvas );
    //RenderHoz( dst.point2, -dst.w, aClip, aCanvas );
    //RenderVert( dst.point2, -dst.h, aClip, aCanvas );
    RenderHoz( outpos, -11, aClip, aCanvas );

    //aCanvas.DrawText( aClip, Application::FontVerdana16, ">"+string(minimum-1), 0, 5, dst, <-15,-20>, 30, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, true);

    if ( NightTime )
    {
        aCanvas.ScaleBitmap( aClip, XFlat::ButtonNight, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
    }
    else
    {
        aCanvas.ScaleBitmap( aClip, XFlat::ButtonDay, 0, dst, src, #FFFFFFFF,#FFFFFFFF,#FFFFFFFF,#FFFFFFFF, true, false );
    }




    return Output( position );


  }

  $rect <200,10,350,50>
  inherited method Size()
  {
    var point sz = XFlat::ButtonNight.FrameSize + <9,4>;

    var point ssz = Input.Size();

    var int32 my = 0;

    if ( sz.y > ssz.y ) my = sz.y - ssz.y;   

    return Input.Size() + point( sz.x, my );






  }

  $rect <280,110,480,150>
  property bool NightTime = true;

  $rect <160,180,360,220>
  property Application::CAEModule Input = null;
}

$rect <830,40,980,80>
$output false
class Popup : Core::Group
{
  $rect <230,580,430,620>
  inherited property Bounds = <0,0,680,460>;

  $rect <5,560,205,600>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <450,590,650,630>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <10,10,160,50>
  inherited method Init()
  {
    // TO DO: Write your code here ... 
  }

  // The property 'Bounds' defines the position and the size of the view in the coordinates \
  // of the corresponding @Owner.
  $rect <140,620,340,660>
  property rect Bounds1 = <0,0,550,310>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <650,10,680,430>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight];
    preset Bounds = <650,430,680,460>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, ResizeHorz];
    preset Bounds = <10,430,650,460>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <650,0,680,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle5
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <0,430,10,460>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle6
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <10,0,650,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle7
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,0,10,10>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle8
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <0,10,10,430>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,10,650,430>;
    preset Color = #7F7F7FFF;
  }

  $rect <0,470,200,510>
  method void Show( arg Core::Root rootObject )
  {
    /* The template just returns the given argument... */

    // Obtain access to the root object.
    //var Core::Root rootObject = GetRoot();

    // Create a new instance of some alert panel component.
    mask = new Views::Rectangle;
    touch = new Core::SimpleTouchHandler;
    root = rootObject;

    touch.Point1 = <0,0>;
    touch.Point2 = <0,480>;
    touch.Point3 = <800,480>;
    touch.Point4 = <800,0>;

    rootObject.Add( touch, 0 );


    mask.Color = #00000020;
    mask.Bounds = <0,0,800,480>;

    rootObject.Add( mask, 0 );

    var point m = point( (800 - this.Bounds.size.x) / 2, (480 - this.Bounds.size.y) / 2);

        
    this.Bounds.point1 = m;
    this.Bounds.point2 = <800,480> - m;


    rootObject.Add( this, 0 );



    return;
  }

  $rect <30,270,230,310>
  var Views::Rectangle mask = null;

  $rect <30,230,230,270>
  var Core::SimpleTouchHandler touch = null;

  $rect <30,310,230,350>
  var Core::Root root = null;

  $rect <10,510,210,550>
  method void Hide()
  {
    /* The template just returns the given argument... */

    // Obtain access to the root object.
    //var Core::Root rootObject = GetRoot();

    // Create a new instance of some alert panel component.
    root.Remove( mask );
    root.Remove( touch );
    root.Remove( this );

    if ( Parent != null )
    {
      if ( Parent.Visible == false )
      {
          Parent.Visible = true; 
          Parent.Enabled = true;
       }
    }

    return;
  }

  $rect <240,490,440,530>
  property Application::Popup Parent = null;
}

$rect <550,260,700,300>
$output false
class DisplayPopup : Application::Popup
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Bounds = <20,320,640,360>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle10
  {
    preset Bounds = <20,20,220,160>;
    preset Color = #FF0000FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle11
  {
    preset Bounds = <230,20,430,160>;
    preset Color = #00FF00FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle12
  {
    preset Bounds = <440,20,640,160>;
    preset Color = #0000FFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle13
  {
    preset Bounds = <20,170,220,310>;
    preset Color = #00FFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle14
  {
    preset Bounds = <230,170,430,310>;
    preset Color = #FF00FFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle15
  {
    preset Bounds = <440,170,640,310>;
    preset Color = #FFFF00FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <20,20,220,160>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Red";
    preset Font = Flat::FontXL;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Layout = Core::Layout[AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <230,20,430,160>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Green";
    preset Font = Flat::FontXL;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <440,20,640,160>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Blue";
    preset Font = Flat::FontXL;
  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <230,170,430,310>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Magenta";
    preset Font = Flat::FontXL;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text5
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <20,20,220,160>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Red";
    preset Font = Flat::FontXL;
  }

  $rect <20,20,160,60>
  object Views::Text Text6
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <20,170,220,310>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Cyan";
    preset Font = Flat::FontXL;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text7
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <440,170,640,310>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Yellow";
    preset Font = Flat::FontXL;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle16
  {
    preset Bounds = <20,320,640,360>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle23
  {
    preset Bounds = <440,280,640,310>;
    preset ColorBL = #FFFF00FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #FFFF00FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle24
  {
    preset Bounds = <230,280,430,310>;
    preset ColorBL = #FF00FFFF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #FF00FFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle25
  {
    preset Bounds = <20,280,220,310>;
    preset ColorBL = #00FFFFFF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #00FFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle26
  {
    preset Bounds = <440,130,640,160>;
    preset ColorBL = #0000FFFF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #0000FFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle27
  {
    preset Bounds = <230,130,430,160>;
    preset ColorBL = #00FF00FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #00FF00FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle28
  {
    preset Bounds = <20,130,220,160>;
    preset ColorBL = #FF0000FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #FF0000FF;
  }

  $rect <0,470,200,510>
  slot Proceed
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <250,370,400,420>;
    preset OnRelease = Proceed;
    preset Label = "Close";
    preset Appearance = Application::NormalPushButton;
  }
}

$rect <0,340,110,380>
$output false
class Settings : Core::Group
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <120,940,666,1296>;
    preset Color = #353535FF;
  }

  $rect <0,550,200,590>
  inherited property Bounds = <0,0,780,350>;

  $rect <0,410,200,450>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

  }

  $rect <0,500,200,540>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <840,150,1040,190>
  slot SMS
  {
    sender; /* the method is called from the sender object */

    var Application::TextPopup bl = new Application::TextPopup;



    bl.Show( GetRoot() );



  }

  $rect <855,50,1055,90>
  slot SetTime
  {
    sender; /* the method is called from the sender object */

    var Application::Popup bl = new Application::SetTimePopup;

    bl.Show( GetRoot() );



  }

  $rect <800,230,1000,270>
  property int32 brightness = 20;

  $rect <840,310,1040,350>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font2 = Application::FontVerdanaProSemiBold18;
    preset Font1 = Resources::FontMedium;
    preset Color0 = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <-1,10,254,45>;
    preset String = "GSM Signal Check Period";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <260,365,390,405>
  slot Slot1min
  {
    sender; /* the method is called from the sender object */

     RadioButton1.Selected = false;
     RadioButton2.Selected = false;


     
    native
    {
        Command1( CMD_GSM_SIGNAL_PERIOD, 1 );
    }
  }

  $rect <415,365,550,405>
  slot Slot5min
  {
    sender; /* the method is called from the sender object */


     RadioButton.Selected = false;
     RadioButton2.Selected = false;

    native
    {
        Command1( CMD_GSM_SIGNAL_PERIOD, 5 );
    }
  }

  $rect <570,365,730,405>
  slot Slot20min
  {
    sender; /* the method is called from the sender object */


     RadioButton.Selected = false;
     RadioButton1.Selected = false;

    native  
    {
        Command1( CMD_GSM_SIGNAL_PERIOD, 20 );
    }
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <10,76,110,106>;
    preset String = "Brightness";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <225,410,335,450>
  slot Change
  {
    sender; /* the method is called from the sender object */

    var int32 val = HorzSlider.CurrentValue;

    native ( val )
    {
        Command1( CMD_SET_BACKLIGHT_LEVEL, val * 5 + 30 );
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzSlider
  {
    preset Bounds = <130,70,480,119>;
    preset OnChange = Change;
    preset Appearance = WidgetSet::HorizontalSlider_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <620,0,780,50>;
    preset OnRelease = SetTime;
    preset Label = "Set Time";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <620,60,780,110>;
    preset OnRelease = null;
    preset Label = "Day/Night";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <620,120,780,170>;
    preset OnRelease = SMS;
    preset Label = "SMS Numbers";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <620,180,780,230>;
    preset OnRelease = SMS;
    preset Label = "Set Pin Code";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton
  {
    preset Bounds = <260,0,380,50>;
    preset OnSelect = Slot1min;
    preset Label = "1 min";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton1
  {
    preset Bounds = <380,0,500,50>;
    preset Selected = true;
    preset OnSelect = Slot5min;
    preset Label = "5 min";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton2
  {
    preset Bounds = <490,0,610,50>;
    preset OnSelect = Slot20min;
    preset Label = "20 min";
    preset Appearance = Application::NormalRadioButton;
  }

  $reorder Rectangle 76
}

$rect <110,340,270,380>
$output false
class BacklightPopup : Application::Popup
{
  $rect <20,20,160,60>
  inherited object Rectangle
  {
    preset Bounds = <490,10,520,160>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle1
  {
    preset Bounds = <490,160,520,190>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle2
  {
    preset Bounds = <10,160,490,190>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset Bounds = <490,0,520,10>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle5
  {
    preset Bounds = <0,160,10,190>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset Bounds = <10,0,490,10>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle8
  {
    preset Bounds = <0,10,10,160>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Bounds = <10,10,490,160>;
    preset Color = #C3C3C3FF;
  }

  $rect <20,240,160,280>
  inherited method Show()
  {
    // TO DO: Write your code here ... 


    super( rootObject );

    startVal = HorzSlider.Outlet^;

         
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <20,37,120,67>;
    preset String = "Brightness";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <0,190,150,230>
  slot Set
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <300,190,500,230>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    HorizontalSlider.Outlet^ = startVal;
    HorizontalSlider.CurrentValue = startVal;

    Hide();

  }

  $rect <170,190,280,230>
  slot Change
  {
    sender; /* the method is called from the sender object */

    var int32 val = HorizontalSlider.CurrentValue;

    native ( val )
    {
        Command1( CMD_SET_BACKLIGHT_LEVEL, val * 5 + 30 );
    }
  }

  $rect <520,30,720,70>
  var int32 startVal = 0;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <330,97,460,147>;
    preset OnActivate = Cancel;
    preset Label = "Cancel";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <40,97,160,147>;
    preset OnActivate = Set;
    preset Label = "Set";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorizontalSlider
  {
    preset Bounds = <131,28,471,78>;
    preset Appearance = WidgetSet::HorizontalSlider_Medium;
  }
}

$rect <270,340,420,380>
$output false
class SetTimePopup : Application::Popup
{
  $rect <660,10,800,50>
  inherited property Bounds = <0,0,670,330>;

  $rect <25,380,165,420>
  inherited method Init()
  {
    // TO DO: Write your code here ... 
    GetCurrent();

    EndDate = new Core::Time;

    EndDate = EndDate.CurrentTime;

    EndDate.Hour = 1;
    EndDate.Minute = 0;
    EndDate.Second = 0;

    EndDate.Day = 1;
    EndDate.Month = 10;



    StartDate = new Core::Time;


    StartDate.Hour = 1;
    StartDate.Minute = 0;
    StartDate.Second = 0;

    StartDate.Day = 1;
    StartDate.Month = 3;
    StartDate.Year = EndDate.Year;




  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Color = #CDCDCDFF;
  }

  $rect <20,20,160,60>
  object Application::TimePicker TimePicker
  {
    preset Bounds = <26,30,216,180>;
  }

  $rect <20,20,160,60>
  object Application::DatePicker DatePicker
  {
    preset Bounds = <231,30,461,180>;
    preset Year = 2018;
  }

  $rect <0,325,200,365>
  slot Proceed
  {
    sender; /* the method is called from the sender object */

    SetCurrent();

    Hide();

  }

  $rect <240,330,440,370>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    Hide();



  }

  $rect <720,30,920,70>
  slot CurrentSlot
  {
    sender; /* the method is called from the sender object */


    GetCurrent();


  }

  $rect <200,380,400,420>
  method void GetCurrent()
  {
    // TO DO: Write your code here ... 

    var Core::Time t = new Core::Time;

    t = t.CurrentTime;

    TimePicker.Hour = t.Hour;
    TimePicker.Minute = t.Minute;
    TimePicker.Second = t.Second;

    DatePicker.Day = t.Day;
    DatePicker.Month = t.Month;
    DatePicker.Year = t.Year;

    CurrentRadioButton.Selected= true;
    StartRadioButton.Selected = false;
    EndRadioButton.Selected = false;

    StartRadioButton.InvalidateViewState();
    CurrentRadioButton.InvalidateViewState();
    EndRadioButton.InvalidateViewState();




  }

  $rect <720,80,920,120>
  slot StartSlot
  {
    sender; /* the method is called from the sender object */



    if ( CurrentRadioButton.Selected )
    {
      SetCurrent();
    }
    else if ( StartRadioButton.Selected )
    {
      return;
    }
    else if (  EndRadioButton.Selected )
    {
       SetEnd();
    }





    var Core::Time t = new Core::Time ;

    t = StartDate;


                                                                                          
    TimePicker.Hour = t.Hour;
    TimePicker.Minute = t.Minute;
    TimePicker.Second = t.Second;

    DatePicker.Day = t.Day;
    DatePicker.Month = t.Month;
    DatePicker.Year = t.Year;

    EndRadioButton.Selected = false;
    CurrentRadioButton.Selected = false;
    StartRadioButton.Selected = true;

    StartRadioButton.InvalidateViewState();
    CurrentRadioButton.InvalidateViewState();
    EndRadioButton.InvalidateViewState();





  }

  $rect <740,210,940,250>
  property Core::Time StartDate = null;

  $rect <740,260,940,300>
  property Core::Time EndDate = null;

  $rect <730,140,930,180>
  slot EndSlot
  {
    sender; /* the method is called from the sender object */



    if ( CurrentRadioButton.Selected )
    {
      SetCurrent();
    }
    else if ( StartRadioButton.Selected )
    {
      SetStart();
    }
    else if (  EndRadioButton.Selected )
    {
       return;
    }


    var Core::Time t = new Core::Time;

    t = EndDate;



    TimePicker.Hour = t.Hour;
    TimePicker.Minute = t.Minute;
    TimePicker.Second = t.Second;

    DatePicker.Day = t.Day;
    DatePicker.Month = t.Month;
    DatePicker.Year = t.Year;

    EndRadioButton.Selected = true;
    CurrentRadioButton.Selected = false;
    StartRadioButton.Selected = false;

    StartRadioButton.InvalidateViewState();
    CurrentRadioButton.InvalidateViewState();
    EndRadioButton.InvalidateViewState();





  }

  $rect <940,10,1140,50>
  property bool EndProperty = false;

  $rect <940,50,1140,90>
  onset EndProperty
  {
    // The value doesn't change - nothing to do.
    if ( pure EndProperty == value )
      return;

    // Remember the property's new value.
    pure EndProperty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <940,90,1140,130>
  onget EndProperty
  {
    return pure EndProperty;
  }

  $rect <970,180,1170,220>
  property bool StartProperty = false;

  $rect <970,220,1170,260>
  onset StartProperty
  {
    // The value doesn't change - nothing to do.
    if ( pure EndProperty == value )
      return;

    // Remember the property's new value.
    pure EndProperty = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <970,260,1170,300>
  onget StartProperty
  {
    return pure EndProperty;
  }

  $rect <450,380,650,420>
  method void SetCurrent()
  {
    var int32 h = TimePicker.Hour;
    var int32 m = TimePicker.Minute;
    var int32 s = TimePicker.Second;

    var int32 d = DatePicker.Day;
    var int32 M = DatePicker.Month;
    var int32 y = DatePicker.Year;



    native ( h, m, s, d, M, y )
    {
       Command3( CMD_SET_TIME, h, m, s );
       Command3( CMD_SET_DATE, d, M, y );
    }

  }

  $rect <670,380,870,420>
  method void SetEnd()
  {
    EndDate.Hour = TimePicker.Hour;
    EndDate.Minute = TimePicker.Minute;
    EndDate.Second = TimePicker.Second;

    EndDate.Day = DatePicker.Day;
    EndDate.Month = DatePicker.Month;
    EndDate.Year = DatePicker.Year;



  }

  $rect <870,390,1070,430>
  method void SetStart()
  {
    StartDate.Hour = TimePicker.Hour;
    StartDate.Minute = TimePicker.Minute;
    StartDate.Second = TimePicker.Second;

    StartDate.Day = DatePicker.Day;
    StartDate.Month = DatePicker.Month;
    StartDate.Year = DatePicker.Year;

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <30,240,180,290>;
    preset OnRelease = Proceed;
    preset Label = "Proceed";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <460,240,610,290>;
    preset OnRelease = Cancel;
    preset Label = "Cancel";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <30,185,210,235>;
    preset Label = "Daylight saving";
    preset Appearance = Application::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton CurrentRadioButton
  {
    preset Bounds = <480,20,630,70>;
    preset OnSelect = CurrentSlot;
    preset Label = "Current";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton StartRadioButton
  {
    preset Bounds = <480,80,630,130>;
    preset OnSelect = StartSlot;
    preset Label = "DST Start";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton EndRadioButton
  {
    preset Bounds = <480,140,630,190>;
    preset OnSelect = EndSlot;
    preset Label = "DST End";
    preset Appearance = Application::NormalRadioButton;
  }
}

// This is a GUI component.
$rect <560,440,690,480>
$output false
class TimePicker : Templates::PickerControl
{
  $rect <250,400,450,440>
  inherited property Bounds = <0,0,190,150>;

  $rect <480,280,680,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the time picker widget.
    //
    // isEnabled  --> the time picker can react to user inputs.
    // isSelected --> the time picker can receive keyboard events.
    // isSliding  --> the user interacts with the time picker.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isSliding  = TouchHandlerHour.Sliding   || 
                          TouchHandlerMinute.Sliding ||
                          TouchHandlerSecond.Sliding;

    /*

      TO DO:

      Depending on your time picker design, you have surely added some new 
      views  to your time picker. In the below code you should update the
      properties of these views. For example, when your picker has an image
      which you want to show only while the user is changing the time, than
      following can be done:

        theImage.Visible = isSliding;

      Depending on the state of the time picker, you can alternate any property 
      of your views. You can change their visibility, colors, opacity, bitmaps
      shown in image views, fonts used to render text, the position and the
      size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the picker
      (e.g. 'isSliding') with its preceding state (e.g. variable 'sliding').

      Assuming you have already added to your time picker component a new
      effect member, named it 'slidingEffect' and configured it to animate
      e.g. the opacity of an image within the time picker. Then following is
      sufficient to trigger the animation:

        if ( isSliding && !sliding )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isSliding && sliding )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( isSliding )
      BorderCurrent.Color = #C1C1C1FF;

    else
      BorderCurrent.Color = #E1E1E1FF;

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // sliding <<-->> not sliding transition.
    enabled  = isEnabled;
    selected = isSelected;
    sliding  = isSliding;
  }

  // To do:
  // 
  // - Adjust the visible size of your picker (the thick blue border). This will \
  // be the picker's default size.
  // - Remove the 'Background', 'Border', 'BorderCurrent', 'Separator1', 'Separator2', \
  // 'ShineAtTop' and 'ShineAtBottom' members if you want other views to be shown \
  // instead these in your picker.
  // - According to your desired picker design add and configure new views (e.g. \
  // text views as captions for Hour, Minute, etc).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the picker's current state.
  // - You can also add and configure animation effects to your picker. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your picker.
  // - Similarly you can arrange the 3 lists 'ListHour', 'ListMinute' and 'ListSecond' \
  // and the corresponding touch handlers 'TouchHandlerHour', TouchHandlerMinute' \
  // and 'TouchHandlerSecond'. Note, the touch handler should always cover the area \
  // of the corresponding list.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the picker itself is resized.
  // - If you want other fonts, colors, etc. to be displayed in the 3 lists, adapt \
  // the implementation of the corresponding slot methods 'OnLoadHourItem', 'OnLoadMinuteItem' \
  // and 'OnLoadSecondItem'.
  // - If you want the items to be displayed with other height, adapt the property \
  // 'ItemHeight' of the 3 'ListHour', 'ListMinute' and 'ListSecond'. Similarly adapt \
  // the property 'SnapNext' of the corresponding touch handlers 'TouchHandlerHour', \
  // TouchHandlerMinute' and 'TouchHandlerSecond'.
  // - From the Gallery folder 'Chora' add properties to your picker. One property \
  // for every picker specific setting (e.g. 'Caption', 'Icon', 'Color', 'Font', \
  // ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Caption' should update the text view in your picker where \
  // some caption is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note4
  {
    attr Bounds = <10,460,1020,900>;
  }

  // State Management
  note group Note3
  {
    attr Bounds = <470,240,690,450>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <240,240,460,370>;
  }

  // List Management
  note group Note1
  {
    attr Bounds = <10,240,230,410>;
  }

  // This variable stores the current state of the time picker.
  $rect <480,400,680,440>
  var bool sliding;

  // This variable stores the current state of the time picker.
  $rect <480,360,680,400>
  var bool selected;

  // This variable stores the current state of the time picker.
  $rect <480,320,680,360>
  var bool enabled;

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has finished the slide animation. \
  // Thereupon the owner of the time picker is notified, that the time has been changed.
  $rect <250,320,450,360>
  slot onEndSlide
  {
    // The user has finished the interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();

    // Notify the owner of the time picker, that the user has selected another time.
    // Do this however only after the last list has finished the slide animation.
    if ( !TouchHandlerHour.Sliding && !TouchHandlerMinute.Sliding && !TouchHandlerSecond.Sliding )
      postsignal OnChange;
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has begun the slide animation.
  $rect <250,280,450,320>
  slot onStartSlide
  {
    // The user has begun an interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();
  }

  // This method is called by 'ListSecond' vertical list every time the list loads \
  // or updates an item.
  $rect <20,360,220,400>
  slot OnLoadSecondItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListSecond.Item;
    var Views::Text itemView = (Views::Text)ListSecond.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your time picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListSecond.Bounds.w, ListSecond.ItemHeight );
  }

  // This method is called by 'ListMinute' vertical list every time the list loads \
  // or updates an item.
  $rect <20,320,220,360>
  slot OnLoadMinuteItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListMinute.Item;
    var Views::Text itemView = (Views::Text)ListMinute.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your time picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListMinute.Bounds.w, ListMinute.ItemHeight );
  }

  // This method is called by 'ListHour' vertical list every time the list loads \
  // or updates an item.
  $rect <20,280,220,320>
  slot OnLoadHourItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListHour.Item;
    var Views::Text itemView = (Views::Text)ListHour.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your time picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListHour.Bounds.w, ListHour.ItemHeight );
  }

  $rect <620,90,820,130>
  onget Second
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListSecond.ScrollOffset / ListSecond.ItemHeight ) + 2 ) % 60;
  }

  $rect <620,50,820,90>
  onset Second
  {
    // Limit the assigned value to the valid range 0 .. 59
    if ( value < 0  ) value = 0;
    if ( value > 59 ) value = 59;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListSecond.ScrollOffset = ( value - 2 ) * -ListSecond.ItemHeight;
  }

  $rect <420,90,620,130>
  onget Minute
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListMinute.ScrollOffset / ListMinute.ItemHeight ) + 2 ) % 60;
  }

  $rect <420,50,620,90>
  onset Minute
  {
    // Limit the assigned value to the valid range 0 .. 59
    if ( value < 0  ) value = 0;
    if ( value > 59 ) value = 59;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListMinute.ScrollOffset = ( value - 2 ) * -ListMinute.ItemHeight;
  }

  $rect <220,90,420,130>
  onget Hour
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListHour.ScrollOffset / ListHour.ItemHeight ) + 2 ) % 24;
  }

  $rect <220,50,420,90>
  onset Hour
  {
    // Limit the assigned value to the valid range 0 .. 23
    if ( value < 0  ) value = 0;
    if ( value > 23 ) value = 23;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListHour.ScrollOffset = ( value - 2 ) * -ListHour.ItemHeight;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,190,150>;
  }

  $rect <20,20,160,60>
  object Views::Border BorderCurrent
  {
    preset Bounds = <10,59,180,91>;
    preset Width = 3;
    preset Color = #E1E1E1FF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerSecond
  {
    preset Bounds = <130,0,180,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerMinute
  {
    preset Bounds = <70,0,120,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerHour
  {
    preset Bounds = <10,0,60,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListSecond
  {
    preset Bounds = <130,0,180,150>;
    preset OnLoadItem = OnLoadSecondItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerSecond;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListMinute
  {
    preset Bounds = <70,0,120,150>;
    preset OnLoadItem = OnLoadMinuteItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerMinute;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListHour
  {
    preset Bounds = <10,0,60,150>;
    preset OnLoadItem = OnLoadHourItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerHour;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 24;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,10,150>;
    preset Width = 2;
    preset ColorL = #1BFF5200;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel1
  {
    preset Bounds = <60,0,70,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel2
  {
    preset Bounds = <120,0,130,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel3
  {
    preset Bounds = <180,0,190,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #1BFF5200;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Rectangle ShineAtBottom
  {
    preset Bounds = <0,88,190,150>;
    preset ColorBL = #CCCCCCFF;
    preset ColorBR = #C6C6C6FF;
    preset ColorTR = #FFFFFF22;
    preset ColorTL = #FFFFFF22;
  }

  $rect <20,20,160,60>
  object Views::Rectangle ShineAtTop
  {
    preset Bounds = <0,0,190,58>;
    preset ColorBL = #FFFFFF22;
    preset ColorBR = #FFFFFF22;
  }

  $rect <20,20,160,60>
  object Views::Text Separator2
  {
    preset Bounds = <113,57,136,89>;
    preset String = ":";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #838083FF;
  }

  $rect <20,20,160,60>
  object Views::Text Separator1
  {
    preset Bounds = <53,57,76,89>;
    preset String = ":";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #838083FF;
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user select another time. Thereupon the method's logic will be \
  // executed. In the associated slot method you can evaluate the time picker properties \
  // @Hour, @Minute and @Second.
  $rect <220,150,420,190>
  property slot OnChange = null;

  // The property 'Second' stores the number of seconds after the minute. The value \
  // is valid in range 0 .. 59.
  $rect <620,10,820,50>
  property int32 Second = 0;

  // The property 'Minute' stores the number of minutes after the hour. The value \
  // is valid in range 0 .. 59.
  $rect <420,10,620,50>
  property int32 Minute = 0;

  // The property 'Hour' stores the number of hours since midnight. The value is \
  // valid in range 0 .. 23.
  $rect <220,10,420,50>
  property int32 Hour = 0;

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,0,190,150>;
    preset Color = #000000FF;
  }
}

// This is a GUI component.
$rect <690,440,820,480>
$output false
class DatePicker : Templates::PickerControl
{
  $rect <250,400,450,440>
  inherited property Bounds = <0,0,230,150>;

  $rect <480,280,680,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the date picker widget.
    //
    // isEnabled  --> the date picker can react to user inputs.
    // isSelected --> the date picker can receive keyboard events.
    // isSliding  --> the user interacts with the date picker.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isSliding  = TouchHandlerDay.Sliding   || 
                          TouchHandlerMonth.Sliding ||
                          TouchHandlerYear.Sliding;

    /*

      TO DO:

      Depending on your date picker design, you have surely added some new 
      views  to your date picker. In the below code you should update the
      properties of these views. For example, when your picker has an image
      which you want to show only while the user is changing the date, than
      following can be done:

        theImage.Visible = isSliding;

      Depending on the state of the date picker, you can alternate any property 
      of your views. You can change their visibility, colors, opacity, bitmaps
      shown in image views, fonts used to render text, the position and the
      size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the picker
      (e.g. 'isSliding') with its preceding state (e.g. variable 'sliding').

      Assuming you have already added to your date picker component a new
      effect member, named it 'slidingEffect' and configured it to animate
      e.g. the opacity of an image within the date picker. Then following is
      sufficient to trigger the animation:

        if ( isSliding && !sliding )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isSliding && sliding )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( isSliding )
      BorderCurrent.Color = #C1C1C1FF;

    else
      BorderCurrent.Color = #E1E1E1FF;

    // Remember the current state. Next date when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // sliding <<-->> not sliding transition.
    enabled  = isEnabled;
    selected = isSelected;
    sliding  = isSliding;
  }

  // To do:
  // 
  // - Adjust the visible size of your picker (the thick blue border). This will \
  // be the picker's default size.
  // - Remove the 'Background', 'Border', 'BorderCurrent', 'ShineAtTop' and 'ShineAtBottom' \
  // members if you want other views to be shown instead these in your picker.
  // - According to your desired picker design add and configure new views (e.g. \
  // text views as captions for Day, Month, etc).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the picker's current state.
  // - You can also add and configure animation effects to your picker. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your picker.
  // - Similarly you can arrange the 3 lists 'ListDay', 'ListMonth' and 'ListYear' \
  // and the corresponding touch handlers 'TouchHandlerDay', TouchHandlerMonth' and \
  // 'TouchHandlerYear'. Note, the touch handler should always cover the area of \
  // the corresponding list.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the picker itself is resized.
  // - If you want other fonts, colors, etc. to be displayed in the 3 lists, adapt \
  // the implementation of the corresponding slot methods 'OnLoadDayItem', 'OnLoadMonthItem' \
  // and 'OnLoadYearItem'.
  // - If you want the items to be displayed with other height, adapt the property \
  // 'ItemHeight' of the 3 'ListDay', 'ListMonth' and 'ListYear'. Similarly adapt \
  // the property 'SnapNext' of the corresponding touch handlers 'TouchHandlerDay', \
  // TouchHandlerMonth' and 'TouchHandlerYear'.
  // - From the Gallery folder 'Chora' add properties to your picker. One property \
  // for every picker specific setting (e.g. 'Caption', 'Icon', 'Color', 'Font', \
  // ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Caption' should update the text view in your picker where \
  // some caption is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,460,1020,900>;
  }

  // Utility Functionality
  note group Note4
  {
    attr Bounds = <700,240,920,330>;
  }

  // State Management
  note group Note3
  {
    attr Bounds = <470,240,690,450>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <240,240,460,370>;
  }

  // List Management
  note group Note1
  {
    attr Bounds = <10,240,230,410>;
  }

  // This variable stores the current state of the date picker.
  $rect <480,400,680,440>
  var bool sliding;

  // This variable stores the current state of the date picker.
  $rect <480,360,680,400>
  var bool selected;

  // This variable stores the current state of the date picker.
  $rect <480,320,680,360>
  var bool enabled;

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has finished the slide animation. Thereupon \
  // the owner of the date picker is notified, that the date has been changed.
  $rect <250,320,450,360>
  slot onEndSlide
  {
    // The user has finished the interaction with the date picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the date picker appearance.
    InvalidateViewState();

    // The last list has finished the slide animation. Adjust the day and notify the owner
    // about the made selection
    if ( !TouchHandlerDay.Sliding && !TouchHandlerMonth.Sliding && !TouchHandlerYear.Sliding )
    {
      // Changing the month may affect the actually selected day.
      var int32 daysInMonth = getDaysInMonth( Month, Year );
      var int32 day         = Day;

      // Ensure the list displays the right number of days
      ListDay.NoOfItems = daysInMonth;

      // Adjust the day if necessary
      if ( day > daysInMonth )
        Day = daysInMonth;

      // Notify the owner of the date picker, that the user has selected another date.
      postsignal OnChange;
    }
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has begun the slide animation.
  $rect <250,280,450,320>
  slot onStartSlide
  {
    // The user has begun an interaction with the date picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the date picker appearance.
    InvalidateViewState();
  }

  // This method is called by 'ListYear' vertical list every time the list loads \
  // or updates an item.
  $rect <20,360,220,400>
  slot OnLoadYearItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListYear.Item;
    var Views::Text itemView = (Views::Text)ListYear.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your date picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo + 1900, 4 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListYear.Bounds.w, ListYear.ItemHeight );
  }

  // This method is called by 'ListMonth' vertical list every time the list loads \
  // or updates an item.
  $rect <20,320,220,360>
  slot OnLoadMonthItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListMonth.Item;
    var Views::Text itemView = (Views::Text)ListMonth.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your date picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Select the text to display in the 'Month' list
    switch ( itemNo )
    {
      case 1  : itemView.String = Resources::FebruaryAbbr;
      case 2  : itemView.String = Resources::MarchAbbr;
      case 3  : itemView.String = Resources::AprilAbbr;
      case 4  : itemView.String = Resources::MayAbbr;
      case 5  : itemView.String = Resources::JuneAbbr;
      case 6  : itemView.String = Resources::JulyAbbr;
      case 7  : itemView.String = Resources::AugustAbbr;
      case 8  : itemView.String = Resources::SeptemberAbbr;
      case 9  : itemView.String = Resources::OctoberAbbr;
      case 10 : itemView.String = Resources::NovemberAbbr;
      case 11 : itemView.String = Resources::DecemberAbbr;
      default : itemView.String = Resources::JanuaryAbbr;
    }

    // Configure the item view ...
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListMonth.Bounds.w, ListMonth.ItemHeight );
  }

  // This method is called by 'ListDay' vertical list every time the list loads or \
  // updates an item.
  $rect <20,280,220,320>
  slot OnLoadDayItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListDay.Item;
    var Views::Text itemView = (Views::Text)ListDay.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    /*

      TO DO:

      Depending on your date picker design, you will need to adapt the following
      initialization. You can change the font, color, the alignment of the text
      within the area, etc.

    */

    // Configure the item view ...
    itemView.String    = string( itemNo + 1, 2 );
    itemView.Font      = Templates::DefaultFontPicker;
    itemView.Color     = #000000FF;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListDay.Bounds.w, ListDay.ItemHeight );
  }

  $rect <650,90,850,130>
  onget Year
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected date at the
    // third position (index 2). Additionally the first item starts with year 1900
    return 1900 + (( -ListYear.ScrollOffset / ListYear.ItemHeight ) + 2 ) % 200;
  }

  $rect <650,50,850,90>
  onset Year
  {
    // Limit the assigned value to the valid range.
    if ( value < 1900 ) value = 1900;
    if ( value > 2100 ) value = 2100;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected date scrolled by two items.
    // Take this displacement in account. Additionally the first item
    // starts with year 1900
    ListYear.ScrollOffset = ( value - 1900 - 2 ) * -ListYear.ItemHeight;

    // Changing the year may affect the actually selected day (February
    // and the leap year).
    var int32 daysInMonth = getDaysInMonth( Month, value );

    // Ensure the list displays the right number of days
    ListDay.NoOfItems = daysInMonth;

    // Adjust the day if necessary
    if ( Day > daysInMonth )
      Day = daysInMonth;
  }

  $rect <450,90,650,130>
  onget Month
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected date at the
    // third position (index 2). Additionally the first item starts with
    // month 1: January
    return 1 + (( -ListMonth.ScrollOffset / ListMonth.ItemHeight ) + 2 ) % 12;
  }

  $rect <450,50,650,90>
  onset Month
  {
    // Limit the assigned value to the valid range 1 .. 12
    if ( value < 1  ) value = 1;
    if ( value > 12 ) value = 12;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected date scrolled by two items.
    // Take this displacement in account. Additionally the first item
    // starts with month 1: January
    ListMonth.ScrollOffset = ( value - 1 - 2 ) * -ListMonth.ItemHeight;

    // Changing the month may affect the actually selected day.
    var int32 daysInMonth = getDaysInMonth( value, Year );

    // Ensure the list displays the right number of days
    ListDay.NoOfItems = daysInMonth;

    // Adjust the day if necessary
    if ( Day > daysInMonth )
      Day = daysInMonth;

  }

  $rect <250,90,450,130>
  onget Day
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected date at the
    // third position (index 2). Additionally the first item starts with day 1.
    return 1 + (( -ListDay.ScrollOffset / ListDay.ItemHeight ) + 2 ) % ListDay.NoOfItems;
  }

  $rect <250,50,450,90>
  onset Day
  {
    // How many days are in the actually selected month?
    var int32 daysInMonth = getDaysInMonth( Month, Year );

    // Limit the assigned value to the valid range 1 .. { 28, 29, 30, 31 }
    if ( value < 1           ) value = 1;
    if ( value > daysInMonth ) value = daysInMonth;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected date scrolled by two items.
    // Take this displacement in account. Additionally the first item
    // starts with day 1
    ListDay.ScrollOffset = ( value - 2 - 1 ) * -ListDay.ItemHeight;
  }

  // This function returns the number of days in the month and year specified in \
  // the method parameters aMonth and aYear. The function takes care of the February \
  // and its dependency of the leap year.
  $rect <710,280,910,320>
  method int32 getDaysInMonth( arg int32 aMonth, arg int32 aYear )
  {
    // The number of days in February depends on the leap year.
    if ( aMonth == 2 )
      if ((( aYear % 4 ) == 0 ) && ((( aYear % 100 ) != 0 ) || (( aYear % 400 ) == 0 )))
        return 29;
      else
        return 28;

    // A month with 30 days?
    else if (( aMonth == 4 ) || ( aMonth == 6 ) || ( aMonth == 9 ) || ( aMonth == 11 ))
      return 30;

    // Every other month has 31 days.
    else
      return 31;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,230,150>;
  }

  $rect <20,20,160,60>
  object Views::Border BorderCurrent
  {
    preset Bounds = <10,59,220,91>;
    preset Width = 3;
    preset Color = #E1E1E1FF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerYear
  {
    preset Bounds = <150,0,220,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerMonth
  {
    preset Bounds = <70,0,140,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerDay
  {
    preset Bounds = <10,0,60,150>;
    preset OnEnd = onEndSlide;
    preset OnStart = onStartSlide;
    preset SnapNext = <0,30>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListYear
  {
    preset Bounds = <150,0,220,150>;
    preset OnLoadItem = OnLoadYearItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerYear;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 200;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListMonth
  {
    preset Bounds = <70,0,140,150>;
    preset OnLoadItem = OnLoadMonthItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerMonth;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 12;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListDay
  {
    preset Bounds = <10,0,60,150>;
    preset OnLoadItem = OnLoadDayItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerDay;
    preset ScrollOffset = 60;
    preset ItemHeight = 30;
    preset NoOfItems = 31;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,10,150>;
    preset Width = 2;
    preset ColorL = #FFFFFF00;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel1
  {
    preset Bounds = <60,0,70,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel2
  {
    preset Bounds = <140,0,150,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #87B6DBFF;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel3
  {
    preset Bounds = <220,0,230,150>;
    preset Width = 2;
    preset ColorL = #87B6DBFF;
    preset ColorR = #1BFF5200;
    preset ColorB = #00000000;
    preset ColorT = #FFFFFF00;
  }

  $rect <20,20,160,60>
  object Views::Rectangle ShineAtBottom
  {
    preset Bounds = <0,88,230,150>;
    preset ColorBL = #D7D7D7FF;
    preset ColorBR = #CFCFCFFF;
    preset ColorTR = #FFFFFF22;
    preset ColorTL = #FFFFFF22;
  }

  $rect <20,20,160,60>
  object Views::Rectangle ShineAtTop
  {
    preset Bounds = <0,0,230,58>;
    preset ColorBL = #FFFFFF22;
    preset ColorBR = #FFFFFF22;
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user select another date. Thereupon the method's logic will be \
  // executed. In the associated slot method you can evaluate the date picker properties \
  // @Day, @Month and @Year.
  $rect <250,150,450,190>
  property slot OnChange = null;

  // The property 'Year' stores the year. The value is valid in range 1900 .. 2100.
  $rect <650,10,850,50>
  property int32 Year = 1900;

  // The property 'Month' store the month of the year. The valid value lies in the \
  // range 1 .. 12.
  $rect <450,10,650,50>
  property int32 Month = 1;

  // The property 'Day' stores the day of the month. The valid value lies in range \
  // 1 .. 31 depending on the actually selected month.
  $rect <250,10,450,50>
  property int32 Day = 0;

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,0,230,150>;
    preset Color = #000000FF;
  }
}

$rect <390,50,550,90>
$output false
class ConfirmPopup : Application::Popup
{
  $rect <20,20,160,60>
  inherited property Bounds = <0,0,630,340>;

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Color = #3755AFFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <30,110,580,190>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
  }

  $rect <0,360,200,400>
  slot Proceed
  {
    sender; /* the method is called from the sender object */

    signal meth;

    Hide();


  }

  $rect <400,370,600,410>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <0,410,200,450>
  method void ShowThen( arg Core::Root rootObject, arg slot method )
  {
    // Create a new instance of some alert panel component.
    mask = new Views::Rectangle;
    touch = new Core::SimpleTouchHandler;
    root = rootObject;

    meth = method;



    touch.Point1 = <0,0>;
    touch.Point2 = <0,480>;
    touch.Point3 = <800,480>;
    touch.Point4 = <800,0>;

    rootObject.Add( touch, 0 );


    mask.Color = #00000030;
    mask.Bounds = <0,0,800,480>;

    rootObject.Add( mask, 0 );

    var point m = point( (800 - this.Bounds.size.x) / 2, (480 - this.Bounds.size.y) / 2);

        
    this.Bounds.point1 = m;
    this.Bounds.point2 = <800,480> - m;


    rootObject.Add( this, 0 );

    return;

  }

  $rect <270,420,470,460>
  var slot meth = null;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <30,250,180,300>;
    preset OnRelease = Proceed;
    preset Label = "Proceed";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <425,250,575,300>;
    preset OnRelease = Cancel;
    preset Label = "Cancel";
    preset Appearance = Application::NormalPushButton;
  }
}

$rect <990,80,1140,120>
$output false
class KeypadPopup : Application::Popup
{
  $rect <20,20,160,60>
  inherited property Bounds = <0,0,480,390>;

  $rect <160,420,300,460>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    accept.Visible = false;
    accept.Visible = false;
    AcceptTimer.Enabled = false;

    Writable.TextEditor.Text.String = "";
    passkey = "";
    Writable.TextEditor.ObtainFocus();






  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Color = #CBCBCBFF;
  }

  $rect <20,20,160,60>
  object Application::KeypadKey KeypadKey
  {
    preset Bounds = <290,100,350,150>;
    preset NumProperty = "5";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object Application::KeypadKey KeypadKey1
  {
    preset Bounds = <360,40,420,90>;
    preset NumProperty = "9";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object Application::KeypadKey KeypadKey2
  {
    preset Bounds = <220,40,280,90>;
    preset NumProperty = "7";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object Application::KeypadKey KeypadKey3
  {
    preset Bounds = <220,100,280,150>;
    preset NumProperty = "4";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object Application::KeypadKey KeypadKey4
  {
    preset Bounds = <290,40,350,90>;
    preset NumProperty = "8";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object Application::KeypadKey KeypadKey5
  {
    preset Bounds = <360,100,420,150>;
    preset NumProperty = "6";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object Application::KeypadKey KeypadKey6
  {
    preset Bounds = <220,160,280,210>;
    preset NumProperty = "1";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object Application::KeypadKey KeypadKey7
  {
    preset Bounds = <290,160,350,210>;
    preset NumProperty = "2";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object Application::KeypadKey KeypadKey8
  {
    preset Bounds = <360,160,420,210>;
    preset NumProperty = "3";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object Application::KeypadKey KeypadKey9
  {
    preset Bounds = <220,220,280,270>;
    preset NumProperty = "0";
    preset UserPress = Press;
  }

  $rect <20,20,160,60>
  object Application::KeypadKey KeypadKey10
  {
    preset Bounds = <290,220,420,270>;
    preset NumProperty = "Del";
    preset UserPress = Press;
  }

  $rect <30,80,170,120>
  object Application::Writable Writable
  {
    preset Bounds = <40,84,140,124>;
    preset Focus = null;
    preset MaxLength = 4;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <40,51,130,80>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Enter Pin";
    preset Font = Resources::FontMedium;
    preset Color = #020202FF;
  }

  $rect <510,220,710,260>
  slot Press
  {
    sender; /* the method is called from the sender object */

    var Application::KeypadKey key = (Application::KeypadKey) sender;

    if (passkey.length < 4 )
    {
        if ( key.NumProperty.length == 1 )
        {
             passkey = passkey + key.NumProperty[0];
            Update();
        }
    }

    if ( key.NumProperty == "Del" && passkey.length > 0 )
    {
        passkey = passkey.left( passkey.length - 1 );
        Update();
    }


  }

  $rect <-10,370,190,410>
  slot Proceeed
  {
    sender; /* the method is called from the sender object */

    var Application::Application ap = (Application::Application) GetRoot();



    if ( passkey == EngLevel )
    {
      ap.LevelAccess.Level = 4;
     
      deny.Visible = false;
      accept.Visible = true;
      AcceptTimer.Enabled = true;
      AcceptTimer.restart( 0, 600 );
    }

    else if ( passkey == SupLevel )  
    {
      ap.LevelAccess.Level = 3;
     
      deny.Visible = false;
      accept.Visible = true;
      AcceptTimer.Enabled = true;
      AcceptTimer.restart( 0, 600 );
    }
    else
    {

      // ap.LogOnButton.Line.Color = #FFFFFFFF;
     //  ap.LogOnButton.Text.String = "Log On";
      accept.Visible = false;
      deny.Visible = true;
      DenyTimer.restart( 0, 600 );
    }




  }

  $rect <280,370,480,410>
  slot Cancel
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <510,20,710,60>
  property string EngLevel = "1234";

  $rect <510,70,710,110>
  property string SupLevel = "0000";

  $rect <20,20,160,60>
  object Views::Text accept
  {
    preset Bounds = <40,134,140,164>;
    preset String = "Accepted";
    preset Font = Flat::FontM;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <550,150,750,190>
  object Core::Timer AcceptTimer
  {
    preset OnTrigger = AcceptSlot;
    preset Period = 1000;
  }

  $rect <20,20,160,60>
  object Views::Text deny
  {
    preset Bounds = <40,134,140,164>;
    preset String = "Denied";
    preset Font = Flat::FontM;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <540,290,740,330>
  slot AcceptSlot
  {
    sender; /* the method is called from the sender object */

    AcceptTimer.Enabled = false;  
    Hide();



  }

  $rect <520,340,720,380>
  object Core::Timer DenyTimer
  {
    preset OnTrigger = DenySlot;
    preset Period = 300;
  }

  $rect <530,390,730,430>
  slot DenySlot
  {
    sender; /* the method is called from the sender object */

    DenyTimer.Enabled = false;  
    deny.Visible = false;


  }

  $rect <750,60,950,100>
  object Core::Timer StarTimer
  {
    preset OnTrigger = StarSlot;
  }

  $rect <780,100,980,140>
  slot StarSlot
  {
    sender; /* the method is called from the sender object */

    StarTimer.Enabled = false;

    var int32 n;
    var string s = "";

    for( n = 0; n < passkey.length; n=n+1 )
    {
        s = s + "*";
    }

    Writable.TextEditor.Text.String = s;

  }

  $rect <810,170,1010,210>
  property string passkey = 0;

  $rect <840,260,1040,300>
  method void Update()
  {
             var int32 n;
             if ( StarTimer.Enabled ) StarTimer.Enabled = false;

             Writable.TextEditor.String = "";
          
             for( n = 0; n < passkey.length; n=n+1)
             {
                if ( n ==  passkey.length-1 )
                {
                   Writable.TextEditor.String = Writable.TextEditor.String + passkey[n];
                }
                else
                {
                    Writable.TextEditor.String = Writable.TextEditor.String + '*';
                }
              }
             StarTimer.Enabled = true;
             StarTimer.restart( 0, 1000 );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <280,300,420,350>;
    preset OnRelease = Cancel;
    preset Label = "Cancel";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <40,300,180,350>;
    preset OnRelease = Proceeed;
    preset Label = "Proceed";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <840,300,1040,340>
  object Core::SystemEventHandler SystemEventHandler
  {
    preset OnEvent = onEvent;
    preset Enabled = true;
    preset Event = Application::Devices.FireListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <830,340,1030,380>
  slot onEvent
  {
    if (this != null )
    {
      if ( GetRoot().FindCurrentDialog() == this || GetRoot().GetIndexOfView( this ) > 0 )
      {
        


    var int32 fires = 0;
     

    native( fires )
    {
      Command cmd;

      Command0( CMD_GET_NUM_FIRES, &cmd );  

      fires = cmd.int0;

     

    }

    if ( fires > 0 )
    {
      Hide();
    }


      }
    }
  }

  $rect <850,390,1050,430>
  object Core::SystemEventHandler SystemEventHandler1
  {
    preset OnEvent = onEvent1;
    preset Event = Application::Devices.EventListChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <840,430,1040,470>
  slot onEvent1
  {
    if (this != null )
    {
      if ( this.Parent != null )
      {

     
    var int32 events = 0;

    native( events )
    {
      Command cmd;

      Command0( CMD_GET_NUM_OTHER_EVENTS, &cmd );  

      events = cmd.int0;

    }

    if ( events > 0 )
    {
      Hide();
    }


    }
    }
  }
}

$rect <1140,80,1280,120>
$output false
class KeypadKey : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,60,50>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );


    //SimpleTouchHandler.Point1 = Bounds.point1;
    //SimpleTouchHandler.Point3 = Bounds.point2;
    //SimpleTouchHandler.Point2 = point( Bounds.point2.x, Bounds.point1.y );
    //SimpleTouchHandler.Point4 = point( Bounds.point1.x, Bounds.point2.y );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


    Text.String = NumProperty ;



    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <5,5,55,45>;
    preset Color = #BABABAFF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,60,50>;
    preset OnRelease = Release;
    preset OnPress = Press;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,60,50>;
    preset String = "8";
    preset Font = Resources::FontMedium;
    preset Color = #424242FF;
  }

  $rect <25,85,180,125>
  property string NumProperty = "0";

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,60,50>;
    preset Color = #A6D2FF92;
    preset Visible = false;
  }

  $rect <270,100,470,140>
  slot Release
  {
    sender; /* the method is called from the sender object */

     
  }

  $rect <270,140,470,180>
  slot Press
  {
    sender; /* the method is called from the sender object */

     

    postsignal UserPress;


  }

  $rect <550,70,750,110>
  property slot UserPress = null;
}

$rect <390,400,540,440>
$output false
class Writable : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,150,50>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <260,60,400,100>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    Property = ^this.TextEditor.Text.String;


  }

  $rect <200,0,340,40>
  inherited property Focus = TextEditor;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,150,50>;
    preset Width = 2;
    preset ColorL = #333333FF;
    preset ColorR = #B5B5B5FF;
    preset ColorB = #B5B5B5FF;
    preset ColorT = #333333FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <3,3,147,47>;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Application::TextEditor TextEditor
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <3,3,147,47>;
    preset Focus = null;
    preset OnChange = null;
    preset WrapText = false;
    preset String = "";
  }

  $rect <20,70,220,110>
  property ^string Property = null;

  $rect <20,110,220,150>
  onset Property
  {
    // The value doesn't change - nothing to do.
    if ( pure Property == value )
      return;

    // Remember the property's new value.
    pure Property = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,150,220,190>
  onget Property
  {
    return pure Property;
  }

  $rect <270,120,470,160>
  property int32 MaxLength = 0;

  $rect <270,170,470,210>
  onset MaxLength
  {
    // The value doesn't change - nothing to do.
    if ( pure MaxLength == value )
      return;

    // Remember the property's new value.
    pure MaxLength = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }
}

// This component implements an editor.
$rect <1190,40,1310,80>
$output false
class TextEditor : Templates::TextEditor
{
  $rect <670,620,870,660>
  inherited property Bounds = <0,0,160,120>;

  $rect <680,280,880,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited version of the method
    super( aState );

    // Activate the caret blinking if the editor component has the input focus
    if ( aState.contains( Core::ViewState[ Focused ]))
      blinkEffect.Enabled = true;

    // ... otherwise hide the caret
    else
    {
      blinkEffect.Enabled = false;
      Caret.Visible       = false;
    }
  }

  // To do:
  // 
  // - Adjust the visible size of the text editor (the thick blue border). This will \
  // be the editor's default size.
  // - Resize and arrange the member 'Text' so it covers the area where you intend \
  // to display the text. This is usually the entire area.
  // - Adjust the position and the size of the 'SimpleTouchHandler' and 'SlideTouchHandler', \
  // so they cover the 'Text' view.
  // - If your design it expects, add and configure more views in the component, \
  // e.g. views to display background, borders, etc.
  // - The editor implements several handler to process keyboard inputs. See the \
  // annotation 'Keyboard events'. Feel free to add more handler for other key events \
  // or remove the handler you don't need in your version.
  // - The editor displays a magnifying glass when the user touches and holds the \
  // finger for a while (see the method 'onHoldTouch'). If you don't want it, remove \
  // the contents within the annotation 'Magnifying glass' and the slot method 'onHoldTouch'.
  // - The editor reacts to touch interactions. See the annotation 'Touch screen \
  // events'. If your device is not touch driven, you can remove the both handlers \
  // 'SimpleTouchHandler', 'SlideTouchHandler' and the methods from the annotation \
  // 'Touch screen events'.
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the editor's current state (e.g. focused editor \
  // may appear with other colors, etc.)
  // - The editor is implemented with various properties allowing the configuration \
  // of the text (e.g. 'Font', 'Color', ...). If your version of the editor doesn't \
  // need such configuration, remove the properties and the associated OnSet methods.
  // - If you need other properties to configure the editor, add from the Gallery \
  // folder 'Chora' new properties. One property for every new setting (e.g. 'BorderWidth', \
  // etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'BorderWidth' should update the eventually used 'Border' \
  // view, etc.).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note6
  {
    attr Bounds = <10,690,990,1150>;
  }

  // Magnifying glass
  note group Note5
  {
    attr Bounds = <440,500,660,670>;
  }

  // Caret
  note group Note4
  {
    attr Bounds = <10,500,430,670>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <670,240,890,330>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <440,240,660,450>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <10,240,430,490>;
  }

  // This internal variable refers to a temporary Views::Image object used to show \
  // the background for the augmented text content around the caret. This view appears \
  // during the user is moving this caret by touching the caret with the finger.
  $rect <450,620,650,660>
  var Views::Rectangle magnifyingBack = null;

  // This internal variable refers to a temporary Views::WarpGroup object used to \
  // show the augmented text content around the caret. This view appears during the \
  // user is moving this caret by touching the caret with the finger.
  $rect <450,580,650,620>
  var Views::WarpGroup magnifyingView = null;

  // This flag is set if it is evtl. necessary to scroll the editor content in order \
  // to ensure that the caret is still visible.
  $rect <220,620,420,660>
  var bool autoScroll;

  // This internal variable stores the current caret index. This is the position \
  // within Text.String property where the user can input text or delete signs.
  $rect <20,620,220,660>
  var int32 caretIndex = 0;

  // This slot method is called after the caret has been adjusted. Its job is to \
  // adjust too the position of the magnifying glass view where the augmented text \
  // content around the caret is shown.
  $rect <450,540,650,580>
  slot updateMagnifyingView
  {
    // There is actually no magnifying glass displayed. Nothing to do.
    if ( magnifyingView == null )
      return;

    var rect  srcArea = magnifyingView.SourceArea;
    var rect  extent  = magnifyingView.GetExtent();
    var rect  bounds  = Bounds;
    var point caret   = Caret.Point1;

    // Calculate the start position of the area to show in the magnifying
    // view. Preferably the caret should appear in the center of this area.
    var int32 srcX = caret.x - ( srcArea.w / 2 );

    // However, the part of magnifying glass displaying the caret should 
    // remain arranged horizontally within the editor area.
    if ( srcX < 0 )
      srcX = 0;

    if (( srcX + srcArea.w ) > bounds.w )
      srcX = bounds.w - srcArea.w;

    // The resulting start position of the area to augment
    magnifyingView.SourceArea.origin = point( srcX, caret.y );

    // Now calculate the position for the magnifyingView. Preferably the
    // the view should be arranged so it shows the augmented caret 
    // exactly above the origin caret
    var int32 dstX = ( bounds.x1 + caret.x ) - ( caret.x - srcX ) * 2;

    // From the new magnifyingView position and its current position calculate
    // an offset.
    var point ofs = point( dstX - extent.x1, bounds.y1 + caret.y - extent.y2 );

    // Move the magnifyingView and its background by the just calculated offset
    magnifyingView.MoveView( ofs, false );
    magnifyingBack.MoveView( ofs, false );
  }

  // This slot method is called after a short delay when the user has moved the caret \
  // or modified the text. Its job is to ensure that the caret is still visible. \
  // If necessary, the editor content is scrolled.
  $rect <220,540,420,580>
  slot updateScrollOffset
  {
    // Get the visible area of the text view
    var rect  bounds = Text.Bounds;
    var int32 ofsX   = 0;
    var int32 ofsY   = 0;

    // Calculate an offset to scroll the text content if the caret lies
    // outside the visible area
    if ( Caret.Point1.x < bounds.x1 ) ofsX = bounds.x1 - Caret.Point1.x;
    if ( Caret.Point1.x > bounds.x2 ) ofsX = bounds.x2 - Caret.Point1.x;
    if ( Caret.Point1.y < bounds.y1 ) ofsY = bounds.y1 - Caret.Point1.y;
    if ( Caret.Point2.y > bounds.y2 ) ofsY = bounds.y2 - Caret.Point2.y;

    // Should the cont be scrolled?
    if (( ofsX != 0 ) || ( ofsY != 0 ))
      Text.ScrollOffset = Text.ScrollOffset + point( ofsX, ofsY );

    // The following code takes care of the automatic adjustment of the
    // text scroll position if after modifying the text, its area is small
    // enough to be completely visible.
    ofsX = Text.ScrollOffset.x;
    ofsY = Text.ScrollOffset.y;

    // Get the current text area of the 
    var point size = Text.GetContentArea().size;

    // Does the area fit completely within the text editor?
    if ( size.x <= Text.Bounds.w ) ofsX = 0;
    if ( size.y <= Text.Bounds.h ) ofsY = 0;

    // If possible arrange the text so it fits within the text editor.
    Text.ScrollOffset = point( ofsX, ofsY );
  }

  // This slot method is attached to the Text view. Each time the Text view has rearranged \
  // the text, this method is called. Its job is to adjust the caret to the evtl. \
  // new position.
  $rect <20,540,220,580>
  slot updateCaret
  {
    // Without the font we don't know the height of the caret
    if ( Font == null )
      return;

    // Get the pixel position of the sign right to the caret
    var point rowCol = Text.StringIndex2RowCol( caretIndex );
    var point pos    = Text.RowCol2Position( rowCol );

    // Arrange the caret at the just determined position. The height of 
    // the caret corresponds to the height of a text row drawn with the
    // font
    Caret.Point1 = pos - point( 0, Font.Ascent  );
    Caret.Point2 = pos + point( 0, Font.Descent );

    // Restart the blink effect -> this ensures that the user can see the
    // caret while it is moved or the text is modified
    if ( blinkEffect.Enabled )
    {
      blinkEffect.Enabled = false;
      blinkEffect.Enabled = true;
    }

    // Should adjust the scroll position so that the caret remains in the visible
    // area? Finally clear the 'autoScroll' flag again.
    if ( autoScroll )
    {
      postsignal updateScrollOffset;
      autoScroll = false;
    }

    // If there is a magnifying glass view visible -> arrange it also to the
    // current caret position.
    if ( magnifyingView != null )
      postsignal updateMagnifyingView;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to hide the magnifying glass view again.
  $rect <450,400,650,440>
  slot onReleaseTouch
  {
    // Hide the views used temporarily to show the augmented editor content
    if ( magnifyingView != null )
    {
      Owner.Remove( magnifyingView );
      Owner.Remove( magnifyingBack );
      magnifyingView = null;
      magnifyingBack = null;

      // Free the temporary used off-screen memory
      Buffered = false;
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to move the caret accordingly to the user's finger movement.
  $rect <450,360,650,400>
  slot onDragTouch
  {
    // Does the user currently drag the caret?
    if ( magnifyingView != null )
    {
      // From the touched screen position estimate the corresponding position
      // within the text string.
      var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
      var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

      // Does the caret position change? Force the editor to update the
      // position of the blinking caret
      if ( newCaretIndex != caretIndex )
      {
        caretIndex = newCaretIndex;
        postsignal updateCaret;

        // Ensure the caret is still visible later in the updateText slot method
        autoScroll = true;
      }
    }

    // No, then redirect the touch interaction to the slide touch handler when the
    // user moved the finger a little bit. In this manner the user can scroll the text.
    else
    {
      var point ofs   = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;
      var int32 limit = GetRoot().CursorDragLimit;

      // Start the slide mode if the user has dragged the finger a little bit
      if (( ofs.x < -limit ) || ( ofs.x > limit ) ||
          ( ofs.y < -limit ) || ( ofs.y > limit ))
        GetRoot().DeflectCursor( SlideTouchHandler, <0,0>);
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to activate the caret movement mode if the user has pressed the finger on the \
  // screen for a while. The method also shows a small magnifying glass where the \
  // text around the caret is shown. This should help the user to navigate the caret \
  // with the finger.
  $rect <450,320,650,360>
  slot onHoldTouch
  {
    // When the user presses the finger within the text editor area,
    // the editor enters the caret dragging mode. In this mode the
    // user can move the caret with the finger. For convenience the
    // area below the finger is displayed in a kind of magnifying glass.
    // Does enter the mode?
    if (( SimpleTouchHandler.HoldPeriod >= 300 ) && ( magnifyingView == null ))
    {
      // Calculate the size of the area to augment
      var int32 height = Caret.Point2.y - Caret.Point1.y;
      var int32 width  = height * 3;

      // Limit to the available size of the editor component
      if ( height > Bounds.h ) height = Bounds.h;
      if ( width  > Bounds.w ) width  = Bounds.w;

      // The editor component should store its content in an off-screen bitmap
      // in order to be able to to show it augmented in an overlay 'magnifyingView'
      Buffered = true;

      // Create a temporary view to show the augmented content and to show the
      // 'magnifying glass' background
      magnifyingView = new Views::WarpGroup;
      magnifyingBack = new Views::Rectangle;

      // Prepare a magnifyingView to show an augmented content of the edited text
      // row. The content is augmented by the factor x 2
      magnifyingView.Group       = this;
      magnifyingView.Quality     = true;
      magnifyingView.Opacity     = 200;
      magnifyingView.SourceArea  = rect( 0, 0, width, height );
      magnifyingView.Point2.x    = width  * 2;
      magnifyingView.Point3.x    = width  * 2;
      magnifyingView.Point3.y    = height * 2;
      magnifyingView.Point4.y    = height * 2;

      // Also prepare the magnifying glass background view. It is a semitransparent
      // rectangle.
      magnifyingBack.Bounds.size   = point( width * 2, height * 2 ) + <20,20>;
      magnifyingBack.Bounds.origin = <-10,-10>;
      magnifyingBack.Color         = #EEEEEECC;

      // Make the just created views visible on the screen
      Owner.Add( magnifyingBack, 0 );
      Owner.Add( magnifyingView, 0 );

      // Arrange the 'magnifying glass' views at the correct position
      postsignal updateMagnifyingView;
    }

    // Even if the user is not moving the cursor (finger) continue the scrolling when
    // the user holds the finger near an edge of the text editor.
    if ( magnifyingView != null )
      signal onDragTouch;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to obtain the focused state for the editor so the user can interact with the \
  // editor content and to place the caret at the touched position.
  $rect <450,280,650,320>
  slot onPressTouch
  {
    // With the first touch focus the text editor
    if ( !HasViewState( Core::ViewState[ Focused ]))
      ObtainFocus();

    // Estimate the position within the text string corresponding to the
    // position touched on the screen.
    var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the text editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // move the caret up/down/left or right in the editor text.
  $rect <220,440,420,480>
  slot onCursorKey
  {
    // No font specified to show the text -> no navigation
    // possible
    if ( Font == null )
      return;

    // Knowing the position of the caret within the string, get the
    // corresponding row/column position in the displayed text.
    var point rc = Text.StringIndex2RowCol( caretIndex );

    // Has the user moved the caret to the left? Get the new resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Left )
    {
      // Navigate to the previous column
      rc.x = rc.x - 1;

      // Skip to the end of the preceding row?
      if ( rc.x < 0 )
      {
        rc.y = rc.y - 1;
        rc.x = Text.GetRowString( rc.y ).length;
      }
    }

    // Has the user moved the caret to the right? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Right )
    {
      // Navigate to the next column
      rc.x = rc.x + 1;

      // Skip to the begin of the next row?
      if ( rc.x == Text.GetRowString( rc.y ).length )
      {
        rc.y = rc.y + 1;
        rc.x = 0;
      }
    }

    // Has the user moved the caret one row up? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Up )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just above
      rc = Text.Position2RowCol( pos - point( 0, rowHeight ));
    }

    // Has the user moved the caret one row down? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Down )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just below
      rc = Text.Position2RowCol( pos + point( 0, rowHeight ));
    }

    // From the just determined new row/column position get the corresponding
    // position within the text string
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign preceding the current caret position and to move the caret accordingly.
  $rect <220,400,420,440>
  slot onBackspaceKey
  {
    // No signs preceding the caret -> Nothing to delete
    if ( caretIndex == 0 )
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex - 1 ];
    var int32 count = 1;

    // Is this a space sign? Usually space signs are eliminated by the
    // text view unless we use the non-breakable space sign \xA0. However,
    // to perform the text wrap, a silent break sign '^' is placed behind
    // the space sign. Consider the both signs '\xA0^' as a unit
    if (( caretIndex > 1 ) && ( ch == '^' ) && 
        ( Text.String[ caretIndex - 2 ] == '\xA0' ))
      count = 2;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    else if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      count = 2;

    // Remove the affected text portion and adjust the caret position
    Text.String = Text.String.remove( caretIndex - count, count );
    caretIndex  = caretIndex - count;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign at the current caret position.
  $rect <220,360,420,400>
  slot onDeleteKey
  {
    // No signs following the caret -> Nothing to delete
    if ( caretIndex >= ( Text.String.length - 1 ))
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if ( ch == '%' )
      count = 2;

    // Is this a space sign? Usually space signs are eliminated by the
    // text view unless we use the non-breakable space sign \xA0. However,
    // to perform the text wrap, a silent break sign '^' is placed behind
    // the space sign. Consider the both signs '\xA0^' as a unit
    else if ( ch == '\xA0' )
      count = 2;

    // Remove the affected text fragment
    Text.String = Text.String.remove( caretIndex, count );

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the <new line> sign and to move the caret \
  // to the next row.
  $rect <220,320,420,360>
  slot onNewlineKey
  {
    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( '\n', caretIndex );
    caretIndex  = caretIndex + 1;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the sign which has been input by the user \
  // and to move the caret to the next column.
  $rect <220,280,420,320>
  slot onCharacterKey
  {
    var char   ch  = CharacterKeyHandler.CharCode;
    var string str = ch;

    // Precede all special control signs with the '%' escape sign. Otherwise
    // the user can't input nor see them
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '\xAD' ) || ( ch == '%' ))
      str = "%" + ch;

    // To avoid the elimination of space signs at the end of a wrapped row
    // use the non-breakable space signs mit the additional 'silent' break
    // sign to perform the wrapping
    else if ( ch == ' ' )
      str = "\xA0^";

    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( str, caretIndex );
    caretIndex  = caretIndex + str.length;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  $rect <390,180,590,220>
  onset WrapText
  {
    // The value doesn't change - nothing to do.
    if ( pure WrapText == value )
      return;

    // Remember the new value ...
    pure WrapText = value;
    Text.WrapText = value;

    // If the text is warp automatically in rows, there is no need to
    // scroll the text horizontally.
    SlideTouchHandler.SlideHorz = !value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <190,180,390,220>
  onset Alignment
  {
    // The value doesn't change - nothing to do.
    if ( pure Alignment == value )
      return;

    // The justified mode is not supported by the editor.
    if ( value.contains( Views::TextAlignment[ AlignHorzJustified ]))
      value = value - Views::TextAlignment[ AlignHorzJustified ]
                    + Views::TextAlignment[ AlignHorzLeft ];

    // Remember the new value ...
    pure Alignment = value;
    Text.Alignment = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <590,90,790,130>
  onget String
  {
    // Get the current text view content
    var string str = Text.String;

    // In the following steps remove any special text view control signs
    // which are usually used to control the text flow. The resulting string
    // should contain the 'pure' text only.
    var int32  inx = str.find( '\xA0', 0 );

    // Internally the text editor works with the sign sequence '\xA0^' as
    // the space ' ' sign. This is because the text view tends to eliminate
    // regular space signs at the end of a text row.
    // Convert all '\xA0^' sign sequences to a regular space ' '
    while ( inx >= 0 )
    {
      if ( str[ inx + 1 ] == '^' )
      {
        str = str.remove( inx, 1 );
        str[ inx ] = ' ';
      }

      inx = str.find( '\xA0', inx + 1 );
    }

    inx = str.find( '%', 0 );

    // The special control/escape signs are not visible until there is a
    // '%' sign in front of them. Remove all superfluous '%' signs
    while ( inx >= 0 )
    {
      str = str.remove( inx, 1 );
      inx = str.find( '%', inx + 1 );
    }

    // Finally remove the <new line> sign at the end of text which was used
    // as workaround for a text flow parser issue
    return str.left( str.length - 1 );
  }

  $rect <590,50,790,90>
  onset String
  {
    // The value doesn't change - nothing to do.
    if ( pure String == value )
      return;

    // Remember the new string ...
    pure String = value;

    // In the following steps disarm in the assigned Unicode string the special
    // control and escape signs, which usually control the text flow in a  text
    // view. Without this conversion step, signs like '%' couldn't be seen in
    // the editor.
    var string str = value;
    var int32  inx = str.find( '%', 0 );

    // The special '%' escape sign is not visible until there is other
    // '%' sign in front of it. Convert all '%' signs into '%%' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '%', inx + 2 );
    }

    inx = str.find( '^', 0 );

    // The special '^' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '^' signs into '%^' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '^', inx + 2 );
    }

    inx = str.find( '~', 0 );

    // The special '~' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '~' signs into '%~' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '~', inx + 2 );
    }

    inx = str.find( '\xAD', 0 );

    // The special '\xAD' hyphen sign is not visible until there is a '%'
    // sign in front of it. Convert all '\xAD' hyphen signs into '%\xAD'
    // sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '\xAD', inx + 2 );
    }

    inx = str.find( ' ', 0 );

    // The text view tends to eliminate space signs at the end of a text row.
    // To avoid it, the editor will work internally with the non-breakable
    // space \xA0 sign. To perform the line wrap, an additional '^' silent
    // break control sign is placed behind the non-breakable space.
    // Convert all ' ' space signs to '\xA0^' sequence
    while ( inx >= 0 )
    {
      str[ inx ] = '\xA0';
      str = str.insert( "^", inx + 1 );
      inx = str.find( ' ', inx + 2 );
    }

    // Ensure that the caret still refers to a sign within the string
    //if ( caretIndex > str.length )
      caretIndex = str.length;

    // Now show the new string in the editor's text view. The additional
    // <new line> is a workaround for a flow text parser issue
    Text.String = str + "\n";

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <390,50,590,90>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Store the new Color
    pure Color  = value;
    Text.Color  = value;
    Caret.Color = value;
  }

  $rect <190,50,390,90>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Store the new font...
    pure Font = value;
    Text.Font = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  // This bool change effect is used to blink the caret.
  $rect <20,580,220,620>
  object Effects::BoolEffect blinkEffect
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Caret.Visible;
    preset CycleDuration = 500;
    preset InterCycleDelay = 500;
  }

  // This key handler reacts to user inputs if the user has pressed the 'up', 'down', \
  // 'left' or 'right' key. In this case the associated onCursorKey method is called.
  $rect <20,440,220,480>
  object Core::KeyPressHandler CursorKeyHandler
  {
    preset OnPress = onCursorKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onCursorKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'backspace' \
  // key. In this case the associated onBackspaceKey method is called.
  $rect <20,400,220,440>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = onBackspaceKey;
    preset Filter = Core::KeyCode.Backspace;
    preset OnHold = onBackspaceKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'delete' \
  // key. In this case the associated onDeleteKey method is called.
  $rect <20,360,220,400>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = onDeleteKey;
    preset Filter = Core::KeyCode.Delete;
    preset OnHold = onDeleteKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'enter' key. \
  // In this case the associated onNewlineKey method is called.
  $rect <20,320,220,360>
  object Core::KeyPressHandler NewlineKeyHandler
  {
    preset OnPress = onNewlineKey;
    preset Filter = Core::KeyCode.Enter;
    preset OnHold = onNewlineKey;
  }

  // This key handler reacts to user inputs if the user has pressed a key corresponding \
  // to character/digit. In this case the associated onCharacterKey method is called.
  $rect <20,280,220,320>
  object Core::KeyPressHandler CharacterKeyHandler
  {
    preset OnPress = onCharacterKey;
    preset Filter = Core::KeyCode.CharacterKeys;
    preset OnHold = onCharacterKey;
  }

  // This slide gesture handler is used to scroll the text content.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,160,120>;
    preset SlideHorz = false;
    preset Friction = 0.05;
  }

  // This generic touch handler is used to move the caret.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,120>;
    preset Point3 = <160,120>;
    preset Point2 = <160,0>;
    preset Point1 = <0,0>;
    preset OnDrag = onDragTouch;
    preset OnHold = onHoldTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset MaxStrikeCount = 3;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,2,157,117>;
    preset OnUpdate = updateCaret;
    preset SlideHandler = SlideTouchHandler;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text\n";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Caret
  {
    preset Point2 = <50,70>;
    preset Point1 = <50,50>;
    preset Width2 = 2;
    preset Width1 = 2;
    preset Color = #000000FF;
    preset Visible = false;
  }

  // The property 'OnChange' can refer to a slot method, which should be invoked \
  // by the text editor when the user modifies the text.
  $rect <590,140,790,180>
  property slot OnChange = null;

  // The property 'WrapText' determines whether long text rows should be wrapped \
  // automatically.
  $rect <390,140,590,180>
  property bool WrapText = true;

  // The property 'Alignment' determines how the editor should display the text rows \
  // if their size differ from the size of the editor. 
  // In this manner the rows can be aligned horizontally. The entire text block can \
  // be aligned vertically.
  $rect <190,140,390,180>
  property Views::TextAlignment Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];

  // The property 'String' stores the text of the editor.
  $rect <590,10,790,50>
  property string String = "Text";

  // The property 'Color' controls the color of the text.
  $rect <390,10,590,50>
  property color Color = #000000FF;

  // The property 'Font' refers to the font object used to display the text. The \
  // text is determined by the property @String.
  $rect <190,10,390,50>
  property Resources::Font Font = Resources::FontMedium;
}

$rect <680,40,830,80>
$output false
class AccesssPopup : Core::Group
{
  $rect <225,480,425,520>
  inherited property Bounds = <0,0,520,190>;

  $rect <0,460,200,500>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <380,290,580,330>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <60,190,210,230>
  inherited method Init()
  {
    // TO DO: Write your code here ... 


  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <490,10,520,160>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight];
    preset Bounds = <490,160,520,190>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, ResizeHorz];
    preset Bounds = <10,160,490,190>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,10,490,160>;
    preset Color = #7F3731FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <490,0,520,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle5
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <0,160,10,190>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle6
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <10,0,490,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle7
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,0,10,10>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle8
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <0,10,10,160>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <5,410,205,450>
  method void Show( arg Core::Root rootObject )
  {
    /* The template just returns the given argument... */

    // Obtain access to the root object.
    //var Core::Root rootObject = GetRoot();

    // Create a new instance of some alert panel component.
    mask = new Views::Rectangle;
    touch = new Core::SimpleTouchHandler;
    root = rootObject;

    touch.Point1 = <0,0>;
    touch.Point2 = <0,480>;
    touch.Point3 = <800,480>;
    touch.Point4 = <800,0>;

    rootObject.Add( touch, 0 );


    mask.Color = #00000020;
    mask.Bounds = <0,0,800,480>;

    rootObject.Add( mask, 0 );

    var point m = point( (800 - this.Bounds.size.x) / 2, (480 - this.Bounds.size.y) / 2);

        
    this.Bounds.point1 = m;
    this.Bounds.point2 = <800,480> - m;


    rootObject.Add( this, 0 );
    Timer.restart( 0, 1200 );
    Timer.Enabled = true;

    return;
  }

  $rect <30,270,230,310>
  var Views::Rectangle mask = null;

  $rect <30,230,230,270>
  var Core::SimpleTouchHandler touch = null;

  $rect <30,310,230,350>
  var Core::Root root = null;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,55,470,100>;
    preset String = "Logon required";
    preset Font = Resources::FontMedium;
  }

  $rect <310,220,510,260>
  object Core::Timer Timer
  {
    preset OnTrigger = Hide;
    preset Period = 1200;
  }

  $rect <340,340,540,380>
  slot Hide
  {
    /* The template just returns the given argument... */

    // Obtain access to the root object.
    //var Core::Root rootObject = GetRoot();

    // Create a new instance of some alert panel component.
    root.Remove( mask );
    root.Remove( touch );
    root.Remove( this );
    Timer.Enabled = false;

    return;

  }
}

$rect <380,260,540,300>
$output false
class TestDeviceItem : Application::DeviceItem
{
  $rect <20,20,160,60>
  inherited object FlatCheckBox0
  {
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  inherited object Image
  {
    preset Bounds = <474,5,514,45>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <375,5,465,45>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <375,10,465,40>;
    preset String = "Normal";
    preset Font = OldResources::FontVerdana18;
  }
}

$rect <1220,470,1420,510>
$output false
resource Resources::Bitmap Key2Bitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\logon40d.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <930,440,1080,480>
$output false
class LogPopup : Application::Popup
{
  $rect <880,10,1020,50>
  inherited property Bounds = <0,0,800,470>;

  $rect <540,510,680,550>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    postsignal RefreshSlot;


  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Color = #CBCBCBFF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,360,770,440>;
    preset Color = #C6C6C6FF;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <10,10,720,360>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 25;
    preset NoOfItems = 50;
    preset ItemClass = Application::LogItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <870,200,1070,240>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Application::LogItem i= (Application::LogItem)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( i == null )
      return;

    i.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );


    var int32 t = 0;
    var int32 filter = Filter;
    var string msg = "---";

    native( t, itemNo, filter, msg )
    {
      char buff[ 128 ];
      Command cmd;
      
      cmd.int0 = itemNo;
      cmd.int1 = filter;
      cmd.int2 = (int) buff;
      
      Command0( CMD_GET_LOG_LINE, &cmd );

      t = cmd.int3;

      msg = EwNewStringAnsi( buff );
    }


    switch (t )
    {
       case 4 :   i.Image.Bitmap = Application::LogAccess;
       case 1 :   i.Image.Bitmap = Application::LogEvents;
       case 5 :   i.Image.Bitmap = Application::LogFaults;
       case 6 :   i.Image.Bitmap = Application::LogFire;
       case 0 :   i.Image.Bitmap = Application::LogMisc;
       case 3 :   i.Image.Bitmap = Application::LogSettings;
       case 2 :   i.Image.Bitmap = Application::LogSystem;
       case 7 :   i.Image.Bitmap = Application::LogTest;
    }

    switch (t )
    {
       case 4 :   i.TypeText.String = "Access";
       case 1 :   i.TypeText.String = "Event";
       case 5 :   i.TypeText.String = "Fault";
       case 6 :   i.TypeText.String = "Fire";
       case 0 :   i.TypeText.String = "Misc";
       case 3 :   i.TypeText.String = "Setting";
       case 2 :   i.TypeText.String = "System";
       case 7 :   i.TypeText.String = "Test";
    }

    i.DescripText.String = msg;

                                                                                                                
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <10,10,720,360>;
    preset OnSlide = ScrollDragSlot;
  }

  $rect <880,60,1080,100>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VerticalScrollbar.Position = -VerticalList.ScrollOffset;
  }

  $rect <880,100,1080,140>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    VerticalList.ScrollOffset = -VerticalScrollbar.Position;


  }

  $rect <900,270,1100,310>
  slot Close
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <855,365,1055,405>
  slot RefreshSlot
  {
    sender; /* the method is called from the sender object */

     
    //var Application::Application app = (Application::Application) this.Parent;

                 
    var int32 filter = GetFilter();

     Filter = filter;                          

     var int32 items = 0;

     native( items, filter )
     {
        Command cmd;

        cmd.int0 = filter;

        Command0( CMD_GET_LOG_LENGTH, &cmd );
        
        items = cmd.int0;
     }
     
     
     VerticalList.NoOfItems = items;
     
     VerticalList.InvalidateItems( 0, items - 1 );
     
     VerticalScrollbar.ContentArea = items * VerticalList.ItemHeight; 

  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Bounds = <727,10,766,360>;
    preset OnScroll = ScrollPressSlot;
    preset ViewArea = 400;
    preset ContentArea = 100000;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <599,376,749,426>;
    preset OnRelease = Close;
    preset Label = "Close";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <840,500,960,540>
  method int32 GetFilter()
  {
    /* The template just returns the given argument... */

    var int32 filter = 0;

    if ( Events.Checked )   filter = filter | 2;
    if ( Faults.Checked )   filter = filter | 32;
    if ( System.Checked )   filter = filter | 4;
    if ( Fire.Checked )     filter = filter | 64;
    if ( Misc.Checked )     filter = filter | 1;
    if ( Access.Checked )   filter = filter | 16;
    if ( Settings.Checked ) filter = filter | 8;
    if ( Testing.Checked )  filter = filter | 128;

    return filter;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Events
  {
    preset Bounds = <30,360,138,400>;
    preset Checked = true;
    preset OnSwitchOn = RefreshSlot;
    preset OnSwitchOff = RefreshSlot;
    preset Label = "Events";
    preset Appearance = Application::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Faults
  {
    preset Bounds = <160,360,268,400>;
    preset Checked = true;
    preset OnSwitchOn = RefreshSlot;
    preset OnSwitchOff = RefreshSlot;
    preset Label = "Faults";
    preset Appearance = Application::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton System
  {
    preset Bounds = <290,360,398,400>;
    preset Checked = true;
    preset OnSwitchOn = RefreshSlot;
    preset OnSwitchOff = RefreshSlot;
    preset Label = "System";
    preset Appearance = Application::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Fire
  {
    preset Bounds = <430,360,538,400>;
    preset Checked = true;
    preset OnSwitchOn = RefreshSlot;
    preset OnSwitchOff = RefreshSlot;
    preset Label = "Fires";
    preset Appearance = Application::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Settings
  {
    preset Bounds = <30,400,138,440>;
    preset Checked = true;
    preset OnSwitchOn = RefreshSlot;
    preset OnSwitchOff = RefreshSlot;
    preset Label = "Settings";
    preset Appearance = Application::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Access
  {
    preset Bounds = <160,400,268,440>;
    preset Checked = true;
    preset OnSwitchOn = RefreshSlot;
    preset OnSwitchOff = RefreshSlot;
    preset Label = "Access";
    preset Appearance = Application::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Testing
  {
    preset Bounds = <290,400,398,440>;
    preset Checked = true;
    preset OnSwitchOn = RefreshSlot;
    preset OnSwitchOff = RefreshSlot;
    preset Label = "Testing";
    preset Appearance = Application::SmallCheckBoxCaption;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Misc
  {
    preset Bounds = <430,400,538,440>;
    preset Checked = true;
    preset OnSwitchOn = RefreshSlot;
    preset OnSwitchOff = RefreshSlot;
    preset Label = "Misc.";
    preset Appearance = Application::SmallCheckBoxCaption;
  }

  $rect <830,550,1030,590>
  property int32 Filter = 0;

  $rect <880,320,1080,360>
  object Core::SystemEventHandler SystemEventHandler2
  {
    preset OnEvent = RefreshSlot;
    preset Event = Application::Devices.LogListChangeEvent;
  }

  $reorder Rectangle9 2
  $reorder VerticalList 2
  $reorder OnLoadItem 2
  $reorder SlideTouchHandler 2
  $reorder ScrollDragSlot 2
  $reorder ScrollPressSlot 2
  $reorder Close 2
  $reorder RefreshSlot 2
  $reorder VerticalScrollbar 2
  $reorder PushButton 2
}

$rect <1080,440,1230,480>
$output false
class LogItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,605,25>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop];
    preset Bounds = <0,0,30,25>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text DescripText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <95,0,610,25>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "012345678901234567890123456789012345678900123456789012345678901234567890123456789001234567890123456789012345678901234567890";
    preset Font = Application::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TypeText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <37,0,100,25>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Type";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }
}

$rect <860,260,1010,300>
$output false
class LEDPopup : Application::Popup
{
  $rect <30,280,170,320>
  inherited property Bounds = <0,0,370,210>;

  $rect <30,330,170,370>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    ToggleButton.Checked = false;

  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Color = #B1B1B1FF;
  }

  $rect <720,80,920,120>
  property int32 InputAction = 0;

  $rect <330,320,530,360>
  slot Close
  {
    Hide();

  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <28,30,220,80>;
    preset OnSwitchOn = Change;
    preset OnSwitchOff = Change;
    preset LabelOn = "LEDs all On";
    preset LabelOff = "LEDs all off";
    preset Label = "LED's";
    preset Appearance = Application::NotmalToggleButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <200,120,330,170>;
    preset OnRelease = Close;
    preset Label = "Close";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <237,39,328,72>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "All Off";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <400,60,600,100>
  slot Change
  {
    sender; /* the method is called from the sender object */

    if (  ToggleButton.Checked )
    {
      Text.String = "All On";
      native
      {
        Command cmd;
        cmd.int0 = 1;
         Command0( CMD_LEDS_TEST, &cmd ); 
       }
    }
    else
    {
      Text.String= "All Off";
      native
      {
         Command cmd;
         cmd.int0 = 0;
         Command0( CMD_LEDS_TEST, &cmd ); 
      }
    }
       
  }
}

$rect <710,260,860,300>
$output false
class WeeklyPopup : Application::Popup
{
  $rect <30,360,170,400>
  inherited property Bounds = <0,0,400,320>;

  $rect <20,20,160,60>
  object Flat::Gauge Gauge
  {
    preset Bounds = <120,93,270,213>;
    preset CurrentValue = 5;
    preset Caption = "minutes";
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <70,30,290,70>;
    preset String = "Time left in test mode";
    preset Font = OldResources::FontVerdana18;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton
  {
    preset Bounds = <130,250,250,280>;
    preset Caption = "Finish";
  }
}

$rect <0,440,140,480>
$output false
class SystemPage : Core::Group
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <2,0,550,350>;
    preset Color = #E5E5E5FF;
  }

  $rect <0,550,200,590>
  inherited property Bounds = <0,0,785,350>;

  $rect <0,410,200,450>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    VertScrollbar.ViewArea = 360;

    var int32 size = 0;
    var Core::View   v = (Core::View) first;

    while ( v != null )
    {
        var Core::Group g = (Core::Group) v;
         
        if ( g != null )
        {
            if ( g.Embedded && g.Visible ) 
            {
                size = size + g.Bounds.h;
            }
        }
        v = v.next;
    }

    //Outline.GetViewAtIndex( Outline.CountViews()-1 );

    VertScrollbar.ContentArea = size;


    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,460,200,500>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var int16 temp = 0;
    var int16 on_charge = 0;
    var int16 on_load = 0;
    var int16 off_load = 0;
    var int16 resistance = 0;
    var int16 status = 0;
    var int32 gsm_signal = -1;
    var bool up_to_date = false;
    var int32 vbacklight = 0;


    native( temp, gsm_signal, on_charge, on_load, off_load, resistance, status, up_to_date )
    {
        Command c;


        Command0( CMD_GET_PSU_STATUS, &c );

        up_to_date  = c.short6;

        temp        = c.short0;
        on_charge   = c.short1;
        on_load     = c.short2;
        off_load    = c.short3;
        resistance  = c.short4;          
        status      = c.short5;

        Command0( CMD_GSM_SIGNAL_QUALITY, &c );

        gsm_signal = c.int0;

        Command0( CMD_GET_BACKLIGHT_VOLTAGE, &c );

        vbacklight = c.int0;
    }

    var string fw = string( (float)fwversion/100.0, 0, 2 );
    var string os = string( (float)osversion/100.0, 0, 2 );

    var string v = "{lay200,*}{col}{fnt2}{clr1}Firmware version{col}{fnt3}{clr1}"+fw+"{end}{lay200,*}{col}{fnt2}{clr1}Cygnus OS version{col}{fnt3}{clr1}"+os+"{end}\n";

    AttrText.String = v;

    var string s = ""; 

    if ( !up_to_date )
    {
        s = "{lay200,*}{col}{fnt2}{clr1}PSU Temperature{col}{fnt3}{clr1}(unknown){end}" +  
              "{lay200,*}{col}{fnt2}{clr1}Output Voltage{col}{fnt3}{clr1}(unknown){end}" + 
              "{lay200,*}{col}{fnt2}{clr1}Loaded Voltage{col}{fnt3}{clr1}(unknown){end}" + 
              "{lay200,*}{col}{fnt2}{clr1}Unloaded Voltage{col}{fnt3}{clr1}(unknown){end}" + 
              "{lay200,*}{col}{fnt2}{clr1}Battery resistance{col}{fnt3}{clr1}(unknown){end}" +
              "{lay200,*}{col}{fnt2}{clr1}Battery status{col}{fnt3}{clr1}Comms lost{end}";
       
    }
    else 
    {
      var string st = "";
      switch ( status )
      {
          case 0 : st = "Good";
          case 1 : st = "Low";
          case 2 : st = "Critical";
          case 3 : st = "High resistance";
          case 4 : st = "Charge fail";
      } 
        
    var string off_load_str;
    var string resistance_str;

    if ( resistance == 0 )
    {
     off_load_str = "(undetermined)";
     resistance_str = "(undetermined)";
     }
     else
     {
       off_load_str = string( (float)off_load/1000.0, 0, 2 ) + "V";
       resistance_str =  string( resistance ) + "m\U03a9";
     }

      s = "{lay200,*}{col}{fnt2}{clr1}PSU Temperature{col}{fnt3}{clr1}" +   string( (float)temp / 1000.0, 0, 2 ) + "C{end}" +  
              "{lay200,*}{col}{fnt2}{clr1}Output Voltage{col}{fnt3}{clr1}" + string( (float)on_charge/1000.0, 0, 2 ) + "V{end}" + 
              "{lay200,*}{col}{fnt2}{clr1}Loaded Voltage{col}{fnt3}{clr1}" + string( (float)on_load/1000.0, 0, 2 ) + "V{end}" + 
              "{lay200,*}{col}{fnt2}{clr1}Unloaded Voltage{col}{fnt3}{clr1}" + off_load_str + "{end}" +
              "{lay200,*}{col}{fnt2}{clr1}Battery resistance{col}{fnt3}{clr1}" + resistance_str + "{end}" +
              "{lay200,*}{col}{fnt2}{clr1}Battery status{col}{fnt3}{clr1}" + st + "{end}";

     
    }

    var string gsm = string(-115+gsm_signal*4) + "dBm"; 


    if ( gsm_signal == 0 )
    {  
        gsm = "\U2264" + gsm;
    }
    else if ( gsm_signal == 31 ) 
    {
        gsm = "\U2265" + gsm;
    }
    else if ( gsm_signal == 99 )
    {
        gsm = "(unknown)";
    }
    else if ( gsm_signal == -1 )
    {
        gsm = "waiting...";
    }
    s = s + "{par}\n{lay200,*}{col}{fnt2}{clr1}GSM Signal{col}{fnt3}{clr1}" + gsm + "{end}";        

    var string voltage = string( (float)vbacklight/100.0, 0, 2 );

    s = s + "{par}\n{lay200,*}{col}{fnt2}{clr1}Backlight voltage{col}{fnt3}{clr1}" + voltage + "V{end}";      
                                  
    AttrText1.String = s;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <660,440,800,480>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    var int32 fw_version = 100;
    var int32 os_version = 100;

    native( fw_version, os_version )
    {
        Command c;

        Command0( CMD_GET_VERSION_NUMBERS, &c );

        fw_version = c.int0;
        os_version = c.int1;
    }
    osversion = os_version;
    fwversion = fw_version;


  }

  $rect <390,390,590,430>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -Outline.ScrollOffset.y;
  }

  $rect <390,430,590,470>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    Outline.ScrollOffset.y = -VertScrollbar.Position;


  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <0,0,550,350>;
    preset SlideHandler = SlideTouchHandler;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,550,350>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2C2C2CFF;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <790,0,990,40>
  slot ViewLog
  {
    var Application::Popup pop = new Application::LogPopup;

    pop.Show( GetRoot() );

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <800,120,1000,160>
  slot Reset
  {
    var Application::ConfirmPopup popup = new Application::ConfirmPopup;

      popup.Text1.String = "WARNING! This will CLEAR ALL DATA and is irreversible. Proceed at your peril.";

      popup.ShowThen( GetRoot(), null );


  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <790,60,990,100>
  slot Update
  {
    var Application::Popup pop = new Application::UpdatePopup;

    pop.Show( GetRoot() );

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <810,190,1010,230>
  slot Calibrate
  {
    var Application::Popup pop = new Application::CalibratePopup;

    pop.Show( GetRoot() );



  }

  $rect <20,20,160,60>
  object Views::AttrText AttrText
  {
    preset Bounds = <10,10,510,60>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertTop];
    preset String = "{lay200,*}{col}{fnt2}{clr1}Firmware version{col}{fnt3}{clr1}1.00{end}{lay200,*}{col}{fnt2}{clr1}Cygnus OS version{col}{fnt3}{clr1}1.00{end}\n";
    preset AttrSet = AttrSet;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Views::AttrText AttrText1
  {
    preset Bounds = <10,71,380,304>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertTop];
    preset String = "{fnt2}{clr1}Firmware version 1.00\nCygwin OS version 1.00\nLast firmware update 1977\n";
    preset AttrSet = AttrSet;
    preset Embedded = true;
  }

  $rect <810,260,1010,300>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font3 = Application::FontVerdanaProSemiBold20;
    preset Font2 = OldResources::FontVerdana18;
    preset Font1 = Application::FontVerdana16;
    preset Font0 = Application::FontVerdana14;
    preset Color1 = #000000FF;
  }

  $rect <830,320,1030,360>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateSlot;
    preset Enabled = false;
  }

  $rect <840,360,1040,400>
  slot UpdateSlot
  {
    sender; /* the method is called from the sender object */

    InvalidateViewState();

  }

  $rect <20,350,260,390>
  object WidgetSet::PushButtonConfig PushButtonConfig
  {
    preset LabelColorDefault = #000000FF;
    preset IconTintDefault = #6F9538FF;
    preset LabelFont = Application::FontVerdanaProSemiBold20;
    preset FaceTintActive = #FF464DFF;
    preset FaceTintFocused = #D49DB4FF;
    preset FaceTintDisabled = #404040FF;
    preset FaceTintDefault = #6464FBFF;
    preset FaceFrameActive = 3;
    preset FaceFrameDisabled = 2;
    preset FaceFrameDefault = 1;
    preset FaceActive = WidgetSet::PushButtonSmall;
    preset FaceFocused = WidgetSet::PushButtonLarge;
    preset FaceDisabled = WidgetSet::PushButtonLarge;
    preset FaceDefault = WidgetSet::PushButtonSmall;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <550,0,600,350>;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,550,350>;
    preset OnSlide = ScrollDragSlot;
    preset SlideHorz = false;
  }

  $rect <1040,10,1240,50>
  property int16 osversion = 0;

  $rect <1050,50,1250,90>
  property int16 fwversion = 0;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <615,0,785,50>;
    preset OnRelease = ViewLog;
    preset Label = "View Log";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <615,60,785,110>;
    preset OnRelease = null;
    preset Label = "Calibrate Touch";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <615,120,785,170>;
    preset OnRelease = null;
    preset Label = "Factory Reset";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <615,180,785,230>;
    preset OnRelease = null;
    preset Label = "System Restore";
    preset Appearance = Application::NormalPushButton;
  }

  $reorder Rectangle 76
}

$rect <140,440,290,480>
$output false
class MemTestPopup : Application::Popup
{
  $rect <10,260,150,300>
  inherited property Bounds = <0,0,540,240>;

  $rect <20,20,160,60>
  object Steel::HorzBar HorzBar0
  {
    preset Bounds = <30,85,480,125>;
    preset Type = Steel::LedType.Blue;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton
  {
    preset Bounds = <200,154,320,184>;
    preset OnAction = CloseSlot;
    preset Caption = "Close";
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <38,43,138,73>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Checking...";
    preset Font = OldResources::FontVerdana18;
  }

  $rect <180,280,380,320>
  slot CloseSlot
  {
    sender; /* the method is called from the sender object */

    Hide();

  }
}

$rect <280,440,430,480>
$output false
class UpdatePopup : Application::Popup
{
  $rect <0,400,140,440>
  inherited property Bounds = <0,0,430,370>;

  $rect <20,20,160,60>
  object XFlat::AnalogDisplay AnalogDisplay
  {
    preset Bounds = <70,10,330,270>;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton
  {
    preset Bounds = <140,290,260,320>;
    preset OnAction = CancelSlot;
    preset Caption = "Cancel";
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <20,20,120,50>;
    preset String = "Updating..";
    preset Font = OldResources::FontVerdana18;
  }

  $rect <150,390,350,430>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

    Hide();


  }
}

$rect <430,440,560,480>
$output false
class CalibratePopup : Application::Popup
{
  $rect <710,460,850,500>
  inherited property Bounds = <0,0,800,480>;

  $rect <840,10,980,50>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    Image0.Visible = true;
    Image1.Visible = false;
    Image2.Visible = false;
    Image3.Visible = false;



    order = 0;
    var int32 n;

    X[0] = Image0.Bounds.center;
    X[1] = Image1.Bounds.center;
    X[2] = Image2.Bounds.center;
    X[3] = Image3.Bounds.center;
     



  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Bounds = <10,10,650,430>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <310,125,475,155>;
    preset String = "Tap on each X";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  object Views::Image Image0
  {
    preset Bounds = <10,10,60,60>;
    preset Bitmap = Application::XBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <720,10,770,60>;
    preset Bitmap = Application::XBitmap;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <10,400,60,450>;
    preset Bitmap = Application::XBitmap;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image Image3
  {
    preset Bounds = <720,400,770,450>;
    preset Bitmap = Application::XBitmap;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <800,0>;
    preset Point2 = <800,480>;
    preset Point1 = <0,480>;
    preset OnPress = TouchSlot;
  }

  $rect <870,100,1070,140>
  slot TouchSlot
  {
    sender; /* the method is called from the sender object */

    var uint16 x;
    var uint16 y;

    native ( x, y )
    {
        Command cmd;

        Command0( CMD_GET_LAST_RAW_TOUCH, &cmd );

        x = cmd.ushort0;
        y = cmd.ushort1; 
    }

    if ( order < 4 )
    {
      coord[ order ].x = x;
      coord[ order ].y = y;
    }

    switch( order )
    {
        case 0 :
        {
            Image0.Visible = false;
            Image1.Visible = true;
        }
        case 1:
        {
            Image1.Visible = false;
            Image2.Visible = true;
        }
        case 2 :
        {
            Image2.Visible = false;
            Image3.Visible = true;
        }
        case 3:
        {
           Image3.Visible = false;
     
            var uint16 xmin = (uint16) ( coord[0].x + coord[2].x ) / 2;
            var uint16 ymin = (uint16) ( coord[0].y + coord[1].y ) / 2; 
            var uint16 xmax = (uint16) ( coord[1].x + coord[3].x ) / 2;  
            var uint16 ymax = (uint16) ( coord[2].y + coord[3].y ) / 2;  

            var uint16 x_xmin = (uint16) X[0].x; 
            var uint16 x_ymin = (uint16) X[0].y; 
            var uint16 x_xmax = (uint16) X[3].x; 
            var uint16 x_ymax = (uint16) X[3].y; 

            native ( xmin, ymin, xmax, ymax, x_xmin, x_ymin, x_xmax, x_ymax )
            {
                 Command8U( CMD_SET_CALIB_VALUES, xmin, ymin, xmax, ymax, x_xmin, x_ymin, x_xmax, x_ymax );
            }
            Text.String = "Now tap on targets.";
            TargetImage1.Visible = true;
         }
         
          case 4, 5, 6:
          {
             if (order == 4 )
             {            
                 TargetImage2.Visible = true;
              }
              if ( order == 5 )
              {
                  TargetImage3.Visible = true;
               }
               if ( order == 6 )
               {   
                  ActionButton.Visible = true;
                  ActionButton.Enabled = true;
              }

              h[ order-4] = new Views::Line;
              v[ order-4] = new Views::Line;

              h[ order-4].Point1 = point( 0, SimpleTouchHandler.CurrentPos.y );
              h[ order-4].Point2 = point( 800, SimpleTouchHandler.CurrentPos.y );
              v[ order-4].Point1 = point( SimpleTouchHandler.CurrentPos.x, 0 );
              v[ order-4].Point2 = point( SimpleTouchHandler.CurrentPos.x, 480 );

              GetRoot().Add( h[ order-4], 0 );
              GetRoot().Add( v[ order-4], 0 );

          }
          default: signal ProceedSlot;
         
        
    }

    order=order + 1;
  }

  $rect <820,220,1020,260>
  var int32 order = 0;

  $rect <850,320,1050,360>
  array point coord[ 4 ];

  $rect <850,365,975,435>
  array point X[ 4 ];

  $rect <845,150,930,195>
  array Views::Line h[ 4 ];

  $rect <920,150,1015,190>
  array Views::Line v[ 4 ];

  $rect <20,20,160,60>
  object Views::Image TargetImage1
  {
    preset Bounds = <115,50,243,178>;
    preset Bitmap = Application::TargetBitmap;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image TargetImage2
  {
    preset Bounds = <300,290,428,418>;
    preset Bitmap = Application::TargetBitmap;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image TargetImage3
  {
    preset Bounds = <610,170,738,298>;
    preset Bitmap = Application::TargetBitmap;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton
  {
    preset Bounds = <330,200,470,240>;
    preset Enabled = false;
    preset Visible = false;
    preset OnAction = ProceedSlot;
    preset Caption = "Proceed";
  }

  $rect <815,50,1015,90>
  slot ProceedSlot
  {
    sender; /* the method is called from the sender object */

     var int32 n;
              for( n = 0; n < 3; n=n+1 )
              {
                   GetRoot().Remove( h[n] );
                   GetRoot().Remove( v[n] );
              }
              ActionButton.Visible = false;
              ActionButton.Enabled = false;
               TargetImage1.Visible = false;
               TargetImage2.Visible = false;
               TargetImage3.Visible = false;

              Hide();

  }
}

$rect <10,540,110,580>
$output false
class Modify : Core::Group
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <2,0,550,350>;
    preset Color = #353535FF;
    preset AlphaBlended = false;
    preset Visible = false;
  }

  $rect <0,550,200,590>
  inherited property Bounds = <0,0,780,350>;

  $rect <0,410,200,450>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );


  }

  $rect <0,500,200,540>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*
      var int32 numZones = 32;

       native( numZones )
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }
       VerticalList.NoOfItems = numZones;
       VerticalList.InvalidateItems( 0, numZones );

      VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;
      VertScrollbar.ViewArea = VerticalList.Bounds.h;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <790,380,930,420>
  inherited method Init()
  {
    // TO DO: Write your code here ...

    signal onEvent1;

  }

  $rect <250,380,390,420>
  inherited property AlphaBlended = true;

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <490,360,630,400>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    var Core::VerticalList vlist = (Core::VerticalList) sender;

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = vlist.Item;

     
    var Application::ZoneToggle item = (Application::ZoneToggle) vlist.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    //var Application::ModifyZoneItem currentZone = null;

    var uint8 curZone = 0;


       var int32 i = 0;
       var int32 numZones = 2;

       native( numZones ) 
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }
        numZones = numZones;  // +panel i/o
       
       while ( numZones > 0 )
       {
          var int32 numdevs = 4; 
          native( numdevs, curZone )
          {  
            Command cmd;
          
            cmd.int0 = curZone;
            Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
            numdevs = cmd.int0;
          }

          if ( numdevs > 0 )
          {
            numZones = numZones - 1;
            if ( itemNo == i )
            {
              item.ZoneNum = curZone;
              item.isDevice = false;
              item.isZone = true;
        
              item.InvalidateViewState();
              return;
            }
            else
            {
               i = i + 1;
            }
            if ( zoneExpanded[ curZone ] )
            {                    
              if ( itemNo < numdevs + i )
              {
                var int32 dev = itemNo - i;
                var string location = "????";
                var uint16 unitno = dev + 1;
                var uint8 zoneno = curZone;
                
                native( dev, curZone, location, unitno, zoneno )
                {  
                  Command cmd;
                
                  cmd.int0 = curZone;
                  cmd.int1 = dev;
                  Command0( CMD_GET_DEV_IN_ZONE, &cmd );
                  DeviceConfig* dev = (DeviceConfig*) cmd.int0;

                  if ( dev != NULL )
                  {
                    location = EwNewStringAnsi( dev->location );
                    unitno = dev->unit;
                    zoneno = dev->zone;
                  }
                } 

                item.isDevice = true;
                item.isZone = false;
                item.UnitNum = unitno;
                item.ZoneNum = zoneno;
                item.DescriptionText.String = location;

                item.InvalidateViewState(); 
                return;
              }
              else
              {
                 i = i + numdevs;
              }
           }
         }
         curZone = curZone + 1;
       }


        // EEK shouldnt be here
        item.isDevice = false;
        item.isZone = false;

       
                      
        vlist.NoOfItems = i;

        native
        {
         while ( 1 );
        }
     
     

  }

  $rect <810,60,1010,100>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -VerticalList.ScrollOffset;
  }

  $rect <810,100,1010,140>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    VerticalList.ScrollOffset = -VertScrollbar.Position;
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems );
    VerticalList.InvalidateViewState();



  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,554,350>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2C2C2CFF;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <551,0,600,350>;
    preset OnScroll = ScrollPressSlot;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <610,0,780,50>;
    preset Label = "Edit Panel";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <2,2,552,348>;
    preset OnLoadItem = OnLoadItem;
    preset Endless = false;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 45;
    preset NoOfItems = 3;
    preset ItemClass = Application::ZoneToggle;
  }

  $rect <800,270,1000,310>
  array bool zoneExpanded[ 97 ];

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <610,60,780,110>;
    preset Label = "Add Device";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <957,330,1187,370>
  object Core::SystemEventHandler SiteLoadedEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = Application::Devices.SiteLoadedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <960,365,1110,405>
  slot onEvent1
  {
     var int32 numZones = 2;

       native( numZones )
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }

    var int32 i = 0;
     
    for( i = 0; i < 97; i=i + 1 )
    {
      zoneExpanded[ i] = false;
    }
      

       VerticalList.NoOfItems = numZones ;
       VerticalList.InvalidateItems( 0, numZones - 1 );
        

      VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;
      VertScrollbar.ViewArea = VerticalList.Bounds.h;
      VertScrollbar.InvalidateViewState();


  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <60,0,420,350>;
    preset OnSlide = ScrollDragSlot;
    preset SlideHorz = false;
  }

  $reorder Rectangle 76
}

$rect <90,540,260,580>
$output false
class ModifyDeviceItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

     

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <70,80,270,120>
  property int32 UnitNum = 0;

  $rect <20,20,160,60>
  object Views::Text UnitNumberText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <6,2,146,19>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Application::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <5,16,420,41>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Hallway, Front building 2";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <505,1,545,41>;
    preset Bitmap = Application::FireAlarmBitmap;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <430,5,500,35>;
    preset OnAction = EditSlot;
    preset Caption = "Edit";
  }

  $rect <570,0,770,40>
  slot EditSlot
  {
    sender; /* the method is called from the sender object */

    var Application::ModifyPopup p = new Application::ModifyPopup;

    var Core::Root r = GetRoot();

    p.zone = ZoneNum;
    p.unitnum = UnitNum;
    p.ZoneText.String = string( ZoneNum );


    p.Show( GetRoot() );

  }

  $rect <70,130,270,170>
  property int32 ZoneNum = 0;
}

$rect <250,540,420,580>
$output false
class ModifyZoneItem : Core::Group
{
  $rect <20,460,220,500>
  inherited property Bounds = <0,0,550,40>;

  $rect <0,350,200,390>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,310,200,350>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
           


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <7,5,37,35>;
    preset Bitmap = Application::ExpandBitmap;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <50,0>;
    preset Point2 = <50,40>;
    preset Point1 = <0,40>;
    preset OnPress = ToggleHandler;
  }

  $rect <670,180,870,220>
  slot ToggleHandler
  {
    sender; /* the method is called from the sender object */

    var Application::Modify modify = (Application::Modify) Owner.Owner.Owner;

    modify.zoneExpanded[ ZoneNum ] = !modify.zoneExpanded[ ZoneNum ];

    var Core::VerticalList lst = (Core::VerticalList) this.Owner.Owner;

      var int32 devs = 4;
      var int32 zone = ZoneNum;

      native( devs, zone )
      {
        Command cmd;
        cmd.int0 = zone;

        Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
        devs = cmd.int0;
      }


    if ( modify.zoneExpanded[ ZoneNum ] )
    {
      lst.NoOfItems = lst.NoOfItems + devs;
    }
    else
    {
      lst.NoOfItems = lst.NoOfItems - devs;
    }


    lst.InvalidateItems( 0, lst.NoOfItems );

    lst.InvalidateViewState();

     modify.VertScrollbar.ContentArea = lst.NoOfItems * lst.ItemHeight;
      modify.VertScrollbar.ViewArea = lst.Bounds.h;
     modify.VertScrollbar.InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <60,6,160,36>;
    preset String = "Zone 1";
    preset Font = Templates::DefaultFontPicker;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Image 6
  $reorder SimpleTouchHandler 6
  $reorder ToggleHandler 6
  $reorder Enabled 5
}

$rect <850,540,1050,580>
$output false
class OutputPop : Core::Group
{
  $rect <230,580,430,620>
  inherited property Bounds = <0,0,800,480>;

  $rect <20,600,220,640>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <450,590,650,630>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // The property 'Bounds' defines the position and the size of the view in the coordinates \
  // of the corresponding @Owner.
  $rect <140,680,340,720>
  property rect Bounds1 = <0,0,550,310>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <770,10,800,450>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight];
    preset Bounds = <770,450,800,480>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, ResizeHorz];
    preset Bounds = <10,450,770,480>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #191919BC;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,9,770,450>;
    preset Color = #6B6B6BFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <770,0,800,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle5
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <0,450,10,480>;
    preset ColorBL = #19191900;
    preset ColorBR = #19191900;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle6
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, ResizeHorz];
    preset Bounds = <10,0,770,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle7
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, ResizeHorz];
    preset Bounds = <0,0,10,10>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle8
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <0,10,10,450>;
    preset ColorBL = #19191900;
    preset ColorBR = #191919BC;
    preset ColorTR = #191919BC;
    preset ColorTL = #19191900;
  }

  $rect <20,20,160,60>
  object Application::Writable Writable
  {
    preset Bounds = <20,189,575,224>;
    preset Focus = null;
  }

  $rect <470,470,670,510>
  property int32 InputAction = 0;

  $rect <470,510,670,550>
  onset InputAction
  {
    // The value doesn't change - nothing to do.
    if ( pure InputAction == value )
      return;

    // Remember the property's new value.
    pure InputAction = 0;//value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <470,550,670,590>
  onget InputAction
  {
    return pure InputAction;
  }

  $rect <260,510,460,550>
  slot ChangeInputAction
  {
    sender; /* the method is called from the sender object */


     // var Application::OutputPopup p = (Application::OutputPopup) Owner.Focus;

    p.Writable.TextEditor.String =  ((Flat::RadioButton)sender).Caption;
    ((Flat::RadioButton)sender).Selected = true;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <20,48,219,78>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "1st Delay (0 secs)";
    preset Font = Resources::FontMedium;
  }

  $rect <10,515,210,555>
  slot DelaySlot
  {
    sender; /* the method is called from the sender object */

    var int32 i = HorzBarSlider.CurrentValue;
          
    if ( i < 6 )
    {
        Text.String = "1st Delay (" + string( i*10) + " secs)";
    }
    else
    {
        var float f = ( ((float)i - 6.0) * 0.5 ) + 1.0;
        Text.String = "1st Delay (" + string( f ) + " mins)";
    }

  }

  $rect <20,20,160,60>
  object XFlat::HorzBarSlider HorzBarSlider
  {
    preset Bounds = <233,52,460,93>;
    preset MaxValue = 14;
    preset CurrentValue = 0;
    preset OnChange = DelaySlot;
    preset MinIcon = null;
    preset MaxIcon = null;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <705,272,765,307>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #DBDBDBFF;
  }

  $rect <20,20,160,60>
  object Flat::CheckBox FireCheckBox
  {
    preset Bounds = <16,13,101,43>;
    preset Caption = "Fire";
  }

  $rect <20,20,160,60>
  object Flat::CheckBox EvacuateCheckBox
  {
    preset Bounds = <505,15,645,45>;
    preset Caption = "Evacuate";
  }

  $rect <20,20,160,60>
  object Flat::CheckBox AlertCheckBox
  {
    preset Bounds = <655,16,763,46>;
    preset Caption = "Alert";
  }

  $rect <20,20,160,60>
  object Flat::CheckBox TechAlarmCheckBox
  {
    preset Bounds = <109,13,265,43>;
    preset Caption = "Tech. Alarm";
  }

  $rect <20,20,160,60>
  object Flat::CheckBox FaultCheckBox
  {
    preset Bounds = <655,54,762,84>;
    preset Caption = "Fault";
  }

  $rect <20,20,160,60>
  object Flat::CheckBox SecurityCheckBox
  {
    preset Bounds = <504,52,644,82>;
    preset Caption = "Security";
  }

  $rect <20,20,160,60>
  object Flat::CheckBox AckSilenceAlarmCheckBox
  {
    preset Bounds = <17,129,247,159>;
    preset Caption = "Silenceable Ack.";
  }

  $rect <20,20,160,60>
  object Flat::HorzSlider HorzSlider
  {
    preset Bounds = <450,135,610,176>;
    preset MinValue = 1;
    preset MaxValue = 4;
    preset CurrentValue = 3;
    preset OnChange = VolumeSlot;
    preset ShowCurrent = false;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <257,128,427,163>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Volume (Medium)";
    preset Font = Resources::FontMedium;
  }

  $rect <250,470,450,510>
  slot VolumeSlot
  {
    sender; /* the method is called from the sender object */


    var int32 i = HorzSlider.CurrentValue;
          
    if ( i == 1 )
    {
        Text3.String = "Volume (Lowest)"; 
    }
    else if ( i == 2 ) 
    {
        Text3.String = "Volume (Low)";
    }
    else if ( i == 3 ) 
    {
        Text3.String = "Volume (Medium)";
    }
    else 
    {
        Text3.String = "Volume (High)";
    }

  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Bounds = <18,85,223,118>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "2nd Delay (0 secs)";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object XFlat::HorzBarSlider HorzBarSlider1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <233,93,457,134>;
    preset MaxValue = 14;
    preset CurrentValue = 0;
    preset OnChange = DelaySlot1;
    preset MinIcon = null;
    preset MaxIcon = null;
  }

  $rect <20,20,160,60>
  object Flat::CheckBox FirstAidCheckBox
  {
    preset Bounds = <505,89,645,119>;
    preset Caption = "First Aid";
  }

  $rect <20,20,160,60>
  object Flat::CheckBox TestCheckBox
  {
    preset Bounds = <655,90,760,120>;
    preset Caption = "Test";
  }

  $rect <20,20,160,60>
  object Flat::CheckBox InvertedCheckBox
  {
    preset Bounds = <293,13,473,46>;
    preset Caption = "Inverted Input";
  }

  $rect <10,550,210,590>
  slot DelaySlot1
  {
    sender; /* the method is called from the sender object */

    var int32 i = HorzBarSlider1.CurrentValue;
          
    if ( i < 6 )
    {
        Text4.String = "2d Delay (" + string( i*10) + " secs)";
    }
    else
    {
        var float f = ( ((float)i - 6.0) * 0.5 ) + 1.0;
        Text4.String = "2nd Delay (" + string( f ) + " mins)";
    }

  }

  $rect <260,510,460,550>
  slot ChangeInputAction1
  {
    sender; /* the method is called from the sender object */


     // var Application::OutputPopup p = (Application::OutputPopup) Owner.Focus;

    p.Writable.TextEditor.String =  ((Flat::RadioButton)sender).Caption;
    ((Flat::RadioButton)sender).Selected = true;
  }

  $rect <20,20,160,60>
  object Application::MattsKeyboard MattsKeyboard
  {
    preset Bounds = <20,233,578,441>;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <21,164,151,190>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Description";
    preset Font = OldResources::FontVerdana18;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton
  {
    preset Bounds = <492,405,627,440>;
    preset Caption = "Proceed";
  }

  $rect <20,20,160,60>
  object Flat::VertSlider VertSlider
  {
    preset Bounds = <635,137,718,437>;
    preset MinValue = 1;
    preset MaxValue = 32;
    preset CurrentValue = 1;
  }
}

// This component implements a virtual keyboard.
$rect <330,620,530,660>
$output false
class AlphaNumKeyboard : Templates::AlphaNumKeyboard
{
  $rect <250,370,450,410>
  inherited property Bounds = <0,0,470,170>;

  $rect <480,250,680,290>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the affected keyboard.
    //
    // isKeyView --> the 'text' or 'image' view representing the pressed key.
    // isPressed --> the affected key should appear pressed.
    //
    var Core::View isKeyView = null;
    var bool       isPressed = ( TouchHandler.Down && TouchHandler.Inside ) || 
                                 FlashTimer.Enabled;

    // Search for the view representing the key at the recent touch position.
    // Do this however only when the position is valid - it lies inside the
    // area where keys are found (here the area of the TouchHandler) and the
    // key should appear pressed (isPressed == true)
    if ( isPressed && ( recentPosition == TouchHandler.GetExtent()))
      isKeyView = FindViewAtPosition( null, recentPosition, Core::ViewState[]);

    /*
       In this template, the keys are represented by simple 'text' and 'image'
       views. Any other view is considered as not corresponding to a key. Thus
       ignore every view, which is not an instance of 'text' or 'image'.
     
       TO DO:

       If you are using other views (not image nor text) to represent the keys,
       adapt the object runtime cast operations in the condition below to react
       on your particular views only. After this condition, 'isKeyView' should
       be either 'null' if the user is not pressing a key or it should refer to
       the view which represents the affected key.
    */

    if (((Views::Text)isKeyView == null ) && ((Views::Image)isKeyView == null ))
      isKeyView = null;

    /*

      TO DO:

      Depending on your keyboard design, you have surely added some new views
      to your keyboard. In the below code you should update the properties of
      these views. For example, when the user drags the finger between two keys
      one key should appear pressed while the other released.

      Whether the user has pressed/released a key can be estimated by comparing
      the variable 'isKeyView' with 'keyView'. If they differ, the user has
      pressed/released a key.

        if ( isKeyView != keyView )
          ...

      In practice, the variable 'isKeyView' represents the just pressed key.
      Your implementation should thus ensure, that the affected key appears
      pressed. If the user is not pressing any key, the variable is 'null'.

      The variable 'keyView' represents the key pressed in the preceding
      interaction. This key has thus to appear released. If there was no key
      pressed, the variable is 'null'.

      In the simplest case you modify the properties of the affected views, so
      they reflect their new state. Please note, the variables 'isKeyView' and
      'keyView' are declared with the generic Core::View class. In order to
      modify view specific properties you have to apply an object runtime cast
      operation on them. For example, if you are using 'text' views to represent
      keys, cast the variable to (Views::Text).

        if ( isKeyView != null )
          ((Views::Text)isKeyView).Color = color for a pressed key

        if ( keyView != null )
          ((Views::Text)keyView).Color = color for a released key

      Or you use, as demonstrated below, another views to highlight the area
      occupied by the affected key. For example, arrange some 'border' view
      to appear at the position of the pressed key with additional 5 pixel 
      padding:

        if ( isKeyView != null )
          BorderView.Bounds = isKeyView.GetExtent() * <5,5>;

      HINT:

      Instead of instantly alternate the views properties you can also start
      here effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the keyboard
      (e.g. 'isKeyView') with its preceding state (e.g. variable 'keyView').

      Assuming you have already added to your keyboard component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image lying behind the pressed key. Then following is 
      sufficient to trigger the animation:

        if (( isKeyView != null ) && ( keyView == null ))
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if (( isKeyView == null ) && ( keyView != null ))
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    // Detect a state alternation when the user presses a new or releases a
    // previously pressed key.
    if ( isKeyView != keyView )
    {
      var Views::Text isTextKeyView = (Views::Text)isKeyView;
      var Views::Text textKeyView   = (Views::Text)keyView;

      // If the user is actually pressing a key, arrange the background view
      // just behind the affected key view so it appears selected. If no key
      // is pressed, the background should disappear.
      if ( isKeyView != null )
      {
        Highlight.Bounds  = isKeyView.GetExtent();
        Highlight.Visible = true;
      }
      else
        Highlight.Visible = false;

      // If the user has pressed a key represented by a 'text' view, change the
      // color of the text to appear highlighted.
      if ( isTextKeyView != null )
        isTextKeyView.Color = #FFFFFFFF;

      // If the user has released a key represented by a 'text' view, restore
      // the color of the text.
      if ( textKeyView != null )
        textKeyView.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    keyView = isKeyView;
  }

  $rect <710,290,910,330>
  inherited method Init()
  {
    // Just at the creation time of the virtual keyboard instance
    // load the default keyboard layout.
    loadLayoutFromString( layoutShiftOff );
  }

  // To do:
  // 
  // - Adjust the visible size of your keyboard (the thick blue border). This will \
  // be the keyboard's default size.
  // - Resize and arrange the member 'TouchHandler' so it covers the area where you \
  // intend to place the keys.
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your keyboard.
  // - In this template, the individual keys are represented by text views 'TextKey01' \
  // .. 'TextKey47'.
  // - Special keys like the 'clear', 'enter' or 'shift' key are represented by image \
  // views 'ImageKeyClear', 'ImageKeyEnter', etc.
  // - The area for the 'space' key is displayed by a 'border' view 'AreaKeySpace'.
  // - Similarly, the 'shift' and 'caps-lock' keys have additional 'border' views \
  // 'ActiveKeyShiftLeft', 'ActiveCapsLock', which are displayed when the affected \
  // key has been activated.
  // - Remove the above described 'text', 'image' and 'border' views if you don't \
  // want them.
  // - Add more 'text', 'image', etc. views to represent more keys.
  // - Arrange the 'text' and 'image' views within the area of the 'TouchHandler'. \
  // The position of a view determines the area of the corresponding key.
  // - According to your desired keyboard design add and configure new decoration \
  // views (e.g. an image view to show some icon, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the keyboard's current state.
  // - Adapt the implementation of the 'activateKey' slot method. This method evaluates \
  // which key the user has pressed and feeds the corresponding key event to the \
  // application.
  // - The keyboard layout is determined by the strings in the variables 'layoutShiftOff' \
  // and 'layoutShiftOn'. Modify the strings accordingly to your desired layout. \
  // Every sign in the string corresponds to one key in the keyboard according the \
  // z-order in which the 'text' views 'TextKey01' .. 'TextKey47' are arranged.
  // - In the slot method 'activateKey' take a look at the code to switch the keyboard \
  // layout. In particular, when the user presses the 'shift' or 'caps-lock' keys \
  // the method switches the layout.
  // - You can also add and configure animation effects to your keyboard. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the keyboard itself is resized.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your keyboard. One property \
  // for every keyboard specific setting (e.g. 'Caption', 'Color', 'Font', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Font' should update the key related 'text' views in your \
  // component).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,430,990,1030>;
  }

  // Keyboard layout
  note group Note4
  {
    attr Bounds = <700,210,920,420>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <470,210,690,380>;
  }

  // Feedback flash effect
  note group Note2
  {
    attr Bounds = <240,210,460,340>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,210,230,420>;
  }

  // This string variable stores the keyboard layout for the case, there is a shift \
  // key pressed. Each character within this string does correspond to one key on \
  // the keyboard. By modifying this variable, the layout is changed.
  // The order in which the characters are listed in the string corresponds to the \
  // z-order of the 'text' views 'TextKey01' .. 'TextKey47'.
  $rect <710,370,910,410>
  var string layoutShiftOn = "!\"$$%&/()=?QWERTZUIOP*ASDFGHJKL\'>YXCVBNM;:_ ";

  // This string variable stores the keyboard layout for the case, there is no shift \
  // key pressed. Each character within this string does correspond to one key on \
  // the keyboard. By modifying this variable, the layout is changed.
  // The order in which the characters are listed in the string corresponds to the \
  // z-order of the 'text' views 'TextKey01' .. 'TextKey47'.
  $rect <710,330,910,370>
  var string layoutShiftOff = "1234567890qwertzuiop+asdfghjkl#<yxcvbnm,.- ";

  // This variable refers to the view representing the actually pressed key or it \
  // is 'null' if the user is not touching a key.
  $rect <480,330,680,370>
  var Core::View keyView;

  // This variable stores the recent position inside the keyboard area where the \
  // user is touching the screen.
  $rect <20,370,220,410>
  var point recentPosition;

  // This timer object is used to flash the pressed key when the user has tapped \
  // it very quickly. This is just a visual feedback effect.
  $rect <250,250,450,290>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This method loads new keyboard layout. The layout is determined by the passed \
  // string parameter aLayoutString. The characters within the string correspond \
  // to the keys accordingly their order.
  // The order in which the characters are listed in the string corresponds to the \
  // z-order of the 'text' views 'TextKey01' .. 'TextKey47'.
  $rect <710,250,910,290>
  method void loadLayoutFromString( arg string aLayoutString )
  {
    var Core::View view  = TextKey01;
    var int32      keyNo = 0;

    // Traverse the entire list of views available within the keyboard component
    while ( view != null )
    {
      var Views::Text textKeyView = (Views::Text)view;

      // Is this a 'text' view representing a key?
      if ( textKeyView != null )
      {
        // From the layout string get the character corresponding to the key
        var string s = aLayoutString[ keyNo ];

        // Note, for text views, some characters have a special control function. 
        // To display those signs prefix them by a percent % sign
        if (( s == "%" ) || ( s == "^" ) || ( s == "~" ))
          s = '%' + s;

        // Let the 'text' view display the corresponding sign
        textKeyView.String = s;
        keyNo = keyNo + 1;
      }

      // Search for next view
      view = FindNextView( view, Core::ViewState[]);
    }
  }

  // This internal slot method is called when the recently pressed key should be \
  // activated. This is when the user presses on a key and then releases the finger \
  // again.
  $rect <480,290,680,330>
  slot activateKey
  {
    // Applying the object runtime casting test whether the user is
    // touching a key with 'text' caption.
    var Views::Text textKeyView = (Views::Text)keyView;

    // Depending on the pressed key, the following variables will be
    // initialized with the corresponding code.
    var char          charCode = '\0';
    var Core::KeyCode keyCode  = Core::KeyCode.NoKey;

    // Has the user touched (activated) one of the keys with text
    // as caption? Use the text as character code to feed the application 
    // with a keyboard event.
    if ( textKeyView != null )
      charCode = textKeyView.String[0];

    // Has the user touched the 'Tab' key?
    else if ( keyView == ImageKeyTab )
      keyCode = Core::KeyCode.Tab;

    // Has the user touched the 'Enter' key?
    else if ( keyView == ImageKeyEnter )
      keyCode = Core::KeyCode.Enter;

    // Has the user touched the 'Clear' key?
    else if ( keyView == ImageKeyClear )
      keyCode = Core::KeyCode.Backspace;

    // Has the user touched a 'Shift' key? This switches the layout for
    // the next sign
    else if (( keyView == ImageKeyShiftLeft ) || 
             ( keyView == ImageKeyShiftRight ))
    {
      // Toggle the highlight of the both 'Shift' keys. The 'CapsLock' key,
      // in turn, is de-highlighted.
      ActiveKeyShiftLeft.Visible  = !ActiveKeyShiftLeft.Visible;
      ActiveKeyShiftRight.Visible = ActiveKeyShiftLeft.Visible;
      ActiveKeyCapsLock.Visible   = false;

      // Depending on the actual 'Shift' key state -> load the right layout
      // version of the keyboard
      if ( ActiveKeyShiftLeft.Visible )
        loadLayoutFromString( layoutShiftOn );
      else
        loadLayoutFromString( layoutShiftOff );
    }

    // Has the user touched a 'CapsLock' key? This switches the layout
    // permanently
    else if ( keyView == ImageKeyCapsLock )
    {
      // Toggle the highlight of the 'CapsLock' key. The both 'Shift' keys,
      // in turn, are de-highlighted.
      ActiveKeyCapsLock.Visible   = !ActiveKeyCapsLock.Visible;
      ActiveKeyShiftLeft.Visible  = false;
      ActiveKeyShiftRight.Visible = false;

      // Depending on the actual 'Shift' key state -> load the right layout
      // version of the keyboard
      if ( ActiveKeyCapsLock.Visible )
        loadLayoutFromString( layoutShiftOn );
      else
        loadLayoutFromString( layoutShiftOff );
    }

    // Pressing a key while after the 'Shift' keys have been activated restores
    // the 'Shift' keys and switches back to the normal keyboard layout.
    if ((( charCode != '\0' ) || ( keyCode != Core::KeyCode.NoKey )) &&
           ActiveKeyShiftLeft.Visible )
    {
      ActiveKeyShiftLeft.Visible  = false;
      ActiveKeyShiftRight.Visible = false;
      loadLayoutFromString( layoutShiftOff );
    }

    // The user has pressed a regular character/digit key. Feed it as keyboard
    // event to the application.
    if ( charCode != '\0' )
    {
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, charCode, true );
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, charCode, false );
    }

    // The user has pressed a special key (e.g. Enter). Feed it as keyboard
    // event to the application.
    if ( keyCode != Core::KeyCode.NoKey )
    {
      GetRoot().DriveKeyboardHitting( keyCode, '\0', true );
      GetRoot().DriveKeyboardHitting( keyCode, '\0', false );
    }
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <250,290,450,330>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the keyboard to update 
    // its appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the key is activated.
    signal activateKey;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the keyboard. This updates the keyboard to highlight the key at the new touch \
  // position.
  $rect <20,330,220,370>
  slot onDragTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // Remember the new position where the user recently touched the screen
    recentPosition = TouchHandler.CurrentPos;
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the keyboard area. This activates the key the user has touched.
  $rect <20,290,220,330>
  slot onReleaseTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // Did the user moved the finger outside the keyboard's area? In such case
    // the keyboard is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user has pressed and held a key for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The keyboard can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      signal activateKey;

    // The user has tapped the keyboard very quickly. Defer the key activation
    // to give the user first a short visual feedback that the key has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the keyboard area.
  $rect <20,250,220,290>
  slot onPressTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // The keyboard is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the keyboard in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new key interaction.
    if ( FlashTimer.Enabled )
    {
      signal activateKey;
      FlashTimer.Enabled = false;
    }

    // Remember the new position where the user has touched the screen
    recentPosition = TouchHandler.CurrentPos;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,470,170>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,470,170>;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <10,160>;
    preset Point3 = <460,160>;
    preset Point2 = <460,10>;
    preset Point1 = <10,10>;
    preset OnDrag = onDragTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset EnableMultiTouch = true;
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Border AreaKeySpace
  {
    preset Bounds = <160,130,310,160>;
    preset Width = 2;
    preset Color = #A5A3A2FF;
  }

  $rect <20,20,160,60>
  object Views::Border ActiveKeyShiftRight
  {
    preset Bounds = <400,100,460,130>;
    preset Width = 3;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Border ActiveKeyShiftLeft
  {
    preset Bounds = <10,100,70,130>;
    preset Width = 3;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Border ActiveKeyCapsLock
  {
    preset Bounds = <10,70,60,100>;
    preset Width = 3;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Highlight
  {
    preset Bounds = <160,130,310,160>;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey01
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,10,70,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey02
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <70,10,100,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey03
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,10,130,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey04
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <130,10,160,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey05
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <160,10,190,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey06
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <190,10,220,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey07
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <220,10,250,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey08
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,10,280,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey09
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <280,10,310,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey10
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <310,10,340,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey11
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <340,10,370,40>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey12
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <50,40,80,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey13
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,40,110,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey14
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <110,40,140,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey15
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <140,40,170,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey16
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <170,40,200,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey17
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <200,40,230,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey18
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <230,40,260,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey19
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <260,40,290,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey20
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <290,40,320,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey21
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <320,40,350,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey22
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <350,40,380,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey23
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <380,40,410,70>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey24
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <60,70,90,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey25
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <90,70,120,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey26
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,70,150,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey27
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <150,70,180,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey28
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <180,70,210,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey29
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <210,70,240,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey30
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <240,70,270,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey31
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <270,70,300,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey32
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <300,70,330,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey33
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <330,70,360,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey34
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <360,70,390,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey35
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <390,70,420,100>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey36
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <70,100,100,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey37
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,100,130,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey38
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <130,100,160,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey39
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <160,100,190,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey40
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <190,100,220,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey41
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <220,100,250,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey42
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,100,280,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey43
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <280,100,310,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey44
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <310,100,340,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey45
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <340,100,370,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey46
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <370,100,400,130>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey47
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <160,130,310,160>;
    preset String = "X";
    preset Font = OldResources::FontArial24;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyTab
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,40,50,70>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyTab;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyCapsLock
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,70,60,100>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyCapsShift;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyShiftLeft
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <10,100,70,130>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyShift;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyClear
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <400,10,460,40>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyBackspace;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyEnter
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <420,40,460,100>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyEnter;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyShiftRight
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <400,100,460,130>;
    preset FrameNumber = 1;
    preset Bitmap = OldResources::KeyShift;
  }
}

$rect <140,620,280,660>
$output false
class IconButton : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,40,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,2,38,38>;
    preset Color = #A383AFFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,40,40>;
    preset Bitmap = Application::PopupBitmap;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,40,40>;
    preset Width = 2;
    preset ColorL = #CDA9D3FF;
    preset ColorR = #4B3B4DFF;
    preset ColorB = #4B3B4DFF;
    preset ColorT = #CDA9D3FF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <40,0>;
    preset Point2 = <40,40>;
    preset Point1 = <0,40>;
    preset OnPress = Slot;
  }

  $rect <0,60,220,100>
  property Application::Popup Popup = null;

  $rect <0,100,200,140>
  slot Slot
  {
    sender; /* the method is called from the sender object */



    if ( Popup != null )
    {
      if ( Owner != null )
      {
        Owner.Visible = false;
        Owner.Enabled = false;
        Popup.Parent = (Application::Popup) Owner;
      }
      Popup.Show( GetRoot() );
    }



  }
}

$rect <1420,750,1570,790>
$output false
resource Resources::Bitmap PopupBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\popup.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <690,540,840,580>
$output false
class ModifyPopup : Application::Popup
{
  $rect <740,200,880,240>
  inherited property Bounds = <0,0,720,450>;

  $rect <740,150,880,190>
  inherited method Init()
  {
    // TO DO: Write your code here ... 


    Writable.TextEditor.ObtainFocus();



      /*
    if (   HorzBarSlider.CurrentValue == 0 )
    {
     RadioButton10.Enabled = false;
      RadioButton11.Enabled = false;
    }
    else
    {
     RadioButton10.Enabled = true;
      RadioButton11.Enabled = true;
     }
        */

  }

  $rect <20,20,160,60>
  inherited object Rectangle
  {
    preset Bounds = <680,10,710,400>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle1
  {
    preset Bounds = <680,400,710,430>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle2
  {
    preset Bounds = <10,400,680,435>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <680,0,710,10>;
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle5
  {
    preset Bounds = <0,400,10,430>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset Bounds = <10,0,680,10>;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle7
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle8
  {
    preset Bounds = <0,10,10,400>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Bounds = <10,10,680,400>;
    preset Color = #C7C7C7FF;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Application::MattsKeyboard MattsKeyboard
  {
    preset Bounds = <30,160,588,368>;
  }

  $rect <20,20,160,60>
  object Application::Writable Writable
  {
    preset Bounds = <128,100,588,137>;
    preset Focus = null;
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <31,108,118,132>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Location";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <730,260,930,300>
  slot ProceedSlot
  {
    sender; /* the method is called from the sender object */

    device.location = Writable.TextEditor.Text.String;

    Application::Lib.SetConfig( device.unitnum, device );

    Hide( );


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <532,327,657,382>;
    preset OnRelease = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton InputChanButton
  {
    preset Bounds = <220,23,425,78>;
    preset OnRelease = InputChannels;
    preset Label = "Input Channels...";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton OutputChanButton
  {
    preset Bounds = <446,23,651,78>;
    preset OnRelease = OutputChannels;
    preset Label = "Output Channels...";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <740,20,910,60>
  slot InputChannels
  {
    sender; /* the method is called from the sender object */

    var Application::InputChannels inputs = new Application::InputChannels;


    inputs.device = device;
     
    inputs.ChanIndex = 0;

    inputs.Show( GetRoot() );



  }

  $rect <930,20,1100,60>
  slot OutputChannels
  {
    sender; /* the method is called from the sender object */

    var Application::OutputChannels outputs = new Application::OutputChannels;


    outputs.device = device;

    outputs.ChanIndex = 0;

    outputs.Show( GetRoot() );
  }

  $rect <930,80,1075,120>
  slot SetZoneSlot
  {
    sender; /* the method is called from the sender object */

    if ( device != null )
    {
      device.zonenum = (uint8) DropDownMenu.VerticalList.SelectedItem + 1;
    }



  }

  $rect <20,20,160,60>
  object Application::DropDownMenu DropDownMenu
  {
    preset Bounds = <24,22,180,880>;
    preset onSelection = SetZoneSlot;
    preset GetItemCallback = FillMenu;
  }

  $rect <740,80,910,120>
  slot FillMenu
  {
    var Application::DropDownMenu menu = (Application::DropDownMenu) sender; /* the method is called from the sender object */

    menu.itemName = "Zone " + string( menu.itemIndex + 1 );




  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <533,256,658,311>;
    preset OnRelease = ProceedSlot;
    preset Label = "Proceed";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <730,330,930,370>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */


    Hide();

  }

  $rect <740,370,940,410>
  property Application::DeviceConfig device = null;

  $rect <740,420,940,460>
  onset device
  {
    // The value doesn't change - nothing to do.
     

    // Remember the property's new value.
    pure device = value;

    if ( device != null )
    {
      DropDownMenu.numItems = Application::Lib.NumZones();

      DropDownMenu.VerticalList.SelectedItem = device.zonenum - 1;

      DropDownMenu.MenuSelectionText.String = "Zone " + string( device.zonenum );

      Writable.TextEditor.String = device.location;

      InputChanButton.Enabled = ( Application::Lib.NumInputChannels( device.unitnum ) != 0 );
     
      OutputChanButton.Enabled = ( Application::Lib.NumOutputChannels( device.unitnum ) != 0 );
    }


  }

  $rect <930,200,1130,240>
  slot SetFocus
  {
    sender; /* the method is called from the sender object */


    Writable.TextEditor.ObtainFocus();



  }
}

$rect <410,540,560,580>
$output false
class TestPopup : Application::Popup
{
  $rect <640,5,780,45>
  inherited property Bounds = <0,0,660,460>;

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset AlphaBlended = false;
  }

  $rect <20,20,160,60>
  object Application::Test Test
  {
    preset Bounds = <15,14,625,374>;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton Cancel
  {
    preset Bounds = <499,384,619,419>;
    preset AlphaBlended = false;
    preset OnAction = CancelSlot;
    preset Caption = "Cancel";
  }

  $rect <20,20,160,60>
  object Flat::ActionButton Proceed
  {
    preset Bounds = <19,385,144,420>;
    preset AlphaBlended = false;
    preset OnAction = ProceedSlot;
    preset Caption = "Proceed";
  }

  $rect <470,450,670,490>
  slot CancelSlot
  {
    Hide();


  }

  $rect <20,450,220,490>
  slot ProceedSlot
  {
    Hide();


  }

  $reorder Test 1
  $reorder Cancel 1
  $reorder Proceed 1
  $reorder CancelSlot 1
  $reorder ProceedSlot 1
}

$rect <540,540,690,580>
$output false
class DisablePopup : Application::Popup
{
  $rect <20,20,160,60>
  inherited property Bounds = <0,0,660,465>;

  $rect <20,20,160,60>
  object Application::EnableDisable EnableDisable
  {
    preset Bounds = <15,15,625,375>;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton
  {
    preset Bounds = <20,385,145,425>;
    preset OnAction = ProceedSlot;
    preset Caption = "Proceed";
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton1
  {
    preset Bounds = <490,385,615,425>;
    preset OnAction = CancelSlot;
    preset Caption = "Cancel";
  }

  $rect <10,430,160,470>
  slot ProceedSlot
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $rect <470,435,615,475>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

    Hide();

  }
}

$rect <120,580,270,620>
$output false
class PhoneNumber : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,750,30>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,180,30>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "+447890123456";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <160,0,220,30>;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton1
  {
    preset Bounds = <230,0,290,30>;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton2
  {
    preset Bounds = <310,0,370,30>;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton3
  {
    preset Bounds = <390,0,450,30>;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton4
  {
    preset Bounds = <460,0,520,30>;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton5
  {
    preset Bounds = <540,0,600,30>;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton6
  {
    preset Bounds = <610,0,670,30>;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton7
  {
    preset Bounds = <690,0,750,30>;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }
}

$rect <620,340,750,380>
$output false
class TextPopup : Application::Popup
{
  $rect <810,0,950,40>
  inherited property Bounds = <0,0,800,435>;

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Color = #CDCDCDFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <177,15,237,35>;
    preset String = "Fire";
    preset Font = OldResources::FontVerdana18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <545,15,625,35>;
    preset String = "Evacuate";
    preset Font = OldResources::FontVerdana18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <478,15,538,35>;
    preset String = "Test";
    preset Font = OldResources::FontVerdana18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text5
  {
    preset Bounds = <328,15,388,35>;
    preset String = "Reset";
    preset Font = OldResources::FontVerdana18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text8
  {
    preset Bounds = <244,15,314,35>;
    preset String = "First-Aid";
    preset Font = OldResources::FontVerdana18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text9
  {
    preset Bounds = <406,15,466,35>;
    preset String = "Disable";
    preset Font = OldResources::FontVerdana18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text10
  {
    preset Bounds = <630,15,690,35>;
    preset String = "Fault";
    preset Font = OldResources::FontVerdana18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text11
  {
    preset Bounds = <696,15,771,35>;
    preset String = "Security";
    preset Font = OldResources::FontVerdana18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <17,41,756,341>;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 30;
    preset NoOfItems = 10;
    preset ItemClass = Application::PhoneNumber;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <830,190,1030,230>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Views::Text itemView = (Views::Text)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = "Item #" + string( itemNo );
    itemView.Font   = Resources::FontMedium;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <0,440,200,480>
  slot ClosePopup
  {
    sender; /* the method is called from the sender object */

    this.Hide();

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <310,350,460,400>;
    preset OnRelease = ClosePopup;
    preset Label = "Close";
    preset Appearance = Application::NormalPushButton;
  }
}

$rect <1250,510,1400,550>
$output false
resource Resources::Bitmap TargetBitmap
{
  attr bitmapfile FileName = C:\Embedded Wizard Projects\Images\target.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <420,340,620,380>
$output false
class ImageRadioButton : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,170,50>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    TextView.String = Text;
    ImageView.Bitmap = Image;

    if ( On )  ImageView.FrameNumber = 1; else  ImageView.FrameNumber = 0;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Image ImageView
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop];
    preset Bounds = <0,0,50,50>;
    preset Bitmap = XFlat::ButtonEmpty;
  }

  $rect <20,20,160,60>
  object Views::Text TextView
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <55,0,170,50>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = OldResources::FontVerdana20;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <170,0>;
    preset Point2 = <170,50>;
    preset Point1 = <0,50>;
    preset OnPress = Slot;
  }

  $rect <250,10,450,50>
  property slot Callback = null;

  $rect <0,80,200,120>
  slot Slot
  {
    sender; /* the method is called from the sender object */

    signal Callback;


  }

  $rect <270,55,470,95>
  property string Text = "Text";

  $rect <285,105,485,145>
  property Resources::Bitmap Image = XFlat::ButtonEmpty;

  $rect <10,165,210,205>
  property bool On = false;
}

$rect <1500,1290,1740,1330>
$output false
resource Resources::Font FontVerdanaProSemiBold18
{
  attr fontname FontName = Verdana Pro SemiBold;
  attr fontheight Height = 18;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7E;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
}

$rect <1250,1290,1490,1330>
$output false
resource Resources::Font FontVerdanaProSemiBold20
{
  attr fontname FontName = Verdana Pro SemiBold;
  attr fontheight Height = 20;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xBB,0x4A9,2264,2265,2126,0x3A9;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
}

$rect <550,40,670,80>
$output false
class Glow : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,200,100>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,50,100,100>;
    preset ColorBL = #BC00FF07;
    preset ColorBR = #BC00FF07;
    preset ColorTR = #BC00FFFF;
    preset ColorTL = #BC00FF07;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,100,50>;
    preset ColorBL = #BC00FF07;
    preset ColorBR = #BC00FFFF;
    preset ColorTR = #BC00FF07;
    preset ColorTL = #BC00FF07;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,50,200,100>;
    preset ColorBL = #BC00FF07;
    preset ColorBR = #BC00FF07;
    preset ColorTR = #BC00FF07;
    preset ColorTL = #BC00FFFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,0,200,50>;
    preset ColorBL = #BC00FFFF;
    preset ColorBR = #BC00FF07;
    preset ColorTR = #BC00FF07;
    preset ColorTL = #BC00FF07;
    preset Visible = false;
  }

  $rect <230,35,430,75>
  slot Press
  {
    sender; /* the method is called from the sender object */

    this.Rectangle.Visible = true;
    this.Rectangle1.Visible = true;
    this.Rectangle2.Visible = true;
    this.Rectangle3.Visible = true;


  }

  $rect <220,75,420,115>
  slot Release
  {
    sender; /* the method is called from the sender object */

    this.Rectangle.Visible = false;
    this.Rectangle1.Visible = false;
    this.Rectangle2.Visible = false;
    this.Rectangle3.Visible = false;

    if ( !SimpleTouchHandler.Down && SimpleTouchHandler.Inside )
    {
        idlesignal action;
    }


  }

  $rect <235,160,435,200>
  property slot action = null;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <10,10>;
    preset Point3 = <190,10>;
    preset Point2 = <190,90>;
    preset Point1 = <10,90>;
    preset OnRelease = Release;
    preset OnPress = Press;
  }
}

$rect <1400,790,1550,830>
$output false
resource Resources::Bitmap LogAccess
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\log_access.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1550,790,1700,830>
$output false
resource Resources::Bitmap LogMisc
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\log_misc.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1700,790,1850,830>
$output false
resource Resources::Bitmap LogFaults
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\log_faults.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1260,790,1410,830>
$output false
resource Resources::Bitmap LogEvents
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\log_events.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1250,830,1400,870>
$output false
resource Resources::Bitmap LogFire
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\log_fire.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1400,830,1550,870>
$output false
resource Resources::Bitmap LogSettings
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\log_settings.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1550,830,1700,870>
$output false
resource Resources::Bitmap LogSystem
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\log_system.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1700,830,1850,870>
$output false
resource Resources::Bitmap LogTest
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\log_tests.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

note arrow Note
{
  attr Point1 = <330,180>;
  attr Point2 = <260,200>;
}

// This is an annotation.
note legend Note1
{
  attr Bounds = <360,160,510,200>;
}

$rect <310,220,510,260>
$output false
class CAEName : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,500,30>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var Core::VerticalList list;

    if ( aState.contains( Core::ViewState[ Selected ]))
    {
      Bevel.ColorB = #777777FF;
      Bevel.ColorL =  #111111FF;
      Bevel.ColorT = #111111FF;
      Bevel.ColorR = #777777FF;
      NameText.Bounds.point1 = <31,2>;

    }
    else
    {
      NameText.Bounds.point1 = <30,0>;
      Bevel.ColorB = #111111FF;
      Bevel.ColorL = #777777FF;
      Bevel.ColorT = #777777FF;
      Bevel.ColorR = #111111FF;
    }   
      

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,500,30>;
    preset Width = 2;
    preset ColorL = #CCCCCCFF;
    preset ColorR = #222222FF;
    preset ColorB = #222222FF;
    preset ColorT = #CCCCCCFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <2,2,496,28>;
    preset Color = #818181FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text NameText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,0,500,30>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Application::FontVerdanaProCondSemiBold18;
  }

  $rect <70,95,270,135>
  property bool Selected = false;

  $rect <20,20,160,60>
  object Views::Text NumText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop];
    preset Bounds = <0,0,25,20>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "999";
    preset Font = Application::FontVerdana14;
  }
}

$rect <600,160,800,200>
$output false
class Keyboard : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,450,160>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,40,40>;
    preset KeyChar = 'Q';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,0,80,40>;
    preset KeyChar = 'W';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,0,120,40>;
    preset KeyChar = 'E';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,0,160,40>;
    preset KeyChar = 'R';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key4
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <160,0,200,40>;
    preset KeyChar = 'T';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key5
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <200,0,240,40>;
    preset KeyChar = 'Y';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key6
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <240,0,280,40>;
    preset KeyChar = 'U';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key7
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <280,0,320,40>;
    preset KeyChar = 'I';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key8
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <320,0,360,40>;
    preset KeyChar = 'O';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key9
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <360,0,400,40>;
    preset KeyChar = 'P';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key10
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <20,40,60,80>;
    preset KeyChar = 'A';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key11
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <60,40,100,80>;
    preset KeyChar = 'S';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key12
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,40,140,80>;
    preset KeyChar = 'D';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key13
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <140,40,180,80>;
    preset KeyChar = 'F';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key14
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <180,40,220,80>;
    preset KeyChar = 'G';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key15
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <220,40,260,80>;
    preset KeyChar = 'H';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key16
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <260,40,300,80>;
    preset KeyChar = 'J';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key17
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <300,40,340,80>;
    preset KeyChar = 'K';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key18
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <340,40,380,80>;
    preset KeyChar = 'L';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key20
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,80,80,120>;
    preset KeyChar = 'Z';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key21
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,80,120,120>;
    preset KeyChar = 'X';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key22
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,80,160,120>;
    preset KeyChar = 'C';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key23
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <160,80,200,120>;
    preset KeyChar = 'V';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key24
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <200,80,240,120>;
    preset KeyChar = 'B';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key25
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <240,80,280,120>;
    preset KeyChar = 'N';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key26
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <280,80,320,120>;
    preset KeyChar = 'M';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key28
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <100,120,340,160>;
    preset KeyChar = ' ';
  }

  $rect <20,20,160,60>
  object Application::KeyBmp KeybBmp1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <320,80,370,120>;
    preset Bitmap = OldResources::KeyCapsShift;
  }

  $rect <20,20,160,60>
  object Application::KeyBmp KeybBmp2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <400,0,450,40>;
    preset Bitmap = OldResources::KeyBackspace;
  }

  $rect <20,20,160,60>
  object Application::KeySwitch KeySwitch
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,120,80,160>;
    preset Word = "Num/Sym";
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Touch
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <450,0>;
    preset Point2 = <450,160>;
    preset Point1 = <0,160>;
    preset OnRelease = ReleaseSlot;
    preset OnPress = PressSlot;
  }

  $rect <480,40,680,80>
  slot PressSlot
  {
    sender; /* the method is called from the sender object */


    var Application::Key k = (Application::Key) this.first;

    while ( k != null )
    {
        if ( k.Bounds == Touch.HittingPos )
        {
            k.Pressed = true;
            k.InvalidateViewState();
        }
        k = (Application::Key) k.next;
    }

            



  }

  $rect <460,100,660,140>
  slot ReleaseSlot
  {
    sender; /* the method is called from the sender object */


    var Application::Key k = (Application::Key) this.first;

    while ( k != null )
    {
        if ( k.Bounds == Touch.HittingPos )
        {
            k.Pressed = false;
            k.InvalidateViewState();
        }
        k = (Application::Key) k.next;
    }

            



  }
}

$rect <750,220,890,260>
$output false
class Key : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,300,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    if ( Pressed )
    {
        Rectangle.Color = #88CCFFFF;
    }
    else
    {
        Rectangle.Color = #DDDDDDFF; 
    }   

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <4,0,296,196>;
    preset Color = #DDDDDDFF;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,-10,300,200>;
    preset Width = 4;
    preset ColorL = #FFFFFFFF;
    preset ColorR = #999999FF;
    preset ColorB = #999999FF;
  }

  $rect <580,30,780,70>
  property bool Pressed = false;

  $rect <590,80,790,120>
  onset Pressed
  {
    // The value doesn't change - nothing to do.
    if ( pure Pressed == value )
      return;

    // Remember the property's new value.
    pure Pressed = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <600,130,800,170>
  onget Pressed
  {
    return pure Pressed;
  }
}

$rect <1420,940,1600,980>
$output false
resource Resources::Bitmap Fire4Bitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\fire4.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <840,220,960,260>
$output false
class KeyLetter : Application::Key
{
  $rect <50,230,360,370>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 


    super( aState);

    Text.String = KeyChar;

  }

  $rect <410,80,600,120>
  inherited onset Pressed
  {
    // TO DO: Write your code here ... 


    if (  value == true )
    {
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, KeyChar, true );
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, KeyChar, false );
      }

    pure Pressed = value;

  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,300,200>;
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #3A3A3AFF;
  }

  $rect <340,0,540,40>
  property char KeyChar = 'A';

  $reorder Text 1
}

$rect <960,220,1080,260>
$output false
class KeyBmp : Application::Key
{
  $rect <20,240,160,280>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 

    super( aState);


    Image.Bitmap = Bitmap;


  }

  $rect <240,270,380,310>
  inherited onset Pressed
  {
    // TO DO: Write your code here ... 

    if ( value == true )
    {


      if ( Bitmap == OldResources::KeyBackspace )
      {
         GetRoot().DriveKeyboardHitting( Core::KeyCode.Backspace, '\0', true );
         GetRoot().DriveKeyboardHitting( Core::KeyCode.Backspace, '\0', false );
      }
      else if ( Bitmap == OldResources::KeyCapsShift )
      {

        var Application::Key k = (Application::Key) this.Owner.first;

        while ( k != null )
        {
            var Application::KeyLetter lk = ( Application::KeyLetter )  k;

            if ( lk != null )
            {
                 if (  lk.KeyChar < 'a' )
                 {
                    lk.KeyChar = lk.KeyChar.lower;
                  }
                  else
                  {
                     lk.KeyChar = lk.KeyChar.upper;
                   }
                lk.InvalidateViewState();
            }

            k = (Application::Key) k.next;
        }   
      }
    }  

    pure Pressed = value;

         
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,300,200>;
    preset FrameNumber = 1;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <350,0,550,40>
  property Resources::Bitmap Bitmap = OldResources::InformationIcon;
}

$rect <810,190,950,230>
$output false
class KeySwitch : Application::Key
{
  $rect <20,250,160,290>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ...

    super( aState);
     


    Text.String = Word;
  }

  $rect <250,290,390,330>
  inherited onset Pressed
  {
    // TO DO: Write your code here ... 

    if ( value == true )
    {
        var Application::MattsKeyboard kbd = (Application::MattsKeyboard) Owner.Owner;
        
        if ( kbd.Numboard.Visible == true )
        {
            kbd.Keyboard.Visible = true;
            kbd.Numboard.Visible = false;
            kbd.Keyboard.Enabled = true;
            kbd.Numboard.Enabled = false;

        }
        else
        {
            kbd.Keyboard.Visible = false;
            kbd.Numboard.Visible = true;
            kbd.Keyboard.Enabled = false;
            kbd.Numboard.Enabled = true;
        } 
    }





    pure Pressed = value;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,300,200>;
    preset String = "Text";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <340,30,540,70>
  property string Word = "?";
}

$rect <600,200,800,240>
$output false
class Numboard : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,330,160>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,0,80,40>;
    preset KeyChar = '7';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,0,120,40>;
    preset KeyChar = '8';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key2
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,0,160,40>;
    preset KeyChar = '9';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key3
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <210,0,250,40>;
    preset KeyChar = '+';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key10
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,40,80,80>;
    preset KeyChar = '4';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key11
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,40,120,80>;
    preset KeyChar = '5';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key12
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,40,160,80>;
    preset KeyChar = '6';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key13
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <210,40,250,80>;
    preset KeyChar = '-';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key14
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,120,160,160>;
    preset KeyChar = '0';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key15
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,40,290,80>;
    preset KeyChar = '=';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key20
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <40,80,80,120>;
    preset KeyChar = '1';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key21
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <80,80,120,120>;
    preset KeyChar = '2';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key22
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <120,80,160,120>;
    preset KeyChar = '3';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key23
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,80,290,120>;
    preset KeyChar = '*';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key24
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <290,40,330,80>;
    preset KeyChar = '/';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key25
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <210,120,250,160>;
    preset KeyChar = '&';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key26
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <210,80,250,120>;
    preset KeyChar = '$$';
  }

  $rect <20,20,160,60>
  object Application::KeyBmp KeybBmp1
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <410,80,460,120>;
    preset Bitmap = OldResources::KeyShift;
  }

  $rect <20,20,160,60>
  object Application::KeySwitch KeySwitch
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,120,80,160>;
    preset Word = "Letters";
  }

  $rect <450,30,650,70>
  slot PressSlot
  {
    sender; /* the method is called from the sender object */


    var Application::Key k = (Application::Key) this.first;

    while ( k != null )
    {
        if ( k.Bounds == Touch.HittingPos )
        {
            k.Pressed = true;
            k.InvalidateViewState();
        }
        k = (Application::Key) k.next;
    }

            



  }

  $rect <460,100,660,140>
  slot ReleaseSlot
  {
    sender; /* the method is called from the sender object */


    var Application::Key k = (Application::Key) this.first;

    while ( k != null )
    {
        if ( k.Bounds == Touch.HittingPos )
        {
            k.Pressed = false;
            k.InvalidateViewState();
        }
        k = (Application::Key) k.next;
    }

            



  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key27
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,120,290,160>;
    preset KeyChar = '';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key16
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <290,0,330,40>;
    preset KeyChar = ')';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key28
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <290,80,330,120>;
    preset KeyChar = '#';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key29
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <250,0,290,40>;
    preset KeyChar = '(';
  }

  $rect <20,20,160,60>
  object Application::KeyLetter Key30
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <290,120,330,160>;
    preset KeyChar = '@';
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Touch
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <330,0>;
    preset Point2 = <330,160>;
    preset Point1 = <0,160>;
    preset OnRelease = ReleaseSlot;
    preset OnPress = PressSlot;
  }
}

$rect <950,180,1150,220>
$output false
class MattsKeyboard : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,450,160>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Application::Keyboard Keyboard
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,450,160>;
  }

  $rect <20,20,160,60>
  object Application::Numboard Numboard
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,330,160>;
    preset Enabled = false;
    preset Visible = false;
  }
}

$rect <10,760,160,800>
$output false
class MeshInit : Core::Group
{
  $rect <20,450,220,490>
  inherited property Bounds = <0,0,780,350>;

  $rect <20,410,220,450>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <20,370,220,410>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <1090,40,1215,80>
  object Core::Timer Timer
  {
    preset OnTrigger = TickSlot;
    preset Period = 1000;
    preset Enabled = false;
  }

  $rect <1105,0,1225,40>
  slot TickSlot
  {
    sender; /* the method is called from the sender object */

    HorizontalValueBar.CurrentValue =  1000 - ((1000-HorizontalValueBar.CurrentValue)*99 / 100 );
        /*
    if ( Count < 10 )
    {
      b = Idle  ;
    }
    else if ( Count < 20 )
    {
      b = Sync;
    }
    else if ( Count < 30 )
    {
      b = Mesh;
    }
    else if (  Count < 40 )
    {
      b = Active;
    }
    else  
    {
       Count = 0;
       return;
    }

    var int32 n = Count % 10;

    if ( (n & 1) > 0 )
    {
     b.CurrentValue = 0; 
    }
    else
    {
     b.CurrentValue = (n*10)+10;
    }

    Count = Count + 1;

                   */
  }

  $rect <800,0,920,40>
  slot ImportSlot
  {
    sender; /* the method is called from the sender object */

    var Application::Popup popy = new Application::ImportConfigPopup;

    popy.Show( GetRoot() );



  }

  $rect <916,0,1041,40>
  slot ExportSlot
  {
    sender; /* the method is called from the sender object */

    var Application::Popup popy = new Application::ExportConfigPopup;

    popy.Show( GetRoot() );

  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,490,350>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 50;
    preset NoOfItems = 0;
    preset ItemClass = Application::MeshDeviceComponent;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <30,510,190,550>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Application::MeshDeviceComponent comp = (Application::MeshDeviceComponent) VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( comp == null )
      return;

    comp.ComboTextFound.String = "";
    comp.ComboTextFound.Visible = true;
     

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    comp.Bounds.w = VerticalList.Bounds.w;

    var string location = "";
    var int16  zone = -1;
    var int16  younit = 0;
    var string serial = "";
    var string combo = "";  
    var string time = "--:--";
    var int16 bmp = 0;
    var int16 combfound = -1;


    native ( location, zone, younit, serial, combo, time, itemNo, bmp, combfound )
    {
        Command cmd;
        Command0( CMD_GET_DEVICE_LISTS, &cmd );  

        if ( (void*)cmd.int0 != NULL )
        {
          DeviceConfig* dev   = (DeviceConfig*)      cmd.int0;  
          RadioUnit* rad      = (RadioUnit*)   cmd.int1;
          const char** combis = (const char**) cmd.int3;

          int numConfig = cmd.short4;
          int numFound =  cmd.short5;

          int n = 0;
          DeviceConfig* d;
          RadioUnit* r;

          // Devices not found

          for( d = dev; d < dev + numConfig; d++ )
          {
              if ( !FindRadioDevice( rad, numFound, d->zone, d->unit ) )
              {
                  if ( n == itemNo )
                  {               
                      location = EwNewStringAnsi( d->location );
                      zone = d->zone;
                      younit = d->unit;

                      serial = EwNewStringAnsi( "-------" );

                      if ( d->type < MAX_COMBINATION_TYPE )
                      {
                         combo  = EwNewStringAnsi( combis[ d->type ] );
                      }
                      else
                      {
                        combo =  EwNewStringAnsi( "------" );
                      }

                      bmp = 1;  // 'X'

                      goto done;
                  }
                  else n++;
              }
          }
          
          // Devices not in config

          if ( rad != NULL )
          {
            for( r = rad; r < rad + numFound; r++ )
            {
                if ( !FindConfigDevice( dev, numConfig, r->zone, r->unit ) )
                {
                    if ( n == itemNo )
                    {
                        location = EwNewStringAnsi( "(Unknown location)" );

                        zone = r->zone;
                        younit = r->unit;

                        serial = EwNewStringAnsi( r->serial );

                        if ( r->combination < MAX_COMBINATION_TYPE )
                        {
                           combo  = EwNewStringAnsi( combis[ r->combination ] );
                        }
                        else
                        {
                          combo =  EwNewStringAnsi( "------" );
                        }
                      
                        bmp = 2; // '+'

                        goto done;
                    }
                    else n++;
                }
            }         
         }                             
                
          // Devices in both
          if ( rad != NULL )
          {
            for( d = dev; d < dev + numConfig; d++ )
            {
                if ( r = FindRadioDevice( rad, numFound, d->zone, d->unit ) )
                {
                    if ( n == itemNo )
                    {               
                        location = EwNewStringAnsi( d->location );
                        zone = d->zone;
                        younit = d->unit;

                        serial = EwNewStringAnsi( r->serial );

                        if ( r->combination < MAX_COMBINATION_TYPE )
                        {
                           combo  = EwNewStringAnsi( combis[ r->combination ] );
                        }
                        else
                        {
                          combo =  EwNewStringAnsi( "------" );
                        }

                        if ( d->type == r->combination )
                        {
                            if ( r->status.active || r->status.joinedMesh )
                            {
                      
                               char buff[ 8];
                               snprintf( buff, 8, "%2d:%02d", r->hour, r->minute );
                              
                              time =  EwNewStringAnsi( buff );

                              if ( r->status.active )
                              {
                                  bmp = 6;    //  '\U221a\U221a'
                              }
                              else
                              {
                                bmp = 5;    //  '\U221a\U221a'
                              }

                            }
                            else
                            {
                              bmp = 3;  // '\U221a'
                            }
                        }
                        else
                        {
                          bmp = 4;
                        }
                        goto done;
                    }
                    else n++;
                }
            }
         }
            //time   = TimeStr( );
       }
    done:    ;
    }

    if ( zone != -1 )
    {  
      comp.ZoneText.String = "Zone " + string( zone );
      comp.DeviceText.String = "Unit " + string( younit );

      comp.DescriptionText.String = location;
      comp.SerialText.String = serial;
      comp.TimeText.String = time;
      comp.ComboText.String = combo;

      switch ( bmp )
      {
         case 1 : comp.Image.Bitmap = Application::RedCrossBitmap;
         case 2 : comp.Image.Bitmap = Application::PurplePlusBitmap;
         case 3 : comp.Image.Bitmap = Application::GreenTickBitmap;
         case 4 : comp.Image.Bitmap = Application::BlueQuestionBitmap;
         case 5 : comp.Image.Bitmap = Application::DoubleTickBitmap;
         case 6 : comp.Image.Bitmap = Application::MagentaTickBitmap;
      }
    }
    else
    {
      comp.ZoneText.String = "";
      comp.DeviceText.String = "";
      comp.DescriptionText.String = "";
      comp.SerialText.String = "";
      comp.TimeText.String = "";
      comp.ComboText.String = "";
      comp.Image.Bitmap = null;
    }

  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,490,345>;
    preset OnSlide = TScrollSlot;
    preset SlideHorz = false;
  }

  $rect <957,330,1187,370>
  object Core::SystemEventHandler SiteLoadedEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = Application::Devices.SiteLoadedEvent;
  }

  $rect <950,410,1210,450>
  object Core::SystemEventHandler MeshListChangeEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = Application::Devices.MeshListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <960,365,1110,405>
  slot onEvent1
  {
    var int32 numDevs;

    native ( numDevs )
    {
        Command cmd;
        Command0( CMD_GET_DEVICE_LISTS, &cmd );    

        numDevs = cmd.short4 +cmd.short5;
    }

    VerticalList.NoOfItems = numDevs;

    VerticalList.InvalidateItems( 0, numDevs - 1 );
     

    VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;
    VertScrollbar.ViewArea = VerticalList.Bounds.h;

    PushButton2.Label = "Start Synchronisation";

  }

  $rect <805,55,1030,95>
  slot StartSync
  {
    sender; /* the method is called from the sender object */

    native 
    {
        Command cmd;
        cmd.int0 = 1;
        Command0( CMD_SET_MESH_STAGE, &cmd );     
    }

    HorizontalValueBar.CurrentValue = 0;
    HorizontalValueBar1.CurrentValue = 0;
    HorizontalValueBar2.CurrentValue = 0;



    Timer.Enabled = true;
    Timer1.Enabled = false;
    Timer2.Enabled = false;


  }

  $rect <985,245,1220,285>
  object Core::SystemEventHandler MeshStatusChangeEventHandler
  {
    preset OnEvent = onEvent2;
    preset Event = Application::Devices.MeshStatusChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <985,284,1105,324>
  slot onEvent2
  {
    var int16 stage;

    native ( stage )
    {
        Command cmd;
        Command0( CMD_GET_MESH_STAGE, &cmd );  

        stage = cmd.int0;
    }

    switch( stage)
    {

        case 0 : {
                  PushButton2.Enabled = true;
                 PushButton3.Enabled = false;
                 PushButton4.Enabled = false; 
                  PushButton4.Label = "Activate";
                 HorizontalValueBar.CurrentValue = 0;
                 HorizontalValueBar1.CurrentValue = 0;
                 HorizontalValueBar2.CurrentValue = 0;
                 }

        case 1 : {
                  PushButton3.Enabled = true;
                  PushButton2.Enabled = true;
                  PushButton4.Enabled = false; 
                  HorizontalValueBar1.CurrentValue = 0;
                 HorizontalValueBar2.CurrentValue = 0;
                  PushButton4.Label  = "Activate";
                 }
        case 2 : {
                  PushButton4.Enabled = true; 
                 PushButton2.Enabled = true;
                 PushButton3.Enabled = true;
                 HorizontalValueBar2.CurrentValue = 0;
                 PushButton4.Label  = "Activate";
                 }
        case 3 : {
                    PushButton4.Enabled = true; 
                  PushButton2.Enabled = true;
                  PushButton3.Enabled = true;
                     HorizontalValueBar2.CurrentValue = 1000;
                    PushButton4.Label = "ACTIVE";
                }
        default:  {
                PushButton2.Enabled = false;
                 PushButton3.Enabled = false;
                 PushButton4.Enabled = false;
                 } 
    }

  }

  $rect <800,155,1025,195>
  slot StartFormation
  {
    sender; /* the method is called from the sender object */

    native 
    {
        Command cmd;
        cmd.int0 = 2;
        Command0( CMD_SET_MESH_STAGE, &cmd );     
    }

    HorizontalValueBar.CurrentValue = 1000;
    HorizontalValueBar1.CurrentValue = 0;
    HorizontalValueBar2.CurrentValue = 0;

    Timer1.Enabled = true;
    Timer.Enabled = false;
    Timer2.Enabled = false;

  }

  $rect <800,255,960,295>
  slot StartActivation
  {
    sender; /* the method is called from the sender object */

    native 
    {
        Command cmd;
        cmd.int0 = 3;
        Command0( CMD_SET_MESH_STAGE, &cmd );     
    }

    HorizontalValueBar.CurrentValue = 1000;
    HorizontalValueBar1.CurrentValue = 1000;
    HorizontalValueBar2.CurrentValue = 0;

    Timer1.Enabled = false;
    Timer.Enabled = false;
    Timer2.Enabled = true;



  }

  $rect <1090,120,1215,160>
  object Core::Timer Timer1
  {
    preset OnTrigger = TickSlot1;
    preset Period = 1000;
    preset Enabled = false;
  }

  $rect <1100,80,1220,120>
  slot TickSlot1
  {
    sender; /* the method is called from the sender object */

    HorizontalValueBar1.CurrentValue =  1000 - ((1000-HorizontalValueBar1.CurrentValue)*99 / 100 );
        /*
    if ( Count < 10 )
    {
      b = Idle  ;
    }
    else if ( Count < 20 )
    {
      b = Sync;
    }
    else if ( Count < 30 )
    {
      b = Mesh;
    }
    else if (  Count < 40 )
    {
      b = Active;
    }
    else  
    {
       Count = 0;
       return;
    }

    var int32 n = Count % 10;

    if ( (n & 1) > 0 )
    {
     b.CurrentValue = 0; 
    }
    else
    {
     b.CurrentValue = (n*10)+10;
    }

    Count = Count + 1;

                   */
  }

  $rect <1075,205,1200,245>
  object Core::Timer Timer2
  {
    preset OnTrigger = TickSlot2;
    preset Period = 1000;
    preset Enabled = false;
  }

  $rect <1085,165,1205,205>
  slot TickSlot2
  {
    sender; /* the method is called from the sender object */

    HorizontalValueBar2.CurrentValue =  1000 - ((1000-HorizontalValueBar2.CurrentValue)*80 / 100 );
        /*
    if ( Count < 10 )
    {
      b = Idle  ;
    }
    else if ( Count < 20 )
    {
      b = Sync;
    }
    else if ( Count < 30 )
    {
      b = Mesh;
    }
    else if (  Count < 40 )
    {
      b = Active;
    }
    else  
    {
       Count = 0;
       return;
    }

    var int32 n = Count % 10;

    if ( (n & 1) > 0 )
    {
     b.CurrentValue = 0; 
    }
    else
    {
     b.CurrentValue = (n*10)+10;
    }

    Count = Count + 1;

                   */
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <490,0,539,350>;
    preset OnScroll = VScrollSlot;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <580,480,780,520>
  slot VScrollSlot
  {
    sender; /* the method is called from the sender object */


    VerticalList.ScrollOffset = -VertScrollbar.Position;

  }

  $rect <570,440,770,480>
  slot TScrollSlot
  {
    sender; /* the method is called from the sender object */


    VertScrollbar.Position = -VerticalList.ScrollOffset;


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <540,0,660,50>;
    preset OnRelease = ImportSlot;
    preset Label = "Import";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <660,0,780,50>;
    preset OnRelease = ExportSlot;
    preset Label = "Export";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <540,60,780,105>;
    preset Enabled = false;
    preset OnRelease = StartSync;
    preset Label = "Auto Learn";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <540,105,790,130>;
    preset MaxValue = 1000;
    preset CurrentValue = 50;
    preset Appearance = HorizontalValueBar_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <540,140,780,185>;
    preset Enabled = false;
    preset OnRelease = StartFormation;
    preset Label = "Mesh Formation";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar1
  {
    preset Bounds = <540,185,790,210>;
    preset MaxValue = 1000;
    preset Appearance = WidgetSet::HorizontalValueBar_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <540,220,780,265>;
    preset Enabled = false;
    preset OnRelease = StartActivation;
    preset Label = "Activate";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar2
  {
    preset Bounds = <540,265,790,290>;
    preset MaxValue = 1000;
    preset Appearance = WidgetSet::HorizontalValueBar_Small;
  }

  // This autoobject provides the default customization for the 'horizontal value \
  // bar' widget (WidgetSet::HorizontalValueBar) in its small size variant.
  $rect <675,380,975,420>
  object WidgetSet::HorizontalValueBarConfig HorizontalValueBar_Small
  {
    preset CoverTint = #FF6C3AFF;
    preset TrackRightTint = #FFFFFFFF;
    preset TrackRightFrame = 0;
    preset TrackRight = WidgetSet::HorizontalValueBarSmall;
    preset TrackLeftTint = #FFFFFFFF;
    preset TrackLeftFrame = 1;
    preset TrackLeft = WidgetSet::HorizontalValueBarSmall;
    preset FaceTint = #FF4FE5BA;
    preset WidgetMinSize = <30,20>;
  }
}

$rect <160,760,340,800>
$output false
class ImportConfigPopup : Application::Popup
{
  $rect <630,10,770,50>
  inherited property Bounds = <0,0,500,330>;

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset Bounds = <470,0,500,10>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset Bounds = <10,0,470,10>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Color = #CDCDCDFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <290,50,395,135>;
    preset Bitmap = Application::LaptopBitmap;
  }

  $rect <220,410,360,450>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

     
    /*
    if ( PushButton.CaptionText.String == "Cancel" )
    {
      native
      {
          Command cmd;
          Command0( CMD_CANCEL_LOAD_SETTINGS, &cmd );  
      }
    }
    */

    this.Hide();


  }

  $rect <80,350,210,390>
  slot USBSlot
  {
    sender; /* the method is called from the sender object */

     

          
  }

  $rect <350,350,505,400>
  slot ConfigSlot
  {
    sender; /* the method is called from the sender object */

    Hide(); 

    native
    {
        Command cmd;
        Command0( CMD_LOAD_SETTINGS_USB_SERIAL, &cmd );  
    }
        
          
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <80,50,185,125>;
    preset Bitmap = Application::USBStick;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <170,240,310,290>;
    preset OnRelease = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <50,150,200,195>;
    preset OnRelease = USBSlot;
    preset Label = "USB Storage";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <270,150,420,195>;
    preset OnRelease = ConfigSlot;
    preset Label = "USB Host";
    preset Appearance = Application::NormalPushButton;
  }
}

$rect <1393,869,1543,909>
$output false
resource Resources::Bitmap USBStick
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\usb_stick.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <510,760,690,800>
$output false
class LoadFilePopup : Application::Popup
{
  $rect <360,0,500,40>
  inherited property Bounds = <0,0,340,340>;

  $rect <20,20,160,60>
  object XFlat::AnalogDisplay AnalogDisplay
  {
    preset Bounds = <10,10,310,270>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <10,260,310,310>;
    preset String = "Loading...";
    preset Font = Application::FontVerdanaProSemiBold18;
  }
}

$rect <1690,870,1840,910>
$output false
resource Resources::Bitmap LaptopBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\laptop.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <810,440,960,480>
$output false
class SysRestorePopup : Application::Popup;

$rect <780,480,980,520>
$output false
class SiteSummary : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,540,240>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <165,40,315,80>
  inherited method Init()
  {
    // TO DO: Write your code here ... 



  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <-40,-20,670,270>;
    preset Color = #464646FF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <25,25,155,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel 1:";
    preset Font = Application::FontVerdanaProSemiBold18;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <540,100,745,155>;
    preset Label = "Proceed";
    preset Appearance = PushButtonConfig;
  }

  $rect <440,0,680,40>
  object WidgetSet::PushButtonConfig PushButtonConfig
  {
    preset LabelColorDefault = #282828FF;
    preset IconTintDefault = #798395FF;
    preset LabelFont = Application::FontVerdanaProSemiBold20;
    preset FaceTintActive = #FF464DFF;
    preset FaceTintFocused = #D49DB4FF;
    preset FaceTintDisabled = #404040FF;
    preset FaceTintDefault = #F1F1F1FF;
    preset FaceFrameActive = 3;
    preset FaceFrameDisabled = 2;
    preset FaceFrameDefault = 1;
    preset FaceActive = WidgetSet::PushButtonLarge;
    preset FaceFocused = WidgetSet::PushButtonLarge;
    preset FaceDisabled = WidgetSet::PushButtonLarge;
    preset FaceDefault = WidgetSet::PushButtonLarge;
  }

  $rect <20,20,160,60>
  object Flat::ActionButton ActionButton
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <575,165,735,205>;
    preset OnAction = null;
    preset Caption = "Proceed";
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <0,0,150,20>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panels:";
    preset Font = Application::FontVerdanaProSemiBold18;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <20,135,146,155>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Device 2:";
    preset Font = Application::FontVerdanaProSemiBold18;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <25,50,155,70>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel 2:";
    preset Font = Application::FontVerdanaProSemiBold18;
  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Bounds = <25,75,155,95>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel 3:";
    preset Font = Application::FontVerdanaProSemiBold18;
  }

  $rect <20,20,160,60>
  object Views::Text Text5
  {
    preset Bounds = <25,100,155,120>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Panel 4:";
    preset Font = Application::FontVerdanaProSemiBold18;
  }

  $rect <0,485,200,525>
  method Views::Text NewLine( arg int32 tab, arg string text )
  {
    /* The template just returns the given argument... */

    var Views::Text t = new Views::Text;

    t.Bounds.x1   = tab;
    t.Bounds.x2  = 380;
    t.Bounds.y1   = ypos;
    t.Bounds.y2   = ypos + height;

    t.String = text;

    ypos += height;

    return text;
  }

  $rect <610,80,810,120>
  var int32 ypos = 0;

  $rect <610,135,810,175>
  property int32 height = 28;
}

$rect <340,760,510,800>
$output false
class ExportConfigPopup : Application::Popup
{
  $rect <630,10,770,50>
  inherited property Bounds = <0,0,500,330>;

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset Bounds = <470,0,500,10>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset Bounds = <10,0,470,10>;
  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Color = #CDCDCDFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <303,38,408,123>;
    preset Bitmap = Application::LaptopBitmap;
  }

  $rect <220,410,360,450>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

     

    native
    {
        Command cmd;
        Command0( CMD_CANCEL_LOAD_SETTINGS, &cmd );  
    }

    this.Hide();


  }

  $rect <200,350,330,390>
  slot SDCardSlot
  {
    sender; /* the method is called from the sender object */
  }

  $rect <350,350,505,400>
  slot ConfigSlot
  {
    sender; /* the method is called from the sender object */

    HorizontalValueBar.CurrentValue = 0;
     
     

    native
    {
        Command cmd;
        Command0( CMD_SAVE_SETTINGS_USB_SERIAL, &cmd );  
    }
        
          
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <70,43,175,118>;
    preset Bitmap = Application::USBStick;
  }

  $rect <30,350,160,390>
  slot USBSlot
  {
    sender;


     var Application::SaveSitePopup ss = new  Application::SaveSitePopup ;
         ss.Show( this.GetRoot() );
         ss.Writable.TextEditor.ObtainFocus() ;
  }

  $rect <550,370,750,410>
  object Core::SystemEventHandler SystemEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = Application::Devices.ExportProgressEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <560,420,760,460>
  slot onEvent
  {
    var Application::Progress p = (Application::Progress) SystemEventHandler.Context;

    HorizontalValueBar.CurrentValue = p.amount;
     

    if ( 100 == p.amount )
    {
       PushButton2.Label = "OK";
        
        
    }


    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <49,138,189,178>;
    preset OnRelease = USBSlot;
    preset Label = "To USB Devie";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <285,138,425,178>;
    preset OnRelease = ConfigSlot;
    preset Label = "To USB Host";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <42,191,432,236>;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <162,243,312,293>;
    preset OnRelease = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = Application::NormalPushButton;
  }
}

$rect <10,970,210,1010>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <420,60,620,100>
  onset Property
  {
    // The property doesn't change -> nothing to do.
    if ( pure Property == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Property = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Property;
  }

  // This property represents an individual setting or state value existing within \
  // the device.
  $rect <220,60,420,100>
  property int32 Property = 0;

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <20,60,220,100>
  $output true
  method void UpdateProperty( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Property )
    {
      // Remember the new value in the internal memory of the property.
      pure Property = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Property;
    }
  }

  // This object represents an individual system event.
  $rect <340,190,580,230>
  object Core::SystemEvent MeshListChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,190,280,230>
  $output true
  method void TriggerMeshListChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    MeshListChangeEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  // Example of an interface to read and modify a device setting or state value
  note group Note1
  {
    attr Bounds = <10,10,630,110>;
  }

  // Example of an interface to react to a system event
  note group Note2
  {
    attr Bounds = <10,150,640,1420>;
  }

  // The property 'Property' represents an individual setting or state value existing \
  // within the device. Through the associated 'onset' method all write operations \
  // to the property can be directed to your particular device API. The read accesses, \
  // in contrast, are handled internally by using the last known value of the property. \
  // See inline documentation inside the 'onset' method 'OnSetProperty'.
  // 
  // The method 'UpdateProperty', in turn, is intended to be called by the device \
  // to notify the GUI application about an alternation of a setting or state value \
  // represented by the property 'Property'. See inline documentation inside the \
  // method.
  // 
  // You will eventually need to change the data type of the property to match the \
  // data in your device (e.g. to 'bool', 'uint32', or 'string', etc.). Use for this \
  // purpose the attribute 'Type' of the property itself. Accordingly the declaration \
  // of the 'UpdateProperty' method may need an adaptation.
  note legend Note4
  {
    attr Bounds = <700,10,1540,220>;
  }

  note arrow Note5
  {
    attr Point1 = <630,60>;
    attr Point2 = <700,60>;
  }

  // The object 'SystemEvent' represents an individual system event. When the system \
  // event is triggered all associated system event handler are notified automatically.
  // 
  // The method 'TriggerEvent' method is intended to be called by the device to notify \
  // the GUI application about the particular system event represented by the object \
  // 'SystemEvent'. This method exists for your convenience only and is optional. \
  // See inline documentation inside the method.
  note legend Note6
  {
    attr Bounds = <700,230,1540,370>;
  }

  note arrow Note7
  {
    attr Point1 = <630,280>;
    attr Point2 = <700,280>;
  }

  $rect <340,230,540,270>
  object Core::SystemEvent SiteLoadedEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,230,260,270>
  $output true
  method void TriggerSiteLoadedEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    SiteLoadedEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent1.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent1.Trigger( null, true );
    */
  }

  $rect <340,270,570,310>
  object Core::SystemEvent MeshStatusChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,270,310,310>
  $output true
  method void TriggerMeshStatusChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    MeshStatusChangeEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,310,540,350>
  object Core::SystemEvent FireEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,310,260,350>
  $output true
  method void TriggerFireEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FireEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,350,540,390>
  object Core::SystemEvent FirstAidEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,350,260,390>
  $output true
  method void TriggerFirstAidEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FireEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,390,540,430>
  object Core::SystemEvent ResetEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,390,260,430>
  $output true
  method void TriggerResetEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FireEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,430,540,470>
  object Core::SystemEvent EvacuateEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,430,260,470>
  $output true
  method void TriggerEvacuateEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FireEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,470,540,510>
  object Core::SystemEvent SecurityEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,470,260,510>
  $output true
  method void TriggerSecurityEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    SecurityEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,510,540,550>
  object Core::SystemEvent DisableEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,510,230,550>
  $output true
  method void TriggerDisableEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    DisableEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,550,540,590>
  object Core::SystemEvent TestEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,550,230,590>
  $output true
  method void TriggerTestEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    TestEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,590,540,630>
  object Core::SystemEvent FaultEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,590,230,630>
  $output true
  method void TriggerFaultEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FaultEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,670,540,710>
  object Core::SystemEvent FireListChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,670,270,710>
  $output true
  method void TriggerFireListChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FireListChangeEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,630,540,670>
  object Core::SystemEvent ExportProgressEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,630,270,670>
  $output true
  method void TriggerExportProgressEvent( arg int32 amount )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var Application::Progress p = new Application::Progress;

    p.amount = amount;

    ExportProgressEvent.Trigger( p, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <350,710,550,750>
  object Core::SystemEvent StartProgressEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,710,290,750>
  $output true
  method void TriggerStartProgressEvent( arg int32 amount )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var Application::Progress p = new Application::Progress;

    p.amount = amount;

    StartProgressEvent.Trigger( p, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,750,540,790>
  object Core::SystemEvent EndProgressEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,750,280,790>
  $output true
  method void TriggerEndProgressEvent( arg int32 amount )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var Application::Progress p = new Application::Progress;

    p.amount = amount;

    EndProgressEvent.Trigger( p, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,790,540,830>
  object Core::SystemEvent OnTestChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,790,270,830>
  $output true
  method void TriggerOnTestChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    OnTestChangeEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <350,830,550,870>
  object Core::SystemEvent FaultListChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <20,830,270,870>
  $output true
  method void TriggerFaultListChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    FaultListChangeEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <350,870,550,910>
  object Core::SystemEvent EventListChangedEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,870,290,910>
  $output true
  method void TriggerEventListChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    EventListChangedEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <350,910,550,950>
  object Core::SystemEvent LogListChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <40,910,290,950>
  $output true
  method void TriggerLogListChangeEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    LogListChangeEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <340,950,540,990>
  object Core::SystemEvent AccessModeChangeEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,950,280,990>
  $output true
  method void TriggerAccessModeChangeEvent( arg int32 level )
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.

    var Application::Access access = new  Application::Access;

    access.Level = level;

    AccessModeChangeEvent.Trigger( access, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <360,990,560,1030>
  object Core::SystemEvent WriteProtectedEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <50,990,300,1030>
  $output true
  method void TriggerWriteProtectedEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    WriteProtectedEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }

  $rect <320,1030,520,1070>
  object Core::SystemEvent DFUEvent;

  // This method is intended to be called by the device to notify the GUI application \
  // about a particular system event.
  $rect <30,1030,230,1070>
  $output true
  method void TriggerDFUEvent()
  {
    // Just trigger the system event. All associated system event handler
    // will then be notified automatically.
    DFUEvent.Trigger( null, false );

    /*
       HINT 1:

       When triggering the event you can pass an optional 'context' object.
       With it additional event specific data can be attached at the event
       and dispatched with it. All notified system event handler can thus
       evaluate this 'context' information.

       To do this, you will need to define a particular 'context' class
       suitable to store the event specific information. Then create an
       instance of the class, initialize it with all the specific context
       data and finally pass the instance in the first parameter of the
       Trigger() method:


       var YourUnit::ContextClass context = new YourUnit::ContextClass;

       context.SomeData1 = ...
       context.SomeData2 = ...

       SystemEvent.Trigger( context, false );


       You can add parameters to the method in order to simply receive
       values from the device.
    */

    /*
       HINT 2:

       When triggering a system event you can determine its priority. Per
       default system events are delivered strictly in the order in which
       they have been triggered. When you pass 'true' in the last parameter
       of Trigger() you can force the event to be dispatched early:

       SystemEvent.Trigger( null, true );
    */
  }
}

$rect <270,970,470,1010>
autoobject Application::DeviceClass Devices;

$rect <10,1040,150,1080>
$output false
class MeshDevice
{
  $rect <30,60,230,100>
  property int16 Zone = 0;

  $rect <30,10,230,50>
  property int16 Device = 0;

  $rect <30,110,230,150>
  property string Serial = 0;

  $rect <30,160,230,200>
  property int16 Combination = 0;

  $rect <30,210,230,250>
  property Core::Time TimeStamp = null;
}

$rect <690,760,890,800>
$output false
class MeshDeviceComponent : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,480,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,480,45>;
    preset Color = #DEDEDEFF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <369,26,432,42>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "12:33";
    preset Font = Application::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <3,2,76,24>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 96";
    preset Font = Application::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <2,22,370,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Hallway, Front building 2";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <438,2,477,45>;
    preset FrameNumber = 0;
    preset Bitmap = Application::GreenTickBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text DeviceText
  {
    preset Bounds = <82,2,171,24>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Device 1";
    preset Font = Application::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text SerialText
  {
    preset Bounds = <198,1,310,26>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "xxx-yy-12345";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ComboText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <318,1,431,22>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "xxx-yy";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ComboTextFound
  {
    preset Bounds = <301,0,340,25>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $reorder Rectangle 2
}

$rect <1250,903,1430,940>
$output false
resource Resources::Bitmap GreenTickBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\greentick.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1420,900,1600,940>
$output false
resource Resources::Bitmap RedCrossBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\redcross.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1590,903,1780,943>
$output false
resource Resources::Bitmap BlueQuestionBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\bluequestion.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <940,760,1040,800>
$output false
enum Enum
{
  $rect <10,10,210,50>
  item FirstItem;

  $rect <220,10,420,50>
  item SecondItem;

  $rect <430,10,630,50>
  item ThirdItem;
}

$rect <1770,910,1960,950>
$output false
resource Resources::Bitmap PurplePlusBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\purpleplus.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1250,940,1430,980>
$output false
resource Resources::Bitmap DoubleTickBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\doubletick.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1590,940,1770,980>
$output false
resource Resources::Bitmap Mute2Bitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\mute40_2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <260,1009,460,1049>
$output false
class Progress
{
  $rect <0,0,200,40>
  property int32 amount = 0;
}

$rect <800,820,970,860>
$output false
class SaveSitePopup : Application::Popup
{
  $rect <780,30,920,70>
  inherited property Bounds = <0,0,710,410>;

  $rect <760,140,900,180>
  inherited property Focus = Writable;

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Color = #CDCDCDFF;
  }

  $rect <20,20,160,60>
  object Application::MattsKeyboard MattsKeyboard
  {
    preset Bounds = <39,124,649,354>;
  }

  $rect <20,20,160,60>
  object Application::Writable Writable
  {
    preset Bounds = <39,43,530,93>;
    preset Property = ^FileName;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <553,41,663,93>;
    preset OnActivate = SaveSlot;
    preset IconFrameDefault = 1;
    preset Icon = null;
    preset Label = "Save";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <730,90,910,130>
  property string FileName = "";

  $rect <750,200,950,240>
  slot SaveSlot
  {
    sender; /* the method is called from the sender object */

    var string fname = Writable.TextEditor.String;

    var int32 success = 0;

    native ( fname )
    {
       char file[ 256];

       EwStringToAnsi( fname, file, 256, '-' );

       success = Command1( CMD_SAVE_SETTINGS_USB_HOST, (int) file );

    }

    if ( success != 0 )
    {
      var Application::AccesssPopup ll = new Application::AccesssPopup;

      ll.Text.String = "Save failed - Check USB device.";

      ll.Show( GetRoot() );
    }


    Hide( );

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <550,310,660,362>;
    preset OnActivate = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <820,340,1060,380>
  object WidgetSet::PushButtonConfig PushButtonConfig
  {
    preset LabelColorActive = #151515FF;
    preset LabelFont = Flat::FontM;
    preset FaceFrameActive = 2;
    preset FaceFrameDefault = 1;
    preset FaceFocused = WidgetSet::PushButtonMedium;
    preset FaceDefault = WidgetSet::PushButtonMedium;
  }

  $rect <800,290,1040,330>
  object WidgetSet::PushButtonConfig PushButtonConfig1
  {
    preset LabelColorActive = #151515FF;
    preset LabelColorDefault = #F5F5F5FF;
    preset LabelFont = Flat::FontM;
    preset FaceFrameActive = 2;
    preset FaceFrameDefault = 2;
    preset FaceFocused = WidgetSet::PushButtonMedium;
    preset FaceDefault = WidgetSet::PushButtonMedium;
  }

  $rect <530,440,730,480>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

     

    Hide( );

  }
}

$rect <1770,950,1960,990>
$output false
resource Resources::Bitmap MagentaTickBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\magentatick.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

// This autoobject provides the default customization for the 'radio button' widget \
// (WidgetSet::RadioButton) in its medium size variant.
$rect <540,1310,730,1350>
$output false
autoobject WidgetSet::RadioButtonConfig NormalRadioButton
{
  preset LabelOnColorActive = #000000FF;
  preset LabelOnColorFocused = #000000FF;
  preset LabelOnColorDisabled = #000000FF;
  preset LabelOnColorDefault = #000000FF;
  preset LabelOffColorActive = #000000FF;
  preset LabelOffColorFocused = #000000FF;
  preset LabelOffColorDisabled = #000000FF;
  preset LabelOffColorDefault = #000000FF;
  preset LabelMarginLeft = 45;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #A8ABABAA;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #A8ABABAA;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 45;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToLeft];
  preset FaceOnFrameActive = 7;
  preset FaceOnFrameFocused = 5;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 3;
  preset FaceOnActive = WidgetSet::RadioButtonMedium;
  preset FaceOnFocused = WidgetSet::RadioButtonMedium;
  preset FaceOnDisabled = WidgetSet::RadioButtonMedium;
  preset FaceOnDefault = WidgetSet::RadioButtonMedium;
  preset FaceOffFrameActive = 6;
  preset FaceOffFrameFocused = 4;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 2;
  preset FaceOffActive = WidgetSet::RadioButtonMedium;
  preset FaceOffFocused = WidgetSet::RadioButtonMedium;
  preset FaceOffDisabled = WidgetSet::RadioButtonMedium;
  preset FaceOffDefault = WidgetSet::RadioButtonMedium;
  preset WidgetMinSize = <39,39>;
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'check box'.
$rect <500,1390,680,1430>
$output false
autoobject WidgetSet::ToggleButtonConfig NormalCheckBox
{
  preset LabelOnColorActive = #000000FF;
  preset LabelOnColorFocused = #000000FF;
  preset LabelOnColorDisabled = #000000FF;
  preset LabelOnColorDefault = #000000FF;
  preset LabelOffColorActive = #000000FF;
  preset LabelOffColorFocused = #000000FF;
  preset LabelOffColorDisabled = #000000FF;
  preset LabelOffColorDefault = #000000FF;
  preset LabelMarginLeft = 45;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #A8ABABAA;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #A8ABABAA;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 40;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToLeft];
  preset FaceOnFrameActive = 7;
  preset FaceOnFrameFocused = 5;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 3;
  preset FaceOnActive = WidgetSet::CheckBoxMedium;
  preset FaceOnFocused = WidgetSet::CheckBoxMedium;
  preset FaceOnDisabled = WidgetSet::CheckBoxMedium;
  preset FaceOnDefault = WidgetSet::CheckBoxMedium;
  preset FaceOffFrameActive = 6;
  preset FaceOffFrameFocused = 4;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 2;
  preset FaceOffActive = WidgetSet::CheckBoxMedium;
  preset FaceOffFocused = WidgetSet::CheckBoxMedium;
  preset FaceOffDisabled = WidgetSet::CheckBoxMedium;
  preset FaceOffDefault = WidgetSet::CheckBoxMedium;
  preset WidgetMinSize = <39,39>;
}

// This autoobject provides the default customization for the 'horizontal slider' \
// widget (WidgetSet::HorizontalSlider) in its medium size variant.
$rect <530,1270,740,1310>
$output false
autoobject WidgetSet::HorizontalSliderConfig NormalHorizontalSlider
{
  preset KeyRepeatPeriod = 100;
  preset KeyRepeatDelay = 500;
  preset CoverTintDisabled = #AEAEAEB0;
  preset ThumbMarginRight = -2;
  preset ThumbMarginLeft = -2;
  preset ThumbFrameActive = 3;
  preset ThumbFrameFocused = 2;
  preset ThumbFrameDisabled = 0;
  preset ThumbFrameDefault = 1;
  preset ThumbActive = WidgetSet::ThumbKnobMedium;
  preset ThumbFocused = WidgetSet::ThumbKnobMedium;
  preset ThumbDisabled = WidgetSet::ThumbKnobMedium;
  preset ThumbDefault = WidgetSet::ThumbKnobMedium;
  preset TrackRightTintDisabled = #AEAEAEB0;
  preset TrackRightFrameActive = 0;
  preset TrackRightFrameFocused = 0;
  preset TrackRightFrameDisabled = 0;
  preset TrackRightFrameDefault = 0;
  preset TrackRightActive = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackRightFocused = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackRightDisabled = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackRightDefault = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackLeftTintActive = #FF007AFF;
  preset TrackLeftTintDisabled = #B2B2B2B1;
  preset TrackLeftFrameActive = 1;
  preset TrackLeftFrameFocused = 1;
  preset TrackLeftFrameDisabled = 1;
  preset TrackLeftFrameDefault = 1;
  preset TrackLeftActive = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackLeftFocused = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackLeftDisabled = WidgetSet::HorizontalSliderTrackMedium;
  preset TrackLeftDefault = WidgetSet::HorizontalSliderTrackMedium;
  preset FaceTintDisabled = #B1B1B1B3;
  preset WidgetMinSize = <45,39>;
}

$rect <1060,530,1210,570>
$output false
class InputChannels : Application::Popup
{
  $rect <820,431,960,471>
  inherited property Bounds = <0,0,800,480>;

  $rect <830,219,970,259>
  inherited method Init()
  {
     
    VerticalScrollbar.ContentArea = Outline.GetContentArea( Core::ViewState[ Enabled] ).h + (Outline.CountViews()-1) * Outline.Space;

    VerticalScrollbar.ViewArea = Outline.Bounds.h;

  }

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle7
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Bounds = <10,10,770,450>;
    preset Color = #C3C3C3FF;
    preset AlphaBlended = false;
  }

  $rect <20,250,160,290>
  slot ProceedSlot
  {
    sender; /* the method is called from the sender object */

    if ( device != null )
    {
      Application::Lib.SetConfig( device.unitnum, device ); 
    }
        
    Hide();

  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <24,20,130,50>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Channel";
    preset Font = Resources::FontMedium;
    preset Embedded = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Bounds = <177,20,727,440>;
    preset Color = #737373FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Bounds = <729,20,769,440>;
    preset OnScroll = Scroll;
    preset ContentArea = 1000;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <177,20,727,440>;
    preset OnSlide = TouchScroll;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <177,20,727,440>;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <30,300,155,355>;
    preset OnRelease = ProceedSlot;
    preset Label = "Proceed";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <177,20,727,440>;
    preset SlideHandler = SlideTouchHandler;
    preset Space = 15;
    preset Formation = Core::Formation.TopToBottom;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Cancel
  {
    preset Bounds = <30,370,155,425>;
    preset OnRelease = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object Application::InputAction InputAction
  {
    preset Bounds = <177,20,727,220>;
    preset Embedded = true;
  }

  $rect <820,10,970,50>
  slot Scroll
  {
    sender; /* the method is called from the sender object */

    Outline.ScrollOffset.y = -VerticalScrollbar.Position;

  }

  $rect <20,20,160,60>
  object Application::DropDownMenu DropDownMenu
  {
    preset Bounds = <17,20,172,360>;
    preset onSelection = Select;
    preset GetItemCallback = LoadMenu;
  }

  $rect <20,20,160,60>
  object Application::InputSignal InputSignal
  {
    preset Bounds = <177,240,727,350>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Application::InputDelay InputDelay
  {
    preset Bounds = <177,320,727,500>;
    preset Embedded = true;
  }

  $rect <980,10,1130,50>
  slot TouchScroll
  {
    sender; /* the method is called from the sender object */

    VerticalScrollbar.Position = -Outline.ScrollOffset.y;

  }

  $rect <10,80,150,120>
  slot Select
  {
     

    ChanIndex = DropDownMenu.VerticalList.SelectedItem;


  }

  $rect <10,130,150,170>
  slot LoadMenu
  {
     
    var Application::DropDownMenu m = ( Application::DropDownMenu) sender;
     
    var int32 i = m.itemIndex;

    if ( device != null )
    {
      m.itemName = Application::Lib.TypeName( device.inputs[ i ].type );
    }
    else 
    {
      m.itemName = "??";
    }


  }

  $rect <830,110,1030,150>
  property int32 ChanIndex = 0;

  $rect <830,150,1030,190>
  onset ChanIndex
  {
     
    if ( device != null && value < Application::Lib.NumInputChannels( device.unitnum ) )
    {

      // Remember the property's new value.
      pure ChanIndex = value;

      var Application::InputChannel i = device.inputs[ ChanIndex ];

      if ( i != null )
      {
        InputAction.inputAction = i.action;

        InputSignal.BypassDelay.Checked = i.flags.contains( Application::Options[ IgnoreDelay] );
        InputSignal.Inverted.Checked = i.flags.contains( Application::Options[ IgnoreDelay ] );
        InputSignal.Latching.Checked = i.flags.contains( Application::Options[ Latching] );
     
        InputDelay.DoubleKnock.Selected =  i.flags.contains( Application::Options[ DoubleKnock ] );
        InputDelay.Sustained.Selected =    i.flags.contains( Application::Options[ Sustained ] );

        InputDelay.DelaySecs = i.delay;


        DropDownMenu.VerticalList.SelectedItem = ChanIndex;
        DropDownMenu.MenuSelectionText.String = Application::Lib.TypeName( i.type );
        DropDownMenu.numItems = device.NumInputs();

        var int32 n;
           var bool extra = false;
           for ( n = 0; n < device.params.size; n = n + 1 )
           {
              if ( device.params[n] != null )
              {
                 var Application::Parameter p = device.params[n];

                 if ( p.code != Application::ParamCode.Unused && p.channel == ChanIndex )
                 {
                    if ( extra == false )
                    {
                       extra = true;
                       var Application::ParamSpecific title = new Application::ParamSpecific;
                       title.Embedded = true;
                       Add( title, 117 );
                     }
                    if ( p.max - p.min == 1 )
                    {     
                       var Application::ParamToggle tog = new Application::ParamToggle;
                       tog.Embedded = true;
                       tog.param = p;
                       tog.Text2.String = p.name;
                       Add( tog, 118 );
                    }
                    else
                    { 
                       var Application::ParamSlider slide = new Application::ParamSlider;
                       slide.Embedded = true;
                       slide.param = p;
                       slide.Text2.String = p.name;
                       Add( slide, 118 );
                    }
                 }
               }
            }  
        }        
    }








     
  }

  $rect <830,299,1030,339>
  property Application::DeviceConfig device = null;

  $rect <0,430,200,470>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

    Hide();

  }

  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder Bounds1 1
  $reorder Rectangle 1
  $reorder Rectangle1 1
  $reorder Rectangle2 1
  $reorder Rectangle4 1
  $reorder Rectangle5 1
  $reorder Rectangle6 1
  $reorder Rectangle7 1
  $reorder Rectangle8 1
  $reorder Rectangle3 1
  $reorder Show 1
  $reorder mask 1
  $reorder touch 1
  $reorder root 1
  $reorder Hide 1
  $reorder Parent 1
}

$rect <0,1200,200,1240>
$output false
class DropDownMenu : Core::Group
{
  $rect <360,130,560,170>
  inherited property Bounds = <0,0,240,390>;

  $rect <410,240,610,280>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );



    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <400,190,600,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <490,330,1270,650>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <2,7,188,47>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <0,5,190,49>;
    preset Width = 2;
    preset ColorL = #1C1C1CFF;
    preset ColorR = #BFBFBFFF;
    preset ColorB = #BFBFBFFF;
    preset ColorT = #1C1C1CFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Point4 = <0,1>;
    preset Point3 = <240,1>;
    preset Point2 = <240,50>;
    preset Point1 = <0,50>;
    preset OnRelease = Release;
    preset OnPress = Press;
    preset Enabled = false;
    preset Embedded = true;
  }

  $rect <290,10,490,50>
  slot Press
  {
    sender; /* the method is called from the sender object */

    VerticalList.Visible = !VerticalList.Visible;
    VerticalList.Enabled  = VerticalList.Visible;

    SimpleTouchHandler1.Enabled = VerticalList.Visible;
    SlideTouchHandler.Enabled = VerticalList.Visible;





     
    /*
     Rectangle1.Color = #8BB8E8FF;

        
     Bevel1.ColorB = #BFBFBFFF;
    Bevel1.ColorL = #1C1C1CFF;
     Bevel1.ColorR = #BFBFBFFF;
      Bevel1.ColorT = #1C1C1CFF;   */

  }

  $rect <290,50,490,90>
  slot Release
  {
    sender; /* the method is called from the sender object */

     
     //Rectangle1.Color = #DBDBDBFF;

    // Bevel1.ColorB = #1C1C1CFF;
    //Bevel1.ColorL = #BFBFBFFF;
    // Bevel1.ColorR = #1C1C1CFF;
      //Bevel1.ColorT = #BFBFBFFF;
      
  }

  $rect <20,20,160,60>
  object Views::Text MenuSelectionText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <8,11,185,43>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <250,85,450,125>
  slot Select
  {
    var Application::DropMenuItem itm = (Application::DropMenuItem) sender;

    MenuSelectionText.String = itm.CaptionText.String;

     

    VerticalList.Visible = false;
    VerticalList.Enabled = false;

    postsignal onSelection;




  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,50,200,390>;
    preset SlideHorz = false;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <0,48,200,390>;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 40;
    preset NoOfItems = 10;
    preset ItemClass = Application::DropMenuItem;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler1
  {
    preset Point4 = <0,47>;
    preset Point3 = <200,47>;
    preset Point2 = <200,575>;
    preset Point1 = <0,575>;
    preset OnRelease = ItemRelease;
    preset OnPress = ItemSelect;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset Enabled = false;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <250,175,400,215>
  slot OnLoadItem
  {
    /*


      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Application::DropMenuItem itemView = (Application::DropMenuItem)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;
                      
                      
    if ( itemNo == VerticalList.SelectedItem )
    {
      itemView.pressed = true;
     } 
     else
     {
       itemView.pressed = false;
     }
                                    
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );

    if ( GetItemCallback != null )
    {
        itemIndex = itemNo;
        signal GetItemCallback;

      // Configure the item view ...
      if ( itemName != "" )
      {
        itemView.CaptionText.String = itemName;
        return;
      }
    }

    itemView.CaptionText.String = "Item "+string(itemNo);






     

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.

  }

  $rect <150,420,350,460>
  property slot onSelection = null;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <189,0,239,55>;
    preset OnPress = Press;
    preset Icon = Application::DropDownSimpleBitmap;
    preset Label = "";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <700,250,900,290>
  property string itemName = 0;

  $rect <700,290,900,330>
  property slot GetItemCallback = null;

  $rect <890,290,1090,330>
  property int32 itemIndex = 0;

  $rect <530,0,730,40>
  property uint8 numItems = 0;

  $rect <530,40,730,80>
  onset numItems
  {
    // The value doesn't change - nothing to do.
    if ( pure numItems == value )
      return;

    // Remember the property's new value.
    pure numItems = value;

    VerticalList.NoOfItems = numItems;

    var int32 size = VerticalList.ItemHeight * numItems;

    VerticalList.Bounds.y2 = VerticalList.Bounds.y1 + size + 20;

    if ( VerticalList.Bounds.y2 > 480 ) VerticalList.Bounds.y2 = 480;
    SimpleTouchHandler1.Point1.y = VerticalList.Bounds.y2;
    SimpleTouchHandler1.Point2.y = VerticalList.Bounds.y2; 

    Bounds.y2 = VerticalList.Bounds.y2 ;
    VerticalList.Bounds.w = Bounds.w - 40;
     

    // TO DO:
    // 
    // Now you can handle the alternation of the property.ou can handle the alternation of the property.
  }

  $rect <255,310,455,350>
  slot ItemSelect
  {
    sender; /* the method is called from the sender object */

    var int32 itemNo = VerticalList.GetItemAtPosition( SimpleTouchHandler1.CurrentPos );

    //var Application::DropMenuItem v = (Application::DropMenuItem) VerticalList.GetViewForItem( itemNo );

    //if ( v != null ) 
    //{
        VerticalList.SelectedItem = itemNo;
       //v.InvalidateViewState();
                                
      VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );
    //}

  }

  $rect <260,345,460,385>
  slot ItemRelease
  {
    sender; /* the method is called from the sender object */

    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !SimpleTouchHandler1.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( SimpleTouchHandler1.AutoDeflected )
      return;

    var int32 itemNo = VerticalList.GetItemAtPosition( SimpleTouchHandler1.CurrentPos );

     var Application::DropMenuItem v = (Application::DropMenuItem) VerticalList.GetViewForItem( itemNo );



    if ( itemNo >= 0 )
    {
      // Select the item in the Vertical List. Thereupon the item appears
      // highlighted
      
      VerticalList.SelectedItem = itemNo;
                              
      VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );
     
      MenuSelectionText.String = v.CaptionText.String;
     
      VerticalList.Visible = false;
      VerticalList.Enabled = false;

      postsignal onSelection;

    }
  }
}

$rect <1300,1170,1520,1210>
$output false
resource Resources::Bitmap DropDownSimpleBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\dropdown_simple.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1050,580,1200,620>
$output false
class InputActionnop : Application::Popup
{
  $rect <820,440,960,480>
  inherited property Bounds = <0,0,800,480>;

  $rect <866,38,1006,78>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 
  }

  $rect <860,235,1000,275>
  inherited method Init()
  {
    // TO DO: Write your code here ... 


    //Writable.TextEditor.ObtainFocus();

    //signal DelaySlot;

      /*
    if (   HorzBarSlider.CurrentValue == 0 )
    {
     RadioButton10.Enabled = false;
      RadioButton11.Enabled = false;
    }
    else
    {
     RadioButton10.Enabled = true;
      RadioButton11.Enabled = true;
     }
        */

  }

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle7
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Bounds = <10,10,770,450>;
    preset AlphaBlended = false;
  }

  $rect <735,490,935,530>
  property int32 InputAction = 0;

  $rect <470,520,670,560>
  onset InputAction
  {
    // The value doesn't change - nothing to do.
    if ( pure InputAction == value )
      return;

    // Remember the property's new value.
    pure InputAction = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    notifyobservers ^InputAction;

  }

  $rect <450,570,650,610>
  onget InputAction
  {
    return pure InputAction;
  }

  $rect <245,480,445,520>
  slot ChangeInputAction
  {
    Writable.TextEditor.String =  ((Flat::RadioButton)sender).Caption;
    ((Flat::RadioButton)sender).Selected = true;
  }

  $rect <0,525,200,565>
  slot DelaySlot
  {
    sender; /* the method is called from the sender object */

    var int32 i = HorzBarSlider.CurrentValue;
        
    if ( i == 0 )
    {
     RadioButton10.Enabled = false;
    RadioButton11.Enabled = false;
    }   
    else
    {
      RadioButton10.Enabled = true;
    RadioButton11.Enabled = true; 
    }      

    if ( i < 6 )
    {
        Text.String = "Input Delay (" + string( i*10) + " secs)";
    }
    else
    {
        var float f = ( ((float)i - 4.0) * 0.5 ) ;
        Text.String = "Input Delay (" + string( f ) + " mins)";
    }


  }

  $rect <5,495,205,535>
  slot ProceedSlot
  {
    sender; /* the method is called from the sender object */

    var int32 action = InputAction;
    var string location = Writable.TextEditor.String;
    var int32 flags = DelayChoice;

    if ( BypassDelay.Checked )  flags |= 32;
    if ( Inverted.Checked )     flags |= 4;
    if ( Latching.Checked )     flags |= 1;

    var int32 delaytime;
    var int32 i = HorzBarSlider.CurrentValue;

    if ( i < 6 )
    {
        delaytime = i * 10;
    }
    else
    {
        delaytime = ((i - 4) * 30 );

    }


    native ( action, location, flags, delaytime ) 
    {
        Command4( CMD_SET_INPUT_DE



    Hide();

  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton
  {
    preset Bounds = <30,20,180,65>;
    preset Outlet = ^InputAction;
    preset Selected = true;
    preset Label = "Fire";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton1
  {
    preset Bounds = <210,20,360,65>;
    preset OutletSelector = 3;
    preset Outlet = ^InputAction;
    preset Label = "Evacuate";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton2
  {
    preset Bounds = <20,101,170,146>;
    preset OutletSelector = 8;
    preset Outlet = ^InputAction;
    preset Label = "Undefined";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton3
  {
    preset Bounds = <20,144,170,189>;
    preset OutletSelector = 5;
    preset Outlet = ^InputAction;
    preset Label = "Pre Alarm";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton4
  {
    preset Bounds = <20,187,170,232>;
    preset OutletSelector = 2;
    preset Outlet = ^InputAction;
    preset Label = "Fault";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton5
  {
    preset Bounds = <20,360,170,405>;
    preset OutletSelector = 4;
    preset Outlet = ^InputAction;
    preset Label = "Security";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton6
  {
    preset Bounds = <20,317,220,362>;
    preset OutletSelector = 9;
    preset Outlet = ^InputAction;
    preset Label = "Fire Routing Ack";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton7
  {
    preset Bounds = <20,402,170,447>;
    preset OutletSelector = 7;
    preset Outlet = ^InputAction;
    preset Label = "Reset";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton8
  {
    preset Bounds = <20,273,170,318>;
    preset OutletSelector = 1;
    preset Outlet = ^InputAction;
    preset Label = "First Aid";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton9
  {
    preset Bounds = <20,230,195,275>;
    preset OutletSelector = 6;
    preset Outlet = ^InputAction;
    preset Label = "Ack / Silence";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <820,330,1020,370>
  property int32 DelayChoice = 1;

  $rect <820,370,1020,410>
  onset DelayChoice
  {
    // The value doesn't change - nothing to do.
    if ( pure DelayChoice == value )
      return;

    // Remember the property's new value.
    pure DelayChoice = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }
}

$rect <1040,630,1240,670>
$output false
class InputAction : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,210>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <80,350,860,670>;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton
  {
    preset Bounds = <10,42,120,90>;
    preset OutletSelector = (int32)Application::Action.Fire;
    preset Outlet = ^inputAction;
    preset Selected = true;
    preset Label = "Fire";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton1
  {
    preset Bounds = <130,45,260,90>;
    preset OutletSelector = (int32)Application::Action.Evacuation;
    preset Outlet = ^inputAction;
    preset Label = "Evacuate";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton2
  {
    preset Bounds = <410,92,550,139>;
    preset OutletSelector = (int32)Application::Action.Undefined;
    preset Outlet = ^inputAction;
    preset Label = "Undefined";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton3
  {
    preset Bounds = <410,42,550,87>;
    preset OutletSelector = (int32)Application::Action.General;
    preset Outlet = ^inputAction;
    preset Label = "General";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton4
  {
    preset Bounds = <10,92,160,137>;
    preset OutletSelector = (int32)Application::Action.Fault;
    preset Outlet = ^inputAction;
    preset Label = "Fault";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton5
  {
    preset Bounds = <270,42,400,87>;
    preset OutletSelector = (int32)Application::Action.Security;
    preset Outlet = ^inputAction;
    preset Label = "Security";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton6
  {
    preset Bounds = <10,142,210,187>;
    preset OutletSelector = (int32)Application::Action.RoutingAck;
    preset Outlet = ^inputAction;
    preset Label = "Fire Routing Ack";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton7
  {
    preset Bounds = <270,92,420,137>;
    preset OutletSelector = (int32)Application::Action.Reset;
    preset Outlet = ^inputAction;
    preset Label = "Reset";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton8
  {
    preset Bounds = <130,92,280,137>;
    preset OutletSelector = (int32)Application::Action.FirstAid;
    preset Outlet = ^inputAction;
    preset Label = "First Aid";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioButton9
  {
    preset Bounds = <270,142,445,187>;
    preset OutletSelector = (int32)Application::Action.Silence;
    preset Outlet = ^inputAction;
    preset Label = "Ack / Silence";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <9,1,299,36>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Input Action";
    preset Font = Flat::FontM;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <540,20>;
    preset Point1 = <150,20>;
    preset Color = #000000FF;
  }

  $rect <600,180,800,220>
  property int32 inputAction = 0;

  $rect <610,230,810,270>
  onset inputAction
  {
    // Remember the property's new value.
    pure inputAction = value;

    var WidgetSet::RadioButton v = (WidgetSet::RadioButton) this.first;

    while ( v != null )
    {
      if ( v.OutletSelector == value )
      {
          v.Selected = true;
      }
      else
      {
          v.Selected = false;
      }

      v = (WidgetSet::RadioButton) v.next;
    }

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }
}

$rect <1040,670,1240,710>
$output false
class InputSignal : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,170>;

  $rect <630,130,830,170>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <760,80,960,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <30,300,810,620>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <9,1,190,35>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Input Signal";
    preset Font = Flat::FontM;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <540,20>;
    preset Point1 = <150,20>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Inverted
  {
    preset Bounds = <206,50,335,95>;
    preset Label = "Inverted";
    preset Appearance = Application::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton Latching
  {
    preset Bounds = <397,50,517,95>;
    preset Label = "Latching";
    preset Appearance = Application::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton BypassDelay
  {
    preset Bounds = <10,50,159,95>;
    preset Label = "Bypass Outp. Delay";
    preset Appearance = Application::NormalCheckBox;
  }
}

$rect <1040,710,1240,750>
$output false
class InputDelay : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,140>;

  $rect <630,130,830,170>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <760,80,960,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <30,300,810,620>;
  }

  $rect <630,170,830,210>
  property int32 InputAction = 0;

  $rect <20,20,160,60>
  object Views::Text TitleText
  {
    preset Bounds = <9,0,140,36>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Input Delay";
    preset Font = Flat::FontM;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <540,20>;
    preset Point1 = <140,20>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <13,44,215,74>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Input Delay (0 secs)";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzBarSlider
  {
    preset Bounds = <226,40,543,82>;
    preset OnChange = DelaySlot;
    preset OnEnd = End;
    preset StepSize = 1;
    preset MaxValue = 14;
    preset CurrentValue = 0;
    preset Appearance = Application::NormalHorizontalSlider;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton DoubleKnock
  {
    preset Bounds = <11,92,201,135>;
    preset OutletSelector;
    preset Outlet = null;
    preset Selected = false;
    preset OnSelect = DKnock;
    preset Label = "Double Knock";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton Sustained
  {
    preset Bounds = <268,88,467,137>;
    preset OutletSelector = 2;
    preset Outlet;
    preset Selected = true;
    preset OnSelect = Sust;
    preset Label = "Sustained Input";
    preset Appearance = Application::NormalRadioButton;
  }

  $rect <230,250,390,290>
  slot DelaySlot
  {
    sender; /* the method is called from the sender object */

    var int32 i = HorzBarSlider.CurrentValue;
        
    if ( i == 0 )
    {
     DoubleKnock.Enabled = false;
    Sustained.Enabled = false;
    }   
    else
    {
      DoubleKnock.Enabled = true;
    Sustained.Enabled = true; 

     if (DelayChoice.isempty )
       
        DelayChoice = Application::Options[ Sustained];
    }      

    if ( i < 6 )                          
    {
        DelaySecs =  i * 10;
        Text.String = "Input Delay (" + string( DelaySecs ) + " secs)";
        
    }
    else
    {
        var float f = ( ((float)i - 4.0) * 0.5 ) ;
        DelaySecs =  f * 60.0;
        Text.String = "Input Delay (" + string( f, 2, 1 ) + " mins)";
    }


  }

  $rect <820,330,1020,370>
  property Application::Options DelayChoice = Application::Options[];

  $rect <820,370,1020,410>
  onset DelayChoice
  {
    // The value doesn't change - nothing to do.
    if ( pure DelayChoice == value )
      return;

    // Remember the property's new value.
    pure DelayChoice = value;


    if ( value.contains( Application::Options[ DoubleKnock ] ) )
    {
      DoubleKnock.Selected = true;
      Sustained.Selected = false;
    }
    else if ( value.contains( Application::Options[ Sustained ] ) )
    {
      DoubleKnock.Selected = false;
      Sustained.Selected = true;
    }

    // TO DO:
    // 
    // Now you can handle the alternation of the property.


  }

  $rect <620,250,820,290>
  slot End
  {
    sender; /* the method is called from the sender object */

    var Effects::PointEffect effect = new Effects::PointEffect;

    // Configure the animation duration and the timing (easing)
    effect.CycleDuration = 250;  // milliseconds
    effect.NoOfCycles    = 1;
    effect.Timing        = Effects::Timing.Exp_InOut;

    // Finally instruct the Outline Box to scroll its content with
    // the prepared animation until the 'view' is fully visible.
    ((Application::InputChannels) Owner).Outline.EnsureVisible( this, true, effect, null );

    ((Application::InputChannels) Owner).VerticalScrollbar.Position = 100;


  }

  $rect <400,230,600,270>
  property int32 DelaySecs = 0;

  $rect <390,260,590,300>
  onset DelaySecs
  {
    // The value doesn't change - nothing to do.
    if ( pure DelaySecs == value )
      return;

    // Remember the property's new value.
    pure DelaySecs = value;


    if ( value < 60 )                          
    {
        HorzBarSlider.CurrentValue = value / 10;

        Text.String = "Input Delay (" + string( value ) + " secs)";
        
    }
    else
    {
        HorzBarSlider.CurrentValue = ( value / 30 ) + 4;

        Text.String = "Input Delay (" + string( value / 60, 2, 1 ) + " mins)";
    }

    if ( value == 0 )
    {
      DoubleKnock.Enabled = false;
      Sustained.Enabled = false;
    }
    else
    {
      DoubleKnock.Enabled = true;
      Sustained.Enabled = true;

      if ( !DoubleKnock.Selected && !Sustained.Selected )
      {
         Sustained.Selected = true;
      }
    }
        



    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <0,150,200,190>
  slot DKnock
  {
    sender; /* the method is called from the sender object */

    Sustained.Selected = false;

    DelayChoice = DelayChoice + Application::Options[ DoubleKnock];
    DelayChoice = DelayChoice - Application::Options[ Sustained];



  }

  $rect <260,150,460,190>
  slot Sust
  {
    sender; /* the method is called from the sender object */

    DelayChoice = DelayChoice + Application::Options[ DoubleKnock];
    DelayChoice = DelayChoice - Application::Options[ Sustained];

  }
}

$rect <0,1340,200,1380>
$output false
class BootMenuRes
{
  $rect <20,60,220,100>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font0 = Resources::FontSmall;
  }

  $rect <50,200,250,240>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <40,300,240,340>
  object WidgetSet::PushButton PushButton
  {
    preset IconFrameDisabled = 0;
    preset IconFrame = 0;
    preset Label = "Caption";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <340,100,540,140>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <10,350,210,390>
  object Views::Text Text
  {
    preset Bounds = <0,0,100,30>;
    preset String = "T";
    preset Font = Resources::FontSmall;
  }
}

$rect <200,1340,400,1380>
$output false
autoobject Application::BootMenuRes BootMenuRes1;

$rect <0,1390,200,1430>
$output false
class BootMenuComponent : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,300,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    HorizontalValueBar.CurrentValue = 0;
    PushButton.IconFrame = 0;
    PushButton.IconFrameDisabled = -1;
    VerticalScrollbar.ContentArea = 100;
    VerticalScrollbar.ViewArea = 10;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,15,100,45>;
    preset String = "Text";
    preset Font = Resources::FontSmall;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <0,75,200,125>;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Bounds = <231,0,270,190>;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,145,150,195>;
    preset Label = "Caption";
    preset Appearance = WidgetSet::PushButton_Medium;
  }
}

$rect <700,630,900,670>
$output false
class EditDeviceItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,470,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Application::ModifyZoneItem DynamicAreaHead
  {
    preset Bounds = <0,0,470,40>;
    preset Embedded = true;
    preset ZoneNum = 16;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,50,470,200>;
    preset Embedded = false;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset ItemHeight = 50;
    preset NoOfItems = 10;
    preset ItemClass = Application::ModifyDeviceItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <50,310,190,350>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    var Core::VerticalList vlist = (Core::VerticalList) sender;

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = vlist.Item;

     
    var Application::ModifyDeviceItem item = (Application::ModifyDeviceItem) vlist.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    // Configure the item view ...
    item.UnitNum = itemNo + 1;


    //ZoneText.String = "Zone 15 Unit " + string( itemNo + 1 );

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    item.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );

    var int32 z = zoneNum;
    var int32 u = item.UnitNum;
    var string s = "Somewhere..";
     
    native( z, u )
    {
      Command cmd;

      cmd.int0 = z;
      cmd.int1 = u; 

      Command0( CMD_GET_ZONE_DEVICE, &cmd );
     
      DeviceConfig* d = (DeviceConfig*) cmd.int3;
      
      s = EwNewStringAnsi( d->location );
    }

    item.DescriptionText.String = s;
        
  }

  $rect <690,10,890,50>
  method void LoadZone()
  {
    /* The template just returns the given argument... */

    var string zone;

    if ( OnSetzoneNum == 0 )
    {
      zone = "Panel I/O";
    }
    else
    {
      zone = "Zone " + OnSetzoneNum;
    }

    return;
  }

  $rect <490,30,690,70>
  property int32 zoneNum = 0;

  $rect <490,70,690,110>
  onset zoneNum
  {
    // The value doesn't change - nothing to do.
    if ( pure zoneNum == value )
      return;

    // Remember the property's new value.
    pure zoneNum = value;

    if ( OnSetzoneNum == 0 )
    {
      DynamicAreaHead.Text.String = "Panel I/O";
    }
    else
    {
      DynamicAreaHead.Text.String = "Zone " + OnSetzoneNum;
    }

    var int32 zn = zoneNum;
    var int32 devs = 1;

    native
    {
       Command cmd;

       cmd.int0 = zn

       Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );

       devs = cmd.int1;
    }

    VerticalList.NoOfItems = devs;
    VerticalList.InvalidateItems( 0, devs - 1 );
    VerticalList.InvalidateViewState();

  }
}

$rect <480,1430,720,1470>
$output false
autoobject WidgetSet::ToggleButtonConfig NotmalToggleButton
{
  preset LabelOnColorActive = #000000FF;
  preset LabelOnColorFocused = #000000FF;
  preset LabelOnColorDisabled = #939393FF;
  preset LabelOnColorDefault = #000000FF;
  preset LabelOffColorActive = #000000FF;
  preset LabelOffColorFocused = #000000FF;
  preset LabelOffColorDisabled = #939393FF;
  preset LabelOffColorDefault = #000000FF;
  preset LabelMarginRight = 75;
  preset IconMarginRight = 75;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = Resources::FontMedium;
  preset LabelOffFont = Resources::FontMedium;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToRight];
  preset FaceOnFrameActive = 7;
  preset FaceOnFrameFocused = 5;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 3;
  preset FaceOnActive = WidgetSet::SwitchMedium;
  preset FaceOnFocused = WidgetSet::SwitchMedium;
  preset FaceOnDisabled = WidgetSet::SwitchMedium;
  preset FaceOnDefault = WidgetSet::SwitchMedium;
  preset FaceOffFrameActive = 6;
  preset FaceOffFrameFocused = 4;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 2;
  preset FaceOffActive = WidgetSet::SwitchMedium;
  preset FaceOffFocused = WidgetSet::SwitchMedium;
  preset FaceOffDisabled = WidgetSet::SwitchMedium;
  preset FaceOffDefault = WidgetSet::SwitchMedium;
  preset WidgetMinSize = <70,39>;
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'switch'.
$rect <720,1420,1020,1460>
$output false
autoobject WidgetSet::ToggleButtonConfig Switch_Medium
{
  preset LabelOnColorActive = #6C6E70FF;
  preset LabelOnColorFocused = #6C6E70FF;
  preset LabelOnColorDisabled = #A8ABABFF;
  preset LabelOnColorDefault = #6C6E70FF;
  preset LabelOffColorActive = #6C6E70FF;
  preset LabelOffColorFocused = #6C6E70FF;
  preset LabelOffColorDisabled = #A8ABABFF;
  preset LabelOffColorDefault = #6C6E70FF;
  preset LabelMarginRight = 75;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #A8ABABAA;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #A8ABABAA;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginRight = 75;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = Resources::FontMedium;
  preset LabelOffFont = Resources::FontMedium;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToRight];
  preset FaceOnFrameActive = 7;
  preset FaceOnFrameFocused = 5;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 3;
  preset FaceOnActive = WidgetSet::SwitchMedium;
  preset FaceOnFocused = WidgetSet::SwitchMedium;
  preset FaceOnDisabled = WidgetSet::SwitchMedium;
  preset FaceOnDefault = WidgetSet::SwitchMedium;
  preset FaceOffFrameActive = 6;
  preset FaceOffFrameFocused = 4;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 2;
  preset FaceOffActive = WidgetSet::SwitchMedium;
  preset FaceOffFocused = WidgetSet::SwitchMedium;
  preset FaceOffDisabled = WidgetSet::SwitchMedium;
  preset FaceOffDefault = WidgetSet::SwitchMedium;
  preset WidgetMinSize = <70,39>;
}

$rect <700,590,900,630>
$output false
class ZoneToggle : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    if ( isDevice )
    {
                Image.Visible = true;
                Image1.Visible = false;
                DescriptionText.Visible = true;
                UnitNumberText.Visible = true;
                Text.Visible = false;
                ActionButton.Enabled = true;
                ActionButton.Visible = true;
                             
                UnitNumberText.String = "Zone " + string(ZoneNum) + "  Unit " + string( UnitNum );
                
    }
    else if ( isZone )
    {
           Image.Visible = false;
           Image1.Visible = true;
           DescriptionText.Visible = false;
           UnitNumberText.Visible = false;
           Text.Visible = true;
           ActionButton.Enabled = false;
           ActionButton.Visible = false;

           Text.String = "Zone " + string(ZoneNum) ;
           

          if ( ((Application::Modify)Owner.Owner).zoneExpanded[ ZoneNum ] )
          {
             Image1.Bitmap = Application::CollapseBitmap;
          }
          else
          {
              Image1.Bitmap = Application::ExpandBitmap;
          }   
     }
     else    // neither
     {
               Image.Visible = false;
                Image1.Visible = false;
                DescriptionText.Visible = false;
                UnitNumberText.Visible = false;
                Text.Visible = false;
                ActionButton.Enabled = false;
                ActionButton.Visible = false;
                
                UnitNumberText.String = "";
     }           
    /*
      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Text UnitNumberText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <60,0,200,17>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Application::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <60,15,415,40>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Hallway, Front building 2";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <510,0,550,40>;
    preset Bitmap = Application::FireAlarmBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <7,5,37,35>;
    preset Bitmap = Application::ExpandBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <60,5,230,36>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 1";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <50,0>;
    preset Point2 = <50,40>;
    preset Point1 = <0,40>;
    preset OnPress = ToggleHandler;
  }

  $rect <670,180,870,220>
  slot ToggleHandler
  {
    sender; /* the method is called from the sender object */

    var Application::Modify modify = (Application::Modify) Owner.Owner;

    modify.zoneExpanded[ ZoneNum ] = !modify.zoneExpanded[ ZoneNum ];

    var Core::VerticalList lst = (Core::VerticalList) Owner;

      var int32 devs = 4;
      var int32 zone = ZoneNum;

      native( devs, zone )
      {
        Command cmd;
        cmd.int0 = zone;

        Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
        devs = cmd.int0;
      }


    if ( modify.zoneExpanded[ ZoneNum ] )
    {
      lst.NoOfItems = lst.NoOfItems + devs;
    }
    else
    {
      lst.NoOfItems = lst.NoOfItems - devs;
    }


    lst.InvalidateItems( 0, lst.NoOfItems - 1 );

    lst.InvalidateViewState();

     modify.VertScrollbar.ContentArea = lst.NoOfItems * lst.ItemHeight;
      modify.VertScrollbar.ViewArea = lst.Bounds.h;
     modify.VertScrollbar.InvalidateViewState();

  }

  $rect <690,20,890,60>
  slot EditSlot
  {
    sender; /* the method is called from the sender object */

    var Application::ModifyPopup p = new Application::ModifyPopup;

    var Core::Root r = GetRoot();

    p.device = Application::Lib.GetConfig( UnitNum );

    postsignal p.SetFocus;

    p.Show( GetRoot() );  

    /*

    var string location = "??";
    var uint16 dev = UnitNum;
    var uint8 flags = 0;
    var uint8 vol = 0;
    var uint8 frate = 0;
    var    int32 icount = 0;
    var    int32 ocount = 0;
    var int32 numzones = 32;

    native( location, dev, flags, frate, vol, ocount, icount )
    {
       Command cmd;
       
       Command0( CMD_GET_NUM_ZONE_LEDS, &cmd );
       numzones = cmd.int0;

       cmd.int0 = (int)dev & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );

       if ( cmd.int0 != 0 )
       {
          InputChannel* input;
          OutputChannel* output;

          DeviceConfig* d = (DeviceConfig*) cmd.int0;
       
          location = EwNewStringAnsi( d->location );

          flags = d->flags;
      //    frate = d->flashRate;
      //    vol = d->volume;
         
          for( input = d->input; input < d->input + 16; input++ )
          {
             if ( input->type != 0 ) icount = icount + 1;
          }
          for( output = d->output; output < d->output + 16; output++ )
          {
             if ( output->type != 0 ) ocount = ocount + 1;
          }

        }
        else
        {
          location = EwNewStringAnsi( "???" );
        }
         
     }
    p.DropDownMenu.numItems = numzones;
    p.DropDownMenu.VerticalList.SelectedItem = ZoneNum - 1;

    p.DropDownMenu.MenuSelectionText.String = "Zone " + string( ZoneNum );


    if ( (flags & 1) == 1 )
    { 
      p.ToggleButton.Enabled = true;
      p.SecondsText.Color = #FFFFFFFF;
    }
    else
    {
      p.ToggleButton.Enabled = false;
      p.SecondsText.Color = #999999FF;
    }

    if ((flags & 2) == 2 )
    {
      p.HorizontalSlider.Enabled = true;
      p.VolumeText.Color = #FFFFFFFF;
    }
    else
    {
      p.HorizontalSlider.Enabled = false;
      p.VolumeText.Color = #999999FF;
    }

    //p.Writable.TextEditor.Text.String = location;
    p.Writable.TextEditor.String = location;

    p.HorizontalSlider.CurrentValue = vol;
    p.ToggleButton.Checked = frate == 0;

    if ( icount == 0 )
    {
      p.InputChanButton.Enabled = false;
    }
    else
    {
      p.InputChanButton.Enabled = true;
    }

    if ( ocount == 0 )
    {
      p.OutputChanButton.Enabled = false;
    }
    else
    {
      p.OutputChanButton.Enabled = true;
    }

    //p.Writable.TextEditor.ObtainFocus();
    postsignal p.GetFocus;

    p.Show( GetRoot() );                       */

  }

  $rect <70,80,270,120>
  property uint16 UnitNum = 0;

  $rect <70,130,270,170>
  property uint8 ZoneNum = 0;

  $rect <320,80,520,120>
  property bool isDevice = false;

  $rect <320,125,520,165>
  property bool isZone = false;

  $rect <20,20,160,60>
  object WidgetSet::PushButton ActionButton
  {
    preset Bounds = <420,0,505,40>;
    preset OnRelease = EditSlot;
    preset Label = "Edit";
    preset Appearance = Application::NormalPushButton;
  }
}

$rect <690,380,890,420>
$output false
class MessAboutComponent : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,300,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,180,190>;
    preset OnLoadItem = OnLoadItem;
    preset NoOfItems = 33;
    preset ItemClass = Application::MessItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <290,60,490,100>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Application::MessItem itemView = (Application::MessItem)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.Property = itemNo;
    itemView.InvalidateViewState();

    //itemView.String = "Item #" + string( itemNo );
    //itemView.Font   = Resources::FontMedium;
    //itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Bounds = <181,0,220,190>;
    preset OnScroll = Slot;
    preset ViewArea = 300;
    preset ContentArea = 3000;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <350,130,550,170>
  slot Slot
  {
    sender; /* the method is called from the sender object */

    VerticalList.ScrollOffset = -VerticalScrollbar.Position;

  }
}

$rect <860,330,1060,370>
$output false
class MessItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,300,70>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    Text.String = " item #" + string(Property);

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,5,100,35>;
    preset String = "Text";
    preset Font = Resources::FontMedium;
  }

  $rect <310,10,510,50>
  property int32 Property = 0;
}

$rect <260,1180,460,1220>
$output false
class DropMenuItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,220,40>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <650,60,850,100>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
     
    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    //var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) ;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color  = #AAAAAAFF;
      Border.Visible    = false;
      CaptionText.Color = #888888FF;
    }

    else if ( pressed )
    {
      Background.Color  = #8BB8E8FF;
      Border.Color      = #000000FF;
      Border.Visible    = true;
      CaptionText.Color = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Color  = #FFFFFFFF;
      Border.Color      = #444444FF;
      Border.Visible    = true;
      CaptionText.Color = #000000FF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color  = #FFFFFFFF;
      Border.Visible    = false;
      CaptionText.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    //pressed  = isPressed;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <370,20,590,190>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
    preset Width = 1;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,210,40>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  // State management
  note group Note4
  {
    attr Bounds = <640,30,860,240>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,190,850,230>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,150,850,190>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,110,850,150>
  var bool enabled = true;
}

$rect <0,1440,180,1480>
$output false
class ProgressPopup : Application::Popup
{
  $rect <0,250,140,290>
  inherited property Bounds = <0,0,430,230>;

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <38,80,368,125>;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <38,43,218,68>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Progress";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <148,149,260,190>;
    preset OnRelease = CancelSlot;
    preset Label = "Cancel";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <460,20,630,60>
  object Core::Timer Timer
  {
    preset OnTrigger = Slot;
    preset Period = 800;
  }

  $rect <460,60,620,100>
  slot Slot
  {
    sender; /* the method is called from the sender object */


    var int16 prog;

    native ( prog )
    {
      Command cmd;

      Command0( CMD_GET_PROGRESS, &cmd );

      prog = cmd.int0;
    }

    HorizontalValueBar.CurrentValue = prog;


  }

  $rect <170,250,310,290>
  slot CancelSlot
  {
    sender; /* the method is called from the sender object */

    Visible = false;
    Timer.Enabled = false;

    native  
    {
      Command cmd;

      Command0( CMD_CANCEL_PROGRESS, &cmd );
    }

  }

  $rect <520,140,720,180>
  object Core::SystemEventHandler EndEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = Application::Devices.EndProgressEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <560,180,760,220>
  slot onEvent
  {
    Timer.Enabled = false;

    var Application::Progress p = (Application::Progress) EndEventHandler.Context;


    if ( p.amount == -1  )
    {
     PushButton.Label = "Failed";
     HorizontalValueBar.CurrentValue = 0;
     
    }
    else  
    {
     PushButton.Label = "Success";  
     HorizontalValueBar.CurrentValue = 100; 
    }

     


    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }
}

$rect <1050,500,1200,540>
$output false
class OutputChannels : Application::Popup
{
  $rect <820,440,960,480>
  inherited property Bounds = <0,0,800,480>;

  $rect <920,90,1060,130>
  inherited method UpdateLayout()
  {
    // TO DO: Write your code here ... 


    VerticalScrollbar.ContentArea = Outline.GetContentArea( Core::ViewState[ Enabled] ).h + (Outline.CountViews()-1) * Outline.Space;

    VerticalScrollbar.ViewArea = Outline.Bounds.h;

  }

  $rect <860,235,1000,275>
  inherited method Init()
  {
    /*

    var int32 d = DevNumber;
    var int32 c = ChanIndex;
    var int32 z = ZoneNumber;

    var bool bypass = false;
    var bool invert = false;
    var bool latch = false;
    var bool pre = false;

    var int32 delay = 0;
    var int32 action = 0;
    var int32 device;

     native ( z, d, c, bypass, invert, latch, pre, action, delay, device )
     {
        Command cmd;

        cmd.int0 = d;  
        cmd.int1 = z; 

        Command0( CMD_GET_DEVICE, &cmd );

        DEVCONFIG* d = (DEVCONFIG*) cmd.int1;

        INPUTSET* input = d->inputSetting + c;

        bypass = input->flags & DEVICE_OPTION_IGNORE_DELAY;
        invert = input->flags & DEVICE_OPTION_INVERTED;
        latch  = input->flags & DEVICE_OPTION_LATCHING;
        pre    = input->flags & DEVICE_OPTION_HAS_PRE_ALARM;

       
        delay = input->delay;   
        action = input->action;
        device = (int) d;
     }

    this.InputAction1.inputAction = action;
    this.InputSignal.BypassDelay.Checked = bypass;
    this.InputSignal.Inverted.Checked = invert;
    this.InputSignal.Latching.Checked = latch;
    this.InputSignal.PreAlarm.Checked = pre;

    this.InputDelay.HorzBarSlider.CurrentValue = 0; // ?

    var int16 i = 0;
    */
    /*
    while ( i < 16 )
    {
      var int16 type = i + 1;
       native (type, device, i )
       {
          DEVCONFIG* d = (DEVCONFIG*) device;

          INPUTSET* input = d->inputSetting + i;

          type = input->type;
       }
         
       switch ( type )
       {
          case 0 : 
          {
            this.DropDownMenu.numItems = i;
            i = 16;
          }
          case 1 : DropDownMenu.Array[ i] = "Smoke";
          case 2 : DropDownMenu.Array[ i] = "Heat A1R";
          case 3 : DropDownMenu.Array[ i] = "Heat B" ;
          case 4 : DropDownMenu.Array[ i] = "PIR";
          case 5 : DropDownMenu.Array[ i] = "Call point";
          
          default :  DropDownMenu.Array[ i] = "Channel " + string( i + 1);
        }
        i = i + 1;
    }                               
    */ 

  }

  $rect <20,20,160,60>
  inherited object Rectangle4
  {
    preset ColorBL = #191919BC;
    preset ColorBR = #19191900;
    preset ColorTR = #19191900;
    preset ColorTL = #19191900;
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle6
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle7
  {
    preset AlphaBlended = true;
  }

  $rect <20,20,160,60>
  inherited object Rectangle3
  {
    preset Bounds = <10,10,770,450>;
    preset Color = #C3C3C3FF;
    preset AlphaBlended = false;
  }

  $rect <5,495,205,535>
  slot ProceedSlot
  {
    sender; /* the method is called from the sender object */

    signal Select;


    /*     
    var int16 action = InputAction1.inputAction; 
    var int16 flags = 0;
    var int16 delaytime = InputDelay.DelayChoice;

    if ( InputDelay.Sustained.Selected ) flags = flags | 2;
    if ( InputDelay.DoubleKnock.Selected )   flags = flags | 8;   
    if ( InputSignal.BypassDelay.Checked )  flags = flags | 32;
    if ( InputSignal.Inverted.Checked )     flags = flags | 4;
    if ( InputSignal.Latching.Checked )     flags = flags | 1;

    //var string location =  
     
    var int16 device = DevNumber;
    var int16 zone = ZoneNumber;
    var int16 chan = ChanIndex;

    native ( action, flags, delaytime, zone, device, chan ) 
    {
    //   char loc[ 41];
    //   EwStringToAnsi( location, loc, 40, '-' );
         
       Command8S( CMD_SET_INPUT_CHANNEL, zone, device, chan, action, flags, delaytime, 0, 0 );
    }

           
    */
                 
    Hide();

  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <24,20,130,50>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Channel";
    preset Font = Resources::FontMedium;
    preset Embedded = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle9
  {
    preset Bounds = <177,20,727,440>;
    preset Color = #737373FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Bounds = <729,20,769,440>;
    preset OnScroll = Scroll;
    preset ViewArea = 1000;
    preset ContentArea = 1000;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <177,20,727,440>;
    preset OnSlide = TouchScroll;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <177,20,727,440>;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <30,379,155,434>;
    preset OnRelease = ProceedSlot;
    preset Label = "Proceed";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <177,20,727,440>;
    preset SlideHandler = SlideTouchHandler;
    preset Space = 0;
    preset Formation = Core::Formation.TopToBottom;
  }

  $rect <850,150,1000,190>
  slot Scroll
  {
    sender; /* the method is called from the sender object */

    Outline.ScrollOffset.y = -VerticalScrollbar.Position;

  }

  $rect <20,20,160,60>
  object Application::DropDownMenu DropDownMenu
  {
    preset Bounds = <17,20,172,360>;
    preset onSelection = Select;
    preset GetItemCallback = LoadMenu;
  }

  $rect <840,190,990,230>
  slot TouchScroll
  {
    sender; /* the method is called from the sender object */

    VerticalScrollbar.Position = -Outline.ScrollOffset.y;

  }

  $rect <30,80,140,120>
  slot Select
  {
     
    ChanIndex = DropDownMenu.VerticalList.SelectedItem;


    /*

    var int16 chan = ChanIndex;
    var int32 dev = DevNumber;
    var int32 actions = 0;

    var uint8 type = 0;
    var uint8 delay1 = 0;
    var uint8 delay2 = 0;

    var Application::ActionBits b = Application::ActionBits[];

    if ( OutputAction.fire.Checked )   b = b + Application::ActionBits[ Fire ];
    if ( OutputAction.evac.Checked )   b = b + Application::ActionBits[ Evacuation ];
    if ( OutputAction.secure.Checked ) b = b + Application::ActionBits[ Security ];
    if ( OutputAction.pre.Checked )    b = b + Application::ActionBits[ General ];
    if ( OutputAction.fault.Checked )  b = b + Application::ActionBits[ Fault ];
    if ( OutputAction.aid.Checked )    b = b + Application::ActionBits[ FirstAid ];

    actions = Application::Lib.GetBits( b );

    var Application::Options flags = Application::Options[];

    if (OutputSignal.silenceable.Checked)   flags = flags + Application::Options[ Silenceable ];
    if ( OutputSignal.inverted.Checked)     flags = flags + Application::Options[ Inverted ];
    if ( OutputSignal.ignore.Checked)       flags = flags + Application::Options[ IgnoreDelay ];

    delay1 = OutputDelays.HorzBarSlider.CurrentValue;
    delay2 = OutputDelays.HorzBarSlider1.CurrentValue;


    native( chan, dev, actions, type, flags, delay1, delay2 )
    {
       Command cmd;

       cmd.int0 = (int)dev & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );

       if ( cmd.int0 != 0 )
       {
          OutputChannel* output;

          DeviceConfig d = *(DeviceConfig*) cmd.int0;
        
          output = d.output + chan;
          
          output->actions = actions;
          output->flags = (uint16) flags;     
          output->delay1 = delay1;
          output->delay2 = delay2;

          cmd.int0 = dev;
          cmd.int1 = (int) &d;

          Command0( CMD_SET_DEVICE_ALL, &cmd );
       }
    }
    */

  }

  $rect <10,130,150,170>
  slot LoadMenu
  {
     
    var Application::DropDownMenu m = ( Application::DropDownMenu) sender;
     
    if ( device != null )
    { 
      m.itemName = Application::Lib.TypeName( device.outputs[ m.itemIndex ].type );
    }
    else m.itemName = "";



  }

  $rect <960,0,1160,40>
  property int32 ChanIndex = 0;

  $rect <960,40,1160,80>
  onset ChanIndex
  {
    if ( device != null && value < Application::Lib.NumOutputChannels( device.unitnum ) )
    {
      // Remember the property's new value.
      pure ChanIndex = value;

      var Application::OutputChannel ch = device.outputs[ ChanIndex ];

      if ( ch != null )
      {
         OutputAction.fire.Checked = ch.actions.contains( Application::ActionBits[ Fire ] );
         OutputAction.evac.Checked = ch.actions.contains( Application::ActionBits[ Evacuation ] );
         OutputAction.fault.Checked = ch.actions.contains( Application::ActionBits[ Fault ] );
         OutputAction.aid.Checked = ch.actions.contains( Application::ActionBits[ FirstAid ] );
         OutputAction.pre.Checked = ch.actions.contains( Application::ActionBits[ General ] );
         OutputAction.secure.Checked = ch.actions.contains( Application::ActionBits[ Security ] );
         
         OutputSignal.ignore.Checked = ch.flags.contains( Application::Options[ IgnoreDelay ] );
         OutputSignal.inverted.Checked = ch.flags.contains( Application::Options[ Inverted ] );
         OutputSignal.silenceable.Checked = ch.flags.contains( Application::Options[ Silenceable ] );

         OutputDelays.HorzBarSlider.CurrentValue = ch.delay1;
         OutputDelays.HorzBarSlider1.CurrentValue = ch.delay2;

         DropDownMenu.VerticalList.SelectedItem = ChanIndex;
         DropDownMenu.MenuSelectionText.String = Application::Lib.TypeName( ch.type );
         DropDownMenu.numItems = device.NumOutputs( );

         var int32 n;
         var bool extra = false;
         for ( n = 0; n < device.params.size; n = n + 1 )
         {
            if ( device.params[n] != null )
            {
               var Application::Parameter p = device.params[n];

               if ( p.code != Application::ParamCode.Unused && p.channel == ChanIndex )
               {
                  if ( extra == false )
                  {
                     extra = true;
                     var Application::ParamSpecific title = new Application::ParamSpecific;
                     title.Embedded = true;
                     Add( title, 122 );
                   }
                  if ( p.max - p.min == 1 )
                  {     
                     var Application::ParamToggle tog = new Application::ParamToggle;
                     tog.Embedded = true;
                     tog.param = p;
                     tog.Text2.String = p.name;
                     Add( tog, 123 );
                  }
                  else
                  { 
                     var Application::ParamSlider slide = new Application::ParamSlider;
                     slide.Embedded = true;
                     slide.param = p;
                     slide.Text2.String = p.name;
                     Add( slide, 123 );
                  }
               }
              
            }        
          }
       }
    }
     





     
  }

  $rect <20,20,160,60>
  object Application::OutputAction OutputAction
  {
    preset Bounds = <180,20,730,180>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Application::OutputSignal OutputSignal
  {
    preset Bounds = <180,180,730,300>;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Application::OutputDelays OutputDelays
  {
    preset Bounds = <180,300,730,445>;
    preset Embedded = true;
  }

  $rect <10,530,210,570>
  slot CancelSlot
  {
     
                 
    Hide();

  }

  $rect <860,320,1060,360>
  property Application::DeviceConfig device = null;

  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder Bounds1 1
  $reorder Rectangle 1
  $reorder Rectangle1 1
  $reorder Rectangle2 1
  $reorder Rectangle4 1
  $reorder Rectangle5 1
  $reorder Rectangle6 1
  $reorder Rectangle7 1
  $reorder Rectangle8 1
  $reorder Rectangle3 1
  $reorder Show 1
  $reorder mask 1
  $reorder touch 1
  $reorder root 1
  $reorder Hide 1
  $reorder Parent 1
}

$rect <890,630,1030,670>
$output false
class OutputAction : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,150>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <80,350,860,670>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <9,1,299,36>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Output Action";
    preset Font = Flat::FontM;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <540,20>;
    preset Point1 = <155,20>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton fire
  {
    preset Bounds = <10,46,110,86>;
    preset Label = "Fire";
    preset Appearance = Application::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton evac
  {
    preset Bounds = <130,47,260,87>;
    preset Label = "Evacuate";
    preset Appearance = Application::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton secure
  {
    preset Bounds = <270,44,400,84>;
    preset Label = "Security";
    preset Appearance = Application::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton pre
  {
    preset Bounds = <410,44,540,84>;
    preset Label = "General";
    preset Appearance = Application::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton fault
  {
    preset Bounds = <10,93,110,133>;
    preset Label = "Fault";
    preset Appearance = Application::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton aid
  {
    preset Bounds = <130,94,250,134>;
    preset Label = "First Aid";
    preset Appearance = Application::NormalCheckBox;
  }
}

$rect <900,670,1040,710>
$output false
class OutputSignal : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,115>;

  $rect <630,130,830,170>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <760,80,960,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <30,300,810,620>;
  }

  $rect <630,170,830,210>
  property int32 InputAction = 0;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <9,1,195,35>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Output Signal";
    preset Font = Flat::FontM;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <540,20>;
    preset Point1 = <165,20>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton silenceable
  {
    preset Bounds = <157,50,307,95>;
    preset OnSwitchOn = null;
    preset OnSwitchOff = null;
    preset Label = "Silenceable";
    preset Appearance = Application::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton inverted
  {
    preset Bounds = <8,50,150,95>;
    preset Label = "Inverted";
    preset Appearance = Application::NormalCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ignore
  {
    preset Bounds = <335,50,532,95>;
    preset OnSwitchOn = null;
    preset OnSwitchOff = null;
    preset Label = "Ignore delays at night";
    preset Appearance = Application::NormalCheckBox;
  }
}

$rect <900,710,1050,750>
$output false
class OutputDelays : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,145>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <30,300,810,620>;
  }

  $rect <20,20,160,60>
  object Views::Text TitleText
  {
    preset Bounds = <9,0,160,35>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Output Delays";
    preset Font = Flat::FontM;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <540,20>;
    preset Point1 = <170,20>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <13,46,215,76>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "First Delay (0 secs)";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzBarSlider
  {
    preset Bounds = <230,42,543,81>;
    preset OnChange = DelaySlot;
    preset OnEnd = End;
    preset MaxValue = 20;
    preset CurrentValue = 0;
    preset Appearance = Application::NormalHorizontalSlider;
  }

  $rect <265,185,465,225>
  slot DelaySlot
  {
    sender; /* the method is called from the sender object */
     
    var int32 i = HorzBarSlider.CurrentValue;
        
        

    var int32 i2 = HorzBarSlider1.CurrentValue;
        


    if ( i + i2 >= 20 ) i2 = 20 - i;


    if ( i == 0 )
    {
      // i2 = 0;
       HorzBarSlider1.Enabled = false;

    }
    else
    {
      HorzBarSlider1.Enabled = true;
    }

    HorzBarSlider1.CurrentValue = i2;


        var float f =  ((float)i * 0.5 ) ;
        
     var float f2 =  ((float)i2 * 0.5 ) ;


         Text.String = "First Delay (" + string( f, 2, 1 ) + " mins)";

        Text1.String = "Second Delay (" + string( f2, 2, 1 ) + " mins)";

       

  }

  $rect <470,210,670,250>
  slot End
  {
    sender; /* the method is called from the sender object */

    var int32 i = HorzBarSlider.CurrentValue;
     
        if ( i == 0 ) 
        {
         HorzBarSlider1.CurrentValue = 0;
         HorzBarSlider1.Enabled = false;
        Text1.Color = #888888FF;
         }
         else  
         {
         
         HorzBarSlider1.Enabled = true;
        Text1.Color = #000000FF;
         }
     
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <12,95,225,124>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Second Delay (0 secs)";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzBarSlider1
  {
    preset Bounds = <230,90,530,131>;
    preset OnChange = Delay2;
    preset OnEnd = null;
    preset MaxValue = 19;
    preset CurrentValue = 0;
    preset Appearance = Application::NormalHorizontalSlider;
  }

  $rect <255,235,455,275>
  slot Delay2
  {
    sender; /* the method is called from the sender object */
     
    var int32 i = HorzBarSlider.CurrentValue;

    var int32 i2 = HorzBarSlider1.CurrentValue;
        

    if ( i + i2 >= 20 ) i = 20 - i2;


    HorzBarSlider.CurrentValue = i;

       var float f =  ((float)i * 0.5 ) ;
        
        var float f2 =  ((float)i2 * 0.5 ) ;

         Text.String = "First Delay (" + string( f, 2, 1 ) + " mins)";

        Text1.String = "Second Delay (" + string( f2, 2, 1 ) + " mins)";

       
  }
}

$rect <240,260,380,300>
$output false
class TestZoneItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,555,50>;

  $rect <20,140,220,180>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    Text.String = "Zone " + string( ZoneNum );


    var Application::TreeView testpage = (Application::TreeView) Owner.Owner.Owner;

    if ( testpage != null )
    {
       var Application::ZoneFlags zf = Application::Lib.GetZoneFlags( ZoneNum );
       
       ToggleButton.Checked = zf.contains( Application::ZoneFlags[ OnTest] );

       if ( (testpage.zoneFlags[ ZoneNum ] & 1) == 1 )
       { 
           ExpandImage.Bitmap = Application::CollapseBitmap;
       }
       else
       {
            ExpandImage.Bitmap = Application::ExpandBitmap;
       }
       
       postsignal testpage.CountOnTest;
    }

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Views::Image ExpandImage
  {
    preset Bounds = <10,15,40,45>;
    preset Bitmap = Application::ExpandBitmap;
  }

  $rect <20,20,160,60>
  object XFlat::CheckBox CheckBox
  {
    preset Bounds = <60,10,210,49>;
    preset Enabled = true;
    preset OnChange = ToggleSlot;
    preset Caption = "";
    preset Outlet;
  }

  $rect <310,150,510,190>
  property uint16 ZoneNum = 0;

  $rect <530,70,730,110>
  slot ClearAll
  {
    sender ; /* the method is called from the sender object */

                                                                                        
    var Application::ZoneFlags zf = Application::Lib.GetZoneFlags( ZoneNum );

     
    zf = zf - Application::ZoneFlags[ OnTest];

    var int16 dev;
    var int16 devs = Application::Lib.NumDevsInZone( ZoneNum );

    for( dev = 0; dev < devs; dev = dev + 1 )
    {
        var int16 unitnum = Application::Lib.GetDevInZone( ZoneNum, dev );

        var Application::Device d = Application::Lib.GetDevice( unitnum );

        if ( d != null )
        {
           d.settings = d.settings - Application::DeviceSetting[ OnTest];

           var uint8 channel;
          
           for( channel = 0; channel < d.flags.size; channel = channel + 1 )
           {
              d.flags[ channel ] = d.flags[ channel ] - Application::ChannelFlags[ OnTest ];
           }
      
           Application::Lib.SetDevice( unitnum, d );
        }
    }


    var Application::TreeView testpage = (Application::TreeView) Owner.Owner.Owner;
      
    if ( testpage != null )
    {
      postsignal testpage.CountOnTest;
      testpage.VerticalList.InvalidateItems( 0, testpage.VerticalList.NoOfItems - 1 );
    }




  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <450,10,535,46>;
    preset OnRelease = ClearAll;
    preset Label = "Clear All";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <280,70,480,110>
  slot ToggleSlot
  {
    sender; /* the method is called from the sender object */


    var Application::TreeView testpage = (Application::TreeView) Owner.Owner.Owner;

    var Application::ZoneFlags zf = Application::Lib.GetZoneFlags( ZoneNum );

    if ( ((WidgetSet::ToggleButton) sender).Checked )
    {
      zf = zf + Application::ZoneFlags[ OnTest];
    }
    else
    {
      zf = zf - Application::ZoneFlags[ OnTest];
    }

    Application::Lib.SetZoneFlags( ZoneNum, zf );
     
    if ( testpage != null )
    {
      postsignal testpage.CountOnTest;
      testpage.VerticalList.InvalidateItems( 0, testpage.VerticalList.NoOfItems - 1 );
    }                                

  }

  $rect <10,70,210,110>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */

     

    if ( Visible )
    { 
      var Core::VerticalList lst = (Core::VerticalList) Owner.Owner;
        
      var Application::TreeView testpage = (Application::TreeView) Owner.Owner.Owner;
      
      var int32 devs = Application::Lib.NumDevsInZone( ZoneNum );

      var int32 total = devs; //?
     
      var int32 dev;
         
      for( dev = 0; dev < devs; dev=dev+1 )
      {
         var int32 unity = Application::Lib.GetDevInZone( ZoneNum, dev );

         if ( testpage.isDeviceExpanded( unity ) )
         {
            var Application::DeviceConfig config = Application::Lib.GetConfig( unity );

            total = total + config.NumInputs() + config.NumOutputs();
         }
      } 


      // if expanded
      if ( (testpage.zoneFlags[ZoneNum] & 1) == 0)
      {
        ExpandImage.Bitmap = Application::CollapseBitmap;
       
        testpage.zoneFlags[ZoneNum] = testpage.zoneFlags[ZoneNum] | 1;
       
        lst.NoOfItems = lst.NoOfItems + total;
      }
      else
      {
        ExpandImage.Bitmap = Application::ExpandBitmap;
        
        testpage.zoneFlags[ZoneNum] = testpage.zoneFlags[ZoneNum] & 254;

        lst.NoOfItems = lst.NoOfItems - total;
      }

     
    //  lst.InvalidateItems( 0, lst.NoOfItems - 1 );


      testpage.VertScrollbar.ContentArea = lst.NoOfItems * lst.ItemHeight;
      testpage.VertScrollbar.ViewArea = lst.Bounds.h;
      testpage.VertScrollbar.InvalidateViewState();
    }

  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <50,0>;
    preset Point2 = <50,50>;
    preset Point1 = <0,50>;
    preset OnPress = ToggleExpand;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <108,15,340,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text InTestText
  {
    preset Bounds = <340,15,415,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <60,0,205,50>;
    preset OnSwitchOn = ToggleSlot;
    preset OnSwitchOff = ToggleSlot;
    preset Label = "";
    preset Appearance = Application::LargeCheckBox;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder ExpandImage 6
  $reorder CheckBox 6
  $reorder Enabled 5
}

$rect <120,280,260,320>
$output false
class TestUnitItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,550,50>;

  $rect <40,135,240,175>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var Application::TreeView testpage = (Application::TreeView) Owner.Owner.Owner;


    if ( aState.contains( Core::ViewState[ Enabled ] )  )
    {
      DescriptionText.Color = #000000FF;
      Text.Color = #000000FF;

      if ( testpage.isDeviceExpanded( UnitNum ) )
      {
        Image1.Bitmap = Application::CollapseBitmap;

      }
      else
      {
        Image1.Bitmap = Application::ExpandBitmap;
      }
       Image1.Visible = true;

    }
    else
    {
       DescriptionText.Color = #AAAAAAFF;
       Text.Color = #AAAAAAFF;
       Image1.Visible = false;
    }
     

    Text.String = "Zone " + string( ZoneNum) + "  Unit " + string(UnitNum);


    var Application::ZoneFlags zf = Application::Lib.GetZoneFlags( ZoneNum );
       
    if ( zf.contains( Application::ZoneFlags[ OnTest] ) )
    { 
        this.CheckBox.Enabled = false;
        this.CheckBox.Checked = true;
    }
    else
    {
        CheckBox.Enabled = true;
        var Application::Device d = Application::Lib.GetDevice( UnitNum );

        if ( d != null ) CheckBox.Checked = d.settings.contains( Application::DeviceSetting[ OnTest] );
    }

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <395,175,595,215>
  property uint16 UnitNum = 0;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <135,1,295,25>;
    preset ColorBL = #000000FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #000000FF;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Application::VerdanaProSemiBold16;
    preset Color = #3D3D3DFF;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <135,19,505,46>;
    preset ColorBL = #000000FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #000000FF;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <39,11,69,41>;
    preset Bitmap = Application::ExpandBitmap;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <29,1>;
    preset Point3 = <79,1>;
    preset Point2 = <79,50>;
    preset Point1 = <29,50>;
    preset OnPress = ToggleExpand;
  }

  $rect <340,90,540,130>
  slot ToggleSlot
  {
    sender; /* the method is called from the sender object */


    var Application::Device d = Application::Lib.GetDevice( UnitNum );

    if ( d != null )
    {
      if ( CheckBox.Checked )
      {
        d.settings = d.settings + Application::DeviceSetting[ OnTest];
      }
      else
      {
        d.settings = d.settings - Application::DeviceSetting[ OnTest];  
      }
      Application::Lib.SetDevice( UnitNum, d );
    }


    var Application::TreeView testpage = (Application::TreeView) Owner.Owner.Owner;
      
    if ( testpage != null )
    {
      postsignal testpage.CountOnTest;
      testpage.VerticalList.InvalidateItems( 0, testpage.VerticalList.NoOfItems - 1 );
    }
     
  }

  $rect <50,75,250,115>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */

     

    if ( Visible )
    {
      var Core::VerticalList lst = (Core::VerticalList) Owner.Owner;

      var int32 devs = 4;  

      var Application::DeviceConfig dc = Application::Lib.GetConfig( UnitNum );
              
      var int32 channels = dc.NumInputs() + dc.NumOutputs();


      var Application::TreeView testpage = (Application::TreeView) Owner.Owner.Owner;

      if ( testpage != null )
      {
        if ( !testpage.isDeviceExpanded( UnitNum ) )
        {
            Image1.Bitmap = Application::CollapseBitmap;
            lst.NoOfItems = lst.NoOfItems + channels;
            testpage.SetExpanded( UnitNum, true );
        }
        else
        {
            Image1.Bitmap = Application::ExpandBitmap;
            lst.NoOfItems = lst.NoOfItems - channels;
            testpage.SetExpanded( UnitNum, false );
        }
     }
     
      lst.InvalidateItems( 0, lst.NoOfItems - 1 );

      lst.InvalidateViewState();


      testpage.VertScrollbar.ContentArea = lst.NoOfItems * lst.ItemHeight;
      testpage.VertScrollbar.ViewArea = lst.Bounds.h;
      testpage.VertScrollbar.InvalidateViewState();

    }

  }

  $rect <390,230,590,270>
  property uint8 ZoneNum = 0;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton CheckBox
  {
    preset Bounds = <80,0,140,50>;
    preset Enabled = false;
    preset OnSwitchOn = ToggleSlot;
    preset OnSwitchOff = ToggleSlot;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <400,300,540,340>
$output false
class TestItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,550,50>;

  $rect <50,200,250,240>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <40,135,240,175>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

     
    if ( TestChannelItem.Visible )
    {
      TestChannelItem.InvalidateViewState();
      TestChannelItem.HorizontalValueBar.InvalidateViewState();
    }


  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Application::TestUnitItem TestUnitItem
  {
    preset Bounds = <0,0,520,50>;
  }

  $rect <20,20,160,60>
  object Application::TestZoneItem TestZoneItem
  {
    preset Bounds = <0,0,550,50>;
  }

  $rect <20,20,160,60>
  object Application::TestChannelItem TestChannelItem
  {
    preset Bounds = <0,0,550,50>;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <0,300,120,340>
$output false
class TreeView : Core::Group
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <2,0,550,350>;
    preset Color = #353535FF;
    preset AlphaBlended = false;
    preset Visible = false;
  }

  $rect <0,550,200,590>
  inherited property Bounds = <0,0,600,350>;

  $rect <0,500,200,540>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <550,0,600,350>;
    preset OnScroll = ScrollPressSlot;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <210,420,360,460>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    signal onEvent1;

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <490,360,630,400>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */
               

    var Core::VerticalList vlist = (Core::VerticalList) sender;

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = vlist.Item;

     
    var Application::TestItem item = (Application::TestItem) vlist.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;


    var uint8 curZone = 1;


    var int32 i = 0;
    var int32 numZones = Application::Lib.NumZonesWithDevices();


     while ( numZones > 0 )
     {
          var int32 numdevs = Application::Lib.NumDevsInZone( curZone ); 
         
          if ( numdevs > 0 )
          {
            numZones = numZones - 1;

            if ( itemNo == i )
            {
              item.TestZoneItem.ZoneNum = curZone;
              item.TestZoneItem.Visible = true;
              item.TestZoneItem.Enabled = true;

              item.TestUnitItem.Visible = false;
              item.TestUnitItem.Enabled = false;

              item.TestChannelItem.Visible = false;
              item.TestChannelItem.Enabled = false;


        
              item.TestZoneItem.InvalidateViewState();
              return;
            }
            else
            {
               i = i + 1;
            }
            if (( zoneFlags[ curZone ] & 1) == 1 )    // if zone expanded
            {                             
                var int32 dev = 0;

                while ( dev < numdevs )
                {
                  var int16 unitno = Application::Lib.GetDevInZone( curZone, dev );
                    
                  var Application::Device device = Application::Lib.GetDevice( unitno );
                  var Application::DeviceConfig config = Application::Lib.GetConfig( unitno ); 

                  if ( i == itemNo )   
                  { 
                      item.TestUnitItem.Visible = true;

                      if ( device == null )
                      {
                        item.TestUnitItem.Enabled = false;
                      }
                      else
                      {
                        item.TestUnitItem.Enabled = true;
                      }

                      item.TestZoneItem.Visible = false;
                      item.TestZoneItem.Enabled = false;

                      item.TestChannelItem.Visible = false;
                      item.TestChannelItem.Enabled = false;

                      

                      item.TestUnitItem.UnitNum = unitno;
               
                      item.TestUnitItem.ZoneNum = curZone;


                      item.TestUnitItem.DescriptionText.String = config.location;                
                      // hack for above
                     /*
                      var int32 sptr = config.locationptr;
                      var string s;
                      native( sptr, s )
                      {
                          s = EwNewStringAnsi( (char*)sptr );
                      }
                      item.TestUnitItem.DescriptionText.String = s;
                       */
                      //end of hack

                      item.TestUnitItem.InvalidateViewState(); 

                      return;
                   }
                   else
                   {
                      i = i + 1;
                   }

                   if ( isDeviceExpanded( unitno ) )
                   {
                     var int32 chan = 0;

                     while ( config != null && config.inputs[ chan] != null && config.inputs[ chan].type != Application::ChannelType.None )
                     {
                           
                        if ( i == itemNo )
                        {
                          item.TestUnitItem.Visible = false;
                          item.TestUnitItem.Enabled = false;

                          item.TestZoneItem.Visible = false;
                          item.TestZoneItem.Enabled = false;

                          item.TestChannelItem.Visible = true;
                          item.TestChannelItem.Enabled = true;


                          item.TestChannelItem.ChanNum = chan;
                          item.TestChannelItem.UnitNum = unitno;
                          item.TestChannelItem.ZoneNum = curZone;

                          item.TestChannelItem.HorizontalValueBar.Enabled = true;
                          item.TestChannelItem.HorizontalValueBar.Visible = true;

                          if ( device.flags[ chan].contains( Application::ChannelFlags[ Active ] ) )
                          {
                            item.TestChannelItem.HorizontalValueBar.CurrentValue = 100;
                          }
                          else
                          {
                            item.TestChannelItem.HorizontalValueBar.CurrentValue = 0;
                          }

                          item.TestChannelItem.ToggleButton.Enabled = false;
                          item.TestChannelItem.ToggleButton.Visible = false;
                          item.TestChannelItem.CheckBox.Visible = true;
                          item.TestChannelItem.CheckBox.Enabled = true;

                          item.TestChannelItem.SmallDropDownMenu.Visible = false;
                          item.TestChannelItem.SmallDropDownMenu.Enabled = false;

                          item.TestChannelItem.ChannelName.String = Application::Lib.TypeName( config.inputs[ chan].type );

                          item.TestChannelItem.InvalidateViewState();
                         
                          return;
                        }
                        else
                        {
                           i = i + 1;
                        }
                        chan = chan + 1;
                      }
                              
                      chan = 0;
                      var Application::Action defau = Application::Action.Fire;

                      while ( config.outputs[ chan] != null && config.outputs[ chan].type != Application::ChannelType.None )
                      {
         
                         if ( i == itemNo )
                         {
                            item.TestUnitItem.Visible = false;
                            item.TestUnitItem.Enabled = false;

                            item.TestZoneItem.Visible = false;
                            item.TestZoneItem.Enabled = false;    

                            item.TestChannelItem.Visible = true;
                            item.TestChannelItem.Enabled = true;

                            item.TestChannelItem.ChanNum = chan;
                            item.TestChannelItem.UnitNum = unitno;
                            item.TestChannelItem.ZoneNum = curZone;

                            item.TestChannelItem.HorizontalValueBar.Visible = false;
                            item.TestChannelItem.HorizontalValueBar.Enabled = false;

                            item.TestChannelItem.ToggleButton.Enabled = true;
                            item.TestChannelItem.ToggleButton.Visible = true;

                            item.TestChannelItem.CheckBox.Visible = false;
                            item.TestChannelItem.CheckBox.Enabled = false;

                            item.TestChannelItem.SmallDropDownMenu.Visible = true;
                            item.TestChannelItem.SmallDropDownMenu.Enabled = true;

                            

                            if ( item.TestChannelItem.SmallDropDownMenu.selIndex == -1 ) //unset
                            {
                               item.TestChannelItem.SmallDropDownMenu.selIndex = (int32) defau;
                               item.TestChannelItem.DefaultAction = defau;
                               item.TestChannelItem.SmallDropDownMenu.Text.String = Application::Lib.ProfileName( defau );
                            }   

                            item.TestChannelItem.ChannelName.String = Application::Lib.TypeName( config.outputs[ chan].type ); 

                            item.TestChannelItem.InvalidateViewState();
                            return;
                         }
                         else
                         {
                            i = i + 1;
                         }

                         chan = chan + 1;
                      }         

                     
                  }
                  dev = dev + 1;
              }
           }
         }
         curZone = curZone + 1;
       }


        // EEK shouldnt be here
        item.TestUnitItem.Visible = false;
        item.TestZoneItem.Visible = false;
        item.TestChannelItem.Visible = false;
       
     
     

  }

  $rect <900,110,1100,150>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -VerticalList.ScrollOffset;


  }

  $rect <900,150,1100,190>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    VerticalList.ScrollOffset = -VertScrollbar.Position;
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems );
    VerticalList.InvalidateViewState();



  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel1
  {
    preset Bounds = <0,0,554,350>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2C2C2CFF;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,550,350>;
    preset OnSlide = ScrollDragSlot;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <2,2,552,348>;
    preset OnLoadItem = OnLoadItem;
    preset Endless = false;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 45;
    preset NoOfItems = 3;
    preset ItemClass = Application::TestItem;
  }

  $rect <800,270,1000,310>
  array uint8 zoneFlags[ 97 ];

  $rect <957,330,1187,370>
  object Core::SystemEventHandler SiteLoadedEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = Application::Devices.SiteLoadedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <960,365,1110,405>
  slot onEvent1
  {
     var int32 numZones = Application::Lib.NumZonesWithDevices();


    var int32 i = 0;
     
    for( i = 0; i < 97; i=i + 1 )
    {
      zoneFlags[ i] = 0;
    }
      

    VerticalList.NoOfItems = numZones ;
    VerticalList.InvalidateItems( 0, numZones - 1);
      
     

    VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;
    VertScrollbar.ViewArea = VerticalList.Bounds.h;
    VertScrollbar.InvalidateViewState();

  }

  $rect <620,0,820,40>
  property uint16 unitnum = 0;

  $rect <620,40,820,80>
  property uint16 zonenum = 0;

  $rect <620,100,820,140>
  property slot ZoneSelect = null;

  $rect <620,140,820,180>
  property slot ZoneDeSelect = null;

  $rect <620,180,820,220>
  property slot DeviceDeSelect = null;

  $rect <620,220,820,260>
  property slot DeviceSelect = null;

  $rect <700,310,900,350>
  array uint32 deviceFlags[ 544 ];

  $rect <660,380,860,420>
  method bool isDeviceExpanded( arg int32 i )
  {
    if ( i >= 2048+256 )
    {
      return (deviceFlags[ 512 + 16 + (i - (2048+256)) ] & 1) == 1;
    }
    else if ( i >= 2048 )
    {
      return (deviceFlags[ 512 + (i - 2048) ] & 1) == 1; 
    }
    else if ( i < 513 && i > 0 )
    {
      return (deviceFlags[ i-1] & 1) == 1;
    }
    return false;
  }

  $rect <660,420,860,460>
  method void SetExpanded( arg int32 i, arg bool val )
  {
     
    if ( val )
    {
      if ( i >= 2048+256 )
      {
        deviceFlags[ 512 + 16 + (i - (2048+256)) ] = deviceFlags[ 512 + 16 + (i - (2048+256)) ] | 1;
      }
      else if ( i >= 2048 )
      {
        deviceFlags[ 512 + (i - 2048) ] = deviceFlags[ 512 + (i - 2048) ] | 1; 
      }
      else if ( i < 513 )
      {
        deviceFlags[ i-1] = deviceFlags[ i-1] | 1;
      }
    }
    else
    {
    var uint32 b = 0xFFFFFFFE;
     if ( i >= 2048+256 )
      {
        deviceFlags[ 512 + 16 + (i - (2048+256)) ] = deviceFlags[ 512 + 16 + (i - (2048+256)) ] & b;
      }
      else if ( i >= 2048 )
      {
        deviceFlags[ 512 + (i - 2048) ] = deviceFlags[ 512 + (i - 2048) ] & b; 
      }
      else if ( i < 513 )
      {
        deviceFlags[ i-1] = deviceFlags[ i-1] & b;
      }
    }

  }

  $rect <660,450,860,490>
  method bool isDeviceSelected( arg int32 i )
  {
    if ( i >= 2048+256 )
    {
      return (deviceFlags[ 512 + 16 + (i - (2048+256)) ] & 2) == 2;
    }
    else if ( i >= 2048 )
    {
      return (deviceFlags[ 512 + (i - 2048) ] & 2) == 2; 
    }
    else if ( i < 513 && i > 0 )
    {
      return (deviceFlags[ i-1] & 2) == 2;
    }
    return false;
  }

  $rect <660,490,860,530>
  method void SetDeviceSelected( arg int32 i, arg bool val )
  {
     
    if ( val )
    {
      if ( i >= 2048+256 )
      {
        deviceFlags[ 512 + 16 + (i - (2048+256)) ] = deviceFlags[ 512 + 16 + (i - (2048+256)) ] | 2;
      }
      else if ( i >= 2048 )
      {
        deviceFlags[ 512 + (i - 2048) ] = deviceFlags[ 512 + (i - 2048) ] | 2; 
      }
      else if ( i < 513 )
      {
        deviceFlags[ i-1] = deviceFlags[ i-1] | 2;
      }
    }
    else
    {
     var uint32 b = 0xFFFFFFFD;
     if ( i >= 2048+256 )
      {
        deviceFlags[ 512 + 16 + (i - (2048+256)) ] = deviceFlags[ 512 + 16 + (i - (2048+256)) ] & b;
      }
      else if ( i >= 2048 )
      {
        deviceFlags[ 512 + (i - 2048) ] = deviceFlags[ 512 + (i - 2048) ] & b; 
      }
      else if ( i < 513 )
      {
        deviceFlags[ i-1] = deviceFlags[ i-1] & b;
      }
    }

             
  }

  $rect <870,450,1070,490>
  method bool isChanSelected( arg int32 i, arg int32 c )
  {
    var uint32 b = 1 << (c+16);

    if ( i >= 2048+256 )
    {
      return (deviceFlags[ 512 + 16 + (i - (2048+256)) ] & b) == b;
    }
    else if ( i >= 2048 )
    {
      return (deviceFlags[ 512 + (i - 2048) ] & b) == b; 
    }
    else if ( i < 513 && i > 0 )
    {
      return (deviceFlags[ i-1] & b) == b;
    }
    return false;

  }

  $rect <880,490,1080,530>
  method void SetChanSelected( arg int32 i, arg int32 c, arg bool val )
  {
    var uint32 b = 1 << (c+16);
     
    if ( val )
    {
      if ( i >= 2048+256 )
      {
        deviceFlags[ 512 + 16 + (i - (2048+256)) ] = deviceFlags[ 512 + 16 + (i - (2048+256)) ] | b;
      }
      else if ( i >= 2048 )
      {
        deviceFlags[ 512 + (i - 2048) ] = deviceFlags[ 512 + (i - 2048) ] | b; 
      }
      else if ( i < 513 )
      {
        deviceFlags[ i-1] = deviceFlags[ i-1] | b;
      }
    }
    else
    {
     if ( i >= 2048+256 )
      {
        deviceFlags[ 512 + 16 + (i - (2048+256)) ] = deviceFlags[ 512 + 16 + (i - (2048+256)) ] & (~b);
      }
      else if ( i >= 2048 )
      {
        deviceFlags[ 512 + (i - 2048) ] = deviceFlags[ 512 + (i - 2048) ] & (~b); 
      }
      else if ( i < 513 )
      {
        deviceFlags[ i-1] = deviceFlags[ i-1] & (~b);
      }
    }

     
  }

  $rect <940,0,1140,40>
  object Core::SystemEventHandler OnTestChangeEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = Application::Devices.OnTestChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <950,40,1150,80>
  slot onEvent
  {
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );



    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <410,500,560,540>
  slot CountOnTest
  {
    sender; /* the method is called from the sender object */


    /*

    var int32 i;
    var int32 unitCount = 0;


    var Core::VerticalList lst = (Core::VerticalList) Owner.Owner;

    var int32 zone;

     var int32 numZones = 2;

       native( numZones )
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }


    for( zone = 0; zone < numZones; zone = zone + 1 )
    {   
        unitCount = unitCount + UpdateZone( zone, false );    
    }

     */
    var Application::Application app = (Application::Application) Owner.Owner;

    if ( app != null )
    {
     // postsignal app.OnTest.Refresh;
    } 

  }

  $rect <410,410,610,450>
  method int32 UpdateZone( arg int32 zone, arg bool modify )
  {
                                                                     

      var int32 total = 0;
      var int32 devs = 4;
     

      native( devs, zone )
      {
        Command cmd;
        cmd.int0 = zone;

        Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
        devs = cmd.int0;
      }

                                                      
        var int32 dev;
        
     
        for( dev = 0; dev < devs; dev=dev+1 )
        {
            var int32 unity = dev + 1;

           native( zone, dev, unity )
           {
            Command cmd;
                    
            cmd.int0 = zone;
            cmd.int1 = dev;
            Command0( CMD_GET_DEV_IN_ZONE, &cmd );
            DeviceConfig* device = (DeviceConfig*) cmd.int0;

            if ( device != NULL )
            {
               unity = device->unit;
            }
           }
           if ( UpdateUnit( zone, unity, modify ) ) total = total + 1;

        }
       

        return total;
  }

  $rect <880,410,1080,450>
  method bool areChansSelected( arg int32 i, arg int32 c )
  {
    var uint32 b = c << 16;

    if ( i >= 2048+256 )
    {
      return (deviceFlags[ 512 + 16 + (i - (2048+256)) ] & b) > 0;
    }
    else if ( i >= 2048 )
    {
      return (deviceFlags[ 512 + (i - 2048) ] & b) > 0; 
    }
    else if ( i < 513 && i > 0 )
    {
      return (deviceFlags[ i-1] & b) > 0;
    }
    return false;

  }

  $rect <400,450,600,490>
  method bool UpdateUnit( arg int32 zone, arg int32 unity, arg bool modify )
  {
                                                                     
           var bool result = false;
           var int32 chan = 0;

           for( chan = 0; chan < 16; chan = chan + 1 )
           {
             var int32 state = 0;

             if ( ( ( zoneFlags[ zone ] & 2 ) > 0 )  || isDeviceSelected( unity ) || isChanSelected( unity, chan ) )
             {
               state = 1;
                 result = true;
                 chan = 16;
              }
          
            if ( modify ) native( unity, state )
            {
       
              Command cmd;
              cmd.int0 = -1;
              cmd.int1 = unity;  
              cmd.int2 = chan;
              cmd.int3 = state;

              Command0( CMD_SET_INPUT_IN_TEST, &cmd );     
            }
           
        }
      return result;
       
     
  }

  $reorder Rectangle 76
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder VertScrollbar 1
}

$rect <250,300,400,340>
$output false
class TestChannelItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,550,50>;

  $rect <35,340,215,380>
  inherited method UpdateViewState()
  {
    var Application::ZoneFlags zf = Application::Lib.GetZoneFlags( ZoneNum );
    var Application::Device d = Application::Lib.GetDevice( UnitNum );
     
    if ( d != null )
    {
       
      if ( zf.contains( Application::ZoneFlags[ OnTest] ) || d.settings.contains( Application::DeviceSetting[ OnTest] ) )
      { 
          this.CheckBox.Enabled = false;
          this.CheckBox.Checked = true;
      }
      else
      {
          CheckBox.Enabled = true;
        
          CheckBox.Checked = d.flags[ ChanNum ].contains( Application::ChannelFlags[ OnTest] );
      }
    }

    var Application::DeviceConfig conf = Application::Lib.GetConfig( UnitNum );


    if ( conf != null && conf.outputs[ ChanNum ] != null ) 
    {
        if ( ToggleButton.Visible )
        {
            Image.Bitmap = Application::Lib.TypeBitmap( conf.outputs[ ChanNum ].type );
        }
        else
        {
            Image.Bitmap = Application::Lib.TypeBitmap( conf.inputs[ ChanNum ].type );
        }
    }

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Views::Text ChannelName
  {
    preset Bounds = <116,10,265,40>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <435,10,485,42>;
    preset MaxValue = 1;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <0,70,200,110>
  property uint8 ChanNum = 0;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <432,0,482,50>;
    preset OnSwitchOn = OnSlot;
    preset OnSwitchOff = OffSlot;
    preset Label = "";
    preset Appearance = WidgetSet::Switch_Small;
  }

  $rect <0,110,200,150>
  property uint16 UnitNum = 0;

  $rect <330,60,530,100>
  slot OnSlot
  {
    sender; /* the method is called from the sender object */
     
    Application::Lib.SwitchOuput( UnitNum, ChanNum, DefaultAction, true ) ;



  }

  $rect <525,65,725,105>
  slot OffSlot
  {
    sender; /* the method is called from the sender object */
     
    Application::Lib.SwitchOuput( UnitNum, ChanNum, DefaultAction, false );


  }

  $rect <20,20,160,60>
  object Application::SmallDropDownMenu SmallDropDownMenu
  {
    preset Bounds = <275,5,400,45>;
    preset onSelection = MenuSelection;
    preset GetItemCallback = LoadNames;
    preset numItems = 8;
  }

  $rect <505,135,705,175>
  slot LoadNames
  {
    sender; /* the method is called from the sender object */

    var Application::SmallDropDownMenuList menu = (Application::SmallDropDownMenuList) sender;

    if ( menu != null )
    {
      menu.itemName = Application::Lib.ProfileName( (Application::Action) menu.itemIndex );
    }
     
  }

  $rect <0,150,200,190>
  property Application::Action DefaultAction = Application::Action.Fire;

  $rect <315,220,515,260>
  slot ToggleChannel
  {
    sender; /* the method is called from the sender object */


    var Application::Device d = Application::Lib.GetDevice( UnitNum );

    if ( d != null )
    {
      if ( CheckBox.Checked )
      {
        d.flags[ ChanNum ] = d.flags[ ChanNum ] + Application::ChannelFlags[ OnTest ];
      }
      else
      {
        d.flags[ ChanNum ] = d.flags[ ChanNum ] - Application::ChannelFlags[ OnTest ];   
      }
      Application::Lib.SetDevice( UnitNum, d );
    }


    var Application::TreeView testpage = (Application::TreeView) Owner.Owner.Owner;
      
    if ( testpage != null )
    {
      postsignal testpage.CountOnTest;
      testpage.VerticalList.InvalidateItems( 0, testpage.VerticalList.NoOfItems - 1 );
    }

  }

  $rect <5,190,205,230>
  property uint8 ZoneNum = 0;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton CheckBox
  {
    preset Bounds = <63,0,113,50>;
    preset OnSwitchOn = ToggleChannel;
    preset OnSwitchOff = ToggleChannel;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $rect <310,130,510,170>
  slot MenuSelection
  {
    sender; /* the method is called from the sender object */

    DefaultAction = (Application::Action) SmallDropDownMenu.list.VerticalList.SelectedItem;


  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <500,0,550,50>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <0,1130,200,1170>
$output false
class SmallDropDownMenu : Core::Group
{
  $rect <360,130,560,170>
  inherited property Bounds = <0,0,135,40>;

  $rect <410,240,610,280>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );



    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <400,190,600,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <25,225,165,265>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    list = new Application::SmallDropDownMenuList;

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <490,330,1270,650>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <2,5,95,35>;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <0,5,95,35>;
    preset Width = 2;
    preset ColorL = #1C1C1CFF;
    preset ColorR = #BFBFBFFF;
    preset ColorB = #BFBFBFFF;
    preset ColorT = #1C1C1CFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Point4 = <0,0>;
    preset Point3 = <135,0>;
    preset Point2 = <135,40>;
    preset Point1 = <0,40>;
    preset OnRelease = null;
    preset OnPress = Press;
    preset Enabled = false;
    preset Embedded = true;
  }

  $rect <290,10,490,50>
  slot Press
  {
    sender; /* the method is called from the sender object */

     
    if ( !ShowingList )
    {    
       var point p = GlobalPosition( Bounds.origin );
       list.Bounds.origin.x = Bounds.origin.x + 12;
       list.Bounds.origin.y = p.y + 32;
       list.numItems = numItems;
       list.GetItemCallback = GetItemCallback;
       list.onSelection = onSelection;
       list.VerticalList.SelectedItem = selIndex;
       list.parent = this;
       list.InvalidateViewState();

         
      GetRoot().Add( list, 0 );

      ShowingList = true;
    }
    else
    {
      HideList();
    }


    //VerticalList.Visible = !VerticalList.Visible;
    //VerticalList.Enabled  = VerticalList.Visible;






     
    /*
     Rectangle1.Color = #8BB8E8FF;

        
     Bevel1.ColorB = #BFBFBFFF;
    Bevel1.ColorL = #1C1C1CFF;
     Bevel1.ColorR = #BFBFBFFF;
      Bevel1.ColorT = #1C1C1CFF;   */

  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <5,5,90,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <150,385,350,425>
  property slot onSelection = null;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <95,0,136,40>;
    preset OnPress = Press;
    preset Icon = Application::DropDownSimpleBitmap;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <700,290,900,330>
  property slot GetItemCallback = null;

  $rect <530,0,730,40>
  property uint8 numItems = 0;

  $rect <20,60,220,100>
  property Application::SmallDropDownMenuList list = null;

  $rect <35,110,235,150>
  property bool ShowingList = false;

  $rect <10,305,210,345>
  property int32 selIndex = -1;

  $rect <700,130,900,170>
  method void HideList()
  {
    if ( ShowingList )
    {
     GetRoot().Remove( list );
      ShowingList = false;
    }
  }
}

$rect <250,1120,450,1160>
$output false
class SmallDropMenuItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,90,35>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <650,60,850,100>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
     
    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) ;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color  = #AAAAAAFF;
      Border.Visible    = false;
      CaptionText.Color = #888888FF;
    }

    else if ( isPressed )
    {
      Background.Color  = #8BB8E8FF;
      Border.Color      = #000000FF;
      Border.Visible    = true;
      CaptionText.Color = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Color  = #DDDDDDFF;
      Border.Color      = #444444FF;
      Border.Visible    = true;
      CaptionText.Color = #000000FF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color  = #DDDDDDFF;
      Border.Visible    = false;
      CaptionText.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <370,20,590,190>;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <380,140,580,180>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <380,100,580,140>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;
     
     
    pressed = false;


      var Core::View v = Owner.first;
       var int32 sel = 0;

       while ( v != null )
       {
          var Application::SmallDropMenuItem i = ( Application::SmallDropMenuItem) v;

          if ( i != null )
          {
               if ( i == this )
               {
                   ((Core::VerticalList) Owner ).SelectedItem = sel;
               }
               else
               {
                   sel = sel + 1;
               }
          }
          v = v.next;
      }
                                  
    InvalidateViewState();
        
        postsignal OnActivate;

  }

  // This internal slot method is called when the user touches the item's area.
  $rect <380,60,580,100>
  slot onPressTouch
  {
    // Clicking on a menu item focuses (selects) the item. If you don't want it,
    // remove the following code line.
    Owner.Focus = this;

     
    pressed = true;


    InvalidateViewState();


  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,90,35>;
    preset Color = #DBDBDBFF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,90,35>;
    preset Width = 1;
    preset Color = #000000FF;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,35>;
    preset Point3 = <95,35>;
    preset Point2 = <95,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <4,0,89,35>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  // State management
  note group Note4
  {
    attr Bounds = <640,30,860,240>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,190,850,230>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,150,850,190>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <650,110,850,150>
  var bool enabled = true;

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <100,100,300,140>
  property slot OnActivate = null;
}

$rect <0,1090,230,1130>
$output false
class SmallDropDownMenuList : Core::Group
{
  $rect <360,130,560,170>
  inherited property Bounds = <0,0,78,320>;

  $rect <410,240,610,280>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );



    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <400,190,600,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <490,330,1270,650>;
  }

  $rect <250,85,450,125>
  slot Select
  {
    var Application::SmallDropMenuItem itm = (Application::SmallDropMenuItem) sender;
                                            
    if ( parent != null )
    {
      parent.Text.String = itm.CaptionText.String;
      parent.ShowingList = false;
    }
     
    GetRoot().Remove( this );


    postsignal onSelection;




  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,78,320>;
    preset SlideHorz = false;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <250,175,400,215>
  slot OnLoadItem
  {
    /*


      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Application::SmallDropMenuItem itemView = (Application::SmallDropMenuItem)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    itemView.OnActivate = Select;
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );

    if ( GetItemCallback != null )
    {
        itemIndex = itemNo;
        signal GetItemCallback;

      // Configure the item view ...
      if ( itemName != "" )
      {
        itemView.CaptionText.String = itemName;
        return;
      }
    }

    itemView.CaptionText.String = "Item "+string(itemNo);






     

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.

  }

  $rect <150,420,350,460>
  property slot onSelection = null;

  $rect <700,250,900,290>
  property string itemName = 0;

  $rect <700,290,900,330>
  property slot GetItemCallback = null;

  $rect <890,290,1090,330>
  property int32 itemIndex = 0;

  $rect <530,0,730,40>
  property uint8 numItems = 0;

  $rect <530,40,730,80>
  onset numItems
  {
    // The value doesn't change - nothing to do.
    if ( pure numItems == value )
      return;

    // Remember the property's new value.
    pure numItems = value;

    VerticalList.NoOfItems = numItems;

    var int32 size = VerticalList.ItemHeight * numItems;

    Bounds.y2 = Bounds.y1 + size + 20;

    if ( Bounds.y2 > 480 ) Bounds.y2 = 480;

     
    VerticalList.InvalidateItems( 0, numItems-1 );
     
                                            
    // TO DO:
    // 
    // Now you can handle the alternation of the property.ou can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,78,322>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 35;
    preset NoOfItems = 10;
    preset ItemClass = Application::SmallDropMenuItem;
  }

  $rect <90,0,290,40>
  property Application::SmallDropDownMenu parent = null;
}

$rect <0,180,110,220>
$output false
class Faults : Core::Group
{
  $rect <10,470,210,510>
  inherited property Bounds = <0,0,790,350>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    VertScrollbar.ViewArea = VerticalList.Bounds.h;
    VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,430,210,470>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <390,370,530,410>
  inherited method Init()
  {
    // TO DO: Write your code here ... 


    postsignal onEvent;


  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,550,350>;
    preset AlphaBlended = true;
    preset OnUpdate = ScrollDragSlot;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 50;
    preset NoOfItems = 2;
    preset ItemClass = Application::FaultItem;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <850,250,1050,290>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Application::FaultItem item = (Application::FaultItem) VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

     
    var string time = "$time";                            
    var string desc = "Random Fault";
    var string type = "PRETEND FAULT" ;
    var int32 unt = 1;
    var int32 zone = 1;

    native( time, desc, type, itemNo, unt, zone )
    {
       Command cmd;

       cmd.int0 = itemNo;
       if ( Command0( CMD_GET_FAULT_ITEM, &cmd ) == CMD_OK )
       {
         if ( cmd.int3 != 0 ) time = EwNewStringAnsi( (char*)cmd.int3 );
         if ( cmd.int1 != 0 ) desc = EwNewStringAnsi( (char*)cmd.int1 );
         if ( cmd.int2 & 2 ) 
         {
            type =  EwNewStringAnsi("SYSTEM FAULT");
         }
         else if ( cmd.int2 & 64 ) 
         {
            type = EwNewStringAnsi("OPEN CIRCUIT FAULT");
         }       
         else if ( cmd.int2 & 128 )
         {
            type = EwNewStringAnsi("SHORT CIRCUIT FAULT");
         }
         else
         {
            type =  EwNewStringAnsi("GENERAL FAULT");
         }
         unt = cmd.ushort1;
         zone = cmd.ushort0;
       }
    }

    item.DescriptionText.String = desc;
    item.TimeText.String = time;
    item.TypeText.String = type;

    if ( zone < 255 )
    {
      item.AddressText.String = "Zone " + string( zone ) + "  Unit " + string( unt );
    }
    else
    {
       item.AddressText.String ="";
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    //item.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );

  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,550,350>;
  }

  $rect <810,60,1010,100>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -VerticalList.ScrollOffset;
  }

  $rect <810,100,1010,140>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    VerticalList.ScrollOffset = -VertScrollbar.Position;


  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <550,0,600,350>;
    preset OnScroll = ScrollPressSlot;
    preset ViewArea = 350;
    preset ContentArea = 350;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <830,330,1030,370>
  object Core::SystemEventHandler SystemEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = Application::Devices.FaultListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <820,370,1020,410>
  slot onEvent
  {
    var int32 numItems = 3;

    native( numItems )
    {
      Command cmd;

      Command0( CMD_GET_NUM_FAULTS, &cmd );

      numItems = cmd.int0;
    }  

    var int32 prevnum = VerticalList.NoOfItems;

    VerticalList.NoOfItems = numItems;


    var Application::Application ap = (Application::Application) Owner;

    if ( ap != null )
    {
      ap.FaultsTabButton.NumberOf = numItems;
      ap.FaultsTabButton.InvalidateViewState();

      if (( ap.AlarmsTabButton.NumberOf == 0 || ap.SelectedTab != "{fnt2}{clr1}Fires" )  &&
        ( ap.SelectedTab != "{fnt2}{clr1}Faults" && numItems != 0 )   )
      {
          postsignal ap.FaultsTabButton.OnPress;
        
      }
      else if ( numItems > 0 && ap.SelectedTab != "{fnt2}{clr1}Faults" )
      {
         ap.FaultsTabButton.Timer.Enabled = true;
      } 
      else
      {
         ap.FaultsTabButton.Timer.Enabled = false;
         ap.FaultsTabButton.Image.Visible = true;
      }
    }

    if ( Visible )
    {
      if ( numItems != prevnum )
      {
        var Effects::Int32Effect effect = new Effects::Int32Effect;

        // Configure the animation duration and the timing (easing)
        effect.CycleDuration = 250;  // milliseconds
        effect.NoOfCycles    = 1;
        effect.Timing        = Effects::Timing.Exp_InOut;
          
        if ( numItems < 8 )
        {
           VerticalList.EnsureVisible( 0, true, effect, null );       
        }
        else
        {       
           VerticalList.EnsureVisible( numItems - 1, true, effect, null ); 
        } 
      }
    }
     

    VertScrollbar.ContentArea = numItems * VerticalList.ItemHeight;




    VerticalList.InvalidateItems( 0, numItems - 1 );



    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }
}

$rect <110,180,240,220>
$output false
class FaultItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,45>;
    preset Color = #E2E2E2FF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <363,3,543,23>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "12:33 31/12/18";
    preset Font = Application::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TypeText
  {
    preset Bounds = <180,2,400,24>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "SYSTEM FAULT";
    preset Font = Application::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <2,24,410,44>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Hallway, Front building 2";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text AddressText
  {
    preset Bounds = <5,3,145,23>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 55  Unit 500";
    preset Font = Application::VerdanaProSemiBold16;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,550,45>;
    preset Color = #D4D4D4FF;
  }
}

$rect <480,110,630,150>
$output false
class EventItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,510,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

       
          var string s = string( OrderPosition );

          switch( OrderPosition )
          {
            case 1: s = s + "st";
            case 2: s = s + "nd";
            case 3: s = s + "rd";
            default: s = s + "th";
            }

            OrderPos.String = s;


            
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,510,45>;
    preset Color = #E2E2E2FF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <69,22,469,44>;
    preset WrapWidth = Bounds.w;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Textual Description";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text OrderPos
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,65,45>;
    preset String = "Text";
    preset Font = Templates::DefaultFontPicker;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <70,1,250,19>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 1 Unit 23";
    preset Font = Application::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <295,2,465,23>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "12:33 31/12/18";
    preset Font = OldResources::FontVerdana18;
    preset Color = #000000FF;
  }

  $rect <230,80,430,120>
  property string DescriptionText = "Textual Description";

  $rect <230,120,430,160>
  onset DescriptionText
  {
    // The value doesn't change - nothing to do.
    if ( pure DescriptionText == value )
      return;

    // Remember the property's new value.
    pure DescriptionText = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <230,160,430,200>
  onget DescriptionText
  {
    return pure DescriptionText;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, ResizeVert];
    preset Bounds = <467,0,510,45>;
    preset Color = #000000FF;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset Bitmap = Application::FireBitmap;
  }

  $rect <190,190,390,230>
  object Core::Timer Timer
  {
    preset OnTrigger = Trigger;
    preset Period = 600;
    preset Enabled = true;
  }

  $rect <660,10,790,50>
  slot Trigger
  {
    sender; /* the method is called from the sender object */

    if (Flashing )
    {
      OrderPos.Visible = !OrderPos.Visible;
    }



  }

  $rect <790,10,910,50>
  var bool Flashing = true;

  $rect <0,70,200,110>
  property int32 OrderPosition = 0;

  $rect <0,110,200,150>
  onset OrderPosition
  {
    // The value doesn't change - nothing to do.
    if ( pure OrderPosition == value )
      return;

    // Remember the property's new value.
    pure OrderPosition = value;


    InvalidateViewState();
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,510,45>;
    preset Color = #D4D4D4FF;
  }
}

$rect <1600,980,1780,1020>
$output false
resource Resources::Bitmap EvacEvent
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\evac_event2.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'check box'.
$rect <520,1490,700,1530>
$output false
autoobject WidgetSet::ToggleButtonConfig LargeCheckBox
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDisabled = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDisabled = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 45;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #A8ABABAA;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #A8ABABAA;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 40;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToLeft];
  preset FaceOnTintDisabled = #94949499;
  preset FaceOnFrameActive = 0;
  preset FaceOnFrameFocused = 0;
  preset FaceOnFrameDisabled = 2;
  preset FaceOnFrameDefault = 2;
  preset FaceOnActive = Application::CheckBoxLarge;
  preset FaceOnFocused = Application::CheckBoxLarge;
  preset FaceOnDisabled = Application::CheckBoxLarge;
  preset FaceOnDefault = Application::CheckBoxLarge;
  preset FaceOffTintDefault = #94949493;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 1;
  preset FaceOffFrameDefault = 1;
  preset FaceOffActive = Application::CheckBoxLarge;
  preset FaceOffFocused = Application::CheckBoxLarge;
  preset FaceOffDisabled = Application::CheckBoxLarge;
  preset FaceOffDefault = Application::CheckBoxLarge;
  preset WidgetMinSize = <39,39>;
}

$rect <1770,1030,1950,1070>
$output false
resource Resources::Bitmap CheckBoxLarge
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\Checkbox.png;
  attr alphafile AlphaName;
  attr framesize FrameSize = <36,36>;
  attr framedelay FrameDelay;
}

$rect <1770,1070,1950,1110>
$output false
resource Resources::Bitmap CheckBoxSmall
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\CheckboxSmall.png;
  attr alphafile AlphaName;
  attr framesize FrameSize = <20,20>;
  attr framedelay FrameDelay;
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'check box'.
$rect <680,1490,860,1530>
$output false
autoobject WidgetSet::ToggleButtonConfig SmallCheckBox
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDisabled = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDisabled = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 0;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #85858587;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #85858587;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 40;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
  preset FaceLayout = Core::Layout[];
  preset FaceOnTintDisabled = #85858587;
  preset FaceOnFrameActive = 0;
  preset FaceOnFrameFocused = 0;
  preset FaceOnFrameDisabled = 2;
  preset FaceOnFrameDefault = 2;
  preset FaceOnActive = Application::CheckBoxSmall;
  preset FaceOnFocused = Application::CheckBoxSmall;
  preset FaceOnDisabled = Application::CheckBoxSmall;
  preset FaceOnDefault = Application::CheckBoxSmall;
  preset FaceOffTintDisabled = #85858587;
  preset FaceOffTintDefault = #94949493;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 1;
  preset FaceOffFrameDefault = 1;
  preset FaceOffActive = Application::CheckBoxSmall;
  preset FaceOffFocused = Application::CheckBoxSmall;
  preset FaceOffDisabled = Application::CheckBoxSmall;
  preset FaceOffDefault = Application::CheckBoxSmall;
  preset WidgetMinSize = <30,30>;
}

$rect <0,870,150,910>
$output false
class Disablements : Core::Group
{
  $rect <10,470,210,510>
  inherited property Bounds = <0,0,790,350>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    VertScrollbar.ViewArea = VerticalList.Bounds.h;
    VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,430,210,470>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <500,450,1280,770>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,550,350>;
    preset AlphaBlended = true;
    preset OnUpdate = ScrollDragSlot;
    preset OnLoadItem = OnLoadItem1;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 50;
    preset NoOfItems = 0;
    preset ItemClass = Application::DisablementItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,550,350>;
  }

  $rect <810,60,1010,100>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -VerticalList.ScrollOffset;
  }

  $rect <810,100,1010,140>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    VerticalList.ScrollOffset = -VertScrollbar.Position;


  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <550,0,600,350>;
    preset OnScroll = ScrollPressSlot;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <850,250,1050,290>
  slot OnLoadItem
  {
    return;

    var int16 itemNo   = VerticalList.Item;

    var Application::EventItem row = (Application::EventItem) VerticalList.View;


    if ( itemNo == 0 )
    {
        row.Flashing = true;
    }
    else
    {  
       row.Flashing = false;
    }

    var int16 order = itemNo + 1;
    var int16 type = 0;
    var string location = "Unknown";
    var int16  zone = 0;
    var int16  yunit = 0;
    var int16 fires = 0;

    native ( order, type, location, zone, yunit, itemNo, fires )
    {
      Command cmd;

      Command0(  CMD_GET_NUM_OTHER_EVENTS, &cmd );  

      fires = cmd.int0;

      if ( fires != 0 )
      {
        if ( itemNo == 0 )
        {
          cmd.int0 = fires - 1;
        }
        else
        {
          cmd.int0 = itemNo - 1;
        }

        order = cmd.int0 + 1;

        Command0( CMD_GET_OTHER_EVENTS_DETAILS, &cmd );
     
        location = EwNewStringAnsi( (char*) cmd.int0 );
        zone  = cmd.short2;
        yunit = cmd.short3;
        type = cmd.short4;
       }
    }

    $if ($prototyper)
    if ( itemNo == 0 )
    {
      order = VerticalList.NoOfItems;
    }
    else
    {
      order = itemNo;
    }
    $endif

    row.OrderPosition = order;

    if ( type == 1 )
    {
      row.Image.Bitmap = Application::GreenCallpointBitmap;
    }
    else if ( type == 4 )
    {
      row.Image.Bitmap = Application::PIRBitmap;
    }
    else if ( type == 3 )
    {
       row.Image.Bitmap = Application::EvacEvent;
    }

    row.Text.String = location;
    row.ZoneText.String = "Zone " + string( zone)+"  Unit " + string( yunit );
     

    row.Bounds.w = VerticalList.Bounds.w;       
  }

  $rect <830,330,1030,370>
  object Core::SystemEventHandler SystemEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = Application::Devices.EventListChangedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <820,370,1020,410>
  slot onEvent
  {
    var int32 numItems = 8;


     
    native( numItems )
    {
      Command cmd;

      Command0( CMD_GET_NUM_OTHER_EVENTS, &cmd );

      numItems = cmd.int0;
    }  


    VerticalList.NoOfItems = numItems;

    var Application::Application ap = (Application::Application) Owner;

    if ( ap != null )
    {
      ap.EventsTabButton.NumberOf = numItems;
      ap.EventsTabButton.InvalidateViewState();

      if ( ap.AlarmsTabButton.NumberOf == 0 && ap.FaultsTabButton.NumberOf == 0 )
      {
        if ( ap.SelectedTab != "Events" )
        {
          postsignal ap.EventsTabButton.OnPress;
        }
      }
    }

    VerticalList.InvalidateItems( 0, numItems - 1 );



    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <470,370,670,410>
  slot Refresh
  {
    sender; /* the method is called from the sender object */

    var int32 num = 0;

    native ( num)
    {
      Command cmd;

      Command0(  CMD_GET_NUM_DISABLED, &cmd );  

      num = cmd.int0;
    }

    var Application::Application app = (Application::Application) Owner;

    if ( app != null )
    {
       app.DisablementsTabButton.NumberOf = num;
       app.DisablementsTabButton.InvalidateViewState( );
    }     
      

    VerticalList.NoOfItems = num;
    VerticalList.InvalidateItems( 0, num - 1 );

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <850,250,1050,290>
  slot OnLoadItem1
  {
    var int16 itemNo   = VerticalList.Item;

    var Application::DisablementItem row = (Application::DisablementItem) VerticalList.View;

                                  
    var int16 type = 0;
    var string location = "Unknown";
    var int16  zone = 0;
    var int16  yunit = 0;
    var int16 fires = 0;
    var int16 inout  = 1;
    var int16 chan = 0;

    native ( type, location, zone, yunit, itemNo, fires, chan, inout )
    {
      Command cmd;

      Command0(  CMD_GET_NUM_DISABLED, &cmd );  

      fires = cmd.int0;

      if ( fires != 0 )
      {
          cmd.int0 = itemNo;
         
        Command0( CMD_GET_DISABLED_DETAILS, &cmd );
     
        location = EwNewStringAnsi( (char*) cmd.int0 );
        zone  = cmd.short2;
        yunit = cmd.short3;
        type = cmd.short4;
        chan = cmd.short5;
        inout = cmd.short6;
       }
    }

     
    var string t = "";
    var string io = "";

     if ( inout == 1 )
     {
     io = "Input";
     switch (type ) 
    {
       case 0 : t = "<Unused>";
          case 1 : t = "Smoke";
          case 2 : t = "Heat";
          case 3 : t = "CO";
          case 4 : t = "PIR";
          case 7 : t = "Call point";
          case 11 : t = "First Aid";
          case 12 : t = "Evacuate";
        
          default :  t = "Generic";
     }
    }
    else
    {
     io = "Output";
     switch (type ) 
    {
          case 5 : t = "Sounder";
          case 6 : t = "Beacon";
          case 9 : t = "SVI" ;
       
          case 10 : t = "Sounder/VI";
          case 13 : t = "Fire Routing";
       
          default :  t = "Generic";
     }
    }

    row.ChanText.String = t;

    row.Text.String = location;
    row.ZoneText.String = "Zone " + string( zone)+"  Unit " + string( yunit ) + " " + io + " Channel " + string(chan);

    row.Bounds.w = VerticalList.Bounds.w;      
     
  }
}

$rect <150,870,320,910>
$output false
class DisablementItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,510,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


            
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,510,45>;
    preset Color = #E2E2E2FF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,510,45>;
    preset Color = #D4D4D4FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <12,20,330,44>;
    preset WrapWidth = Bounds.w;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Textual Description";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <13,0,320,20>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 1 Unit 23";
    preset Font = Application::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <230,80,430,120>
  property string DescriptionText = "Textual Description";

  $rect <20,20,160,60>
  object Views::Text ChanText
  {
    preset Bounds = <340,0,500,19>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Application::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }
}

// This autoobject provides one of the default customizations for the 'toggle' widget \
// (WidgetSet::ToggleButton) in its medium size variant. With this customization \
// the toggle button appears as a 'check box'.
$rect <690,1540,920,1580>
$output false
autoobject WidgetSet::ToggleButtonConfig SmallCheckBoxCaption
{
  preset LabelOnColorActive = #000000FF;
  preset LabelOnColorFocused = #000000FF;
  preset LabelOnColorDisabled = #000000FF;
  preset LabelOnColorDefault = #000000FF;
  preset LabelOffColorActive = #000000FF;
  preset LabelOffColorFocused = #000000FF;
  preset LabelOffColorDisabled = #000000FF;
  preset LabelOffColorDefault = #000000FF;
  preset LabelMarginLeft = 34;
  preset IconOnTintActive = #6C6E70FF;
  preset IconOnTintFocused = #6C6E70FF;
  preset IconOnTintDisabled = #A8ABABAA;
  preset IconOnTintDefault = #6C6E70FF;
  preset IconOffTintActive = #6C6E70FF;
  preset IconOffTintFocused = #6C6E70FF;
  preset IconOffTintDisabled = #A8ABABAA;
  preset IconOffTintDefault = #6C6E70FF;
  preset IconMarginLeft = 6;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = OldResources::FontVerdana20;
  preset LabelOffFont = OldResources::FontVerdana20;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToLeft];
  preset FaceOnTintDisabled = #94949499;
  preset FaceOnFrameActive = 0;
  preset FaceOnFrameFocused = 0;
  preset FaceOnFrameDisabled = 2;
  preset FaceOnFrameDefault = 2;
  preset FaceOnActive = Application::CheckBoxSmall;
  preset FaceOnFocused = Application::CheckBoxSmall;
  preset FaceOnDisabled = Application::CheckBoxSmall;
  preset FaceOnDefault = Application::CheckBoxSmall;
  preset FaceOffTintDefault = #94949493;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 1;
  preset FaceOffFrameDefault = 1;
  preset FaceOffActive = Application::CheckBoxSmall;
  preset FaceOffFocused = Application::CheckBoxSmall;
  preset FaceOffDisabled = Application::CheckBoxSmall;
  preset FaceOffDefault = Application::CheckBoxSmall;
  preset WidgetMinSize = <39,39>;
}

$rect <10,710,120,750>
$output false
class OnTest : Core::Group
{
  $rect <10,470,210,510>
  inherited property Bounds = <0,0,790,350>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    VertScrollbar.ViewArea = VerticalList.Bounds.h;
    VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,430,210,470>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <500,450,1280,770>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,550,350>;
    preset AlphaBlended = true;
    preset OnUpdate = ScrollDragSlot;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 50;
    preset NoOfItems = 0;
    preset ItemClass = Application::OnTestItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,550,350>;
  }

  $rect <810,60,1010,100>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -VerticalList.ScrollOffset;
  }

  $rect <810,100,1010,140>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    VerticalList.ScrollOffset = -VertScrollbar.Position;


  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <550,0,600,350>;
    preset OnScroll = ScrollPressSlot;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <850,250,1050,290>
  slot OnLoadItem
  {
    var int16 itemNo   = VerticalList.Item;

    var Application::OnTestItem row = (Application::OnTestItem) VerticalList.View;


     

    var int16 order = itemNo + 1;
    var Application::ChannelType type = Application::ChannelType.None;
    var string location = "Unknown";
    var int16  zone = 0;
    var int16  yunit = 0;
    var int16 fires = 0;

    native ( order, type, location, zone, yunit, itemNo, fires )
    {
      Command cmd;

      Command0(  CMD_GET_NUM_ON_TEST, &cmd );  

      fires = cmd.int0;

      if ( fires != 0 )
      {
        if ( itemNo == 0 )
        {
          cmd.int0 = fires - 1;
        }
        else
        {
          cmd.int0 = itemNo - 1;
        }

        order = cmd.int0 + 1;

        Command0( CMD_GET_ON_TEST_DETAILS, &cmd );
     
        location = EwNewStringAnsi( (char*) cmd.int0 );
        zone  = cmd.short2;
        yunit = cmd.short3;
        type = cmd.short4;
       }
    }

    $if ($prototyper)
    if ( itemNo == 0 )
    {
      order = VerticalList.NoOfItems;
    }
    else
    {
      order = itemNo;
    }
    $endif
     

    row.Image.Bitmap = Application::Lib.TypeBitmap( type );


    row.Text.String = location;
    row.ZoneText.String = "Zone " + string( zone)+"  Unit " + string( yunit );
     
    row.Bounds.w = VerticalList.Bounds.w;       
  }

  $rect <580,370,780,410>
  slot Refresh
  {
    sender; /* the method is called from the sender object */

    var int32 num = 0;

    native ( num)
    {
      Command cmd;

      Command0(  CMD_GET_NUM_ON_TEST, &cmd );  

      num = cmd.int0;
    }

    var Application::Application app = (Application::Application) Owner;

    if ( app != null )
    {
       app.OnTestTabButton.NumberOf = num;
       app.OnTestTabButton.InvalidateViewState( );
     }     
      

    VerticalList.NoOfItems = num;
    VerticalList.InvalidateItems( 0, num - 1 );

  }
}

$rect <130,710,280,750>
$output false
class OnTestItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,510,45>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

       
           
            


            
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,510,45>;
    preset Color = #E2E2E2FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,510,45>;
    preset Color = #D4D4D4FF;
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Bounds = <9,21,459,43>;
    preset WrapWidth = Bounds.w;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Textual Description";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <10,0,190,18>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Zone 1 Unit 23";
    preset Font = Application::FontVerdanaProSemiBold20;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <295,2,465,23>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "12:33 31/12/18";
    preset Font = OldResources::FontVerdana18;
    preset Color = #000000FF;
  }

  $rect <229,80,429,120>
  property string DescriptionText = "Textual Description";

  $rect <230,120,430,160>
  onset DescriptionText
  {
    // The value doesn't change - nothing to do.
    if ( pure DescriptionText == value )
      return;

    // Remember the property's new value.
    pure DescriptionText = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <230,160,430,200>
  onget DescriptionText
  {
    return pure DescriptionText;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, ResizeVert];
    preset Bounds = <467,0,510,45>;
    preset Color = #000000FF;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset Bitmap = Application::FireBitmap;
  }
}

$rect <230,920,370,960>
$output false
class DisableZoneItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,555,50>;

  $rect <50,200,250,240>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <40,135,240,175>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    if ( ZoneNum == 0 )
    {
      Text.String = "Panel I/O";
    }
    else
    {
      Text.String = "Zone " + string( ZoneNum );
    }

     
    var Application::Disable testpage = (Application::Disable) Owner.Owner.Owner;

    if ( testpage != null )
    {
       /*
    UnitsInTest = testpage.UpdateZone( ZoneNum, false );

    if ( UnitsInTest == 0 )
    {
       InTestText.String = "";
    }
    else
     {
       InTestText.String = "In Test: " + string(UnitsInTest);
     }   */

       if ( (testpage.zoneFlags[ ZoneNum ] & 1) == 1 )
       { 
           ExpandImage.Bitmap = Application::CollapseBitmap;
       }
       else
       {
            ExpandImage.Bitmap = Application::ExpandBitmap;
       }
    }

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Views::Image ExpandImage
  {
    preset Bounds = <10,15,40,45>;
    preset Bitmap = Application::ExpandBitmap;
  }

  $rect <20,20,160,60>
  object XFlat::CheckBox CheckBox
  {
    preset Bounds = <60,10,210,49>;
    preset Enabled = true;
    preset OnChange = ToggleSlot;
    preset Caption = "";
    preset Outlet;
  }

  $rect <395,175,595,215>
  property uint16 ZoneNum = 0;

  $rect <495,280,695,320>
  slot ClearAll
  {
    sender ; /* the method is called from the sender object */



    var Application::Disable disable = (Application::Disable) Owner.Owner.Owner;

    if ( ( disable.zoneFlags[ ZoneNum] & 1) == 1 )
    {
       var Application::DisableItem i = (Application::DisableItem) Owner.next;

       while ( i != null && ( i.DisableUnitItem.Visible || i.DisableChannelItem.Visible ) )
       {
        i.DisableUnitItem.CheckBox.Checked = false;
        if (i.DisableUnitItem.Visible)  disable.SetDeviceSelected( i.DisableUnitItem.UnitNum, false );

         i.DisableChannelItem.OutputCheckBox.Checked = false;
         i.DisableChannelItem.InputCheckBox.Checked = false;
         if (i.DisableChannelItem.Visible && i.DisableChannelItem.InputCheckBox.Visible  )  disable.SetInputChanSelected( i.DisableChannelItem.UnitNum, i.DisableChannelItem.ChanNum, false );
         if (i.DisableChannelItem.Visible && i.DisableChannelItem.OutputCheckBox.Visible  )  disable.SetOutputChanSelected( i.DisableChannelItem.UnitNum, i.DisableChannelItem.ChanNum, false );
        i = (Application::DisableItem) i.next;
       }
    }

        
    if ( ( disable.zoneFlags[ ZoneNum] & 2) == 0 )
    {

     
    var uint16 zone =    ZoneNum;

      native( zone )
        {
       
          Command cmd;
          cmd.int0 = zone;
          cmd.int1 = -1; // all units
          cmd.int2 = -1; // all channels
          cmd.int3 = 0;

          Command0( CMD_SET_INPUT_DISABLED, &cmd );   
          Command0( CMD_SET_OUTPUT_DISABLED, &cmd );      
        }    

        signal ((Application::Application) disable.Owner).Disablements.Refresh;
    }
     

     


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <450,10,535,46>;
    preset OnRelease = ClearAll;
    preset Label = "Clear All";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <435,325,635,365>
  slot ToggleSlot
  {
    sender; /* the method is called from the sender object */


    var Application::Disable testpage = (Application::Disable) Owner.Owner.Owner;


    if ( ((WidgetSet::ToggleButton) sender).Checked )
    {
      testpage.zoneFlags[ ZoneNum] = testpage.zoneFlags[ ZoneNum] | 2;

       var Application::DisableItem i = (Application::DisableItem) Owner.next;

       while ( i != null && ( i.DisableUnitItem.Visible || i.DisableChannelItem.Visible ) )
       {
     
        i.DisableUnitItem.CheckBox.Enabled = false;
        i.DisableUnitItem.CheckBox.Checked = true;

        if ( i.DisableChannelItem.Visible )
        {
           if ( i.DisableChannelItem.InputCheckBox.Visible ) 
           {
            i.DisableChannelItem.InputCheckBox.Enabled = false;
            i.DisableChannelItem.InputCheckBox.Checked = true;
           }
           else if ( i.DisableChannelItem.OutputCheckBox.Visible ) 
           {
            i.DisableChannelItem.OutputCheckBox.Enabled = false;
            i.DisableChannelItem.OutputCheckBox.Checked = true;
           }
         }
        i = (Application::DisableItem) i.next;
       }
       var int32 zone =  ZoneNum;

        native( zone )
        {
       
          Command cmd;
          cmd.int0 = zone;
          cmd.int1 = -1;
          cmd.int2 = -1; // all channels
          cmd.int3 = 1;

          Command0( CMD_SET_INPUT_DISABLED, &cmd );  
          Command0( CMD_SET_OUTPUT_DISABLED, &cmd );      
        }

      
    }
    else
    {
        testpage.zoneFlags[ ZoneNum] = testpage.zoneFlags[ ZoneNum] & 253;

       var Application::DisableItem i = (Application::DisableItem) Owner.next;

       while ( i != null && ( i.DisableUnitItem.Visible || i.DisableChannelItem.Visible ) )
       {
        i.DisableUnitItem.CheckBox.Enabled = true;
        i.DisableUnitItem.CheckBox.Checked = testpage.isDeviceSelected( i.DisableUnitItem.UnitNum );

        if ( i.DisableChannelItem.Visible )
        {
           if ( i.DisableChannelItem.InputCheckBox.Visible )
           {
             i.DisableChannelItem.InputCheckBox.Enabled = true;
             i.DisableChannelItem.InputCheckBox.Checked = testpage.isInputChanSelected( i.DisableChannelItem.UnitNum, i.DisableChannelItem.ChanNum );
           }
           if ( i.DisableChannelItem.OutputCheckBox.Visible )
           {
             i.DisableChannelItem.OutputCheckBox.Enabled = true;
             i.DisableChannelItem.OutputCheckBox.Checked = testpage.isOutputChanSelected( i.DisableChannelItem.UnitNum, i.DisableChannelItem.ChanNum );
           }
        }

        i = (Application::DisableItem) i.next;
       }
       testpage.UpdateZone( ZoneNum, true );
    }
     
    postsignal testpage.CountOnTest;  
                                                                   

  }

  $rect <165,90,365,130>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */

     

    if ( Visible )
    {

     
    var Core::VerticalList lst = (Core::VerticalList) Owner.Owner;

      var int32 total = 0;
      var int32 devs = 4;
      var int32 zone = ZoneNum;

      native( devs, zone )
      {
        Command cmd;
        cmd.int0 = zone;

        Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
        devs = cmd.int0;
      }


    var Application::Disable testpage = (Application::Disable) Owner.Owner.Owner;

    if ( (testpage.zoneFlags[ZoneNum] & 1) == 0)
    {
        ExpandImage.Bitmap = Application::CollapseBitmap;
       
        testpage.zoneFlags[ZoneNum] = testpage.zoneFlags[ZoneNum] | 1;

     
        var int32 dev;
        
        var int32 count = 2;

        total = total + devs;

        for( dev = 0; dev < devs; dev=dev+1 )
        {
            var int32 unity = dev + 1;

           native( zone, dev, unity, count )
           {
            Command cmd;
                    
            cmd.int0 = zone;
            cmd.int1 = dev;
            Command0( CMD_GET_DEV_IN_ZONE, &cmd );
            DeviceConfig* device = (DeviceConfig*) cmd.int0;

            if ( device != NULL )
            {
               int chan;
               count = 0;
               unity = device->unit;
               for( chan = 0; chan < 16; chan++ )
               {
                  if ( device->input[ chan].type != 0 ) count++;
                  if ( device->output[ chan].type != 0 ) count++; 
               }
            }
           }
           if ( testpage.isDeviceExpanded( unity ) )
           {
              total = total + count;
           }
        }
        lst.NoOfItems = lst.NoOfItems + total;
    }
    else
    {
        ExpandImage.Bitmap = Application::ExpandBitmap;
        
        testpage.zoneFlags[ZoneNum] = testpage.zoneFlags[ZoneNum] & 254;

        var int32 n;
        var int32 dev;
       
         var int32 count = 2;

        total = total + devs;

        for( dev = 0; dev < devs; dev=dev+1 )
        {
           var int32 unity = dev + 1;

           native( zone, dev, unity )
           {
            Command cmd;
                    
            cmd.int0 = zone;
            cmd.int1 = dev;
            Command0( CMD_GET_DEV_IN_ZONE, &cmd );
            DeviceConfig* device = (DeviceConfig*) cmd.int0;

            if ( device != NULL )
            {
               int chan;
               count = 0;
               unity = device->unit;
               for( chan = 0; chan < 16; chan++ )
               {
                  if ( device->input[ chan].type != 0 ) count++;
                  if ( device->output[ chan].type != 0 ) count++; 
               }
            }
           }
           if ( testpage.isDeviceExpanded( unity ) )
           {
              total = total + count;
           }
        }
        lst.NoOfItems = lst.NoOfItems - total;
    }

     
    lst.InvalidateItems( 0, lst.NoOfItems - 1 );

    lst.InvalidateViewState();


     testpage.VertScrollbar.ContentArea = lst.NoOfItems * lst.ItemHeight;
      testpage.VertScrollbar.ViewArea = lst.Bounds.h;
     testpage.VertScrollbar.InvalidateViewState();

     }

  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <50,0>;
    preset Point2 = <50,50>;
    preset Point1 = <0,50>;
    preset OnPress = ToggleExpand;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <108,15,340,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text InTestText
  {
    preset Bounds = <340,15,415,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <655,25,800,65>
  property int16 UnitsInTest = 0;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <60,0,205,50>;
    preset OnSwitchOn = ToggleSlot;
    preset OnSwitchOff = ToggleSlot;
    preset Label = "";
    preset Appearance = Application::LargeCheckBox;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder ExpandImage 6
  $reorder CheckBox 6
  $reorder Enabled 5
}

$rect <110,920,250,960>
$output false
class DisableUnitItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,550,50>;

  $rect <40,135,240,175>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    var Application::Disable testpage = (Application::Disable) Owner.Owner.Owner;


    if ( aState.contains( Core::ViewState[ Enabled ] )  )
    {
      DescriptionText.Color = #000000FF;
      Text.Color = #000000FF;

      if ( testpage.isDeviceExpanded( UnitNum ) )
      {
        Image1.Bitmap = Application::CollapseBitmap;

      }
      else
      {
        Image1.Bitmap = Application::ExpandBitmap;
      }
       Image1.Visible = true;

    }
    else
    {
       DescriptionText.Color = #AAAAAAFF;
       Text.Color = #AAAAAAFF;
       Image1.Visible = false;
    }
     

    Text.String = "Zone " + string( ActualZone) + "  Unit " + string(UnitNum);




    if ( (testpage.zoneFlags[ ZoneNum] & 2 ) == 2 )
    {
        this.CheckBox.Enabled = false;
        this.CheckBox.Checked = true;
     
    }
     
    else
    {
        CheckBox.Enabled = true;
        CheckBox.Checked = testpage.isDeviceSelected( UnitNum );
    }
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <395,175,595,215>
  property uint16 UnitNum = 0;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <135,1,295,25>;
    preset ColorBL = #000000FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #000000FF;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Application::VerdanaProSemiBold16;
    preset Color = #3D3D3DFF;
  }

  $rect <20,20,160,60>
  object Views::Text DescriptionText
  {
    preset Bounds = <135,19,505,46>;
    preset ColorBL = #000000FF;
    preset ColorBR = #000000FF;
    preset ColorTR = #000000FF;
    preset ColorTL = #000000FF;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <390,220,590,260>
  property uint8 ZoneNum = 0;

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <39,11,69,41>;
    preset Bitmap = Application::ExpandBitmap;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <29,1>;
    preset Point3 = <79,1>;
    preset Point2 = <79,50>;
    preset Point1 = <29,50>;
    preset OnPress = ToggleExpand;
  }

  $rect <340,90,540,130>
  slot ToggleSlot
  {
    sender; /* the method is called from the sender object */


    var Application::Disable testpage = (Application::Disable) Owner.Owner.Owner;

    testpage.SetDeviceSelected( UnitNum, this.CheckBox.Checked );


    if ( CheckBox.Checked )                                        
    {  
       var Application::DisableItem i = (Application::DisableItem) Owner.next;

       while ( i != null && i.DisableChannelItem.Visible )
       {
          if ( i.DisableChannelItem.InputCheckBox.Visible )
           {
             i.DisableChannelItem.InputCheckBox.Enabled = false;
             i.DisableChannelItem.InputCheckBox.Checked = true;
           }
           if ( i.DisableChannelItem.OutputCheckBox.Visible )
           {
             i.DisableChannelItem.OutputCheckBox.Enabled = false;
             i.DisableChannelItem.OutputCheckBox.Checked = true;
           }
        i = (Application::DisableItem) i.next;
       }  
       var int32 zone = ZoneNum;
       var int32 unt = UnitNum;
       native( zone, unt )
      {
       
        Command cmd;
        cmd.int0 = -1;
        cmd.int1 = unt;  
        cmd.int2 = -1; // all channels
        cmd.int3 = 1;

        Command0( CMD_SET_INPUT_DISABLED, &cmd );     
        Command0( CMD_SET_OUTPUT_DISABLED, &cmd );   
      }  
    }
    else
    {                                                                       
       var Application::DisableItem i = (Application::DisableItem) Owner.next;

       while ( i != null && i.DisableChannelItem.Visible )
       {
         if ( i.DisableChannelItem.InputCheckBox.Visible )
           {
             i.DisableChannelItem.InputCheckBox.Enabled = true;
             i.DisableChannelItem.InputCheckBox.Checked = testpage.isInputChanSelected( i.DisableChannelItem.UnitNum, i.DisableChannelItem.ChanNum );
           }
           if ( i.DisableChannelItem.OutputCheckBox.Visible )
           {
             i.DisableChannelItem.OutputCheckBox.Enabled = true;
             i.DisableChannelItem.OutputCheckBox.Checked = testpage.isOutputChanSelected( i.DisableChannelItem.UnitNum, i.DisableChannelItem.ChanNum );
           }
     
        i = (Application::DisableItem) i.next;
       }
       testpage.UpdateUnit( ZoneNum, UnitNum, true );
    }

     
     postsignal testpage.CountOnTest ;
  }

  $rect <50,75,250,115>
  slot ToggleExpand
  {
    sender; /* the method is called from the sender object */

     

    if ( Visible )
    {

     
    var Core::VerticalList lst = (Core::VerticalList) Owner.Owner;


      var int32 devs = 4;
       
      var int32 dev = UnitNum;
          
      var int32 channels = 2;
                
      native( dev, channels  )
      {  
        Command cmd;
        channels = 0;
      
        cmd.int0 = dev;
        
        Command0( CMD_GET_DEVICE, &cmd );
        DeviceConfig* dev = (DeviceConfig*) cmd.int0;

        for( int n = 0 ; n < 16; n++ )
        {
            if ( dev->input[ n].type != 0  ) channels++;
            if ( dev->output[ n].type != 0 ) channels++;
        }
       }

    var Application::Disable testpage = (Application::Disable) Owner.Owner.Owner;

    if ( !testpage.isDeviceExpanded( UnitNum ) )
    {
        Image1.Bitmap = Application::CollapseBitmap;
        lst.NoOfItems = lst.NoOfItems + channels;
        testpage.SetExpanded( UnitNum, true );
    }
    else
    {
        Image1.Bitmap = Application::ExpandBitmap;
        lst.NoOfItems = lst.NoOfItems - channels;
        testpage.SetExpanded( UnitNum, false );
    }

     
    lst.InvalidateItems( 0, lst.NoOfItems - 1 );

    lst.InvalidateViewState();


     testpage.VertScrollbar.ContentArea = lst.NoOfItems * lst.ItemHeight;
      testpage.VertScrollbar.ViewArea = lst.Bounds.h;
     testpage.VertScrollbar.InvalidateViewState();

     }

  }

  $rect <400,265,600,305>
  property uint8 ActualZone = 0;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton CheckBox
  {
    preset Bounds = <80,0,140,50>;
    preset Enabled = false;
    preset OnSwitchOn = ToggleSlot;
    preset OnSwitchOff = ToggleSlot;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <530,910,670,950>
$output false
class DisableItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,550,50>;

  $rect <50,200,250,240>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <40,135,240,175>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

     

  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Application::DisableUnitItem DisableUnitItem
  {
    preset Bounds = <0,0,520,50>;
  }

  $rect <20,20,160,60>
  object Application::DisableZoneItem DisableZoneItem
  {
    preset Bounds = <0,0,550,50>;
  }

  $rect <20,20,160,60>
  object Application::DisableChannelItem DisableChannelItem
  {
    preset Bounds = <0,0,550,50>;
  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <0,920,120,960>
$output false
class Disable : Core::Group
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <2,0,550,350>;
    preset Color = #353535FF;
    preset AlphaBlended = false;
    preset Visible = false;
  }

  $rect <0,550,200,590>
  inherited property Bounds = <0,0,600,350>;

  $rect <0,410,200,450>
  inherited method UpdateLayout()
  {
    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,500,200,540>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VertScrollbar
  {
    preset Bounds = <550,0,600,350>;
    preset OnScroll = ScrollPressSlot;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <210,420,360,460>
  inherited method Init()
  {
    // TO DO: Write your code here ... 

    signal onEvent1;

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <490,360,630,400>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */
               

    var Core::VerticalList vlist = (Core::VerticalList) sender;

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = vlist.Item;

     
    var Application::DisableItem item = (Application::DisableItem) vlist.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( item == null )
      return;

    //var Application::ModifyZoneItem currentZone = null;

    var uint8 curZone = 0;


       var int32 i = 0;
       var int32 numZones = 2;

       native( numZones ) 
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }
       
       
       while ( numZones > 0 )
       {
          var int32 numdevs = 4; 
          native( numdevs, curZone )
          {  
            Command cmd;
          
            cmd.int0 = curZone;
            Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
            numdevs = cmd.int0;
          }

          if ( numdevs > 0 )
          {
            numZones = numZones - 1;
            if ( itemNo == i )
            {
              item.DisableZoneItem.ZoneNum = curZone;
              item.DisableZoneItem.Visible = true;
              item.DisableZoneItem.Enabled = true;

              item.DisableUnitItem.Visible = false;
              item.DisableUnitItem.Enabled = false;

              item.DisableChannelItem.Visible = false;
              item.DisableChannelItem.Enabled = false;
        
              item.DisableZoneItem.InvalidateViewState();
              return;
            }
            else
            {
               i = i + 1;
            }
            if (( zoneFlags[ curZone ] & 1) == 1 )
            {                             
                var int32 dev = 0;

                while ( dev < numdevs )
                {
                  var string location = "~";
                  var uint16 unitno = dev + 1;
                  var uint8 zoneno = curZone;
                  var int32 devptr = 0;
                  var int32 found = 1;
                
                  native( dev, curZone, location, unitno, zoneno, devptr )
                  {  
                    Command cmd;
                    
                    cmd.int0 = curZone;
                    cmd.int1 = dev;
                    Command0( CMD_GET_DEV_IN_ZONE, &cmd );
                    DeviceConfig* device = (DeviceConfig*) cmd.int0;

                    if ( device != NULL )
                    {
                      if ( strlen( device->location ) > 40 )   device->location[ 39] = 0; 
                      location = EwNewStringAnsi( device->location );
                      unitno = device->unit;
                      zoneno = device->zone;
                      devptr = (int) device;

                      cmd.int0 = unitno;
                      Command0( CMD_FIND_DEVICE_FROM_UNIT, &cmd );
                      found = cmd.int0;
                    } 
                  }

                  if ( i == itemNo )
                  {   
                      item.DisableUnitItem.Visible = true;

                      if ( found == 0 )
                      {
                      item.DisableUnitItem.Enabled = false;
                      }
                      else
                      {
                       item.DisableUnitItem.Enabled = true;
                      }

                      item.DisableZoneItem.Visible = false;
                      item.DisableZoneItem.Enabled = false;

                      item.DisableChannelItem.Visible = false;
                      item.DisableChannelItem.Enabled = false;

                      item.DisableUnitItem.UnitNum = unitno;
                      item.DisableUnitItem.ZoneNum = curZone;
                      item.DisableUnitItem.ActualZone = zoneno;
                      item.DisableUnitItem.DescriptionText.String = location;

                      item.DisableUnitItem.InvalidateViewState(); 

                      return;
                   }
                   else
                   {
                      i = i + 1;
                   }

                   if ( isDeviceExpanded( unitno ) )
                   {
                     var int32 type = 0;
                     var string channame;
                     var int32 chan = 0;
                

                     do
                     {                
                        native( chan, channame, type, devptr ) 
                        {
                           DeviceConfig* d = (DeviceConfig*) devptr;
                           if ( d != NULL )
                           {
                              Command cmd;
                              type = d->input[ chan].type;

                              cmd.int0 = (int) d;

                              Command0( CMD_GET_DEVICE_FROM_CONFIG, &cmd );

                              Device* dev = (Device*)  cmd.int0;
                           }
                        }
    $if (!$prototyper)
                        if ( type != 0 )
                        {
    $endif                      
                          if ( i == itemNo )
                          {
                            item.DisableUnitItem.Visible = false;
                            item.DisableUnitItem.Enabled = false;

                            item.DisableZoneItem.Visible = false;
                            item.DisableZoneItem.Enabled = false;

                            item.DisableChannelItem.Visible = true;
                            item.DisableChannelItem.Enabled = true;

                            item.DisableChannelItem.ChanNum = chan;
                            item.DisableChannelItem.UnitNum = unitno;
                            item.DisableChannelItem.ZoneNum = curZone;

                            item.DisableChannelItem.InputCheckBox.Visible = true;
                            item.DisableChannelItem.InputCheckBox.Enabled = true;

                            item.DisableChannelItem.OutputCheckBox.Visible = false;
                            item.DisableChannelItem.OutputCheckBox.Enabled = false;



                            switch ( type )
                            {
                                case 1 : item.DisableChannelItem.ChannelName.String = "Smoke";
                                case 2 : item.DisableChannelItem.ChannelName.String = "Heat A1R";
                                case 3 : item.DisableChannelItem.ChannelName.String = "Heat B" ;
                                case 4 : item.DisableChannelItem.ChannelName.String = "PIR";
                                case 5 : item.DisableChannelItem.ChannelName.String = "Call point";
                                case 7 : item.DisableChannelItem.ChannelName.String = "First Aid";
        
                                default : item.DisableChannelItem.ChannelName.String = "Input " + string(chan + 1);
                            }
                            return;
                          }
                          else
                          {
                             i = i + 1;
                          }
    $if (!$prototyper)
                         }
    $endif
                         chan = chan + 1;
                      } while ( type != 0 );
                              
                      chan = 0;
                     

                     do
                     {                
                        native( chan, channame, type, devptr ) 
                        {
                           DeviceConfig* d = (DeviceConfig*) devptr;
                           if ( d != NULL )
                           {
                              int bit;
                              OutputChannel* out = d->output + chan;
                              type = out->type;
                           }
                        }
    $if (!$prototyper)
                        if ( type != 0 )
                        {
    $endif                      
                          if ( i == itemNo )
                          {
                            item.DisableUnitItem.Visible = false;
                            item.DisableUnitItem.Enabled = false;

                            item.DisableZoneItem.Visible = false;
                            item.DisableZoneItem.Enabled = false;

                            item.DisableChannelItem.Visible = true;
                            item.DisableChannelItem.Enabled = true;

                            item.DisableChannelItem.ChanNum = chan;
                            item.DisableChannelItem.UnitNum = unitno;
                            item.DisableChannelItem.ZoneNum = curZone;

                            item.DisableChannelItem.OutputCheckBox.Visible = true;
                            item.DisableChannelItem.OutputCheckBox.Enabled = true;
                            item.DisableChannelItem.InputCheckBox.Visible = false;
                            item.DisableChannelItem.InputCheckBox.Enabled = false;

                            switch ( type )
                            {
                                case 5 : item.DisableChannelItem.ChannelName.String = "Sounder";
                                case 6 : item.DisableChannelItem.ChannelName.String = "Beacon";
                                case 9 : item.DisableChannelItem.ChannelName.String = "SVI" ;
                                case 10 : item.DisableChannelItem.ChannelName.String = "Sounder/VI" ;
                                case 13 : item.DisableChannelItem.ChannelName.String = "Fire Routing" ;
                                default : item.DisableChannelItem.ChannelName.String = "Output " + string( chan + 1);
                             }
                             return;
                           }
                           else
                           {
                            i = i + 1;
                           }
    $if (!$prototyper)
                         }
    $endif
                         chan = chan + 1;
                      } while ( type != 0 );                

                     
                  }
                  dev = dev + 1;
              }
           }
         }
         curZone = curZone + 1;
       }


        // EEK shouldnt be here
        item.DisableUnitItem.Visible = false;
        item.DisableZoneItem.Visible = false;

       
                      
        vlist.NoOfItems = i;

        native
        {
         while ( 1 );
        }
     
     

  }

  $rect <900,110,1100,150>
  slot ScrollDragSlot
  {
    sender; /* the method is called from the sender object */

    VertScrollbar.Position = -VerticalList.ScrollOffset;
  }

  $rect <900,150,1100,190>
  slot ScrollPressSlot
  {
    sender; /* the method is called from the sender object */


    VerticalList.ScrollOffset = -VertScrollbar.Position;
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems );
    VerticalList.InvalidateViewState();



  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel1
  {
    preset Bounds = <0,0,554,350>;
    preset Width = 2;
    preset ColorL = #202020FF;
    preset ColorR = #AEAEAEFF;
    preset ColorB = #909090FF;
    preset ColorT = #2C2C2CFF;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,550,350>;
    preset OnSlide = ScrollDragSlot;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <2,2,552,348>;
    preset OnLoadItem = OnLoadItem;
    preset Endless = false;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 45;
    preset NoOfItems = 3;
    preset ItemClass = Application::DisableItem;
  }

  $rect <800,270,1000,310>
  array uint8 zoneFlags[ 97 ];

  $rect <960,280,1190,320>
  object Core::SystemEventHandler SiteLoadedEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = Application::Devices.SiteLoadedEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <980,310,1130,350>
  slot onEvent1
  {
     var int32 numZones = 2;

       native( numZones )
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }

    var int32 i = 0;
     
    for( i = 0; i < 97; i=i + 1 )
    {
      zoneFlags[ i] = 0;
    }
      

       VerticalList.NoOfItems = numZones ;
       VerticalList.InvalidateItems( 0, numZones - 1);
        
       

      VertScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;
      VertScrollbar.ViewArea = VerticalList.Bounds.h;
      VertScrollbar.InvalidateViewState();

  }

  $rect <620,0,820,40>
  property uint16 unitnum = 0;

  $rect <620,40,820,80>
  property uint16 zonenum = 0;

  $rect <620,100,820,140>
  property slot ZoneSelect = null;

  $rect <620,140,820,180>
  property slot ZoneDeSelect = null;

  $rect <620,180,820,220>
  property slot DeviceDeSelect = null;

  $rect <620,220,820,260>
  property slot DeviceSelect = null;

  $rect <700,310,900,350>
  array uint32 deviceInputFlags[ 544 ];

  $rect <660,380,860,420>
  method bool isDeviceExpanded( arg int32 i )
  {
    if ( i >= 2048+256 )
    {
      return (deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] & 1) == 1;
    }
    else if ( i >= 2048 )
    {
      return (deviceInputFlags[ 512 + (i - 2048) ] & 1) == 1; 
    }
    else if ( i < 513 && i > 0 )
    {
      return (deviceInputFlags[ i-1] & 1) == 1;
    }
    return false;
  }

  $rect <660,420,860,460>
  method void SetExpanded( arg int32 i, arg bool val )
  {
     
    if ( val )
    {
      if ( i >= 2048+256 )
      {
        deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] = deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] | 1;
      }
      else if ( i >= 2048 )
      {
        deviceInputFlags[ 512 + (i - 2048) ] = deviceInputFlags[ 512 + (i - 2048) ] | 1; 
      }
      else if ( i < 513 )
      {
        deviceInputFlags[ i-1] = deviceInputFlags[ i-1] | 1;
      }
    }
    else
    {
    var uint32 b = 0xFFFFFFFE;
     if ( i >= 2048+256 )
      {
        deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] = deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] & b;
      }
      else if ( i >= 2048 )
      {
        deviceInputFlags[ 512 + (i - 2048) ] = deviceInputFlags[ 512 + (i - 2048) ] & b; 
      }
      else if ( i < 513 )
      {
        deviceInputFlags[ i-1] = deviceInputFlags[ i-1] & b;
      }
    }

  }

  $rect <660,450,860,490>
  method bool isDeviceSelected( arg int32 i )
  {
    if ( i >= 2048+256 )
    {
      return (deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] & 2) == 2;
    }
    else if ( i >= 2048 )
    {
      return (deviceInputFlags[ 512 + (i - 2048) ] & 2) == 2; 
    }
    else if ( i < 513 && i > 0 )
    {
      return (deviceInputFlags[ i-1] & 2) == 2;
    }
    return false;
  }

  $rect <660,490,860,530>
  method void SetDeviceSelected( arg int32 i, arg bool val )
  {
     
    if ( val )
    {
      if ( i >= 2048+256 )
      {
        deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] = deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] | 2;
      }
      else if ( i >= 2048 )
      {
        deviceInputFlags[ 512 + (i - 2048) ] = deviceInputFlags[ 512 + (i - 2048) ] | 2; 
      }
      else if ( i < 513 )
      {
        deviceInputFlags[ i-1] = deviceInputFlags[ i-1] | 2;
      }
    }
    else
    {
     var uint32 b = 0xFFFFFFFD;
     if ( i >= 2048+256 )
      {
        deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] = deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] & b;
      }
      else if ( i >= 2048 )
      {
        deviceInputFlags[ 512 + (i - 2048) ] = deviceInputFlags[ 512 + (i - 2048) ] & b; 
      }
      else if ( i < 513 )
      {
        deviceInputFlags[ i-1] = deviceInputFlags[ i-1] & b;
      }
    }

             
  }

  $rect <890,400,1090,440>
  method bool isInputChanSelected( arg int32 i, arg int32 c )
  {
    var uint32 b = 1 << (c+16);

    if ( i >= 2048+256 )
    {
      return (deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] & b) == b;
    }
    else if ( i >= 2048 )
    {
      return (deviceInputFlags[ 512 + (i - 2048) ] & b) == b; 
    }
    else if ( i < 513 && i > 0 )
    {
      return (deviceInputFlags[ i-1] & b) == b;
    }
    return false;

  }

  $rect <890,440,1090,480>
  method void SetInputChanSelected( arg int32 i, arg int32 c, arg bool val )
  {
    var uint32 b = 1 << (c+16);
     
    if ( val )
    {
      if ( i >= 2048+256 )
      {
        deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] = deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] | b;
      }
      else if ( i >= 2048 )
      {
        deviceInputFlags[ 512 + (i - 2048) ] = deviceInputFlags[ 512 + (i - 2048) ] | b; 
      }
      else if ( i < 513 )
      {
        deviceInputFlags[ i-1] = deviceInputFlags[ i-1] | b;
      }
    }
    else
    {
     if ( i >= 2048+256 )
      {
        deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] = deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] & (~b);
      }
      else if ( i >= 2048 )
      {
        deviceInputFlags[ 512 + (i - 2048) ] = deviceInputFlags[ 512 + (i - 2048) ] & (~b); 
      }
      else if ( i < 513 )
      {
        deviceInputFlags[ i-1] = deviceInputFlags[ i-1] & (~b);
      }
    }

     
  }

  $rect <940,0,1140,40>
  object Core::SystemEventHandler OnTestChangeEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = Application::Devices.OnTestChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <950,40,1150,80>
  slot onEvent
  {
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );



    /*
       HINT 1:

       You can evaluate the 'sender' parameter. It refers to the handler 
       this method has been called from. This is very useful if multiple
       system event handlers are connected to one and the same 'onEvent'
       method:

       if ( sender == Handler1 )
         trace "The event comes from the Handler1";

       if ( sender == Handler2 )
         trace "... or from the Handler2";
    */

    /*
       HINT 2:

       From this 'onEvent' slot method you can evaluate the optional
       'context' data dispatched together with the system event:

       // First get the context data. You need to cast from the generic 'object'
       // to your own specific context class:
       var YourUnit::ContextClass context = (YourUnit::ContextClass)SystemEventHandler.Context;

       // Any context data passed and the cast was successful?
       if ( context != null )
       {
         // Evaluate the context data:
         someTarget1 = context.SomeData1;
         someTarget2 = context.SomeData2;
       }
    */
  }

  $rect <410,500,560,540>
  slot CountOnTest
  {
    sender; /* the method is called from the sender object */


    /*

    var int32 i;
    var int32 unitCount = 0;


    var Core::VerticalList lst = (Core::VerticalList) Owner.Owner;

    var int32 zone;

     var int32 numZones = 2;

       native( numZones )
       {
          Command cmd;
          Command0( CMD_GET_NUM_ZONES, &cmd );
          numZones = cmd.int0;
        }


    for( zone = 0; zone < numZones; zone = zone + 1 )
    {   
        unitCount = unitCount + UpdateZone( zone, false );    
    }

     */
    var Application::Application app = (Application::Application) Owner;

    if ( app != null )
    {
      postsignal app.Disablements.Refresh;
    } 

  }

  $rect <410,410,610,450>
  method int32 UpdateZone( arg int32 zone, arg bool modify )
  {
                                                                     

      var int32 total = 0;
      var int32 devs = 4;
     

      native( devs, zone )
      {
        Command cmd;
        cmd.int0 = zone;

        Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
        devs = cmd.int0;
      }

                                                      
        var int32 dev;
        
     
        for( dev = 0; dev < devs; dev=dev+1 )
        {
            var int32 unity = dev + 1;

           native( zone, dev, unity )
           {
            Command cmd;
                    
            cmd.int0 = zone;
            cmd.int1 = dev;
            Command0( CMD_GET_DEV_IN_ZONE, &cmd );
            DeviceConfig* device = (DeviceConfig*) cmd.int0;

            if ( device != NULL )
            {
               unity = device->unit;
            }
           }
           if ( UpdateUnit( zone, unity, modify ) ) total = total + 1;

        }
       

        return total;
  }

  $rect <890,360,1090,400>
  method bool areInputChansSelected( arg int32 i, arg int32 c )
  {
    var uint32 b = c << 16;

    if ( i >= 2048+256 )
    {
      return (deviceInputFlags[ 512 + 16 + (i - (2048+256)) ] & b) > 0;
    }
    else if ( i >= 2048 )
    {
      return (deviceInputFlags[ 512 + (i - 2048) ] & b) > 0; 
    }
    else if ( i < 513 && i > 0 )
    {
      return (deviceInputFlags[ i-1] & b) > 0;
    }
    return false;

  }

  $rect <400,450,600,490>
  method bool UpdateUnit( arg int32 zone, arg int32 unity, arg bool modify )
  {
                                                                     
           var bool result = false;
           var int32 chan = 0;

           for( chan = 0; chan < 16; chan = chan + 1 )
           {
             var int32 inputstate = 0;
             var int32 outputstate = 0;

             if ( ( ( zoneFlags[ zone ] & 2 ) > 0 )  || isDeviceSelected( unity ) || isInputChanSelected( unity, chan ) )
             {
                inputstate = 1;
                 result = true;
              //   chan = 16;
              }
              if ( ( ( zoneFlags[ zone ] & 2 ) > 0 )  || isDeviceSelected( unity ) || isOutputChanSelected( unity, chan ) )
             {
                outputstate = 1;
                 result = true;
              //   chan = 16;
              }
          
            if ( modify ) native( unity, inputstate, outputstate )
            {
       
              Command cmd;
              cmd.int0 = -1;
              cmd.int1 = unity;  
              cmd.int2 = chan;
              cmd.int3 = inputstate;

              Command0( CMD_SET_INPUT_DISABLED, &cmd );    

              cmd.int3 = outputstate;
              Command0( CMD_SET_OUTPUT_DISABLED, &cmd );    
            }
           
        }
      return result;
       
     
  }

  $rect <660,540,860,580>
  array uint32 deviceOutputFlags[ 544 ];

  $rect <890,540,1090,580>
  method bool isOutputChanSelected( arg int32 i, arg int32 c )
  {
    var uint32 b = 1 << (c+16);

    if ( i >= 2048+256 )
    {
      return (deviceOutputFlags[ 512 + 16 + (i - (2048+256)) ] & b) == b;
    }
    else if ( i >= 2048 )
    {
      return (deviceOutputFlags[ 512 + (i - 2048) ] & b) == b; 
    }
    else if ( i < 513 && i > 0 )
    {
      return (deviceOutputFlags[ i-1] & b) == b;
    }
    return false;

  }

  $rect <890,580,1090,620>
  method void SetOutputChanSelected( arg int32 i, arg int32 c, arg bool val )
  {
    var uint32 b = 1 << (c+16);
     
    if ( val )
    {
      if ( i >= 2048+256 )
      {
        deviceOutputFlags[ 512 + 16 + (i - (2048+256)) ] = deviceOutputFlags[ 512 + 16 + (i - (2048+256)) ] | b;
      }
      else if ( i >= 2048 )
      {
        deviceOutputFlags[ 512 + (i - 2048) ] = deviceOutputFlags[ 512 + (i - 2048) ] | b; 
      }
      else if ( i < 513 )
      {
        deviceOutputFlags[ i-1] = deviceOutputFlags[ i-1] | b;
      }
    }
    else
    {
     if ( i >= 2048+256 )
      {
        deviceOutputFlags[ 512 + 16 + (i - (2048+256)) ] = deviceOutputFlags[ 512 + 16 + (i - (2048+256)) ] & (~b);
      }
      else if ( i >= 2048 )
      {
        deviceOutputFlags[ 512 + (i - 2048) ] = deviceOutputFlags[ 512 + (i - 2048) ] & (~b); 
      }
      else if ( i < 513 )
      {
        deviceOutputFlags[ i-1] = deviceOutputFlags[ i-1] & (~b);
      }
    }

     
  }

  $rect <890,500,1090,540>
  method bool areOutputChansSelected( arg int32 i, arg int32 c )
  {
    var uint32 b = c << 16;

    if ( i >= 2048+256 )
    {
      return (deviceOutputFlags[ 512 + 16 + (i - (2048+256)) ] & b) > 0;
    }
    else if ( i >= 2048 )
    {
      return (deviceOutputFlags[ 512 + (i - 2048) ] & b) > 0; 
    }
    else if ( i < 513 && i > 0 )
    {
      return (deviceOutputFlags[ i-1] & b) > 0;
    }
    return false;

  }

  $reorder Rectangle 76
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder VertScrollbar 1
}

$rect <370,910,520,950>
$output false
class DisableChannelItem : Core::Group
{
  $rect <40,260,240,300>
  inherited property Bounds = <0,0,550,50>;

  $rect <35,340,215,380>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 



    var Application::Disable testpage = (Application::Disable) Owner.Owner.Owner;

    if ( this.InputCheckBox.Visible )
    {

      if ( (testpage.zoneFlags[ ZoneNum] & 2) == 2 || testpage.isDeviceSelected( UnitNum ) )
      {
        InputCheckBox.Checked = true;
        InputCheckBox.Enabled = false;
      }
      else
      {
        InputCheckBox.Checked = testpage.isInputChanSelected( UnitNum, ChanNum );
      }
    }
    if ( this.OutputCheckBox.Visible )
    {

      if ( (testpage.zoneFlags[ ZoneNum] & 2) == 2 || testpage.isDeviceSelected( UnitNum ) )
      {
        OutputCheckBox.Checked = true;
        OutputCheckBox.Enabled = false;
      }
      else
      {
        OutputCheckBox.Checked = testpage.isOutputChanSelected( UnitNum, ChanNum );
      }
    }



  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <360,390,1140,710>;
  }

  $rect <20,20,160,60>
  object Views::Text ChannelName
  {
    preset Bounds = <210,10,355,40>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = OldResources::FontVerdana20;
    preset Color = #000000FF;
  }

  $rect <0,70,200,110>
  property uint8 ChanNum = 0;

  $rect <0,110,200,150>
  property uint16 UnitNum = 0;

  $rect <515,200,715,240>
  slot LoadNames
  {
    sender; /* the method is called from the sender object */

    var Application::SmallDropDownMenuList menu = (Application::SmallDropDownMenuList) sender;

    if ( menu != null )
    {
      menu.itemName = GetName( menu.itemIndex );
    }
     
  }

  $rect <0,150,200,190>
  property int8 DefaultAction = -1;

  $rect <475,260,675,300>
  method string GetName( arg int32 index )
  {
     

      switch ( index )
      {
        case 0 : return "Fire";
        case 1 : return "First Aid";
        case 2 : return "Fault";
        case 3 : return "Evacuate";
        case 4 : return "Security";
        case 5 : return "Pre Alarm";
        case 6 : return "Quiet Test";
        case 7 : return "Test Sound";
        default : return "-";
      }
  }

  $rect <255,315,455,355>
  slot ToggleInputChannel
  {
    sender; /* the method is called from the sender object */


    var Application::Disable testpage = (Application::Disable) Owner.Owner.Owner;

    testpage.SetInputChanSelected( UnitNum, ChanNum, InputCheckBox.Checked );


    var int32 u = UnitNum ;
    var int32 c = ChanNum ;
    var int32 v = 0;

    if ( InputCheckBox.Checked ) v = 1;

    native( u, c, v )
    {
      Command cmd;

      cmd.int0 = -1;
      cmd.int1 = u;
      cmd.int2 = c;
      cmd.int3 = v;

      Command0( CMD_SET_INPUT_DISABLED, &cmd );
    }
      
    postsignal testpage.CountOnTest;

  }

  $rect <180,65,380,105>
  property uint8 ZoneNum = 0;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton InputCheckBox
  {
    preset Bounds = <130,0,180,50>;
    preset OnSwitchOn = ToggleInputChannel;
    preset OnSwitchOff = ToggleInputChannel;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton OutputCheckBox
  {
    preset Bounds = <130,0,180,50>;
    preset OnSwitchOn = ToggleOutputChannel;
    preset OnSwitchOff = ToggleOutputChannel;
    preset Label = "";
    preset Appearance = Application::SmallCheckBox;
  }

  $rect <510,320,710,360>
  slot ToggleOutputChannel
  {
    sender; /* the method is called from the sender object */


    var Application::Disable testpage = (Application::Disable) Owner.Owner.Owner;

    testpage.SetOutputChanSelected( UnitNum, ChanNum, OutputCheckBox.Checked );


    var int32 u = UnitNum ;
    var int32 c = ChanNum ;
    var int32 v = 0;

    if ( OutputCheckBox.Checked ) v = 1;

    native( u, c, v )
    {
      Command cmd;

      cmd.int0 = -1;
      cmd.int1 = u;
      cmd.int2 = c;
      cmd.int3 = v;

      Command0( CMD_SET_OUTPUT_DISABLED, &cmd );
    }
      
    postsignal testpage.CountOnTest;

  }

  $reorder OnSetOpacity 5
  $reorder OnGetEmbedded 5
  $reorder OnSetEmbedded 5
  $reorder OnGetAlphaBlended 5
  $reorder OnSetAlphaBlended 5
  $reorder OnGetVisible 5
  $reorder OnSetVisible 5
  $reorder OnSetEnabled 1
  $reorder ObtainFocus 5
  $reorder HasViewState 5
  $reorder LocalPosition 5
  $reorder GlobalPosition 5
  $reorder DispatchEvent 5
  $reorder BroadcastEventAtPosition 5
  $reorder BroadcastEvent 5
  $reorder UpdateLayout 5
  $reorder UpdateViewState 5
  $reorder InvalidateViewState 5
  $reorder InvalidateArea 5
  $reorder Init 5
  $reorder GetIndexOfView 5
  $reorder GetViewAtIndex 5
  $reorder CountViews 5
  $reorder FindViewInDirection 5
  $reorder FindViewWithinArea 5
  $reorder FindViewAtPosition 5
  $reorder FindPrevView 5
  $reorder FindNextView 5
  $reorder FindSiblingView 5
  $reorder GetContentArea 5
  $reorder RestackBehind 5
  $reorder RestackBack 5
  $reorder RestackTop 5
  $reorder Restack 5
  $reorder Remove 5
  $reorder AddBehind 5
  $reorder Add 5
  $reorder Focus 5
  $reorder Buffered 5
  $reorder Opacity 6
  $reorder Embedded 6
  $reorder AlphaBlended 6
  $reorder Visible 6
  $reorder Note1 6
  $reorder Enabled 5
}

$rect <1440,1000,1620,1040>
$output false
resource Resources::Bitmap SiteNetBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\sitenet180.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <20,820,170,860>
$output false
class MeshTree : Core::Group
{
  $rect <490,380,690,420>
  inherited property Bounds = <0,0,800,350>;

  $rect <700,420,900,460>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <690,380,890,420>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

     
    Path.SetMaxNoOfSubPaths(512);
     

    SubIndex = 0;
     

    Row = 0;

    DrawBranch( 0, 0 );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <430,250,630,290>
  object Graphics::Path Path;

  $rect <540,10,710,50>
  property point Origin = <-20,24>;

  $rect <20,20,160,60>
  object WidgetSet::VerticalScrollbar VerticalScrollbar
  {
    preset Bounds = <565,0,605,350>;
    preset OnScroll = Scroll;
    preset ViewArea = 200;
    preset ContentArea = 1000;
    preset Appearance = WidgetSet::VerticalScrollbar_Medium;
  }

  $rect <835,250,1035,290>
  slot Scroll
  {
    sender; /* the method is called from the sender object */

    Origin.y = 25 - VerticalScrollbar.Position;
    VerticalList.ScrollOffset = -VerticalScrollbar.Position;

    InvalidateViewState();

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <500,420,660,460>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Application::MeshUnitItem device = (Application::MeshUnitItem) VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( device == null )
      return;
     
    if ( itemNo == 0 )
    {
       device.MeshUnit.Visible = false;
       device.MeshNCU.Visible = true;
       
       return;
    }

    var int32 combinames = 0;

    device.MeshUnit.Selected = ( itemNo == VerticalList.SelectedItem );


    native ( combinames )
    {
        Command cmd;
        Command0( CMD_GET_DEVICE_LISTS, &cmd );  

        combinames = cmd.int3;
    }

    pure Row = 1;

    if ( GetChildren( device, 0, itemNo, 0, combinames ) ) return;


                                
    var int16  zone = -1;
    var int16  younit = 0;
     
    var string radiocombo = "";  
     
    var string defcombo = "";
    var int16 status = -1;

    var int32 row = pure Row;

    var int16  snr = -32768;
     
    var int32 selected = VerticalList.SelectedItem;

    native ( zone, younit, defcombo, itemNo, radiocombo, status, row, snr, selected )
    {
        Command cmd;
        Command0( CMD_GET_DEVICE_LISTS, &cmd );  

        if ( (void*)cmd.int0 != NULL )
        {
          DeviceConfig* dev      = (DeviceConfig*)   cmd.int0;  
          RadioUnit* rad      = (RadioUnit*)   cmd.int1;
          const char** combis = (const char**) cmd.int3;

          int numConfig = cmd.short4;
          int numFound =  cmd.short5;

       
          DeviceConfig* d;
          RadioUnit* r;

          // Devices not found

          for( d = dev; d < dev + numConfig; d++ )
          {
              if ( !FindRadioDevice( rad, numFound, d->zone, d->unit ) )
              {
                  if ( row == itemNo )
                  {               
                      zone = d->zone;
                      younit = d->unit;

                      status = 0;  // unfound 'x'

                      if ( d->type < MAX_COMBINATION_TYPE )
                      {
                         defcombo  = EwNewStringAnsi( combis[ d->type ] );
                      }
                      else
                      {
                        defcombo =  EwNewStringAnsi( "------" );
                      }
                      
                      goto done;
                  }
                  else row++;
              }
          }
          
          // Devices not in config

          if ( rad != NULL )
          {
            for( r = rad; r < rad + numFound; r++ )
            {
                if ( !FindConfigDevice( dev, numConfig, r->zone, r->unit ) )
                {
                    if ( r->primary == -1 )
                    {
                        if ( row == itemNo )
                        {
                            zone = r->zone;
                            younit = r->unit;
                            snr = r->snrprimary;

                            if ( r->combination < MAX_COMBINATION_TYPE )
                            {
                               radiocombo  = EwNewStringAnsi( combis[ r->combination ] );
                            }
                            else
                            {
                              radiocombo =  EwNewStringAnsi( "------" );
                            }
                      
                            status = 2;  // additional +

                            
                            snr = r->snrprimary;
                               
                        
                            goto done;
                        }
                        else row++;
                    }
                    
                }
            }         
         }                             
                
          // Devices in both
          if ( rad != NULL )
          {
            for( d = dev; d < dev + numConfig; d++ )
            {
                if ( r = FindRadioDevice( rad, numFound, d->zone, d->unit ) )
                {
                    if ( r->primary == -1 )
                    {
                      if ( row == itemNo )
                      {               
                          zone = d->zone;
                          younit = d->unit;
                          

                          if ( r->combination < MAX_COMBINATION_TYPE )
                          {
                             radiocombo  = EwNewStringAnsi( combis[ r->combination ] );
                          }
                          else
                          {
                            radiocombo =  EwNewStringAnsi( "------" );
                          }
                          if ( d->type < MAX_COMBINATION_TYPE )
                          {
                             defcombo  = EwNewStringAnsi( combis[ d->type ] );
                          }
                          else
                          {
                            defcombo =  EwNewStringAnsi( "------" );
                          }

                          snr = r->primary;

                         
                          if ( d->type == r->combination )
                          {
                            status = 1;  // found
                          }
                          else
                          {
                            status = 3; // different ?   
                          }    
                         
                          goto done;
                      }
                      else row++;
                    }
                }
            }
         }
            //time   = TimeStr( );
       }
    done:    ;
     
    }

          device.MeshUnit.UnitNum.String = string(younit);
          device.MeshUnit.ZoneNum.String = string(zone);
          device.MeshUnit.SNR = snr;            
          device.MeshUnit.DefinedComb = defcombo;
          device.MeshUnit.RadioComb = radiocombo;
          device.MeshUnit.Status = status;
          device.MeshNCU.Visible = false;
          device.MeshUnit.Visible = true;

          device.MeshUnit.InvalidateViewState();
          
     

  }

  $rect <340,400,510,440>
  method void DrawConnector( arg int32 x, arg int32 y, arg int32 y2 )
  {
    /* The template just returns the given argument... */



    Path.InitSubPath( pure SubIndex, 16 );
     

    Path.Begin( pure SubIndex, pure Origin.x + x, pure Origin.y + y + 1);
    Path.AddArc( pure SubIndex, pure Origin.x + x + pure Radius, Origin.y + y2 + 1, pure Radius, pure Radius, 180, 90, 15 );



    SubIndex = SubIndex + 1;

     

                    
  }

  $rect <420,240,570,280>
  array int8 Array[ 15 ] =
  (
    Default[0] = -1;
    Default[1] = 0;
    Default[2] = 0;
    Default[3] = 0;
    Default[4] = 1;
    Default[5] = 1;
    Default[6] = 1;
    Default[7] = 1;
    Default[8] = 2;
    Default[9] = 3;
    Default[10] = 2;
    Default[11] = 1;
    Default[12] = 2;
    Default[13] = 2;
    Default[14] = 10;
  );

  $rect <1075,190,1225,230>
  property point Spacing = <40,30>;

  $rect <535,60,705,100>
  property int32 Radius = 17;

  $rect <360,240,550,280>
  property int32 SubIndex = 0;

  $rect <1070,115,1270,155>
  property int32 Row = 0;

  $rect <360,360,500,400>
  method void DrawBranch( arg int32 indent, arg int32 parent )
  {
    var int32 child = FindNextChild( 0, parent );
    var int32 startrow = pure Row;

    indent = indent + 1;

    while ( child != 0 )
    {   
       DrawConnector( indent * pure Spacing.x, startrow * pure Spacing.y, pure Row * pure Spacing.y );

       pure Row = pure Row + 1;
      
       var int32 unitnum = child;

       native( child, unitnum )
       {
           RadioUnit* ru = (RadioUnit*) child;
             
           unitnum = ru->unit; 
       }    
       DrawBranch( indent, unitnum );       

       child = FindNextChild( child, parent );
    }


  }

  $rect <900,340,1100,380>
  method int32 FindNextChild( arg int32 start, arg int32 parent )
  {
    var int32 i;

    $if ($prototyper)
    for( i = start + 1 ; i < 15; i = i + 1 )
    {
      if ( Array[ i] == parent ) return i;
    }

    return 0;

    $endif

    var int32 child = 0;

    native( start, parent, child )
    {
        Command cmd;

        cmd.int0 = start;
        cmd.int1 = parent;

        Command0( CMD_GET_RADIO_UNIT_CHILD, &cmd );

        child = cmd.int0;
    }

    return child;
  }

  $rect <20,20,160,60>
  object Views::StrokePath BranchPath
  {
    preset Bounds = <0,0,547,350>;
    preset Color = #000000FF;
    preset Width = 3;
    preset Path = Path;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,565,350>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 30;
    preset NoOfItems = 15;
    preset ItemClass = Application::MeshUnitItem;
  }

  $rect <890,380,1090,420>
  method bool GetChildren( arg Application::MeshUnitItem device, arg int32 parent, arg int32 itemNo, arg int32 indent, arg int32 combinames )
  {
    var int32 child = FindNextChild( 0, parent );
    var int32 startrow = pure Row;

    var int32 zonenum = 0;
    var int32 Status = 1;
     

    indent = indent + 1;

    while ( child != 0 )
    {   
       var int32 unitnum = child;
        
       var int32 snr = 22;
       var string radiocomb = "SN.VAD0.????";
       var string defcomb = "SN.VAD0.????";

       native( child, unitnum )
       {
          RadioUnit* ru = (RadioUnit*) child;
           
          unitnum = ru->unit; 
       }

       if ( Row == itemNo )
       {  
          var int32 tx = 0;
          var int32 rx = 0;
          native( child, snr, radiocomb, defcomb, combinames, Status )
          {
             RadioUnit* ru = (RadioUnit*) child;
             zonenum = ru->zone;
            
             Command cmd;
             cmd.int0 = unitnum;

             Command0( CMD_GET_DEVICE, &cmd );

             if ( cmd.int0 != 0 )
             {
                DeviceConfig* dc = (DeviceConfig*) cmd.int0;
                const char** combis = (const char**) combinames;

                if ( dc->type == ru->combination )
                {
                   Status = 1;   // ok
                }
                else
                {
                   Status = 3;    // different ?
                }
                if ( dc->type < MAX_COMBINATION_TYPE )
                  defcomb   = EwNewStringAnsi( combis[ dc->type ] );     
                if ( ru->combination <  MAX_COMBINATION_TYPE ) 
                  radiocomb = EwNewStringAnsi( combis[ ru->combination ] );
             }
             else
             { 
                Status = 2;    // additional  +
             }

          }  

          if ( device.MeshUnit.Selected )
          {
            native( child )
            {
              Command cmd;
              cmd.int0 = (int)child;

              Command0( CMD_SET_CURRENT_DEVICE, &cmd );
            }
            DeviceInfo.device = child;
          }

          device.MeshUnit.UnitNum.String = string(unitnum);
          device.MeshUnit.ZoneNum.String = string(zonenum);
          device.MeshUnit.SNR = snr;            
          device.MeshUnit.DefinedComb = defcomb;
          device.MeshUnit.RadioComb = radiocomb;
          device.MeshUnit.Status = Status;
          device.MeshNCU.Visible = false;
          device.MeshUnit.Visible = true;


          device.MeshUnit.Bounds.x1 = indent * pure Spacing.x - 4;
          device.MeshUnit.Bounds.x2 = device.MeshUnit.Bounds.x1 + 320;

          device.Bounds.w = VerticalList.Bounds.w;
          device.MeshUnit.InvalidateViewState();
          device.InvalidateViewState();



          return true;
       }    

       pure Row = pure Row + 1;

       if ( GetChildren( device, unitnum, itemNo, indent, combinames ) ) return true;

       child = FindNextChild( child, parent );
    }

    return false;
  }

  $rect <1115,75,1315,115>
  property int8 Radius2 = 9;

  $rect <1320,-10,1440,30>
  slot ImportSlot
  {
    sender; /* the method is called from the sender object */

    var Application::Popup popy = new Application::ImportConfigPopup;

    popy.Show( GetRoot() );



  }

  $rect <1436,-10,1561,30>
  slot ExportSlot
  {
    sender; /* the method is called from the sender object */

    var Application::Popup popy = new Application::ExportConfigPopup;

    popy.Show( GetRoot() );

  }

  $rect <1477,320,1707,360>
  object Core::SystemEventHandler SiteLoadedEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = Application::Devices.SiteLoadedEvent;
  }

  $rect <1470,400,1730,440>
  object Core::SystemEventHandler MeshListChangeEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = Application::Devices.MeshListChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1480,355,1630,395>
  slot onEvent1
  {
    var int32 numDevs;

    native ( numDevs )
    {
        Command cmd;
        Command0( CMD_GET_DEVICE_LISTS, &cmd );    

        numDevs = cmd.short4;

        Command0( CMD_GET_NUM_EXTRA_RADIO_UNITS, &cmd );  
          
        numDevs += cmd.int0;
    }

    VerticalList.NoOfItems = numDevs + 1;       // for ncu

    VerticalList.InvalidateItems( 0, numDevs );


    VerticalScrollbar.ContentArea = VerticalList.NoOfItems * VerticalList.ItemHeight;
    VerticalScrollbar.ViewArea = VerticalList.Bounds.h;



    InvalidateViewState();
  }

  $rect <815,15,1040,55>
  slot StartSync
  {
    sender; /* the method is called from the sender object */

    var int32 stage = 0;
          
    native 
    {
        Command cmd;
        cmd.int0 = 1;
        Command0( CMD_SET_MESH_STAGE, &cmd );     
    }

    ProgressArrow.Arrow.Point1.y =  ProgressArrow.Line.Point1.y;
    ProgressArrow.Arrow.Point2.y  = ProgressArrow.Arrow.Point1.y;
    ProgressArrow.Target = ProgressArrow.Line2.Point1.y;
    ProgressArrow.Timer.Enabled = true;
    ProgressArrow.Timer.Period = 2000;


  }

  $rect <1505,235,1740,275>
  object Core::SystemEventHandler MeshStatusChangeEventHandler
  {
    preset OnEvent = onEvent2;
    preset Event = Application::Devices.MeshStatusChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <1505,274,1625,314>
  slot onEvent2
  {
    var int16 stage;

    native ( stage )
    {
        Command cmd;
        Command0( CMD_GET_MESH_STAGE, &cmd );  

        stage = cmd.int0;
    }

    RoundBox.FillColour.alpha = 127;
    RoundBox.LineColour.alpha = 127;

    switch( stage)
    {

        case 0 : {
                  MeshControl.Enabled = true;
                 PushButton3.Enabled = false;
                 PushButton4.Enabled = false; 
                 
                  
                ProgressArrow.Arrow.Point1.y =  ProgressArrow.Line1.Point1.y;
                ProgressArrow.Arrow.Point2.y  = ProgressArrow.Arrow.Point1.y;

                 }

        case 1 : {
                  PushButton3.Enabled = true;
                  MeshControl.Enabled = true;
                  PushButton4.Enabled = false; 
                  

                   ProgressArrow.Arrow.Point1.y =  ProgressArrow.Line2.Point1.y;
                ProgressArrow.Arrow.Point2.y  = ProgressArrow.Arrow.Point1.y;
                 }
        case 2 : {
                  PushButton4.Enabled = true; 
                 MeshControl.Enabled = true;
                 PushButton3.Enabled = true;
                 
                   ProgressArrow.Arrow.Point1.y =  ProgressArrow.Line3.Point1.y;
                ProgressArrow.Arrow.Point2.y  = ProgressArrow.Arrow.Point1.y;
                 }
        case 3 : {
                    PushButton4.Enabled = true; 
                  MeshControl.Enabled = true;
                  PushButton3.Enabled = true;

                   ProgressArrow.Arrow.Point1.y =  ProgressArrow.Line4.Point1.y;
                ProgressArrow.Arrow.Point2.y  = ProgressArrow.Arrow.Point1.y;
                   RoundBox.FillColour.alpha = 255;
                   RoundBox.LineColour.alpha = 255;
                }
        default:  {
                MeshControl.Enabled = false;
                 PushButton3.Enabled = false;
                 PushButton4.Enabled = false;
                 } 
    }

  }

  $rect <815,60,1040,100>
  slot StartFormation
  {
    sender; /* the method is called from the sender object */

    native 
    {
        Command cmd;
        cmd.int0 = 2;
        Command0( CMD_SET_MESH_STAGE, &cmd );     
    }

    ProgressArrow.Arrow.Point1.y =  ProgressArrow.Line1.Point1.y;
    ProgressArrow.Arrow.Point2.y  = ProgressArrow.Arrow.Point1.y;
    ProgressArrow.Target = ProgressArrow.Line2.Point1.y;
    ProgressArrow.Timer.Enabled = true;
    ProgressArrow.Timer.Period = 5000;


  }

  $rect <820,105,980,145>
  slot StartActivation
  {
    sender; /* the method is called from the sender object */

    native 
    {
        Command cmd;
        cmd.int0 = 3;
        Command0( CMD_SET_MESH_STAGE, &cmd );     
    }

    ProgressArrow.Arrow.Point1.y =  ProgressArrow.Line2.Point1.y;
    ProgressArrow.Arrow.Point2.y  = ProgressArrow.Arrow.Point1.y;
    ProgressArrow.Target = ProgressArrow.Line3.Point1.y;
    ProgressArrow.Timer.Enabled = true;
    ProgressArrow.Timer.Period = 2000;


  }

  $rect <830,210,1030,250>
  slot TScrollSlot
  {
    sender; /* the method is called from the sender object */


    VerticalScrollbar.Position = -VerticalList.ScrollOffset;

    Origin.y = 25 + SlideTouchHandler.Offset.y;

    InvalidateViewState();

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <860,0,960,50>;
    preset OnRelease = ImportSlot;
    preset Label = "Import";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <970,0,1070,50>;
    preset OnRelease = ExportSlot;
    preset Label = "Export";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MeshControl
  {
    preset Bounds = <639,4,744,36>;
    preset Enabled = true;
    preset OnRelease = StartSync;
    preset Label = "Start Sync.";
    preset Appearance = Application::SmallPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <640,50,745,85>;
    preset Enabled = false;
    preset OnRelease = StartFormation;
    preset Label = "Formation";
    preset Appearance = Application::SmallPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <640,100,745,134>;
    preset Enabled = false;
    preset OnRelease = StartActivation;
    preset Label = "Activation";
    preset Appearance = Application::SmallPushButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <615,200,795,249>;
    preset Label = "Add Devices";
    preset Appearance = Application::NormalPushButton;
  }

  $rect <20,20,160,60>
  object Application::ProgressArrow ProgressArrow
  {
    preset Bounds = <744,6,785,185>;
  }

  $rect <20,20,160,60>
  object Application::RoundBox RoundBox
  {
    preset Bounds = <640,150,745,180>;
    preset Radius1 = 8;
    preset LineColour = #4C4C4C83;
    preset FillColour = #AAD1FF87;
    preset Label = "Active";
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,565,350>;
    preset OnSlide = TScrollSlot;
  }

  $rect <20,20,160,60>
  object Application::DeviceInfo DeviceInfo
  {
    preset Bounds = <360,5,560,220>;
    preset Visible = false;
    preset Radius1 = 6;
  }

  $rect <0,400,200,440>
  slot InfoTap
  {
    sender; /* the method is called from the sender object */

    if ( SimpleTouchHandler.AutoDeflected )
       return;

    // Get the index of the item at the tapped position
    var int32 itemNo = VerticalList.GetItemAtPosition( SimpleTouchHandler.CurrentPos );


    if ( VerticalList.SelectedItem == itemNo && DeviceInfo.Visible )
    {
       DeviceInfo.Visible = false;
       DeviceInfo.device = 0;
       return;
    }

     VerticalList.SelectedItem = itemNo;

     if ( itemNo > 0 )
     {
      DeviceInfo.Visible = true;
      
     }

     VerticalList.InvalidateItems( 0, VerticalList.NoOfItems-1 );

  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <565,0>;
    preset Point2 = <565,350>;
    preset Point1 = <0,350>;
    preset OnPress = InfoTap;
    preset RetargetDelay = 500;
    preset RetargetCondition = Core::RetargetReason[LongPress, WipeDown, WipeLeft, WipeRight, WipeUp];
  }
}

$rect <180,820,330,860>
$output false
class MeshUnit : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,385,25>;

  $rect <5,195,205,235>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <5,155,205,195>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


     if ( Selected )
     {     
        BoxPath.Width = 3
      ;
     }
     else
     {
        BoxPath.Width = 1;
     }

    if ( Status == 3 )
    {
       Extention.String = "?";
       Extention.Color = #220022FF;
        FillPath.Color =  #1122FF80;
    }
    else if ( Status == 2 )
    {
       Extention.String = "+";
       Extention.Color = #002222FF;
       FillPath.Color =  #0055BB80;
       TypeText.String = RadioComb;
    }
    else  if ( Status == 0 )
    {
         Extention.String = "x";
       Extention.Color = #220000FF;
        FillPath.Color =  #FF22FF80;
      TypeText.String = DefinedComb;
    }
    else  if ( Status == 1 )
    {
       Extention.String = "";
        Extention.Color = #002222FF;
          FillPath.Color =  #11882280;
       TypeText.String = RadioComb;
    }      

    if ( SNR != -127 )
    {
      FillPath.Color = Hue( (int32)SNR );
    }

    DrawFillBox( 1, 1, FillPath.Bounds.w-2, FillPath.Bounds.h-2 );
    DrawBox( 1, 1, BoxPath.Bounds.w-2, BoxPath.Bounds.h-2 );
    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <160,50,330,70>;
    preset String = "Zone 55 Unit 555";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath
  {
    preset Bounds = <0,0,255,26>;
    preset ColorBL = #1BFF0000;
    preset ColorBR = #3FFF37FF;
    preset ColorTR = #3FFF37FF;
    preset ColorTL = #1BFF0000;
    preset Color = #FF1D3493;
    preset Path = Path2;
  }

  $rect <280,115,480,155>
  method void DrawFillBox( arg int32 x, arg int32 y, arg int32 width, arg int32 height )
  {
     
      Path2.InitSubPath( 0, 4 + 20  );

      Path2.Begin( 0,  x + pure Radius1, y + 0 );
      Path2.AddArc( 0,  x +  + width - pure Radius1 ,  y + pure Radius1, pure Radius1, pure Radius1, -90, 0, 5 );
      Path2.AddArc( 0,  x + width - pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 0, 90, 5 );
      Path2.AddArc( 0, x + pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 90, 180, 5 );
      Path2.AddArc( 0, x + pure Radius1, y + pure Radius1, pure Radius1, pure Radius1, 180, 270, 5 );
      Path2.Close(0 );

      
  }

  $rect <275,155,445,195>
  object Graphics::Path Path2;

  $rect <635,0,835,40>
  property int8 Radius1 = 9;

  $rect <20,20,160,60>
  object Views::StrokePath BoxPath
  {
    preset Bounds = <0,0,255,25>;
    preset Color = #000000FF;
    preset Width = 1;
    preset Path = Path1;
  }

  $rect <565,160,735,200>
  object Graphics::Path Path1;

  $rect <570,60,770,100>
  method void DrawBox( arg int32 x, arg int32 y, arg int32 width, arg int32 height )
  {
     
      Path1.InitSubPath( 0, 4 + 20  );

      Path1.Begin( 0,  x + pure Radius1, y + 0 );
      Path1.AddArc( 0,  x +  + width - pure Radius1 ,  y + pure Radius1, pure Radius1, pure Radius1, -90, 0, 5 );
      Path1.AddArc( 0,  x + width - pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 0, 90, 5 );
      Path1.AddArc( 0, x + pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 90, 180, 5 );
      Path1.AddArc( 0, x + pure Radius1, y + pure Radius1, pure Radius1, pure Radius1, 180, 270, 5 );
      Path1.Close( 0 );

     
  }

  $rect <80,35,260,75>
  $output true
  object Graphics::AttrSet AttrSet
  {
    preset Font2 = Application::FontVerdanaProSemiBold20;
    preset Font1 = Application::FontVerdanaProCondSemiBold18;
    preset Font0 = Application::VerdanaProSemiBold16;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText
  {
    preset Bounds = <4,6,41,16>;
    preset String = "ZONE";
    preset Font = Application::FontVerdana14;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneNum
  {
    preset Bounds = <42,5,63,20>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "56";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText1
  {
    preset Bounds = <64,6,93,16>;
    preset String = "UNIT";
    preset Font = Application::FontVerdana14;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text UnitNum
  {
    preset Bounds = <95,5,124,19>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "565";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <20,20,160,60>
  object Views::Text ZoneText2
  {
    preset Bounds = <125,6,154,16>;
    preset String = "TYPE";
    preset Font = Application::FontVerdana14;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TypeText
  {
    preset Bounds = <156,5,250,19>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "SN.VAD0.RB10";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }

  $rect <0,80,145,120>
  property string RadioComb = 0;

  $rect <140,80,285,120>
  property string DefinedComb = 0;

  $rect <295,80,395,120>
  property uint8 Type = 0;

  $rect <20,20,160,60>
  object Views::Text Extention
  {
    preset Bounds = <255,0,280,25>;
    preset String = "+?";
    preset Font = Resources::FontLarge;
  }

  $rect <0,120,110,155>
  object Core::Timer Timer
  {
    preset OnTrigger = Slot;
  }

  $rect <120,120,210,160>
  slot Slot
  {
    sender; /* the method is called from the sender object */

    if (  TypeText.String == DefinedComb ) 
    {
       TypeText.String = RadioComb;
    }
    else 
    {
       TypeText.String = DefinedComb;
    }

  }

  $rect <315,0,420,40>
  property int32 Status = 0;

  $rect <270,38,415,78>
  onset Status
  {
    // The value doesn't change - nothing to do.
    if ( pure Status == value )
      return;

    // Remember the property's new value.
    pure Status = value;

    if ( pure Status == 3 ) // different
    {
       Timer.Enabled = true;
    }
    else
    {
       Timer.Enabled = false;
    }




    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <420,0,560,40>
  property int8 SNR = 0;

  $rect <425,60,545,100>
  method color Hue( arg int32 h )
  {
    /* The template just returns the given argument... */

    if ( h < 0 ) h = 0;

    var int32 val  = (h % HueRange) * 255 / (HueRange-1);
    var int32 band = h / HueRange;
    var color res  = #00000050;

    if ( band == 0 )
    {
      res.red = 255;
      res.green = val;
    }
    else
    {
      res.red = 255 - val;
      res.green = 255;
    }

    return res;

  }

  $rect <460,105,660,145>
  property int32 HueRange = 10;

  $rect <280,215,480,255>
  property bool Selected = false;
}

$rect <290,710,490,750>
$output false
enum UnitState
{
  $rect <10,10,210,50>
  item Additional;

  $rect <220,10,420,50>
  item Different;

  $rect <430,10,630,50>
  item ThirdItem;
}

$rect <340,820,490,860>
$output false
class MeshUnitItem : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,600,25>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


  }

  $rect <20,20,160,60>
  object Application::MeshUnit MeshUnit
  {
    preset Bounds = <10,0,600,25>;
  }

  $rect <20,20,160,60>
  object Application::MeshNCU MeshNCU
  {
    preset Bounds = <0,0,145,25>;
  }
}

$rect <500,820,650,860>
$output false
class MeshNCU : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,220,25>;

  $rect <5,195,205,235>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <5,155,205,195>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
                                         
    DrawFillBox( 1, 1, FillPath.Bounds.w-2, FillPath.Bounds.h-2 );
    DrawBox( 1, 1, BoxPath.Bounds.w-2, BoxPath.Bounds.h-2 );

  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,26>;
    preset ColorBL = #5FEEFF82;
    preset ColorBR = #5FEEFF82;
    preset ColorTR = #ED76FFFF;
    preset ColorTL = #ED76FFFF;
    preset Color;
    preset Path = Path2;
  }

  $rect <280,115,480,155>
  method void DrawFillBox( arg int32 x, arg int32 y, arg int32 width, arg int32 height )
  {
     
      Path2.InitSubPath( 0, 4 + 20  );

      Path2.Begin( 0,  x + pure Radius1, y + 0 );
      Path2.AddArc( 0,  x +  + width - pure Radius1 ,  y + pure Radius1, pure Radius1, pure Radius1, -90, 0, 5 );
      Path2.AddArc( 0,  x + width - pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 0, 90, 5 );
      Path2.AddArc( 0, x + pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 90, 180, 5 );
      Path2.AddArc( 0, x + pure Radius1, y + pure Radius1, pure Radius1, pure Radius1, 180, 270, 5 );
      Path2.Close(0 );

      
  }

  $rect <275,155,445,195>
  object Graphics::Path Path2;

  $rect <635,0,835,40>
  property int8 Radius1 = 9;

  $rect <20,20,160,60>
  object Views::StrokePath BoxPath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,25>;
    preset Color = #000000FF;
    preset Width = 1;
    preset Path = Path1;
  }

  $rect <640,120,810,160>
  object Graphics::Path Path1;

  $rect <570,60,770,100>
  method void DrawBox( arg int32 x, arg int32 y, arg int32 width, arg int32 height )
  {
     
      Path1.InitSubPath( 0, 4 + 20  );

      Path1.Begin( 0,  x + pure Radius1, y + 0 );
      Path1.AddArc( 0,  x +  + width - pure Radius1 ,  y + pure Radius1, pure Radius1, pure Radius1, -90, 0, 5 );
      Path1.AddArc( 0,  x + width - pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 0, 90, 5 );
      Path1.AddArc( 0, x + pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 90, 180, 5 );
      Path1.AddArc( 0, x + pure Radius1, y + pure Radius1, pure Radius1, pure Radius1, 180, 270, 5 );
      Path1.Close( 0 );

     
  }

  $rect <20,20,160,60>
  object Views::Text TypeText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,5,220,20>;
    preset String = "NCU / Mesh Head";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #020202FF;
  }
}

$rect <250,1040,450,1080>
$output false
class Access
{
  $rect <0,20,200,60>
  property int32 Level = 0;
}

$rect <710,80,910,120>
$output false
class LevelAccess : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,135,15>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text LevelText
  {
    preset Bounds = <0,1,132,16>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertBottom];
    preset String = "Level 1 Access";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <160,0,360,40>
  property int32 Level = 1;

  $rect <160,40,360,80>
  onset Level
  {
    // The value doesn't change - nothing to do.
    if ( pure Level == value )
      return;

    // Remember the property's new value.
    pure Level = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.

    LevelText.String = "Level " + string( pure Level ) + " Access";

    var Application::Application app = (Application::Application) Owner;

    if ( pure Level > 1 ) 
    {
        Timer.Enabled = true;

        if (app != null )
        {
          app.LogOnButton.ButtonText = "{parc}Log Off";
          app.LogOnButton.Icon = Application::Key2Bitmap;
          app.LogOnButton.InvalidateViewState();
        }
    }
    else 
    {
        Timer.Enabled = false;     

        if (app != null )
        {
          app.LogOnButton.ButtonText = "{parc}Log On";
          app.LogOnButton.Icon = Application::KeyBitmap;
          app.LogOnButton.InvalidateViewState();
          postsignal app.AlarmsTabButton.OnPress;
        }
    }
    /*

      native
      {
        Command cmd;
        cmd.int0 = 4;
        cmd.int1 = 0;
        Command0( CMD_LOGON_ACCESS, &cmd );
       }*/
  }

  $rect <435,-5,635,35>
  object Core::Timer Timer
  {
    preset OnTrigger = Slot;
    preset Period = 60000;
  }

  $rect <735,0,935,40>
  object Core::SystemEventHandler AccessEventHandler
  {
    preset OnEvent = onEvent1;
    preset Event = Application::Devices.AccessModeChangeEvent;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <725,40,925,80>
  slot onEvent1
  {
    var Application::Access a = (Application::Access) AccessEventHandler.Context;

    if ( a.Level == 2 )
    {
       KeySwitchOn = true;

      if ( Level == 1 ) Level = 2;
    }
    else if ( a.Level == 1 )
    {
       if ( Level == 2 ) Level = 1;

        KeySwitchOn = false;
    }

  }

  $rect <325,140,525,180>
  property bool KeySwitchOn = false;

  $rect <430,35,630,75>
  slot Slot
  {
    sender; /* the method is called from the sender object */


    var bool logout = false;

    native ( logout )
    {
       Command cmd;

     //  Command0( CMD_GET_LAST_TOUCH_TIME, &cmd );

     //  if ( now() - cmd.int0 > 100 * 60 * 10 )
       {
     //     logout = true;
       }
    }


    if ( logout )
    {
       Level = 1;
    }
  }
}

// This autoobject provides the default customization for the 'push button' widget \
// (WidgetSet::PushButton) in its small size variant.
$rect <750,1350,920,1390>
$output false
autoobject WidgetSet::PushButtonConfig SmallPushButton
{
  preset LabelColorActive = #FFFFFFFF;
  preset LabelColorFocused = #FFFFFFFF;
  preset LabelColorDisabled = #A8ABABFF;
  preset LabelColorDefault = #000000FF;
  preset LabelMarginBottom = 4;
  preset LabelMarginTop = 4;
  preset LabelMarginRight = 4;
  preset LabelMarginLeft = 4;
  preset IconTintDisabled = #A8ABABAA;
  preset IconTintDefault = #6C6E70FF;
  preset IconMarginBottom = 4;
  preset IconMarginTop = 4;
  preset IconMarginRight = 4;
  preset IconMarginLeft = 4;
  preset LabelFont = Resources::FontSmall;
  preset FaceFrameActive = 3;
  preset FaceFrameFocused = 2;
  preset FaceFrameDisabled = 0;
  preset FaceFrameDefault = 1;
  preset FaceActive = WidgetSet::PushButtonSmall;
  preset FaceFocused = WidgetSet::PushButtonSmall;
  preset FaceDisabled = WidgetSet::PushButtonSmall;
  preset FaceDefault = WidgetSet::PushButtonSmall;
  preset WidgetMinSize = <23,23>;
}

$rect <650,820,800,860>
$output false
class ProgressArrow : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,45,185>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Point2 = <15,165>;
    preset Point1 = <15,14>;
    preset Width2;
    preset Width1;
    preset Width = 5;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <0,15>;
    preset Point1 = <15,15>;
    preset Width2;
    preset Width1;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Point2 = <0,65>;
    preset Point1 = <15,65>;
    preset Width2;
    preset Width1;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Point2 = <1,115>;
    preset Point1 = <16,115>;
    preset Width2;
    preset Width1;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Arrow
  {
    preset Point2 = <44,13>;
    preset Point1 = <24,13>;
    preset Width2 = 25;
    preset Color = #FF0000FF;
  }

  $rect <120,40,245,80>
  object Core::Timer Timer
  {
    preset OnTrigger = TickSlot;
    preset Period = 1000;
    preset Enabled = false;
  }

  $rect <135,0,255,40>
  slot TickSlot
  {
    sender; /* the method is called from the sender object */
     
    if ( Arrow.Point1.y < Target )
    {
        Arrow.Point1.y = Arrow.Point1.y + 1;
        Arrow.Point2.y = Arrow.Point1.y;
    }

    Timer.Period = Timer.Period + 20;




        /*
    if ( Count < 10 )
    {
      b = Idle  ;
    }
    else if ( Count < 20 )
    {
      b = Sync;
    }
    else if ( Count < 30 )
    {
      b = Mesh;
    }
    else if (  Count < 40 )
    {
      b = Active;
    }
    else  
    {
       Count = 0;
       return;
    }

    var int32 n = Count % 10;

    if ( (n & 1) > 0 )
    {
     b.CurrentValue = 0; 
    }
    else
    {
     b.CurrentValue = (n*10)+10;
    }

    Count = Count + 1;

                   */
  }

  $rect <325,25,525,65>
  property int32 Target = 0;

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft];
    preset Point2 = <1,165>;
    preset Point1 = <16,165>;
    preset Width2;
    preset Width1;
    preset Width = 3;
    preset Color = #000000FF;
  }
}

$rect <180,1250,380,1290>
$output false
class RoundBox : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,270,210>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    StrokePath.Color = LineColour;
    FillPath.Color = FillColour;

    DrawBox(  ((int16)StrokePath.Width)/2, ((int16)StrokePath.Width)/2, Bounds.w - (int16)StrokePath.Width, Bounds.h - (int16)StrokePath.Width );
    DrawFillBox(  ((int16)StrokePath.Width)/2, ((int16)StrokePath.Width)/2, Bounds.w - (int16)StrokePath.Width, Bounds.h - (int16)StrokePath.Width );


    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    Text.String = Label;


    //, DrawFillBox, Path1, Path2

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,270,210>;
    preset Color = #FF00B2FF;
    preset Path = Path2;
  }

  $rect <20,20,160,60>
  object Views::StrokePath StrokePath
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,270,210>;
    preset Color = #000000FF;
    preset Width = 2;
    preset Path = Path1;
  }

  $rect <305,110,505,150>
  method void DrawFillBox( arg int32 x, arg int32 y, arg int32 width, arg int32 height )
  {
     
      Path2.InitSubPath( 0, 4 + 20  );

      Path2.Begin( 0,  x + pure Radius1, y + 0 );
      Path2.AddArc( 0,  x +  + width - pure Radius1 ,  y + pure Radius1, pure Radius1, pure Radius1, -90, 0, 5 );
      Path2.AddArc( 0,  x + width - pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 0, 90, 5 );
      Path2.AddArc( 0, x + pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 90, 180, 5 );
      Path2.AddArc( 0, x + pure Radius1, y + pure Radius1, pure Radius1, pure Radius1, 180, 270, 5 );
      Path2.Close(0 );

      
  }

  $rect <300,150,470,190>
  object Graphics::Path Path2;

  $rect <600,80,770,120>
  object Graphics::Path Path1;

  $rect <585,20,785,60>
  method void DrawBox( arg int32 x, arg int32 y, arg int32 width, arg int32 height )
  {
     
      Path1.InitSubPath( 0, 4 + 20  );

      Path1.Begin( 0,  x + pure Radius1, y + 0 );
      Path1.AddArc( 0,  x +  + width - pure Radius1 ,  y + pure Radius1, pure Radius1, pure Radius1, -90, 0, 5 );
      Path1.AddArc( 0,  x + width - pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 0, 90, 5 );
      Path1.AddArc( 0, x + pure Radius1, y + height - pure Radius1, pure Radius1, pure Radius1, 90, 180, 5 );
      Path1.AddArc( 0, x + pure Radius1, y + pure Radius1, pure Radius1, pure Radius1, 180, 270, 5 );
      Path1.Close( 0 );

     
  }

  $rect <600,130,800,170>
  property int32 Radius1 = 5;

  $rect <310,10,510,50>
  property color LineColour = #000000FF;

  $rect <310,50,510,90>
  property color FillColour = #FF4399FF;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,270,210>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "....";
    preset Font = Resources::FontSmall;
    preset Color = #373737FF;
  }

  $rect <900,0,1100,40>
  property string Label = "Label";
}

$rect <960,820,1160,860>
$output false
class DeviceInfo : Application::RoundBox
{
  $rect <285,75,425,115>
  inherited property Bounds = <0,0,200,215>;

  $rect <60,375,305,430>
  inherited method UpdateViewState()
  {
    // TO DO: Write your code here ... 
                            
    var int32 Status = -1;
    var int32 minutes = -1;
    var int16 second = -1;                               
    var int32 SNR = -32768;
    var uint32 tx = 0;
    var uint32 lost = 0;
    var int32 child = device;


    if ( device != 0 ) native( child, SNR, Status, second, minutes, tx, lost )
    {
       RadioUnit* ru = (RadioUnit*) child;
       SNR           = ru->snrprimary;
       minutes       = ( now( ) - ru->starttime ) / 60;
       second        = ru->secondary;
       tx            = ru->sent;
       lost            = ru->lost;
     
       Command cmd;
       cmd.int0 = ru->unit;

       Command0( CMD_GET_DEVICE, &cmd );

       if ( cmd.int0 != 0 )
       {
          DeviceConfig* dc = (DeviceConfig*) cmd.int0;

          if ( dc->type == ru->combination )
          {
             Status = 1;   // ok
          }
          else
          {
             Status = 3;    // different ?
          }
       }
       else
       { 
          Status = 2;    // additional  +
       }
    }


    if ( second != -1 )
    {
       secondary.String = "Unit "+string(second);
    }
    else
    {
       secondary.String = "---";
    }  

    switch( Status )
    {
      case 0 : status.String = "Not Found";
      case 1 : status.String = "Found";
      case 2 : status.String = "Additional";
      case 3 : status.String = "Mismatched";
      default: status.String = "---";
    }

    if ( SNR != -32768 )
      snr.String = string(SNR) + "dB";
    else
      snr.String = "---";

    stats_sent.String = string(tx);
    stats_lost.String = string(lost);

    if ( tx == 0 )
    {
      stats_success.String = "-";
    }
    else
    {
      stats_success.String = string( (float)(tx - lost) * 100.0 / (float)tx, 0, 2 ) +"%%";
    }

    if ( minutes != -1 )
    {
       if ( minutes < 60 )
       {
          live.String = string(minutes) + "mins";
       }
       else if ( minutes < 60 * 24 )
       {
          live.String = string(minutes/60) + "hours";
       }
       else if ( minutes < 60 * 24 * 7 )
       {
          live.String = string(minutes/60/24) + "days";
       }
       else if ( minutes < 60 * 24 * 365 )
       {
          live.String = string(minutes/60/24/7) + "weeks"; 
       }
       else
       {
           live.String = string(minutes/60/24/30) + "months"; 
       }
    }
  }

  $rect <280,10,420,50>
  inherited property FillColour = #E0E0E0FF;

  $rect <20,20,160,60>
  inherited object Text
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <10,10,55,35>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "SNR:";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <10,35,100,60>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Secondary:";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Bounds = <10,60,100,85>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Status:";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text5
  {
    preset Bounds = <10,85,100,110>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Battery:";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text snr
  {
    preset Bounds = <93,10,141,35>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text secondary
  {
    preset Bounds = <93,35,190,60>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text status
  {
    preset Bounds = <93,60,190,85>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text battery
  {
    preset Bounds = <93,85,190,110>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text11
  {
    preset Bounds = <10,110,100,135>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Live:";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text live
  {
    preset Bounds = <93,110,190,135>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <40,250,240,290>
  property int32 device = 0;

  $rect <40,295,240,335>
  onset device
  {
    // The value doesn't change - nothing to do.
    if ( pure device == value )
      return;

    // Remember the property's new value.
    pure device = value;

    if ( device == 0 )
    {
      Timer.Enabled = false;
    }
    else
    {
      Timer.Enabled = true;
    }
     
    InvalidateViewState(  );
           

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Views::Text stats_4
  {
    preset Bounds = <10,160,100,185>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Lost:";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text stats_sent
  {
    preset Bounds = <93,135,190,160>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "0";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <445,180,645,220>
  object Core::Timer Timer
  {
    preset OnTrigger = Slot;
  }

  $rect <440,225,640,265>
  slot Slot
  {
    sender; /* the method is called from the sender object */

    if ( Visible )
    {
      if ( device != 0 )
      {
        InvalidateViewState( );
      }
    }
  }

  $rect <20,20,160,60>
  object Views::Text stats_1
  {
    preset Bounds = <10,135,100,160>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Sent:";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text stats_3
  {
    preset Bounds = <10,185,100,210>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Success:";
    preset Font = Application::FontVerdanaProCondSemiBold18;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text stats_lost
  {
    preset Bounds = <93,160,190,185>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text stats_success
  {
    preset Bounds = <93,185,190,210>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "---";
    preset Font = Flat::FontS;
    preset Color = #000000FF;
  }
}

$rect <0,1540,180,1580>
$output false
class DFUPopup : Application::Popup
{
  $rect <0,250,140,290>
  inherited property Bounds = <0,0,430,210>;

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <37,105,367,150>;
    preset CurrentValue = 0;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <38,21,279,54>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Firmware Upgrade Mode";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <42,84,290,105>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "File transfer";
    preset Font = Resources::FontSmall;
  }

  $rect <230,280,430,320>
  slot Activate
  {
    sender; /* the method is called from the sender object */


    native
    {
      Command cmd;
    		
      Command0( CMD_DFU_MODE, &cmd );
    }


  }

  $rect <480,30,680,70>
  object Core::Timer Timer
  {
    preset OnTrigger = Activate;
    preset Period = 200;
  }
}

$rect <640,1170,840,1210>
$output false
set ActionBits
{
  $rect <10,10,210,50>
  item Fire;

  $rect <220,10,420,50>
  item FirstAid;

  $rect <220,60,420,100>
  item Evacuation;

  $rect <430,10,630,50>
  item Security;

  $rect <690,130,890,170>
  item General;

  $rect <690,70,890,110>
  item Fault;

  $rect <640,10,840,50>
  item Test;

  $rect <10,60,210,100>
  item SilentTest;

  $rect <460,130,660,170>
  item RoutingAck;

  $rect <10,110,210,150>
  item Reset;

  $rect <210,120,410,160>
  item Silence;

  $rect <460,70,660,110>
  item Undefined;
}

$rect <230,1500,430,1540>
$output false
class LibClass
{
  $rect <0,60,200,100>
  method uint16 GetBits( arg Application::ActionBits bits )
  {
    /* The template just returns the given argument... */

    var uint16 b = (uint16) bits;

    return b;


  }

  $rect <10,10,210,50>
  method Application::DeviceConfig GetConfig( arg int16 unit_num )
  {
    //var Application::DeviceConfig d;
    //var Application::DeviceConfig d;

    var Application::DeviceConfig dev = new Application::DeviceConfig;

    var string s = "";

    if ( dev != null ) native( dev, unit_num )
    {
       Command cmd;

      
       cmd.int0 = (int)unit_num & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );
       

       DeviceConfig* d = (DeviceConfig*) cmd.int0;

       if ( d != NULL ) 
       { 
         dev->combination = d->type;
         s    = EwNewStringAnsi( d->location );
    //     dev->locationptr = (int) d->location; 
         dev->numparams   = d->numParams;
         dev->unitnum     = d->unit;
         dev->zonenum     = d->zone;
       }
       else dev = NULL;
    }

    var uint8 i;
    var uint8 o;
    var uint8 p;

    if ( dev != null )
    {
      dev.location = s;

      for( i = 0; i < Application::Lib.NumInputChannels( unit_num ); i = i + 1 )
      {
         dev.inputs[i] = GetInput( unit_num, i );
      }

      for( o = 0; o < Application::Lib.NumOutputChannels( unit_num ); o = o + 1 )
      {
         dev.outputs[o] = GetOutput( unit_num, o );
      }

      for( p = 0; p < dev.params.size; p = p + 1 )
      {
         dev.params[p] = GetParameter( unit_num, p );
      }
      return dev;
    }

        
    return Application::DummyConfig;

  }

  $rect <20,110,220,150>
  method Application::InputChannel GetInput( arg int16 unitnum, arg uint8 channel )
  {
    var Application::InputChannel input = new Application::InputChannel; 

    if ( input != null ) native( unitnum, channel, input)
    {
       Command cmd;

       cmd.int0 = (int)unitnum & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );

       DeviceConfig* d = (DeviceConfig*) cmd.int0;
       InputChannel* i = d->input + channel;

       if ( d != NULL ) 
       {

         input->delay  = i->delay;
         input->flags  = i->flags;
         input->action = i->action;
         input->type   = i->type;

         return input;
       }
    }

    return null;

  }

  $rect <0,190,200,230>
  method int32 NumInputChannels( arg int16 unitnum )
  {
    var int32 result = 0;

    native( unitnum )
    {
       Command cmd;

       cmd.int0 = (int)unitnum & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );

       DeviceConfig* d = (DeviceConfig*) cmd.int0;

       if ( d != NULL ) 
       {
         InputChannel* i;
         for( i = d->input; i < d->input + SITE_MAX_INPUT_CHANNELS; i++ )
         {
            if ( i->type != CO_CHANNEL_NONE_E ) result++;
         }
       }   
    }

    return result;

  }

  $rect <10,240,210,280>
  method int32 NumOutputChannels( arg int16 unitnum )
  {
    var int32 result = 0;

    native( unitnum )
    {
       Command cmd;

       cmd.int0 = (int)unitnum & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );

       DeviceConfig* d = (DeviceConfig*) cmd.int0;

       if ( d != NULL ) 
       {
         OutputChannel* o;
         for( o = d->output; o < d->output + SITE_MAX_OUTPUT_CHANNELS; o++ )
         {
            if ( o->type != CO_CHANNEL_NONE_E ) result++;
         }
       }   
    }

    return result;

  }

  $rect <20,300,220,340>
  method int32 NumZones()
  {
    var int32 numzones = 32;

    native( numzones )
    {
       Command cmd;
       
       Command0( CMD_GET_NUM_ZONE_LEDS, &cmd );
       numzones = cmd.int0;
    }

    return numzones;
  }

  $rect <10,150,210,190>
  method Application::OutputChannel GetOutput( arg int16 unitnum, arg uint8 channel )
  {
     
    var Application::OutputChannel output = new Application::OutputChannel;

    if ( output != null ) native( unitnum, channel, output )
    {
       Command cmd;

       cmd.int0 = (int)unitnum & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );

       DeviceConfig* d = (DeviceConfig*) cmd.int0;
       OutputChannel* o = d->output + channel;

       if ( d != NULL ) 
       {
           
         output->delay1  = o->delay1;
         output->delay2  = o->delay2;
         output->flags   = o->flags;
         output->actions = o->actions;
         output->type    = o->type;
         return output;
       }
    }

    return null;

  }

  $rect <270,10,470,50>
  method string TypeName( arg Application::ChannelType type )
  {
    /* The template just returns the given argument... */
       switch ( type )
       {
      	  case Application::ChannelType.None : return "<Unused>";								
          case Application::ChannelType.Smoke : return "Smoke";				
          case Application::ChannelType.Heat : return "Heat";				
          case Application::ChannelType.Co : return "CO";					
          case Application::ChannelType.Pir : return "PIR";								
          case Application::ChannelType.Sounder : return "Sounder";							
          case Application::ChannelType.Beacon : return "Beacon";								
          case Application::ChannelType.Fire_callpoint : return "Fire Callpoint";					
          case Application::ChannelType.Status_indicator_led : return " lED";			
          case Application::ChannelType.Visual_indicator : return "Visual Indicator";
          case Application::ChannelType.Sounder_visual_indicator_combined : return "Sounder/VI";	
          case Application::ChannelType.Medical_callpoint : return "Medical Callpoint";
          case Application::ChannelType.Evac_callpoint : return "Evac Callpoint";
          case Application::ChannelType.Output_routing : return "Output Routing";
    	    default :
          {
               if ( (int32) type <=  (int32) Application::ChannelType.Input32 &&
                    (int32) type >=  (int32) Application::ChannelType.Input1)
               {
                   return "Channel " + string( ((int32) type + 1 ) -  (int32) Application::ChannelType.Input1);
               }
               if ( (int32) type <=  (int32) Application::ChannelType.Output32 &&
                    (int32) type >=  (int32) Application::ChannelType.Output1 )
               {
                   return "Channel " + string( ((int32) type + 1 ) -  (int32) Application::ChannelType.Output1);
               }
           }
        }
    return "?";

  }

  $rect <290,70,490,110>
  method bool SetConfig( arg int16 unit_num, arg Application::DeviceConfig dev )
  {
    //var Application::DeviceConfig d;

     
    var bool result = false;

    native( dev, unit_num )
    {
       int i = 0;
     
       DeviceConfig d;
       Command cmd;
     
       d.type      = dev->combination;
       EwStringToAnsi( dev->location, d.location, SITE_MAX_STRING_LEN, '^' ); 
       d.numParams = dev->numparams;
       d.unit      = dev->unitnum;
       d.zone      = dev->zonenum;

       while ( dev->inputs[ i] != NULL && i < SITE_MAX_INPUT_CHANNELS )
       {
          d.input[ i].flags = (uint16_t) dev->inputs[ i]->flags;
          d.input[ i].delay = dev->inputs[ i]->delay;
          d.input[ i].action = dev->inputs[ i]->action;
          d.input[ i].type   = (ChannelType) dev->inputs[ i]->type;
          i++;
       }
       i = 0;
       while ( dev->outputs[ i] != NULL && i < SITE_MAX_OUTPUT_CHANNELS )
       {
          d.output[ i].flags = (uint16_t) dev->outputs[ i]->flags;
          d.output[ i].delay1 = dev->outputs[ i]->delay1;
          d.output[ i].delay2 = dev->outputs[ i]->delay2;

          d.output[ i].actions = dev->outputs[ i]->actions;
          d.output[ i].type   = (ChannelType) dev->outputs[ i]->type;
          i++;
       }
       for( i = 0; i < SITE_MAX_CHANNEL_PARAMS; i++ )
       {
          d.param[ i].code = (ParamType) dev->params[ i]->code;
          d.param[ i].channel =          dev->params[ i]->channel;
          d.param[ i].value =            dev->params[ i]->value;
          d.param[ i].min =            dev->params[ i]->min;
          d.param[ i].max =            dev->params[ i]->max;
          EwStringToAnsi( dev->params[ i]->name, d.param[ i].name, SITE_MAX_STRING_LEN, '^' ); 
       }
       

       if ( cmd.int0 != 0 )
       {
          cmd.int0 = unit_num;  // dest address
          cmd.int1 = (int) &d;        // new device data
          
          result = ( Command0( CMD_SET_DEVICE_ALL, &cmd ) == CMD_OK );
       }
    }

    return result;

  }

  $rect <270,140,470,180>
  method Application::Parameter GetParameter( arg int16 unitnum, arg uint8 index )
  {
    var Application::Parameter param = new Application::Parameter;

    if ( param != null ) native( param, unitnum, index )
    {
      if ( index < SITE_MAX_CHANNEL_PARAMS )
      {
       Command cmd;

       cmd.int0 = (int)unitnum & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );

       DeviceConfig* d = (DeviceConfig*) cmd.int0;
       Parameter* p = d->param + index;

       if ( d != NULL ) 
       {         
         param->code = (ParamType) p->code;
         param->channel =  p->channel;
         param->value   =  p->value;
         param->min     =  p->min;
         param->max     =  p->max;
         EwStringToAnsi( param->name, p->name, SITE_MAX_STRING_LEN, '^' ); 
         return param;
       }
      }
    }

    return null;


  }

  $rect <270,230,470,270>
  method int32 NumDevsInZone( arg uint8 zone )
  {
    var int32 numdevs = 4; 

    native( numdevs, zone )
    {  
      Command cmd;

      cmd.int0 = (int) zone;
      Command0( CMD_GET_NUM_DEVS_IN_ZONE, &cmd );
      numdevs = cmd.int0;
    }

    return numdevs;
  }

  $rect <260,300,460,340>
  $output true
  method int16 GetDevInZone( arg int32 zone, arg int32 devno )
  {
    native( zone, devno )
    {  
      Command cmd;

      cmd.int0 = zone;
      cmd.int1 = devno;
      Command0( CMD_GET_DEV_IN_ZONE, &cmd );
      DeviceConfig* device = (DeviceConfig*) cmd.int0;

      return device->unit;
    }

    return devno + 1;
  }

  $rect <20,390,220,430>
  method Application::Device GetDevice( arg int16 unit_num )
  {
    //var Application::DeviceConfig d;
                            
    var Application::Device dev = new Application::Device;

    native( dev, unit_num )
    {
       Command cmd;
     
       cmd.int0 = (int)unit_num & 0xFFFF;
       Command0( CMD_FIND_DEVICE_FROM_UNIT, &cmd );
       
       Device* d = (Device*) cmd.int0;

       if ( d != NULL ) 
       {
         for( int n = 0; n < SITE_MAX_INPUT_CHANNELS; n++ )
         {
            dev->flags[n]   = d->flags[n];    
         }
         dev->settings = d->settings;
         return dev; 
       }     
    }

    return null;

  }

  $rect <530,50,730,90>
  method int32 GetCuRadio( arg int32 aArg1 )
  {
    /* The template just returns the given argument... */
    return aArg1;
  }

  $rect <280,380,480,420>
  method int32 NumZonesWithDevices()
  {
    var int32 numzones = NumZones();
    var int32 z;
    var int32 usedzones = 0;

    for( z = 1; z <= 96; z = z + 1 )
    {
        if ( NumDevsInZone( z) > 0 ) usedzones = usedzones + 1;
    }

    return usedzones;
  }

  $rect <520,320,690,360>
  method Application::ZoneFlags GetZoneFlags( arg int16 zone )
  {
    var Application::ZoneFlags zf = Application::ZoneFlags[];

    native( zone, zf )
    {
      Command cmd;
      cmd.int0 = zone;
      Command0( CMD_GET_ZONE_FLAGS, &cmd );

      zf = (ApplicationZoneFlags) cmd.int0;
    }

    return zf;


  }

  $rect <520,360,690,400>
  method void SetZoneFlags( arg int16 zone, arg Application::ZoneFlags flags )
  {
    native( zone, flags )
    {
      Command2( CMD_SET_ZONE_FLAGS, zone, flags );
    }


  }

  $rect <10,430,210,470>
  method void SetDevice( arg int16 unit_num, arg Application::Device dev )
  {
    //var Application::DeviceConfig d;
                            
    native( dev, unit_num )
    {
       Command cmd;
     
       cmd.int0 = (int)unit_num & 0xFFFF;
       Command0( CMD_FIND_DEVICE_FROM_UNIT, &cmd );
       
       Device* d = (Device*) cmd.int0;

       if ( d != NULL ) 
       {
         for( int n = 0; n < SITE_MAX_INPUT_CHANNELS; n++ )
         {
            d->flags[n]   = dev->flags[n];    
         }
         d->settings = dev->settings; 
       }     
    }
                 

  }

  $rect <590,190,790,230>
  method void SwitchOuput( arg int16 UnitNum, arg uint8 ChanNum, arg Application::Action profile, arg bool state )
  {
    native( UnitNum, ChanNum, state, profile )
    {
        Command cmd;
       
        cmd.int0 = (int) UnitNum;
        cmd.int1 = (int) ChanNum;
        cmd.int2 = (int) state;
        cmd.int3 = (int) profile;

        Command0( CMD_SET_OUTPUT_CHANNEL, &cmd ) == CMD_OK;
    }

  }

  $rect <530,100,730,140>
  method string ProfileName( arg Application::Action action )
  {
      switch ( action )
      {
        case Application::Action.Fire : return "Fire";
        case Application::Action.FirstAid : return "First Aid";
        case Application::Action.Security : return "Security";
        case Application::Action.Test : return "Test Sound";
        case Application::Action.SilentTest : return "Quiet Test";
        case Application::Action.Evacuation : return "Evacuatiom";
        case Application::Action.General : return "General";
        case Application::Action.Fault : return "Fault";
        default : return "-";
      }
  }

  $rect <590,260,790,300>
  method Resources::Bitmap TypeBitmap( arg Application::ChannelType type )
  {
    /* The template just returns the given argument... */
       switch ( type )
       {
      	  case Application::ChannelType.None : return null;								
          case Application::ChannelType.Smoke : return Application::SmokeBitmap;				
          case Application::ChannelType.Heat : return Application::HeatSensorBitmap;			
          case Application::ChannelType.Co : return Application::COBitmap;					
          case Application::ChannelType.Pir : return Application::PIRBitmap;							
          case Application::ChannelType.Sounder : return Application::SounderBitmap;						
          case Application::ChannelType.Beacon : return Application::BeaconBitmap;					
          case Application::ChannelType.Fire_callpoint : return Application::FireAlarmBitmap;					
          case Application::ChannelType.Status_indicator_led : return null;			
          case Application::ChannelType.Visual_indicator : return Application::VIBitmap;
          case Application::ChannelType.Sounder_visual_indicator_combined : return Application::SounderVIBitmap;	
          case Application::ChannelType.Medical_callpoint : return Application::GreenCallpointBitmap;
          case Application::ChannelType.Evac_callpoint : return Application::evacuate;
          case Application::ChannelType.Output_routing : return Application::FireRouting;
    	    default :
          {
               if ( (int32) type <=  (int32) Application::ChannelType.Input32 &&
                    (int32) type >=  (int32) Application::ChannelType.Input1)
               {
                   return Application::GeneralInputBitmap;
               }
               if ( (int32) type <=  (int32) Application::ChannelType.Output32 &&
                    (int32) type >=  (int32) Application::ChannelType.Output1 )
               {
                   return Application::GeneralOutputBitmap;
               }
           }
        }
    return null;

  }

  $rect <530,0,730,40>
  method Application::DeviceConfig GetConfigNum( arg int16 unit_num )
  {
    //var Application::DeviceConfig d;
    //var Application::DeviceConfig d;

    var Application::DeviceConfig dev = new Application::DeviceConfig;

    var string s = "";

    if ( dev != null ) native( dev, unit_num )
    {
       Command cmd;
      
       cmd.int0 = (int)unit_num & 0xFFFF;
       Command0( CMD_GET_DEVICE, &cmd );
       
       DeviceConfig* d = (DeviceConfig*) cmd.int0;

       if ( d != NULL ) 
       { 
         dev->combination = d->type;
         s    = EwNewStringAnsi( d->location );
    //     dev->locationptr = (int) d->location; 
         dev->numparams   = d->numParams;
         dev->unitnum     = d->unit;
         dev->zonenum     = d->zone;
       }
       else dev = NULL;
    }

    var uint8 i;
    var uint8 o;
    var uint8 p;

    if ( dev != null )
    {
      dev.location = s;

      for( i = 0; i < Application::Lib.NumInputChannels( unit_num ); i = i + 1 )
      {
         dev.inputs[i] = GetInput( unit_num, i );
      }

      for( o = 0; o < Application::Lib.NumOutputChannels( unit_num ); o = o + 1 )
      {
         dev.outputs[o] = GetOutput( unit_num, o );
      }

      for( p = 0; p < dev.params.size; p = p + 1 )
      {
         dev.params[p] = GetParameter( unit_num, p );
      }
      return dev;
    }

        
    return Application::DummyConfig;

  }
}

$rect <240,1540,440,1580>
$output false
autoobject Application::LibClass Lib;

$rect <860,1170,1060,1210>
$output false
set Options
{
  $rect <10,10,210,50>
  item Latching;

  $rect <220,10,420,50>
  item Sustained;

  $rect <430,10,630,50>
  item Inverted;

  $rect <640,10,840,50>
  item DoubleKnock;

  $rect <480,60,680,100>
  item Disabled;

  $rect <250,70,450,110>
  item IgnoreDelay;

  $rect <20,70,220,110>
  item Silenceable;
}

$rect <880,1220,1080,1260>
$output false
class RadioUnit
{
  $rect <0,0,200,40>
  property int16 zonenum = 0;

  $rect <0,40,200,80>
  property int16 unitnum = 0;

  $rect <0,80,200,120>
  property char combination = 0;

  $rect <0,120,200,160>
  property uint32 starttime = 0;

  $rect <0,160,200,200>
  property int16 snr = 0;

  $rect <0,200,200,240>
  property int16 primary = 0;

  $rect <0,240,200,280>
  property int16 received = 0;

  $rect <0,280,200,320>
  property int16 sent = 0;
}

$rect <660,1210,860,1250>
$output false
class DeviceConfig
{
  $rect <0,0,200,40>
  property int16 zonenum = 0;

  $rect <0,40,200,80>
  property int16 unitnum = 0;

  $rect <0,80,200,120>
  $output true
  property uint8 combination = 0;

  $rect <0,120,200,160>
  $output true
  property uint8 numparams = 0;

  $rect <10,220,210,260>
  $output true
  array Application::InputChannel inputs[ 32 ];

  $rect <10,270,210,310>
  $output true
  array Application::OutputChannel outputs[ 32 ];

  $rect <10,320,210,360>
  $output true
  array Application::Parameter params[ 4 ];

  $rect <20,390,220,430>
  method int32 NumInputs()
  {
    /* The template just returns the given argument... */

    var int32 n = 0;

    while ( inputs[ n] != null && inputs[ n].type != Application::ChannelType.None )
    {
       n = n + 1;
    }

    return n;
  }

  $rect <10,430,210,470>
  method int32 NumOutputs()
  {
    /* The template just returns the given argument... */

    var int32 n = 0;

    while ( outputs[ n] != null && outputs[ n].type != Application::ChannelType.None )
    {
       n = n + 1;
    }

    return n;
  }

  $rect <210,410,410,450>
  method int32 NumParams()
  {
    /* The template just returns the given argument... */

    var int32 n = 0;

    while ( params[ n] != null && params[ n].code != Application::ParamCode.Unused )
    {
       n = n + 1;
    }

    return n;

  }

  $rect <260,10,460,50>
  property string location;

  $rect <0,160,200,200>
  $output true
  property string combiname = 0;
}

$rect <980,1260,1180,1300>
$output false
class InputChannel
{
  $rect <0,0,200,40>
  property uint16 delay = 0;

  $rect <0,40,230,80>
  property Application::Options flags = Application::Options[];

  $rect <0,80,200,120>
  property uint8 action = 0;

  $rect <0,120,200,160>
  property Application::ChannelType type = Application::ChannelType.None;
}

$rect <810,1130,1010,1170>
$output false
enum Action
{
  $rect <10,10,210,50>
  item Fire = 0;

  $rect <220,10,420,50>
  item FirstAid;

  $rect <240,60,440,100>
  item Evacuation;

  $rect <430,10,630,50>
  item Security;

  $rect <680,110,880,150>
  item General;

  $rect <460,110,660,150>
  item Fault;

  $rect <640,10,840,50>
  item Test;

  $rect <10,60,210,100>
  item SilentTest;

  $rect <240,110,440,150>
  item RoutingAck;

  $rect <20,110,220,150>
  item Reset;

  $rect <650,60,850,100>
  item Silence;

  $rect <440,60,640,100>
  item Undefined;
}

$rect <770,1260,970,1300>
$output false
enum ChannelType
{
  $rect <430,10,630,50>
  item None = 0;

  $rect <310,250,510,290>
  item Smoke;

  $rect <780,220,980,260>
  item Heat;

  $rect <530,220,730,260>
  item Co;

  $rect <60,230,260,270>
  item Pir;

  $rect <80,170,280,210>
  item Sounder;

  $rect <740,160,940,200>
  item Beacon;

  $rect <500,160,700,200>
  item Fire_callpoint;

  $rect <280,120,480,160>
  item Status_indicator_led;

  $rect <50,120,250,160>
  item Visual_indicator;

  $rect <290,200,550,240>
  item Sounder_visual_indicator_combined;

  $rect <220,10,420,50>
  item Medical_callpoint;

  $rect <710,30,910,70>
  item Evac_callpoint;

  $rect <490,90,690,130>
  item Output_routing;

  $rect <260,70,460,110>
  item Input1;

  $rect <280,360,480,400>
  item Input32 = 45;

  $rect <10,70,210,110>
  item Output1 = 46;

  $rect <30,360,230,400>
  item Output32 = 77;
}

$rect <980,1300,1180,1340>
$output false
class OutputChannel
{
  $rect <0,0,200,40>
  property uint16 delay1 = 0;

  $rect <230,0,430,40>
  property uint16 delay2 = 0;

  $rect <0,40,230,80>
  property Application::Options flags = Application::Options[];

  $rect <0,80,200,120>
  property Application::ActionBits actions = Application::ActionBits[];

  $rect <0,120,200,160>
  property Application::ChannelType type = Application::ChannelType.None;
}

$rect <1080,1220,1230,1260>
$output false
class Parameter
{
  $rect <0,0,200,40>
  $output true
  property uint8 channel = 0;

  $rect <0,50,200,90>
  $output true
  property string name = "";

  $rect <0,100,200,140>
  $output true
  property int16 value = 0;

  $rect <0,150,200,190>
  $output true
  property Application::ParamCode code = Application::ParamCode.Unused;

  $rect <230,200,430,240>
  $output true
  property int16 max = 0;

  $rect <10,200,210,240>
  $output true
  property int16 min = 0;
}

$rect <640,1120,840,1160>
$output false
enum ParamCode
{
  $rect <10,60,210,100>
  item Unused = 0;

  $rect <10,10,210,50>
  item Volume = 1;

  $rect <220,10,420,50>
  item FlashRate;
}

$rect <900,580,1060,620>
$output false
class OutputParams : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,510,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorizontalSlider
  {
    preset Bounds = <117,80,317,130>;
    preset Enabled = true;
    preset MaxValue = 3;
    preset MinValue = 0;
    preset CurrentValue = 2;
    preset Appearance = WidgetSet::HorizontalSlider_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <60,10,240,65>;
    preset Checked = true;
    preset OnSwitchOn = FlashSlotOn;
    preset OnSwitchOff = FlashSlotOff;
    preset Icon = null;
    preset LabelOn = "0.5Hz";
    preset LabelOff = "1Hz";
    preset Label = "Flash Rate";
    preset Appearance = Application::NotmalToggleButton;
  }

  $rect <20,20,160,60>
  object Views::Text VolumeText
  {
    preset Bounds = <20,91,103,115>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Volume";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text SecondsText
  {
    preset Bounds = <249,20,357,45>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "1 Second";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <805,10,975,50>
  slot FlashSlotOff
  {
    sender; /* the method is called from the sender object */

    SecondsText.String = "2 Seconds";


  }

  $rect <810,60,980,100>
  slot FlashSlotOn
  {
    sender; /* the method is called from the sender object */

    SecondsText.String = "1 Second";




  }

  $rect <580,130,780,170>
  method int32 Method( arg int32 aArg1 )
  {
      /*
    if ( (flags & 1) == 1 )
    { 
      p.ToggleButton.Enabled = true;
      p.SecondsText.Color = #FFFFFFFF;
    }
    else
    {
      p.ToggleButton.Enabled = false;
      p.SecondsText.Color = #999999FF;
    }

    if ((flags & 2) == 2 )
    {
      p.HorizontalSlider.Enabled = true;
      p.VolumeText.Color = #FFFFFFFF;
    }
    else
    {
      p.HorizontalSlider.Enabled = false;
      p.VolumeText.Color = #999999FF;
    }

    //p.Writable.TextEditor.Text.String = location;
    p.Writable.TextEditor.String = location;

    p.HorizontalSlider.CurrentValue = vol;
    p.ToggleButton.Checked = frate == 0;

    if ( icount == 0 )
    {
      p.InputChanButton.Enabled = false;
    }
    else
    {
      p.InputChanButton.Enabled = true;
    }

    if ( ocount == 0 )
    {
      p.OutputChanButton.Enabled = false;
    }
    else
    {
      p.OutputChanButton.Enabled = true;
    }
    */
  }
}

$rect <770,670,910,710>
$output false
class ParamSlider : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,70>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <80,350,860,670>;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <10,16,212,46>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorzBarSlider
  {
    preset Bounds = <221,10,538,52>;
    preset OnChange = null;
    preset OnEnd = null;
    preset StepSize = 1;
    preset MaxValue = 14;
    preset CurrentValue = 0;
    preset Appearance = Application::NormalHorizontalSlider;
  }

  $rect <30,90,230,130>
  property Application::Parameter param = null;
}

$rect <650,670,790,710>
$output false
class ParamToggle : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,60>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <80,350,860,670>;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <270,10,355,55>;
    preset Label = "";
    preset Appearance = WidgetSet::Switch_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <10,16,212,46>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <30,90,230,130>
  property Application::Parameter param = null;
}

$rect <760,710,900,750>
$output false
class ParamSpecific : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,550,40>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <80,350,860,670>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <9,1,299,36>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Channel parameters";
    preset Font = Flat::FontM;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <542,20>;
    preset Point1 = <222,20>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <11,46,213,76>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }
}

$rect <470,1220,610,1260>
$output false
class Device
{
  $rect <70,90,310,120>
  $output true
  array Application::ChannelFlags flags[ 32 ];

  $rect <20,40,220,80>
  property Application::DeviceSetting settings = Application::DeviceSetting[];
}

$rect <430,1160,630,1200>
$output false
set ChannelFlags
{
  $rect <10,10,210,50>
  item Asserted = 1;

  $rect <220,10,420,50>
  item Silenced = 2;

  $rect <430,10,630,50>
  item Latched = 4;

  $rect <240,70,440,110>
  item InputDisabled = 8;

  $rect <640,10,840,50>
  item Active = 16;

  $rect <850,10,1050,50>
  item OnTest = 32;

  $rect <20,70,220,110>
  item InFault = 64;

  $rect <520,70,720,110>
  item OutputDisabled = 128;
}

$rect <660,1070,860,1110>
$output false
autoobject Application::DeviceConfig DummyConfig
{
  preset zonenum = 1;
  preset unitnum = 1;
  preset combination = 10;
  preset numparams = 0;
  preset location = "Devcice Location";
}

$rect <250,1420,450,1460>
$output false
class Zone;

$rect <260,1380,460,1420>
$output false
set ZoneFlags
{
  $rect <10,10,210,50>
  item OnTest = 8;

  $rect <220,10,420,50>
  item SecondItem;

  $rect <430,10,630,50>
  item ThirdItem;
}

$rect <400,1270,600,1310>
$output false
set DeviceSetting
{
  $rect <10,10,210,50>
  item Disabled = 1;

  $rect <220,10,420,50>
  item SecondItem = 2;

  $rect <430,10,630,50>
  item OnTest = 4;
}

$rect <1260,1050,1440,1090>
$output false
resource Resources::Bitmap FireRouting
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\fire_routing.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1450,1040,1630,1080>
$output false
resource Resources::Bitmap GeneralOutputBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\general_output.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1450,1080,1630,1120>
$output false
resource Resources::Bitmap GeneralInputBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\general_input.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1260,1090,1440,1130>
$output false
resource Resources::Bitmap SounderBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\sounder1.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1090,1070,1250,1110>
$output false
resource Resources::Bitmap SounderVIBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\svi.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1130,1030,1260,1070>
$output false
resource Resources::Bitmap VIBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\vi_ring.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1110,1110,1270,1150>
$output false
resource Resources::Bitmap BeaconBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\sounder_beacon1.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1120,980,1250,1020>
$output false
resource Resources::Bitmap COBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\co.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1710,750,1910,790>
$output false
resource Resources::Bitmap evacuate
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\evacuate.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}

$rect <1620,1050,1780,1090>
$output false
resource Resources::Bitmap SilencedBitmap
{
  attr bitmapfile FileName = C:\Users\matthewault\Documents\Embedded Wizard Projects\Images\silenced.png;
  attr alphafile AlphaName;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
}
